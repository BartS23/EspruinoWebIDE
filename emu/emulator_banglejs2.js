// Copyright 2010 The Emscripten Authors.  All rights reserved.
// Emscripten is available under two separate licenses, the MIT license and the
// University of Illinois/NCSA Open Source License.  Both these licenses can be
// found in the LICENSE file.

// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = typeof Module !== 'undefined' ? Module : {};

// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)
// {{PRE_JSES}}

// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = {};
var key;
for (key in Module) {
  if (Module.hasOwnProperty(key)) {
    moduleOverrides[key] = Module[key];
  }
}

var arguments_ = [];
var thisProgram = './this.program';
var quit_ = function(status, toThrow) {
  throw toThrow;
};

// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).

var ENVIRONMENT_IS_WEB = false;
var ENVIRONMENT_IS_WORKER = false;
var ENVIRONMENT_IS_NODE = false;
var ENVIRONMENT_HAS_NODE = false;
var ENVIRONMENT_IS_SHELL = false;
ENVIRONMENT_IS_WEB = typeof window === 'object';
ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
// A web environment like Electron.js can have Node enabled, so we must
// distinguish between Node-enabled environments and Node environments per se.
// This will allow the former to do things like mount NODEFS.
// Extended check using process.versions fixes issue #8816.
// (Also makes redundant the original check that 'require' is a function.)
ENVIRONMENT_HAS_NODE = typeof process === 'object' && typeof process.versions === 'object' && typeof process.versions.node === 'string';
ENVIRONMENT_IS_NODE = ENVIRONMENT_HAS_NODE && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;
ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

if (Module['ENVIRONMENT']) {
  throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)');
}



// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  }
  return scriptDirectory + path;
}

// Hooks that are implemented differently in different runtime environments.
var read_,
    readAsync,
    readBinary,
    setWindowTitle;

var nodeFS;
var nodePath;

if (ENVIRONMENT_IS_NODE) {
  scriptDirectory = __dirname + '/';


  read_ = function shell_read(filename, binary) {
    var ret;
    ret = tryParseAsDataURI(filename);
    if (ret) {
      return binary ? ret : ret.toString();
    }
    if (!nodeFS) nodeFS = require('fs');
    if (!nodePath) nodePath = require('path');
    filename = nodePath['normalize'](filename);
    return nodeFS['readFileSync'](filename, binary ? null : 'utf8');
  };

  readBinary = function readBinary(filename) {
    var ret = read_(filename, true);
    if (!ret.buffer) {
      ret = new Uint8Array(ret);
    }
    assert(ret.buffer);
    return ret;
  };




  if (process['argv'].length > 1) {
    thisProgram = process['argv'][1].replace(/\\/g, '/');
  }

  arguments_ = process['argv'].slice(2);

  if (typeof module !== 'undefined') {
    module['exports'] = Module;
  }

  process['on']('uncaughtException', function(ex) {
    // suppress ExitStatus exceptions from showing an error
    if (!(ex instanceof ExitStatus)) {
      throw ex;
    }
  });

  process['on']('unhandledRejection', abort);

  quit_ = function(status) {
    process['exit'](status);
  };

  Module['inspect'] = function () { return '[Emscripten Module object]'; };


} else
if (ENVIRONMENT_IS_SHELL) {


  if (typeof read != 'undefined') {
    read_ = function shell_read(f) {
      var data = tryParseAsDataURI(f);
      if (data) {
        return intArrayToString(data);
      }
      return read(f);
    };
  }

  readBinary = function readBinary(f) {
    var data;
    data = tryParseAsDataURI(f);
    if (data) {
      return data;
    }
    if (typeof readbuffer === 'function') {
      return new Uint8Array(readbuffer(f));
    }
    data = read(f, 'binary');
    assert(typeof data === 'object');
    return data;
  };

  if (typeof scriptArgs != 'undefined') {
    arguments_ = scriptArgs;
  } else if (typeof arguments != 'undefined') {
    arguments_ = arguments;
  }

  if (typeof quit === 'function') {
    quit_ = function(status) {
      quit(status);
    };
  }

  if (typeof print !== 'undefined') {
    // Prefer to use print/printErr where they exist, as they usually work better.
    if (typeof console === 'undefined') console = {};
    console.log = print;
    console.warn = console.error = typeof printErr !== 'undefined' ? printErr : print;
  }
} else

// Note that this includes Node.js workers when relevant (pthreads is enabled).
// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and
// ENVIRONMENT_HAS_NODE.
if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled
    scriptDirectory = self.location.href;
  } else if (document.currentScript) { // web
    scriptDirectory = document.currentScript.src;
  }
  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
  // otherwise, slice off the final part of the url to find the script directory.
  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
  // and scriptDirectory will correctly be replaced with an empty string.
  if (scriptDirectory.indexOf('blob:') !== 0) {
    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf('/')+1);
  } else {
    scriptDirectory = '';
  }


  // Differentiate the Web Worker from the Node Worker case, as reading must
  // be done differently.
  {


  read_ = function shell_read(url) {
    try {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.send(null);
      return xhr.responseText;
    } catch (err) {
      var data = tryParseAsDataURI(url);
      if (data) {
        return intArrayToString(data);
      }
      throw err;
    }
  };

  if (ENVIRONMENT_IS_WORKER) {
    readBinary = function readBinary(url) {
      try {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.responseType = 'arraybuffer';
        xhr.send(null);
        return new Uint8Array(xhr.response);
      } catch (err) {
        var data = tryParseAsDataURI(url);
        if (data) {
          return data;
        }
        throw err;
      }
    };
  }

  readAsync = function readAsync(url, onload, onerror) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = function xhr_onload() {
      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
        onload(xhr.response);
        return;
      }
      var data = tryParseAsDataURI(url);
      if (data) {
        onload(data.buffer);
        return;
      }
      onerror();
    };
    xhr.onerror = onerror;
    xhr.send(null);
  };




  }

  setWindowTitle = function(title) { document.title = title };
} else
{
  throw new Error('environment detection error');
}


// Set up the out() and err() hooks, which are how we can print to stdout or
// stderr, respectively.
var out = Module['print'] || console.log.bind(console);
var err = Module['printErr'] || console.warn.bind(console);

// Merge back in the overrides
for (key in moduleOverrides) {
  if (moduleOverrides.hasOwnProperty(key)) {
    Module[key] = moduleOverrides[key];
  }
}
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
moduleOverrides = null;

// Emit code to handle expected values on the Module object. This applies Module.x
// to the proper local x. This has two benefits: first, we only emit it if it is
// expected to arrive, and second, by using a local everywhere else that can be
// minified.
if (Module['arguments']) arguments_ = Module['arguments'];if (!Object.getOwnPropertyDescriptor(Module, 'arguments')) Object.defineProperty(Module, 'arguments', { configurable: true, get: function() { abort('Module.arguments has been replaced with plain arguments_') } });
if (Module['thisProgram']) thisProgram = Module['thisProgram'];if (!Object.getOwnPropertyDescriptor(Module, 'thisProgram')) Object.defineProperty(Module, 'thisProgram', { configurable: true, get: function() { abort('Module.thisProgram has been replaced with plain thisProgram') } });
if (Module['quit']) quit_ = Module['quit'];if (!Object.getOwnPropertyDescriptor(Module, 'quit')) Object.defineProperty(Module, 'quit', { configurable: true, get: function() { abort('Module.quit has been replaced with plain quit_') } });

// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message
// Assertions on removed incoming Module JS APIs.
assert(typeof Module['memoryInitializerPrefixURL'] === 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['pthreadMainPrefixURL'] === 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['cdInitializerPrefixURL'] === 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['filePackagePrefixURL'] === 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['read'] === 'undefined', 'Module.read option was removed (modify read_ in JS)');
assert(typeof Module['readAsync'] === 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');
assert(typeof Module['readBinary'] === 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');
assert(typeof Module['setWindowTitle'] === 'undefined', 'Module.setWindowTitle option was removed (modify setWindowTitle in JS)');
if (!Object.getOwnPropertyDescriptor(Module, 'read')) Object.defineProperty(Module, 'read', { configurable: true, get: function() { abort('Module.read has been replaced with plain read_') } });
if (!Object.getOwnPropertyDescriptor(Module, 'readAsync')) Object.defineProperty(Module, 'readAsync', { configurable: true, get: function() { abort('Module.readAsync has been replaced with plain readAsync') } });
if (!Object.getOwnPropertyDescriptor(Module, 'readBinary')) Object.defineProperty(Module, 'readBinary', { configurable: true, get: function() { abort('Module.readBinary has been replaced with plain readBinary') } });
// TODO: add when SDL2 is fixed if (!Object.getOwnPropertyDescriptor(Module, 'setWindowTitle')) Object.defineProperty(Module, 'setWindowTitle', { configurable: true, get: function() { abort('Module.setWindowTitle has been replaced with plain setWindowTitle') } });
var IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';
var PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';
var WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';
var NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js';


// TODO remove when SDL2 is fixed (also see above)



// Copyright 2017 The Emscripten Authors.  All rights reserved.
// Emscripten is available under two separate licenses, the MIT license and the
// University of Illinois/NCSA Open Source License.  Both these licenses can be
// found in the LICENSE file.

// {{PREAMBLE_ADDITIONS}}

var STACK_ALIGN = 16;

// stack management, and other functionality that is provided by the compiled code,
// should not be used before it is ready
stackSave = stackRestore = stackAlloc = function() {
  abort('cannot use the stack before compiled code is ready to run, and has provided stack access');
};

function staticAlloc(size) {
  abort('staticAlloc is no longer available at runtime; instead, perform static allocations at compile time (using makeStaticAlloc)');
}

function dynamicAlloc(size) {
  assert(DYNAMICTOP_PTR);
  var ret = HEAP32[DYNAMICTOP_PTR>>2];
  var end = (ret + size + 15) & -16;
  if (end > _emscripten_get_heap_size()) {
    abort('failure to dynamicAlloc - memory growth etc. is not supported there, call malloc/sbrk directly');
  }
  HEAP32[DYNAMICTOP_PTR>>2] = end;
  return ret;
}

function alignMemory(size, factor) {
  if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default
  return Math.ceil(size / factor) * factor;
}

function getNativeTypeSize(type) {
  switch (type) {
    case 'i1': case 'i8': return 1;
    case 'i16': return 2;
    case 'i32': return 4;
    case 'i64': return 8;
    case 'float': return 4;
    case 'double': return 8;
    default: {
      if (type[type.length-1] === '*') {
        return 4; // A pointer
      } else if (type[0] === 'i') {
        var bits = parseInt(type.substr(1));
        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);
        return bits / 8;
      } else {
        return 0;
      }
    }
  }
}

function warnOnce(text) {
  if (!warnOnce.shown) warnOnce.shown = {};
  if (!warnOnce.shown[text]) {
    warnOnce.shown[text] = 1;
    err(text);
  }
}

var asm2wasmImports = { // special asm2wasm imports
    "f64-rem": function(x, y) {
        return x % y;
    },
    "debugger": function() {
        debugger;
    }
};




// Wraps a JS function as a wasm function with a given signature.
// In the future, we may get a WebAssembly.Function constructor. Until then,
// we create a wasm module that takes the JS function as an import with a given
// signature, and re-exports that as a wasm function.
function convertJsFunctionToWasm(func, sig) {
  return func;
}

// Add a wasm function to the table.
function addFunctionWasm(func, sig) {
  var table = wasmTable;
  var ret = table.length;

  // Grow the table
  try {
    table.grow(1);
  } catch (err) {
    if (!err instanceof RangeError) {
      throw err;
    }
    throw 'Unable to grow wasm table. Use a higher value for RESERVED_FUNCTION_POINTERS or set ALLOW_TABLE_GROWTH.';
  }

  // Insert new element
  try {
    // Attempting to call this with JS function will cause of table.set() to fail
    table.set(ret, func);
  } catch (err) {
    if (!err instanceof TypeError) {
      throw err;
    }
    assert(typeof sig !== 'undefined', 'Missing signature argument to addFunction');
    var wrapped = convertJsFunctionToWasm(func, sig);
    table.set(ret, wrapped);
  }

  return ret;
}

function removeFunctionWasm(index) {
  // TODO(sbc): Look into implementing this to allow re-using of table slots
}

// 'sig' parameter is required for the llvm backend but only when func is not
// already a WebAssembly function.
function addFunction(func, sig) {
  assert(typeof func !== 'undefined');

  return addFunctionWasm(func, sig);
}

function removeFunction(index) {
  removeFunctionWasm(index);
}

var funcWrappers = {};

function getFuncWrapper(func, sig) {
  if (!func) return; // on null pointer, return undefined
  assert(sig);
  if (!funcWrappers[sig]) {
    funcWrappers[sig] = {};
  }
  var sigCache = funcWrappers[sig];
  if (!sigCache[func]) {
    // optimize away arguments usage in common cases
    if (sig.length === 1) {
      sigCache[func] = function dynCall_wrapper() {
        return dynCall(sig, func);
      };
    } else if (sig.length === 2) {
      sigCache[func] = function dynCall_wrapper(arg) {
        return dynCall(sig, func, [arg]);
      };
    } else {
      // general case
      sigCache[func] = function dynCall_wrapper() {
        return dynCall(sig, func, Array.prototype.slice.call(arguments));
      };
    }
  }
  return sigCache[func];
}


function makeBigInt(low, high, unsigned) {
  return unsigned ? ((+((low>>>0)))+((+((high>>>0)))*4294967296.0)) : ((+((low>>>0)))+((+((high|0)))*4294967296.0));
}

function dynCall(sig, ptr, args) {
  if (args && args.length) {
    assert(args.length == sig.length-1);
    assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \'' + sig + '\'');
    return Module['dynCall_' + sig].apply(null, [ptr].concat(args));
  } else {
    assert(sig.length == 1);
    assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \'' + sig + '\'');
    return Module['dynCall_' + sig].call(null, ptr);
  }
}

var tempRet0 = 0;

var setTempRet0 = function(value) {
  tempRet0 = value;
};

var getTempRet0 = function() {
  return tempRet0;
};

function getCompilerSetting(name) {
  throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for getCompilerSetting or emscripten_get_compiler_setting to work';
}

var Runtime = {
  // helpful errors
  getTempRet0: function() { abort('getTempRet0() is now a top-level function, after removing the Runtime object. Remove "Runtime."') },
  staticAlloc: function() { abort('staticAlloc() is now a top-level function, after removing the Runtime object. Remove "Runtime."') },
  stackAlloc: function() { abort('stackAlloc() is now a top-level function, after removing the Runtime object. Remove "Runtime."') },
};

// The address globals begin at. Very low in memory, for code size and optimization opportunities.
// Above 0 is static memory, starting with globals.
// Then the stack.
// Then 'dynamic' memory for sbrk.
var GLOBAL_BASE = 1024;




// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html


var wasmBinary;if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];if (!Object.getOwnPropertyDescriptor(Module, 'wasmBinary')) Object.defineProperty(Module, 'wasmBinary', { configurable: true, get: function() { abort('Module.wasmBinary has been replaced with plain wasmBinary') } });
var noExitRuntime;if (Module['noExitRuntime']) noExitRuntime = Module['noExitRuntime'];if (!Object.getOwnPropertyDescriptor(Module, 'noExitRuntime')) Object.defineProperty(Module, 'noExitRuntime', { configurable: true, get: function() { abort('Module.noExitRuntime has been replaced with plain noExitRuntime') } });


// wasm2js.js - enough of a polyfill for the WebAssembly object so that we can load
// wasm2js code that way.

// Emit "var WebAssembly" if definitely using wasm2js. Otherwise, in MAYBE_WASM2JS
// mode, we can't use a "var" since it would prevent normal wasm from working.
var
WebAssembly = {
  Memory: function(opts) {
    return {
      buffer: new ArrayBuffer(opts['initial'] * 65536),
      grow: function(amount) {
        var oldBuffer = this.buffer;
        var ret = __growWasmMemory(amount);
        assert(this.buffer !== oldBuffer); // the call should have updated us
        return ret;
      }
    };
  },

  Table: function(opts) {
    var ret = new Array(opts['initial']);
    ret.grow = function(by) {
      if (ret.length >= 693 + 0) {
        abort('Unable to grow wasm table. Use a higher value for RESERVED_FUNCTION_POINTERS or set ALLOW_TABLE_GROWTH.')
      }
      ret.push(null);
    };
    ret.set = function(i, func) {
      ret[i] = func;
    };
    ret.get = function(i) {
      return ret[i];
    };
    return ret;
  },

  Module: function(binary) {
    // TODO: use the binary and info somehow - right now the wasm2js output is embedded in
    // the main JS
    return {};
  },

  Instance: function(module, info) {
    // TODO: use the module and info somehow - right now the wasm2js output is embedded in
    // the main JS
    // XXX hack to get an atob implementation

// Copied from https://github.com/strophe/strophejs/blob/e06d027/src/polyfills.js#L149

// This code was written by Tyler Akins and has been placed in the
// public domain.  It would be nice if you left this header intact.
// Base64 code from Tyler Akins -- http://rumkin.com

/**
 * Decodes a base64 string.
 * @param {String} input The string to decode.
 */
var decodeBase64 = typeof atob === 'function' ? atob : function (input) {
  var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  var output = '';
  var chr1, chr2, chr3;
  var enc1, enc2, enc3, enc4;
  var i = 0;
  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
  do {
    enc1 = keyStr.indexOf(input.charAt(i++));
    enc2 = keyStr.indexOf(input.charAt(i++));
    enc3 = keyStr.indexOf(input.charAt(i++));
    enc4 = keyStr.indexOf(input.charAt(i++));

    chr1 = (enc1 << 2) | (enc2 >> 4);
    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
    chr3 = ((enc3 & 3) << 6) | enc4;

    output = output + String.fromCharCode(chr1);

    if (enc3 !== 64) {
      output = output + String.fromCharCode(chr2);
    }
    if (enc4 !== 64) {
      output = output + String.fromCharCode(chr3);
    }
  } while (i < input.length);
  return output;
};

// Converts a string of base64 into a byte array.
// Throws error on invalid input.
function intArrayFromBase64(s) {
  if (typeof ENVIRONMENT_IS_NODE === 'boolean' && ENVIRONMENT_IS_NODE) {
    var buf;
    try {
      buf = Buffer.from(s, 'base64');
    } catch (_) {
      buf = new Buffer(s, 'base64');
    }
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }

  try {
    var decoded = decodeBase64(s);
    var bytes = new Uint8Array(decoded.length);
    for (var i = 0 ; i < decoded.length ; ++i) {
      bytes[i] = decoded.charCodeAt(i);
    }
    return bytes;
  } catch (_) {
    throw new Error('Converting base64 string to bytes failed.');
  }
}

// If filename is a base64 data URI, parses and returns data (Buffer on node,
// Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.
function tryParseAsDataURI(filename) {
  if (!isDataURI(filename)) {
    return;
  }

  return intArrayFromBase64(filename.slice(dataURIPrefix.length));
}


    var atob = decodeBase64;
    // This will be replaced by the actual wasm2js code.
    var exports = (
// EMSCRIPTEN_START_ASM
function instantiate(asmLibraryArg, wasmMemory, wasmTable) {


  var scratchBuffer = new ArrayBuffer(8);
  var i32ScratchView = new Int32Array(scratchBuffer);
  var f32ScratchView = new Float32Array(scratchBuffer);
  var f64ScratchView = new Float64Array(scratchBuffer);
  
  function wasm2js_scratch_load_i32(index) {
    return i32ScratchView[index];
  }
      
  function wasm2js_scratch_store_i32(index, value) {
    i32ScratchView[index] = value;
  }
      
  function wasm2js_scratch_load_f64() {
    return f64ScratchView[0];
  }
      
  function wasm2js_scratch_store_f64(value) {
    f64ScratchView[0] = value;
  }
      
  function legalimport$wasm2js_scratch_store_i64(low, high) {
    i32ScratchView[0] = low;
    i32ScratchView[1] = high;
  }
      
  function wasm2js_scratch_load_f32() {
    return f32ScratchView[0];
  }
      
  function wasm2js_scratch_store_f32(value) {
    f32ScratchView[0] = value;
  }
      
function asmFunc(global, env, buffer) {
 var memory = env.memory;
 var FUNCTION_TABLE = wasmTable;
 var HEAP8 = new global.Int8Array(buffer);
 var HEAP16 = new global.Int16Array(buffer);
 var HEAP32 = new global.Int32Array(buffer);
 var HEAPU8 = new global.Uint8Array(buffer);
 var HEAPU16 = new global.Uint16Array(buffer);
 var HEAPU32 = new global.Uint32Array(buffer);
 var HEAPF32 = new global.Float32Array(buffer);
 var HEAPF64 = new global.Float64Array(buffer);
 var Math_imul = global.Math.imul;
 var Math_fround = global.Math.fround;
 var Math_abs = global.Math.abs;
 var Math_clz32 = global.Math.clz32;
 var Math_min = global.Math.min;
 var Math_max = global.Math.max;
 var Math_floor = global.Math.floor;
 var Math_ceil = global.Math.ceil;
 var Math_sqrt = global.Math.sqrt;
 var abort = env.abort;
 var nan = global.NaN;
 var infinity = global.Infinity;
 var abort = env.abort;
 var roundf = env.roundf;
 var round = env.round;
 var __lock = env.__lock;
 var __unlock = env.__unlock;
 var __wasi_fd_write = env.fd_write;
 var __wasi_fd_close = env.fd_close;
 var emscripten_resize_heap = env.emscripten_resize_heap;
 var emscripten_memcpy_big = env.emscripten_memcpy_big;
 var setTempRet0 = env.setTempRet0;
 var legalimport$__wasi_fd_seek = env.fd_seek;
 var emscripten_asm_const_iii = env.emscripten_asm_const_iii;
 var emscripten_asm_const_dii = env.emscripten_asm_const_dii;
 var global$0 = 5580432;
 var global$1 = 337540;
 var i64toi32_i32$HIGH_BITS = 0;
 // EMSCRIPTEN_START_FUNCS
function jswCallFunctionHack($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $5 = global$0 - 544 | 0;
 global$0 = $5;
 HEAP32[$5 + 536 >> 2] = $0;
 HEAP16[$5 + 534 >> 1] = $1;
 HEAP32[$5 + 528 >> 2] = $2;
 HEAP32[$5 + 524 >> 2] = $3;
 HEAP32[$5 + 520 >> 2] = $4;
 label$1 : {
  label$2 : {
   label$3 : {
    label$4 : {
     label$5 : {
      label$6 : {
       label$7 : {
        label$8 : {
         label$9 : {
          label$10 : {
           label$11 : {
            label$12 : {
             label$13 : {
              label$14 : {
               label$15 : {
                label$16 : {
                 label$17 : {
                  label$18 : {
                   label$19 : {
                    label$20 : {
                     label$21 : {
                      label$22 : {
                       label$23 : {
                        label$24 : {
                         label$25 : {
                          label$26 : {
                           label$27 : {
                            label$28 : {
                             label$29 : {
                              label$30 : {
                               label$31 : {
                                label$32 : {
                                 label$33 : {
                                  label$34 : {
                                   label$35 : {
                                    label$36 : {
                                     label$37 : {
                                      label$38 : {
                                       label$39 : {
                                        label$40 : {
                                         label$41 : {
                                          label$42 : {
                                           label$43 : {
                                            label$44 : {
                                             label$45 : {
                                              label$46 : {
                                               label$47 : {
                                                label$48 : {
                                                 label$49 : {
                                                  label$50 : {
                                                   label$51 : {
                                                    label$52 : {
                                                     label$53 : {
                                                      label$54 : {
                                                       label$55 : {
                                                        label$56 : {
                                                         label$57 : {
                                                          label$58 : {
                                                           label$59 : {
                                                            label$60 : {
                                                             label$61 : {
                                                              label$62 : {
                                                               label$63 : {
                                                                label$64 : {
                                                                 label$65 : {
                                                                  label$66 : {
                                                                   label$67 : {
                                                                    label$68 : {
                                                                     label$69 : {
                                                                      label$70 : {
                                                                       label$71 : {
                                                                        label$72 : {
                                                                         label$73 : {
                                                                          label$74 : {
                                                                           label$75 : {
                                                                            label$76 : {
                                                                             label$77 : {
                                                                              label$78 : {
                                                                               label$79 : {
                                                                                label$80 : {
                                                                                 label$81 : {
                                                                                  label$82 : {
                                                                                   label$83 : {
                                                                                    label$84 : {
                                                                                     label$85 : {
                                                                                      label$86 : {
                                                                                       label$87 : {
                                                                                        label$88 : {
                                                                                         label$89 : {
                                                                                          label$90 : {
                                                                                           label$91 : {
                                                                                            label$92 : {
                                                                                             label$93 : {
                                                                                              label$94 : {
                                                                                               label$95 : {
                                                                                                label$96 : {
                                                                                                 label$97 : {
                                                                                                  label$98 : {
                                                                                                   label$99 : {
                                                                                                    label$100 : {
                                                                                                     label$101 : {
                                                                                                      label$102 : {
                                                                                                       label$103 : {
                                                                                                        label$104 : {
                                                                                                         label$105 : {
                                                                                                          label$106 : {
                                                                                                           label$107 : {
                                                                                                            label$108 : {
                                                                                                             label$109 : {
                                                                                                              label$110 : {
                                                                                                               label$111 : {
                                                                                                                label$112 : {
                                                                                                                 label$113 : {
                                                                                                                  label$114 : {
                                                                                                                   label$115 : {
                                                                                                                    label$116 : {
                                                                                                                     label$117 : {
                                                                                                                      label$118 : {
                                                                                                                       $0 = HEAPU16[$5 + 534 >> 1];
                                                                                                                       if ($0) {
                                                                                                                        if (($0 | 0) == 1) {
                                                                                                                         break label$114;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 3) {
                                                                                                                         break label$112;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 4) {
                                                                                                                         break label$109;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 6) {
                                                                                                                         break label$79;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 8) {
                                                                                                                         break label$115;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 9) {
                                                                                                                         break label$108;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 11) {
                                                                                                                         break label$88;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 12) {
                                                                                                                         break label$62;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 14) {
                                                                                                                         break label$71;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 16) {
                                                                                                                         break label$52;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 17) {
                                                                                                                         break label$99;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 22) {
                                                                                                                         break label$18;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 24) {
                                                                                                                         break label$117;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32) {
                                                                                                                         break label$113;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 33) {
                                                                                                                         break label$85;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 36) {
                                                                                                                         break label$61;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 41) {
                                                                                                                         break label$45;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 46) {
                                                                                                                         break label$49;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 48) {
                                                                                                                         break label$116;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 49) {
                                                                                                                         break label$19;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 54) {
                                                                                                                         break label$21;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 72) {
                                                                                                                         break label$103;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 73) {
                                                                                                                         break label$102;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 75) {
                                                                                                                         break label$29;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 91) {
                                                                                                                         break label$110;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 96) {
                                                                                                                         break label$111;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 97) {
                                                                                                                         break label$23;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 112) {
                                                                                                                         break label$65;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 136) {
                                                                                                                         break label$55;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 200) {
                                                                                                                         break label$63;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 201) {
                                                                                                                         break label$31;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 204) {
                                                                                                                         break label$59;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 264) {
                                                                                                                         break label$53;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 265) {
                                                                                                                         break label$60;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 288) {
                                                                                                                         break label$106;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 289) {
                                                                                                                         break label$105;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 392) {
                                                                                                                         break label$50;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 398) {
                                                                                                                         break label$68;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 417) {
                                                                                                                         break label$104;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 438) {
                                                                                                                         break label$20;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 584) {
                                                                                                                         break label$64;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 585) {
                                                                                                                         break label$54;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 609) {
                                                                                                                         break label$70;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 744) {
                                                                                                                         break label$47;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 841) {
                                                                                                                         break label$44;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 936) {
                                                                                                                         break label$48;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 1417) {
                                                                                                                         break label$51;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 1608) {
                                                                                                                         break label$66;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 1609) {
                                                                                                                         break label$57;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 1640) {
                                                                                                                         break label$46;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 2126) {
                                                                                                                         break label$67;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 2313) {
                                                                                                                         break label$83;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 3510) {
                                                                                                                         break label$69;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 6433) {
                                                                                                                         break label$17;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 15793) {
                                                                                                                         break label$56;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 16968) {
                                                                                                                         break label$58;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 18507) {
                                                                                                                         break label$30;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 28673) {
                                                                                                                         break label$101;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 28675) {
                                                                                                                         break label$107;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 28676) {
                                                                                                                         break label$37;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 28677) {
                                                                                                                         break label$118;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 28678) {
                                                                                                                         break label$38;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32768) {
                                                                                                                         break label$42;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32769) {
                                                                                                                         break label$93;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32771) {
                                                                                                                         break label$43;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32772) {
                                                                                                                         break label$78;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32774) {
                                                                                                                         break label$77;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32776) {
                                                                                                                         break label$39;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32777) {
                                                                                                                         break label$98;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32779) {
                                                                                                                         break label$36;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32780) {
                                                                                                                         break label$7;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32784) {
                                                                                                                         break label$32;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32785) {
                                                                                                                         break label$87;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32788) {
                                                                                                                         break label$94;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32792) {
                                                                                                                         break label$41;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32793) {
                                                                                                                         break label$16;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32801) {
                                                                                                                         break label$100;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32804) {
                                                                                                                         break label$26;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32806) {
                                                                                                                         break label$72;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32822) {
                                                                                                                         break label$76;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32840) {
                                                                                                                         break label$91;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32841) {
                                                                                                                         break label$92;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32843) {
                                                                                                                         break label$24;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32844) {
                                                                                                                         break label$25;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32865) {
                                                                                                                         break label$89;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32870) {
                                                                                                                         break label$73;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32904) {
                                                                                                                         break label$35;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32905) {
                                                                                                                         break label$34;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32968) {
                                                                                                                         break label$33;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32969) {
                                                                                                                         break label$4;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 32993) {
                                                                                                                         break label$81;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 33032) {
                                                                                                                         break label$82;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 33033) {
                                                                                                                         break label$96;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 33035) {
                                                                                                                         break label$95;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 33057) {
                                                                                                                         break label$5;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 33060) {
                                                                                                                         break label$12;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 33097) {
                                                                                                                         break label$28;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 33176) {
                                                                                                                         break label$40;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 33353) {
                                                                                                                         break label$9;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 33356) {
                                                                                                                         break label$10;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 33382) {
                                                                                                                         break label$74;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 33545) {
                                                                                                                         break label$86;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 33569) {
                                                                                                                         break label$11;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 33704) {
                                                                                                                         break label$22;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 33889) {
                                                                                                                         break label$90;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 34400) {
                                                                                                                         break label$80;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 35105) {
                                                                                                                         break label$14;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 37478) {
                                                                                                                         break label$75;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 39177) {
                                                                                                                         break label$3;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 47369) {
                                                                                                                         break label$6;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 49929) {
                                                                                                                         break label$8;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 51465) {
                                                                                                                         break label$15;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 51489) {
                                                                                                                         break label$13;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 55560) {
                                                                                                                         break label$27;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 61441) {
                                                                                                                         break label$97;
                                                                                                                        }
                                                                                                                        if (($0 | 0) == 61444) {
                                                                                                                         break label$84;
                                                                                                                        }
                                                                                                                        break label$2;
                                                                                                                       }
                                                                                                                       HEAP32[$5 + 516 >> 2] = 0;
                                                                                                                       FUNCTION_TABLE[HEAP32[$5 + 536 >> 2]]();
                                                                                                                       HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 516 >> 2];
                                                                                                                       break label$1;
                                                                                                                      }
                                                                                                                      HEAP32[$5 + 512 >> 2] = 0;
                                                                                                                      HEAP32[$5 + 512 >> 2] = jsvNewFromPin(FUNCTION_TABLE[HEAP32[$5 + 536 >> 2]]() & 255);
                                                                                                                      HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 512 >> 2];
                                                                                                                      break label$1;
                                                                                                                     }
                                                                                                                     HEAP32[$5 + 508 >> 2] = 0;
                                                                                                                     $0 = HEAP32[$5 + 536 >> 2];
                                                                                                                     if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                                                      $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                                                                     } else {
                                                                                                                      $1 = 0;
                                                                                                                     }
                                                                                                                     FUNCTION_TABLE[$0](jsvGetBool($1) & 1);
                                                                                                                     HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 508 >> 2];
                                                                                                                     break label$1;
                                                                                                                    }
                                                                                                                    HEAP32[$5 + 504 >> 2] = 0;
                                                                                                                    $0 = HEAP32[$5 + 536 >> 2];
                                                                                                                    if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                                                     $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                                                                    } else {
                                                                                                                     $1 = 0;
                                                                                                                    }
                                                                                                                    FUNCTION_TABLE[$0](jsvGetFloat($1));
                                                                                                                    HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 504 >> 2];
                                                                                                                    break label$1;
                                                                                                                   }
                                                                                                                   HEAP32[$5 + 500 >> 2] = 0;
                                                                                                                   $0 = HEAP32[$5 + 536 >> 2];
                                                                                                                   if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                                                    $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                                                                   } else {
                                                                                                                    $1 = 0;
                                                                                                                   }
                                                                                                                   FUNCTION_TABLE[$0]($1);
                                                                                                                   HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 500 >> 2];
                                                                                                                   break label$1;
                                                                                                                  }
                                                                                                                  HEAP32[$5 + 496 >> 2] = 0;
                                                                                                                  HEAP32[$5 + 496 >> 2] = FUNCTION_TABLE[HEAP32[$5 + 536 >> 2]]();
                                                                                                                  HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 496 >> 2];
                                                                                                                  break label$1;
                                                                                                                 }
                                                                                                                 HEAP32[$5 + 492 >> 2] = 0;
                                                                                                                 $0 = HEAP32[$5 + 536 >> 2];
                                                                                                                 if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                                                  $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                                                                 } else {
                                                                                                                  $1 = 0;
                                                                                                                 }
                                                                                                                 FUNCTION_TABLE[$0](jsvGetInteger($1));
                                                                                                                 HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 492 >> 2];
                                                                                                                 break label$1;
                                                                                                                }
                                                                                                                HEAP32[$5 + 488 >> 2] = 0;
                                                                                                                HEAP32[$5 + 488 >> 2] = jsvNewFromBool(FUNCTION_TABLE[HEAP32[$5 + 536 >> 2]]() & 1);
                                                                                                                HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 488 >> 2];
                                                                                                                break label$1;
                                                                                                               }
                                                                                                               HEAP32[$5 + 484 >> 2] = 0;
                                                                                                               $1 = HEAP32[$5 + 536 >> 2];
                                                                                                               if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                                                $0 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                                                               } else {
                                                                                                                $0 = 0;
                                                                                                               }
                                                                                                               $0 = jsvGetInteger($0);
                                                                                                               if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                                                                $2 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                                                               } else {
                                                                                                                $2 = 0;
                                                                                                               }
                                                                                                               FUNCTION_TABLE[$1]($0, $2);
                                                                                                               HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 484 >> 2];
                                                                                                               break label$1;
                                                                                                              }
                                                                                                              HEAP32[$5 + 480 >> 2] = 0;
                                                                                                              $2 = HEAP32[$5 + 536 >> 2];
                                                                                                              $0 = $5;
                                                                                                              if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                                               $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                                                              } else {
                                                                                                               $1 = 0;
                                                                                                              }
                                                                                                              $1 = jsvGetBool($1) & 1;
                                                                                                              if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                                                               $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                                                              } else {
                                                                                                               $3 = 0;
                                                                                                              }
                                                                                                              HEAP32[$0 + 480 >> 2] = jsvNewFromBool(FUNCTION_TABLE[$2]($1, $3) & 1);
                                                                                                              HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 480 >> 2];
                                                                                                              break label$1;
                                                                                                             }
                                                                                                             HEAP32[$5 + 476 >> 2] = 0;
                                                                                                             HEAP32[$5 + 476 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[HEAP32[$5 + 536 >> 2]]() | 0);
                                                                                                             HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 476 >> 2];
                                                                                                             break label$1;
                                                                                                            }
                                                                                                            HEAP32[$5 + 472 >> 2] = 0;
                                                                                                            $1 = HEAP32[$5 + 536 >> 2];
                                                                                                            $0 = $5;
                                                                                                            if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                                             $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                                                            } else {
                                                                                                             $2 = 0;
                                                                                                            }
                                                                                                            HEAP32[$0 + 472 >> 2] = FUNCTION_TABLE[$1]($2);
                                                                                                            HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 472 >> 2];
                                                                                                            break label$1;
                                                                                                           }
                                                                                                           HEAP32[$5 + 468 >> 2] = 0;
                                                                                                           HEAP32[$5 + 468 >> 2] = jsvNewFromBool(FUNCTION_TABLE[HEAP32[$5 + 536 >> 2]]() & 1);
                                                                                                           HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 468 >> 2];
                                                                                                           break label$1;
                                                                                                          }
                                                                                                          HEAP32[$5 + 464 >> 2] = 0;
                                                                                                          $1 = HEAP32[$5 + 536 >> 2];
                                                                                                          if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                                           $0 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                                                          } else {
                                                                                                           $0 = 0;
                                                                                                          }
                                                                                                          $0 = jsvGetInteger($0);
                                                                                                          if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                                                           $2 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                                                          } else {
                                                                                                           $2 = 0;
                                                                                                          }
                                                                                                          FUNCTION_TABLE[$1]($0, jsvGetInteger($2));
                                                                                                          HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 464 >> 2];
                                                                                                          break label$1;
                                                                                                         }
                                                                                                         HEAP32[$5 + 460 >> 2] = 0;
                                                                                                         $2 = HEAP32[$5 + 536 >> 2];
                                                                                                         $0 = $5;
                                                                                                         if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                                          $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                                                         } else {
                                                                                                          $1 = 0;
                                                                                                         }
                                                                                                         $1 = jsvGetInteger($1);
                                                                                                         if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                                                          $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                                                         } else {
                                                                                                          $3 = 0;
                                                                                                         }
                                                                                                         HEAP32[$0 + 460 >> 2] = FUNCTION_TABLE[$2]($1, jsvGetInteger($3));
                                                                                                         HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 460 >> 2];
                                                                                                         break label$1;
                                                                                                        }
                                                                                                        HEAP32[$5 + 456 >> 2] = 0;
                                                                                                        $2 = HEAP32[$5 + 536 >> 2];
                                                                                                        $0 = $5;
                                                                                                        if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                                         $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                                                        } else {
                                                                                                         $1 = 0;
                                                                                                        }
                                                                                                        $1 = jsvGetInteger($1);
                                                                                                        if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                                                         $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                                                        } else {
                                                                                                         $3 = 0;
                                                                                                        }
                                                                                                        HEAP32[$0 + 456 >> 2] = FUNCTION_TABLE[$2]($1, jsvGetFloat($3));
                                                                                                        HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 456 >> 2];
                                                                                                        break label$1;
                                                                                                       }
                                                                                                       HEAP32[$5 + 452 >> 2] = 0;
                                                                                                       $1 = HEAP32[$5 + 536 >> 2];
                                                                                                       if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                                        $0 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                                                       } else {
                                                                                                        $0 = 0;
                                                                                                       }
                                                                                                       if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                                                        $2 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                                                       } else {
                                                                                                        $2 = 0;
                                                                                                       }
                                                                                                       FUNCTION_TABLE[$1]($0, $2);
                                                                                                       HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 452 >> 2];
                                                                                                       break label$1;
                                                                                                      }
                                                                                                      HEAP32[$5 + 448 >> 2] = 0;
                                                                                                      $2 = HEAP32[$5 + 536 >> 2];
                                                                                                      $0 = $5;
                                                                                                      if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                                       $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                                                      } else {
                                                                                                       $1 = 0;
                                                                                                      }
                                                                                                      if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                                                       $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                                                      } else {
                                                                                                       $3 = 0;
                                                                                                      }
                                                                                                      HEAP32[$0 + 448 >> 2] = FUNCTION_TABLE[$2]($1, $3);
                                                                                                      HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 448 >> 2];
                                                                                                      break label$1;
                                                                                                     }
                                                                                                     HEAP32[$5 + 444 >> 2] = 0;
                                                                                                     HEAP32[$5 + 444 >> 2] = FUNCTION_TABLE[HEAP32[$5 + 536 >> 2]]();
                                                                                                     HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 444 >> 2];
                                                                                                     break label$1;
                                                                                                    }
                                                                                                    HEAP32[$5 + 440 >> 2] = 0;
                                                                                                    $2 = HEAP32[$5 + 536 >> 2];
                                                                                                    $0 = $5;
                                                                                                    $1 = HEAP32[$5 + 528 >> 2];
                                                                                                    if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                                     $3 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                                                    } else {
                                                                                                     $3 = 0;
                                                                                                    }
                                                                                                    HEAP32[$0 + 440 >> 2] = FUNCTION_TABLE[$2]($1, jsvGetInteger($3));
                                                                                                    HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 440 >> 2];
                                                                                                    break label$1;
                                                                                                   }
                                                                                                   HEAP32[$5 + 436 >> 2] = 0;
                                                                                                   $0 = $5;
                                                                                                   label$160 : {
                                                                                                    if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                                     $1 = jsvNewArray(HEAP32[$5 + 524 >> 2], HEAP32[$5 + 520 >> 2]);
                                                                                                     break label$160;
                                                                                                    }
                                                                                                    $1 = jsvNewWithFlags(3);
                                                                                                   }
                                                                                                   HEAP32[$0 + 432 >> 2] = $1;
                                                                                                   HEAP32[$5 + 436 >> 2] = FUNCTION_TABLE[HEAP32[$5 + 536 >> 2]](HEAP32[$5 + 432 >> 2]);
                                                                                                   jsvUnLock(HEAP32[$5 + 432 >> 2]);
                                                                                                   HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 436 >> 2];
                                                                                                   break label$1;
                                                                                                  }
                                                                                                  HEAP32[$5 + 428 >> 2] = 0;
                                                                                                  $2 = HEAP32[$5 + 536 >> 2];
                                                                                                  $0 = $5;
                                                                                                  $1 = HEAP32[$5 + 528 >> 2];
                                                                                                  if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                                   $3 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                                                  } else {
                                                                                                   $3 = 0;
                                                                                                  }
                                                                                                  HEAP32[$0 + 428 >> 2] = FUNCTION_TABLE[$2]($1, $3);
                                                                                                  HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 428 >> 2];
                                                                                                  break label$1;
                                                                                                 }
                                                                                                 HEAP32[$5 + 424 >> 2] = 0;
                                                                                                 HEAP32[$5 + 424 >> 2] = FUNCTION_TABLE[HEAP32[$5 + 536 >> 2]](HEAP32[$5 + 528 >> 2]);
                                                                                                 HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 424 >> 2];
                                                                                                 break label$1;
                                                                                                }
                                                                                                HEAP32[$5 + 420 >> 2] = 0;
                                                                                                $3 = HEAP32[$5 + 536 >> 2];
                                                                                                $0 = $5;
                                                                                                $2 = HEAP32[$5 + 528 >> 2];
                                                                                                if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                                 $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                                                } else {
                                                                                                 $1 = 0;
                                                                                                }
                                                                                                if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                                                 $4 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                                                } else {
                                                                                                 $4 = 0;
                                                                                                }
                                                                                                HEAP32[$0 + 420 >> 2] = FUNCTION_TABLE[$3]($2, $1, jsvGetInteger($4));
                                                                                                HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 420 >> 2];
                                                                                                break label$1;
                                                                                               }
                                                                                               HEAP32[$5 + 416 >> 2] = 0;
                                                                                               $3 = HEAP32[$5 + 536 >> 2];
                                                                                               $0 = $5;
                                                                                               $2 = HEAP32[$5 + 528 >> 2];
                                                                                               if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                                $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                                               } else {
                                                                                                $1 = 0;
                                                                                               }
                                                                                               if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                                                $4 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                                               } else {
                                                                                                $4 = 0;
                                                                                               }
                                                                                               HEAP32[$0 + 416 >> 2] = jsvNewFromBool(FUNCTION_TABLE[$3]($2, $1, jsvGetInteger($4)) & 1);
                                                                                               HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 416 >> 2];
                                                                                               break label$1;
                                                                                              }
                                                                                              HEAP32[$5 + 412 >> 2] = 0;
                                                                                              $0 = $5;
                                                                                              label$172 : {
                                                                                               if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                                $1 = jsvNewArray(HEAP32[$5 + 524 >> 2], HEAP32[$5 + 520 >> 2]);
                                                                                                break label$172;
                                                                                               }
                                                                                               $1 = jsvNewWithFlags(3);
                                                                                              }
                                                                                              HEAP32[$0 + 408 >> 2] = $1;
                                                                                              HEAP32[$5 + 412 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[HEAP32[$5 + 536 >> 2]](HEAP32[$5 + 528 >> 2], HEAP32[$5 + 408 >> 2]) | 0);
                                                                                              jsvUnLock(HEAP32[$5 + 408 >> 2]);
                                                                                              HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 412 >> 2];
                                                                                              break label$1;
                                                                                             }
                                                                                             HEAP32[$5 + 404 >> 2] = 0;
                                                                                             HEAP32[$5 + 404 >> 2] = FUNCTION_TABLE[HEAP32[$5 + 536 >> 2]](HEAP32[$5 + 528 >> 2]);
                                                                                             HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 404 >> 2];
                                                                                             break label$1;
                                                                                            }
                                                                                            HEAP32[$5 + 400 >> 2] = 0;
                                                                                            $3 = HEAP32[$5 + 536 >> 2];
                                                                                            $0 = $5;
                                                                                            $2 = HEAP32[$5 + 528 >> 2];
                                                                                            if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                             $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                                            } else {
                                                                                             $1 = 0;
                                                                                            }
                                                                                            if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                                             $4 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                                            } else {
                                                                                             $4 = 0;
                                                                                            }
                                                                                            HEAP32[$0 + 400 >> 2] = FUNCTION_TABLE[$3]($2, $1, $4);
                                                                                            HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 400 >> 2];
                                                                                            break label$1;
                                                                                           }
                                                                                           HEAP32[$5 + 396 >> 2] = 0;
                                                                                           $2 = HEAP32[$5 + 536 >> 2];
                                                                                           $1 = HEAP32[$5 + 528 >> 2];
                                                                                           if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                            $0 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                                           } else {
                                                                                            $0 = 0;
                                                                                           }
                                                                                           if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                                            $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                                           } else {
                                                                                            $3 = 0;
                                                                                           }
                                                                                           FUNCTION_TABLE[$2]($1, $0, $3);
                                                                                           HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 396 >> 2];
                                                                                           break label$1;
                                                                                          }
                                                                                          HEAP32[$5 + 392 >> 2] = 0;
                                                                                          $0 = $5;
                                                                                          label$182 : {
                                                                                           if (HEAP32[$5 + 520 >> 2] > 2) {
                                                                                            $1 = jsvNewArray(HEAP32[$5 + 524 >> 2] + 8 | 0, HEAP32[$5 + 520 >> 2] - 2 | 0);
                                                                                            break label$182;
                                                                                           }
                                                                                           $1 = jsvNewWithFlags(3);
                                                                                          }
                                                                                          HEAP32[$0 + 388 >> 2] = $1;
                                                                                          $3 = HEAP32[$5 + 536 >> 2];
                                                                                          $0 = $5;
                                                                                          $1 = HEAP32[$5 + 528 >> 2];
                                                                                          if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                           $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                                          } else {
                                                                                           $2 = 0;
                                                                                          }
                                                                                          $2 = jsvGetInteger($2);
                                                                                          if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                                           $4 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                                          } else {
                                                                                           $4 = 0;
                                                                                          }
                                                                                          HEAP32[$0 + 392 >> 2] = FUNCTION_TABLE[$3]($1, $2, $4, HEAP32[$5 + 388 >> 2]);
                                                                                          jsvUnLock(HEAP32[$5 + 388 >> 2]);
                                                                                          HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 392 >> 2];
                                                                                          break label$1;
                                                                                         }
                                                                                         HEAP32[$5 + 384 >> 2] = 0;
                                                                                         $3 = HEAP32[$5 + 536 >> 2];
                                                                                         $0 = $5;
                                                                                         $1 = HEAP32[$5 + 528 >> 2];
                                                                                         if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                          $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                                         } else {
                                                                                          $2 = 0;
                                                                                         }
                                                                                         $2 = jsvGetInteger($2);
                                                                                         if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                                          $4 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                                         } else {
                                                                                          $4 = 0;
                                                                                         }
                                                                                         HEAP32[$0 + 384 >> 2] = FUNCTION_TABLE[$3]($1, $2, $4);
                                                                                         HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 384 >> 2];
                                                                                         break label$1;
                                                                                        }
                                                                                        HEAP32[$5 + 380 >> 2] = 0;
                                                                                        $1 = HEAP32[$5 + 536 >> 2];
                                                                                        $0 = $5;
                                                                                        if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                         $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                                        } else {
                                                                                         $2 = 0;
                                                                                        }
                                                                                        HEAP32[$0 + 380 >> 2] = jsvNewFromBool(FUNCTION_TABLE[$1]($2) & 1);
                                                                                        HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 380 >> 2];
                                                                                        break label$1;
                                                                                       }
                                                                                       HEAP32[$5 + 376 >> 2] = 0;
                                                                                       $0 = $5;
                                                                                       label$194 : {
                                                                                        if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                         $1 = jsvNewArray(HEAP32[$5 + 524 >> 2], HEAP32[$5 + 520 >> 2]);
                                                                                         break label$194;
                                                                                        }
                                                                                        $1 = jsvNewWithFlags(3);
                                                                                       }
                                                                                       HEAP32[$0 + 372 >> 2] = $1;
                                                                                       HEAP32[$5 + 376 >> 2] = FUNCTION_TABLE[HEAP32[$5 + 536 >> 2]](HEAP32[$5 + 528 >> 2], HEAP32[$5 + 372 >> 2]);
                                                                                       jsvUnLock(HEAP32[$5 + 372 >> 2]);
                                                                                       HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 376 >> 2];
                                                                                       break label$1;
                                                                                      }
                                                                                      HEAP32[$5 + 368 >> 2] = 0;
                                                                                      $4 = HEAP32[$5 + 536 >> 2];
                                                                                      $0 = $5;
                                                                                      $2 = HEAP32[$5 + 528 >> 2];
                                                                                      if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                       $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                                      } else {
                                                                                       $1 = 0;
                                                                                      }
                                                                                      if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                                       $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                                      } else {
                                                                                       $3 = 0;
                                                                                      }
                                                                                      $3 = jsvGetInteger($3);
                                                                                      if (HEAP32[$5 + 520 >> 2] > 2) {
                                                                                       $6 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
                                                                                      } else {
                                                                                       $6 = 0;
                                                                                      }
                                                                                      HEAP32[$0 + 368 >> 2] = FUNCTION_TABLE[$4]($2, $1, $3, $6);
                                                                                      HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 368 >> 2];
                                                                                      break label$1;
                                                                                     }
                                                                                     HEAP32[$5 + 364 >> 2] = 0;
                                                                                     $1 = HEAP32[$5 + 536 >> 2];
                                                                                     $0 = $5;
                                                                                     if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                      $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                                     } else {
                                                                                      $2 = 0;
                                                                                     }
                                                                                     HEAP32[$0 + 364 >> 2] = FUNCTION_TABLE[$1](jsvGetInteger($2));
                                                                                     HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 364 >> 2];
                                                                                     break label$1;
                                                                                    }
                                                                                    HEAP32[$5 + 360 >> 2] = 0;
                                                                                    HEAP32[$5 + 360 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[HEAP32[$5 + 536 >> 2]](HEAP32[$5 + 528 >> 2]) | 0);
                                                                                    HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 360 >> 2];
                                                                                    break label$1;
                                                                                   }
                                                                                   HEAP32[$5 + 356 >> 2] = 0;
                                                                                   $3 = HEAP32[$5 + 536 >> 2];
                                                                                   $0 = $5;
                                                                                   if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                    $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                                   } else {
                                                                                    $1 = 0;
                                                                                   }
                                                                                   if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                                    $2 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                                   } else {
                                                                                    $2 = 0;
                                                                                   }
                                                                                   $2 = jsvGetInteger($2);
                                                                                   if (HEAP32[$5 + 520 >> 2] > 2) {
                                                                                    $4 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
                                                                                   } else {
                                                                                    $4 = 0;
                                                                                   }
                                                                                   HEAP32[$0 + 356 >> 2] = FUNCTION_TABLE[$3]($1, $2, jsvGetInteger($4));
                                                                                   HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 356 >> 2];
                                                                                   break label$1;
                                                                                  }
                                                                                  HEAP32[$5 + 352 >> 2] = 0;
                                                                                  $2 = HEAP32[$5 + 536 >> 2];
                                                                                  $1 = HEAP32[$5 + 528 >> 2];
                                                                                  if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                   $0 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                                  } else {
                                                                                   $0 = 0;
                                                                                  }
                                                                                  if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                                   $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                                  } else {
                                                                                   $3 = 0;
                                                                                  }
                                                                                  FUNCTION_TABLE[$2]($1, $0, jsvGetInteger($3));
                                                                                  HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 352 >> 2];
                                                                                  break label$1;
                                                                                 }
                                                                                 HEAP32[$5 + 348 >> 2] = 0;
                                                                                 $3 = HEAP32[$5 + 536 >> 2];
                                                                                 $0 = $5;
                                                                                 $1 = HEAP32[$5 + 528 >> 2];
                                                                                 if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                  $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                                 } else {
                                                                                  $2 = 0;
                                                                                 }
                                                                                 $2 = jsvGetInteger($2);
                                                                                 if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                                  $4 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                                 } else {
                                                                                  $4 = 0;
                                                                                 }
                                                                                 HEAP32[$0 + 348 >> 2] = FUNCTION_TABLE[$3]($1, $2, jsvGetBool($4) & 1);
                                                                                 HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 348 >> 2];
                                                                                 break label$1;
                                                                                }
                                                                                HEAP32[$5 + 344 >> 2] = 0;
                                                                                $3 = HEAP32[$5 + 536 >> 2];
                                                                                $1 = HEAP32[$5 + 528 >> 2];
                                                                                if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                                 $0 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                                } else {
                                                                                 $0 = 0;
                                                                                }
                                                                                $2 = jsvGetInteger($0);
                                                                                if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                                 $0 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                                } else {
                                                                                 $0 = 0;
                                                                                }
                                                                                if (HEAP32[$5 + 520 >> 2] > 2) {
                                                                                 $4 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
                                                                                } else {
                                                                                 $4 = 0;
                                                                                }
                                                                                FUNCTION_TABLE[$3]($1, $2, $0, jsvGetBool($4) & 1);
                                                                                HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 344 >> 2];
                                                                                break label$1;
                                                                               }
                                                                               HEAP32[$5 + 340 >> 2] = 0;
                                                                               HEAP32[$5 + 340 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[HEAP32[$5 + 536 >> 2]]());
                                                                               HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 340 >> 2];
                                                                               break label$1;
                                                                              }
                                                                              HEAP32[$5 + 336 >> 2] = 0;
                                                                              HEAP32[$5 + 336 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[HEAP32[$5 + 536 >> 2]](HEAP32[$5 + 528 >> 2]) | 0);
                                                                              HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 336 >> 2];
                                                                              break label$1;
                                                                             }
                                                                             HEAP32[$5 + 332 >> 2] = 0;
                                                                             HEAP32[$5 + 332 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[HEAP32[$5 + 536 >> 2]](HEAP32[$5 + 528 >> 2]));
                                                                             HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 332 >> 2];
                                                                             break label$1;
                                                                            }
                                                                            HEAP32[$5 + 328 >> 2] = 0;
                                                                            $2 = HEAP32[$5 + 536 >> 2];
                                                                            $0 = $5;
                                                                            $1 = HEAP32[$5 + 528 >> 2];
                                                                            if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                             $3 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                            } else {
                                                                             $3 = 0;
                                                                            }
                                                                            HEAP32[$0 + 328 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$2]($1, jsvGetFloat($3)));
                                                                            HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 328 >> 2];
                                                                            break label$1;
                                                                           }
                                                                           HEAP32[$5 + 324 >> 2] = 0;
                                                                           $0 = HEAP32[$5 + 536 >> 2];
                                                                           $1 = $5;
                                                                           $4 = HEAP32[$5 + 528 >> 2];
                                                                           if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                            $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                           } else {
                                                                            $2 = 0;
                                                                           }
                                                                           $6 = jsvGetInteger($2);
                                                                           if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                            $2 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                           } else {
                                                                            $2 = 0;
                                                                           }
                                                                           if (HEAP32[$5 + 520 >> 2] > 2) {
                                                                            $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
                                                                           } else {
                                                                            $3 = 0;
                                                                           }
                                                                           if (HEAP32[$5 + 520 >> 2] > 3) {
                                                                            $7 = HEAP32[HEAP32[$5 + 524 >> 2] + 12 >> 2];
                                                                           } else {
                                                                            $7 = 0;
                                                                           }
                                                                           HEAP32[$1 + 324 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$0]($4, $6, $2, $3, $7));
                                                                           HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 324 >> 2];
                                                                           break label$1;
                                                                          }
                                                                          HEAP32[$5 + 320 >> 2] = 0;
                                                                          $4 = HEAP32[$5 + 536 >> 2];
                                                                          $0 = $5;
                                                                          $2 = HEAP32[$5 + 528 >> 2];
                                                                          if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                           $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                          } else {
                                                                           $1 = 0;
                                                                          }
                                                                          $3 = jsvGetInteger($1);
                                                                          if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                           $1 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                          } else {
                                                                           $1 = 0;
                                                                          }
                                                                          if (HEAP32[$5 + 520 >> 2] > 2) {
                                                                           $6 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
                                                                          } else {
                                                                           $6 = 0;
                                                                          }
                                                                          HEAP32[$0 + 320 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$4]($2, $3, $1, $6));
                                                                          HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 320 >> 2];
                                                                          break label$1;
                                                                         }
                                                                         HEAP32[$5 + 316 >> 2] = 0;
                                                                         $3 = HEAP32[$5 + 536 >> 2];
                                                                         $0 = $5;
                                                                         $1 = HEAP32[$5 + 528 >> 2];
                                                                         if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                          $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                         } else {
                                                                          $2 = 0;
                                                                         }
                                                                         $2 = jsvGetInteger($2);
                                                                         if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                          $4 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                         } else {
                                                                          $4 = 0;
                                                                         }
                                                                         HEAP32[$0 + 316 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$3]($1, $2, $4));
                                                                         HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 316 >> 2];
                                                                         break label$1;
                                                                        }
                                                                        HEAP32[$5 + 312 >> 2] = 0;
                                                                        $2 = HEAP32[$5 + 536 >> 2];
                                                                        $0 = $5;
                                                                        $1 = HEAP32[$5 + 528 >> 2];
                                                                        if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                         $3 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                        } else {
                                                                         $3 = 0;
                                                                        }
                                                                        HEAP32[$0 + 312 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$2]($1, jsvGetInteger($3)));
                                                                        HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 312 >> 2];
                                                                        break label$1;
                                                                       }
                                                                       HEAP32[$5 + 308 >> 2] = 0;
                                                                       $1 = HEAP32[$5 + 536 >> 2];
                                                                       $0 = $5;
                                                                       if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                        $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                       } else {
                                                                        $2 = 0;
                                                                       }
                                                                       HEAP32[$0 + 308 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$1]($2));
                                                                       HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 308 >> 2];
                                                                       break label$1;
                                                                      }
                                                                      HEAP32[$5 + 304 >> 2] = 0;
                                                                      $3 = HEAP32[$5 + 536 >> 2];
                                                                      $0 = $5;
                                                                      if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                       $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                      } else {
                                                                       $1 = 0;
                                                                      }
                                                                      $2 = jsvGetInteger($1);
                                                                      if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                       $1 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                      } else {
                                                                       $1 = 0;
                                                                      }
                                                                      if (HEAP32[$5 + 520 >> 2] > 2) {
                                                                       $4 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
                                                                      } else {
                                                                       $4 = 0;
                                                                      }
                                                                      HEAP32[$0 + 304 >> 2] = FUNCTION_TABLE[$3]($2, $1, $4);
                                                                      HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 304 >> 2];
                                                                      break label$1;
                                                                     }
                                                                     HEAP32[$5 + 300 >> 2] = 0;
                                                                     $1 = HEAP32[$5 + 536 >> 2];
                                                                     $0 = $5;
                                                                     if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                      $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                     } else {
                                                                      $2 = 0;
                                                                     }
                                                                     $8 = jsvGetFloat($2);
                                                                     if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                      $2 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                     } else {
                                                                      $2 = 0;
                                                                     }
                                                                     $9 = jsvGetFloat($2);
                                                                     if (HEAP32[$5 + 520 >> 2] > 2) {
                                                                      $2 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
                                                                     } else {
                                                                      $2 = 0;
                                                                     }
                                                                     HEAP32[$0 + 300 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$1]($8, $9, jsvGetFloat($2)));
                                                                     HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 300 >> 2];
                                                                     break label$1;
                                                                    }
                                                                    HEAP32[$5 + 296 >> 2] = 0;
                                                                    $2 = HEAP32[$5 + 536 >> 2];
                                                                    $0 = $5;
                                                                    if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                     $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                    } else {
                                                                     $1 = 0;
                                                                    }
                                                                    if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                     $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                    } else {
                                                                     $3 = 0;
                                                                    }
                                                                    HEAP32[$0 + 296 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$2]($1, jsvGetFloat($3)));
                                                                    HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 296 >> 2];
                                                                    break label$1;
                                                                   }
                                                                   HEAP32[$5 + 292 >> 2] = 0;
                                                                   $3 = HEAP32[$5 + 536 >> 2];
                                                                   $0 = $5;
                                                                   if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                    $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                   } else {
                                                                    $1 = 0;
                                                                   }
                                                                   if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                    $2 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                   } else {
                                                                    $2 = 0;
                                                                   }
                                                                   if (HEAP32[$5 + 520 >> 2] > 2) {
                                                                    $4 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
                                                                   } else {
                                                                    $4 = 0;
                                                                   }
                                                                   HEAP32[$0 + 292 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$3]($1, $2, jsvGetInteger($4)));
                                                                   HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 292 >> 2];
                                                                   break label$1;
                                                                  }
                                                                  HEAP32[$5 + 288 >> 2] = 0;
                                                                  $2 = HEAP32[$5 + 536 >> 2];
                                                                  if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                   $0 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                  } else {
                                                                   $0 = 0;
                                                                  }
                                                                  if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                   $1 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                  } else {
                                                                   $1 = 0;
                                                                  }
                                                                  if (HEAP32[$5 + 520 >> 2] > 2) {
                                                                   $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
                                                                  } else {
                                                                   $3 = 0;
                                                                  }
                                                                  FUNCTION_TABLE[$2]($0, $1, jsvGetBool($3) & 1);
                                                                  HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 288 >> 2];
                                                                  break label$1;
                                                                 }
                                                                 HEAP32[$5 + 284 >> 2] = 0;
                                                                 $0 = HEAP32[$5 + 536 >> 2];
                                                                 if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                  $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                 } else {
                                                                  $1 = 0;
                                                                 }
                                                                 $8 = jsvGetFloat($1);
                                                                 if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                  $1 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                 } else {
                                                                  $1 = 0;
                                                                 }
                                                                 FUNCTION_TABLE[$0]($8, $1);
                                                                 HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 284 >> 2];
                                                                 break label$1;
                                                                }
                                                                HEAP32[$5 + 280 >> 2] = 0;
                                                                $2 = HEAP32[$5 + 536 >> 2];
                                                                if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                 $0 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                                } else {
                                                                 $0 = 0;
                                                                }
                                                                if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                 $1 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                                } else {
                                                                 $1 = 0;
                                                                }
                                                                if (HEAP32[$5 + 520 >> 2] > 2) {
                                                                 $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
                                                                } else {
                                                                 $3 = 0;
                                                                }
                                                                FUNCTION_TABLE[$2]($0, $1, $3);
                                                                HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 280 >> 2];
                                                                break label$1;
                                                               }
                                                               HEAP32[$5 + 276 >> 2] = 0;
                                                               $1 = HEAP32[$5 + 536 >> 2];
                                                               if (HEAP32[$5 + 520 >> 2] > 0) {
                                                                $0 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                               } else {
                                                                $0 = 0;
                                                               }
                                                               if (HEAP32[$5 + 520 >> 2] > 1) {
                                                                $2 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                               } else {
                                                                $2 = 0;
                                                               }
                                                               FUNCTION_TABLE[$1]($0, jsvGetBool($2) & 1);
                                                               HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 276 >> 2];
                                                               break label$1;
                                                              }
                                                              HEAP32[$5 + 272 >> 2] = 0;
                                                              $1 = HEAP32[$5 + 536 >> 2];
                                                              $0 = $5;
                                                              if (HEAP32[$5 + 520 >> 2] > 0) {
                                                               $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                              } else {
                                                               $2 = 0;
                                                              }
                                                              HEAP32[$0 + 272 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$1]($2) | 0);
                                                              HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 272 >> 2];
                                                              break label$1;
                                                             }
                                                             HEAP32[$5 + 268 >> 2] = 0;
                                                             $1 = HEAP32[$5 + 536 >> 2];
                                                             $0 = $5;
                                                             if (HEAP32[$5 + 520 >> 2] > 0) {
                                                              $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                             } else {
                                                              $2 = 0;
                                                             }
                                                             HEAP32[$0 + 268 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$1](jsvGetInteger($2)) | 0);
                                                             HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 268 >> 2];
                                                             break label$1;
                                                            }
                                                            HEAP32[$5 + 264 >> 2] = 0;
                                                            $2 = HEAP32[$5 + 536 >> 2];
                                                            $0 = $5;
                                                            if (HEAP32[$5 + 520 >> 2] > 0) {
                                                             $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                            } else {
                                                             $1 = 0;
                                                            }
                                                            if (HEAP32[$5 + 520 >> 2] > 1) {
                                                             $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                            } else {
                                                             $3 = 0;
                                                            }
                                                            HEAP32[$0 + 264 >> 2] = FUNCTION_TABLE[$2]($1, jsvGetInteger($3));
                                                            HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 264 >> 2];
                                                            break label$1;
                                                           }
                                                           HEAP32[$5 + 260 >> 2] = 0;
                                                           $2 = HEAP32[$5 + 536 >> 2];
                                                           $0 = $5;
                                                           if (HEAP32[$5 + 520 >> 2] > 0) {
                                                            $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                           } else {
                                                            $1 = 0;
                                                           }
                                                           if (HEAP32[$5 + 520 >> 2] > 1) {
                                                            $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                           } else {
                                                            $3 = 0;
                                                           }
                                                           HEAP32[$0 + 260 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$2]($1, jsvGetBool($3) & 1) | 0);
                                                           HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 260 >> 2];
                                                           break label$1;
                                                          }
                                                          HEAP32[$5 + 256 >> 2] = 0;
                                                          $3 = HEAP32[$5 + 536 >> 2];
                                                          if (HEAP32[$5 + 520 >> 2] > 0) {
                                                           $0 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                          } else {
                                                           $0 = 0;
                                                          }
                                                          if (HEAP32[$5 + 520 >> 2] > 1) {
                                                           $1 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                          } else {
                                                           $1 = 0;
                                                          }
                                                          if (HEAP32[$5 + 520 >> 2] > 2) {
                                                           $2 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
                                                          } else {
                                                           $2 = 0;
                                                          }
                                                          if (HEAP32[$5 + 520 >> 2] > 3) {
                                                           $4 = HEAP32[HEAP32[$5 + 524 >> 2] + 12 >> 2];
                                                          } else {
                                                           $4 = 0;
                                                          }
                                                          FUNCTION_TABLE[$3]($0, $1, $2, jsvGetInteger($4));
                                                          HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 256 >> 2];
                                                          break label$1;
                                                         }
                                                         HEAP32[$5 + 252 >> 2] = 0;
                                                         $3 = HEAP32[$5 + 536 >> 2];
                                                         $0 = $5;
                                                         if (HEAP32[$5 + 520 >> 2] > 0) {
                                                          $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                         } else {
                                                          $1 = 0;
                                                         }
                                                         if (HEAP32[$5 + 520 >> 2] > 1) {
                                                          $2 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                         } else {
                                                          $2 = 0;
                                                         }
                                                         if (HEAP32[$5 + 520 >> 2] > 2) {
                                                          $4 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
                                                         } else {
                                                          $4 = 0;
                                                         }
                                                         HEAP32[$0 + 252 >> 2] = FUNCTION_TABLE[$3]($1, $2, jsvGetBool($4) & 1);
                                                         HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 252 >> 2];
                                                         break label$1;
                                                        }
                                                        HEAP32[$5 + 248 >> 2] = 0;
                                                        $1 = HEAP32[$5 + 536 >> 2];
                                                        $0 = $5;
                                                        if (HEAP32[$5 + 520 >> 2] > 0) {
                                                         $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                        } else {
                                                         $2 = 0;
                                                        }
                                                        $8 = jsvGetFloat($2);
                                                        if (HEAP32[$5 + 520 >> 2] > 1) {
                                                         $2 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                        } else {
                                                         $2 = 0;
                                                        }
                                                        $9 = jsvGetFloat($2);
                                                        if (HEAP32[$5 + 520 >> 2] > 2) {
                                                         $2 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
                                                        } else {
                                                         $2 = 0;
                                                        }
                                                        $10 = jsvGetFloat($2);
                                                        if (HEAP32[$5 + 520 >> 2] > 3) {
                                                         $2 = HEAP32[HEAP32[$5 + 524 >> 2] + 12 >> 2];
                                                        } else {
                                                         $2 = 0;
                                                        }
                                                        HEAP32[$0 + 248 >> 2] = FUNCTION_TABLE[$1]($8, $9, $10, jsvGetBool($2) & 1);
                                                        HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 248 >> 2];
                                                        break label$1;
                                                       }
                                                       HEAP32[$5 + 244 >> 2] = 0;
                                                       $0 = $5;
                                                       label$324 : {
                                                        if (HEAP32[$5 + 520 >> 2] > 1) {
                                                         $1 = jsvNewArray(HEAP32[$5 + 524 >> 2] + 4 | 0, HEAP32[$5 + 520 >> 2] - 1 | 0);
                                                         break label$324;
                                                        }
                                                        $1 = jsvNewWithFlags(3);
                                                       }
                                                       HEAP32[$0 + 240 >> 2] = $1;
                                                       $0 = HEAP32[$5 + 536 >> 2];
                                                       if (HEAP32[$5 + 520 >> 2] > 0) {
                                                        $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                       } else {
                                                        $1 = 0;
                                                       }
                                                       FUNCTION_TABLE[$0]($1, HEAP32[$5 + 240 >> 2]);
                                                       jsvUnLock(HEAP32[$5 + 240 >> 2]);
                                                       HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 244 >> 2];
                                                       break label$1;
                                                      }
                                                      HEAP32[$5 + 236 >> 2] = 0;
                                                      $3 = HEAP32[$5 + 536 >> 2];
                                                      $0 = $5;
                                                      if (HEAP32[$5 + 520 >> 2] > 0) {
                                                       $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                      } else {
                                                       $1 = 0;
                                                      }
                                                      if (HEAP32[$5 + 520 >> 2] > 1) {
                                                       $2 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                      } else {
                                                       $2 = 0;
                                                      }
                                                      if (HEAP32[$5 + 520 >> 2] > 2) {
                                                       $4 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
                                                      } else {
                                                       $4 = 0;
                                                      }
                                                      HEAP32[$0 + 236 >> 2] = FUNCTION_TABLE[$3]($1, $2, $4);
                                                      HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 236 >> 2];
                                                      break label$1;
                                                     }
                                                     HEAP32[$5 + 232 >> 2] = 0;
                                                     $1 = HEAP32[$5 + 536 >> 2];
                                                     if (HEAP32[$5 + 520 >> 2] > 0) {
                                                      $0 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                     } else {
                                                      $0 = 0;
                                                     }
                                                     if (HEAP32[$5 + 520 >> 2] > 1) {
                                                      $2 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                     } else {
                                                      $2 = 0;
                                                     }
                                                     FUNCTION_TABLE[$1]($0, jsvGetInteger($2));
                                                     HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 232 >> 2];
                                                     break label$1;
                                                    }
                                                    HEAP32[$5 + 228 >> 2] = 0;
                                                    $0 = $5;
                                                    label$338 : {
                                                     if (HEAP32[$5 + 520 >> 2] > 0) {
                                                      $1 = jsvNewArray(HEAP32[$5 + 524 >> 2], HEAP32[$5 + 520 >> 2]);
                                                      break label$338;
                                                     }
                                                     $1 = jsvNewWithFlags(3);
                                                    }
                                                    HEAP32[$0 + 224 >> 2] = $1;
                                                    FUNCTION_TABLE[HEAP32[$5 + 536 >> 2]](HEAP32[$5 + 224 >> 2]);
                                                    jsvUnLock(HEAP32[$5 + 224 >> 2]);
                                                    HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 228 >> 2];
                                                    break label$1;
                                                   }
                                                   HEAP32[$5 + 220 >> 2] = 0;
                                                   $0 = $5;
                                                   label$340 : {
                                                    if (HEAP32[$5 + 520 >> 2] > 2) {
                                                     $1 = jsvNewArray(HEAP32[$5 + 524 >> 2] + 8 | 0, HEAP32[$5 + 520 >> 2] - 2 | 0);
                                                     break label$340;
                                                    }
                                                    $1 = jsvNewWithFlags(3);
                                                   }
                                                   HEAP32[$0 + 216 >> 2] = $1;
                                                   $2 = HEAP32[$5 + 536 >> 2];
                                                   $0 = $5;
                                                   if (HEAP32[$5 + 520 >> 2] > 0) {
                                                    $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                   } else {
                                                    $1 = 0;
                                                   }
                                                   if (HEAP32[$5 + 520 >> 2] > 1) {
                                                    $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                   } else {
                                                    $3 = 0;
                                                   }
                                                   HEAP32[$0 + 220 >> 2] = FUNCTION_TABLE[$2]($1, jsvGetFloat($3), HEAP32[$5 + 216 >> 2]);
                                                   jsvUnLock(HEAP32[$5 + 216 >> 2]);
                                                   HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 220 >> 2];
                                                   break label$1;
                                                  }
                                                  HEAP32[$5 + 212 >> 2] = 0;
                                                  $1 = HEAP32[$5 + 536 >> 2];
                                                  if (HEAP32[$5 + 520 >> 2] > 0) {
                                                   $0 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                  } else {
                                                   $0 = 0;
                                                  }
                                                  if (HEAP32[$5 + 520 >> 2] > 1) {
                                                   $2 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                  } else {
                                                   $2 = 0;
                                                  }
                                                  FUNCTION_TABLE[$1]($0, jsvGetFloat($2));
                                                  HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 212 >> 2];
                                                  break label$1;
                                                 }
                                                 HEAP32[$5 + 208 >> 2] = 0;
                                                 $1 = HEAP32[$5 + 536 >> 2];
                                                 $0 = $5;
                                                 if (HEAP32[$5 + 520 >> 2] > 0) {
                                                  $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                 } else {
                                                  $2 = 0;
                                                 }
                                                 HEAP32[$0 + 208 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$1](jshGetPinFromVar($2) & 255));
                                                 HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 208 >> 2];
                                                 break label$1;
                                                }
                                                HEAP32[$5 + 204 >> 2] = 0;
                                                $1 = HEAP32[$5 + 536 >> 2];
                                                if (HEAP32[$5 + 520 >> 2] > 0) {
                                                 $0 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                                } else {
                                                 $0 = 0;
                                                }
                                                $0 = jshGetPinFromVar($0) & 255;
                                                if (HEAP32[$5 + 520 >> 2] > 1) {
                                                 $2 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                                } else {
                                                 $2 = 0;
                                                }
                                                $8 = jsvGetFloat($2);
                                                if (HEAP32[$5 + 520 >> 2] > 2) {
                                                 $2 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
                                                } else {
                                                 $2 = 0;
                                                }
                                                FUNCTION_TABLE[$1]($0, $8, $2);
                                                HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 204 >> 2];
                                                break label$1;
                                               }
                                               HEAP32[$5 + 200 >> 2] = 0;
                                               $2 = HEAP32[$5 + 536 >> 2];
                                               if (HEAP32[$5 + 520 >> 2] > 0) {
                                                $0 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                               } else {
                                                $0 = 0;
                                               }
                                               $0 = jshGetPinFromVar($0) & 255;
                                               if (HEAP32[$5 + 520 >> 2] > 1) {
                                                $1 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                               } else {
                                                $1 = 0;
                                               }
                                               $1 = jsvGetBool($1) & 1;
                                               if (HEAP32[$5 + 520 >> 2] > 2) {
                                                $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
                                               } else {
                                                $3 = 0;
                                               }
                                               FUNCTION_TABLE[$2]($0, $1, $3);
                                               HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 200 >> 2];
                                               break label$1;
                                              }
                                              HEAP32[$5 + 196 >> 2] = 0;
                                              $2 = HEAP32[$5 + 536 >> 2];
                                              if (HEAP32[$5 + 520 >> 2] > 0) {
                                               $0 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                              } else {
                                               $0 = 0;
                                              }
                                              $1 = jshGetPinFromVar($0) & 255;
                                              if (HEAP32[$5 + 520 >> 2] > 1) {
                                               $0 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                              } else {
                                               $0 = 0;
                                              }
                                              if (HEAP32[$5 + 520 >> 2] > 2) {
                                               $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
                                              } else {
                                               $3 = 0;
                                              }
                                              FUNCTION_TABLE[$2]($1, $0, jsvGetBool($3) & 1);
                                              HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 196 >> 2];
                                              break label$1;
                                             }
                                             HEAP32[$5 + 192 >> 2] = 0;
                                             $1 = HEAP32[$5 + 536 >> 2];
                                             $0 = $5;
                                             if (HEAP32[$5 + 520 >> 2] > 0) {
                                              $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                             } else {
                                              $2 = 0;
                                             }
                                             HEAP32[$0 + 192 >> 2] = FUNCTION_TABLE[$1](jshGetPinFromVar($2) & 255);
                                             HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 192 >> 2];
                                             break label$1;
                                            }
                                            HEAP32[$5 + 188 >> 2] = 0;
                                            $3 = HEAP32[$5 + 536 >> 2];
                                            $0 = $5;
                                            if (HEAP32[$5 + 520 >> 2] > 0) {
                                             $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                            } else {
                                             $1 = 0;
                                            }
                                            if (HEAP32[$5 + 520 >> 2] > 1) {
                                             $2 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                            } else {
                                             $2 = 0;
                                            }
                                            $2 = jshGetPinFromVar($2) & 255;
                                            if (HEAP32[$5 + 520 >> 2] > 2) {
                                             $4 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
                                            } else {
                                             $4 = 0;
                                            }
                                            HEAP32[$0 + 188 >> 2] = FUNCTION_TABLE[$3]($1, $2, $4);
                                            HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 188 >> 2];
                                            break label$1;
                                           }
                                           HEAP32[$5 + 184 >> 2] = 0;
                                           HEAP32[$5 + 184 >> 2] = jsvNewFromBool(FUNCTION_TABLE[HEAP32[$5 + 536 >> 2]](HEAP32[$5 + 528 >> 2]) & 1);
                                           HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 184 >> 2];
                                           break label$1;
                                          }
                                          HEAP32[$5 + 180 >> 2] = 0;
                                          FUNCTION_TABLE[HEAP32[$5 + 536 >> 2]](HEAP32[$5 + 528 >> 2]);
                                          HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 180 >> 2];
                                          break label$1;
                                         }
                                         HEAP32[$5 + 176 >> 2] = 0;
                                         $1 = HEAP32[$5 + 536 >> 2];
                                         $0 = HEAP32[$5 + 528 >> 2];
                                         if (HEAP32[$5 + 520 >> 2] > 0) {
                                          $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                         } else {
                                          $2 = 0;
                                         }
                                         FUNCTION_TABLE[$1]($0, jsvGetBool($2) & 1);
                                         HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 176 >> 2];
                                         break label$1;
                                        }
                                        HEAP32[$5 + 172 >> 2] = 0;
                                        $2 = HEAP32[$5 + 536 >> 2];
                                        $0 = HEAP32[$5 + 528 >> 2];
                                        if (HEAP32[$5 + 520 >> 2] > 0) {
                                         $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                        } else {
                                         $1 = 0;
                                        }
                                        $1 = jsvGetBool($1) & 1;
                                        if (HEAP32[$5 + 520 >> 2] > 1) {
                                         $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                        } else {
                                         $3 = 0;
                                        }
                                        FUNCTION_TABLE[$2]($0, $1, jsvGetFloat($3));
                                        HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 172 >> 2];
                                        break label$1;
                                       }
                                       HEAP32[$5 + 168 >> 2] = 0;
                                       $1 = HEAP32[$5 + 536 >> 2];
                                       $0 = HEAP32[$5 + 528 >> 2];
                                       if (HEAP32[$5 + 520 >> 2] > 0) {
                                        $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                       } else {
                                        $2 = 0;
                                       }
                                       FUNCTION_TABLE[$1]($0, $2);
                                       HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 168 >> 2];
                                       break label$1;
                                      }
                                      HEAP32[$5 + 164 >> 2] = 0;
                                      HEAP32[$5 + 164 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[HEAP32[$5 + 536 >> 2]]());
                                      HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 164 >> 2];
                                      break label$1;
                                     }
                                     HEAP32[$5 + 160 >> 2] = 0;
                                     HEAP32[$5 + 160 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[HEAP32[$5 + 536 >> 2]]() | 0);
                                     HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 160 >> 2];
                                     break label$1;
                                    }
                                    HEAP32[$5 + 156 >> 2] = 0;
                                    $2 = HEAP32[$5 + 536 >> 2];
                                    $0 = $5;
                                    $1 = HEAP32[$5 + 528 >> 2];
                                    if (HEAP32[$5 + 520 >> 2] > 0) {
                                     $3 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                    } else {
                                     $3 = 0;
                                    }
                                    HEAP32[$0 + 156 >> 2] = jsvNewFromBool(FUNCTION_TABLE[$2]($1, $3) & 1);
                                    HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 156 >> 2];
                                    break label$1;
                                   }
                                   HEAP32[$5 + 152 >> 2] = 0;
                                   $0 = $5;
                                   label$388 : {
                                    if (HEAP32[$5 + 520 >> 2] > 1) {
                                     $1 = jsvNewArray(HEAP32[$5 + 524 >> 2] + 4 | 0, HEAP32[$5 + 520 >> 2] - 1 | 0);
                                     break label$388;
                                    }
                                    $1 = jsvNewWithFlags(3);
                                   }
                                   HEAP32[$0 + 148 >> 2] = $1;
                                   $1 = HEAP32[$5 + 536 >> 2];
                                   $0 = HEAP32[$5 + 528 >> 2];
                                   if (HEAP32[$5 + 520 >> 2] > 0) {
                                    $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                   } else {
                                    $2 = 0;
                                   }
                                   FUNCTION_TABLE[$1]($0, $2, HEAP32[$5 + 148 >> 2]);
                                   jsvUnLock(HEAP32[$5 + 148 >> 2]);
                                   HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 152 >> 2];
                                   break label$1;
                                  }
                                  HEAP32[$5 + 144 >> 2] = 0;
                                  $0 = $5;
                                  label$392 : {
                                   if (HEAP32[$5 + 520 >> 2] > 1) {
                                    $1 = jsvNewArray(HEAP32[$5 + 524 >> 2] + 4 | 0, HEAP32[$5 + 520 >> 2] - 1 | 0);
                                    break label$392;
                                   }
                                   $1 = jsvNewWithFlags(3);
                                  }
                                  HEAP32[$0 + 140 >> 2] = $1;
                                  $2 = HEAP32[$5 + 536 >> 2];
                                  $0 = $5;
                                  $1 = HEAP32[$5 + 528 >> 2];
                                  if (HEAP32[$5 + 520 >> 2] > 0) {
                                   $3 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                  } else {
                                   $3 = 0;
                                  }
                                  HEAP32[$0 + 144 >> 2] = FUNCTION_TABLE[$2]($1, $3, HEAP32[$5 + 140 >> 2]);
                                  jsvUnLock(HEAP32[$5 + 140 >> 2]);
                                  HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 144 >> 2];
                                  break label$1;
                                 }
                                 HEAP32[$5 + 136 >> 2] = 0;
                                 $2 = HEAP32[$5 + 536 >> 2];
                                 $1 = HEAP32[$5 + 528 >> 2];
                                 if (HEAP32[$5 + 520 >> 2] > 0) {
                                  $0 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                                 } else {
                                  $0 = 0;
                                 }
                                 if (HEAP32[$5 + 520 >> 2] > 1) {
                                  $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                                 } else {
                                  $3 = 0;
                                 }
                                 FUNCTION_TABLE[$2]($1, $0, jsvGetBool($3) & 1);
                                 HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 136 >> 2];
                                 break label$1;
                                }
                                HEAP32[$5 + 132 >> 2] = 0;
                                $0 = $5;
                                label$400 : {
                                 if (HEAP32[$5 + 520 >> 2] > 0) {
                                  $1 = jsvNewArray(HEAP32[$5 + 524 >> 2], HEAP32[$5 + 520 >> 2]);
                                  break label$400;
                                 }
                                 $1 = jsvNewWithFlags(3);
                                }
                                HEAP32[$0 + 128 >> 2] = $1;
                                FUNCTION_TABLE[HEAP32[$5 + 536 >> 2]](HEAP32[$5 + 528 >> 2], HEAP32[$5 + 128 >> 2]);
                                jsvUnLock(HEAP32[$5 + 128 >> 2]);
                                HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 132 >> 2];
                                break label$1;
                               }
                               HEAP32[$5 + 124 >> 2] = 0;
                               $2 = HEAP32[$5 + 536 >> 2];
                               $0 = $5;
                               if (HEAP32[$5 + 520 >> 2] > 0) {
                                $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                               } else {
                                $1 = 0;
                               }
                               if (HEAP32[$5 + 520 >> 2] > 1) {
                                $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                               } else {
                                $3 = 0;
                               }
                               HEAP32[$0 + 124 >> 2] = FUNCTION_TABLE[$2]($1, jsvGetBool($3) & 1);
                               HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 124 >> 2];
                               break label$1;
                              }
                              HEAP32[$5 + 120 >> 2] = 0;
                              $4 = HEAP32[$5 + 536 >> 2];
                              $0 = $5;
                              if (HEAP32[$5 + 520 >> 2] > 0) {
                               $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                              } else {
                               $1 = 0;
                              }
                              if (HEAP32[$5 + 520 >> 2] > 1) {
                               $2 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                              } else {
                               $2 = 0;
                              }
                              if (HEAP32[$5 + 520 >> 2] > 2) {
                               $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
                              } else {
                               $3 = 0;
                              }
                              $3 = jsvGetInteger($3);
                              if (HEAP32[$5 + 520 >> 2] > 3) {
                               $6 = HEAP32[HEAP32[$5 + 524 >> 2] + 12 >> 2];
                              } else {
                               $6 = 0;
                              }
                              HEAP32[$0 + 120 >> 2] = jsvNewFromBool(FUNCTION_TABLE[$4]($1, $2, $3, jsvGetInteger($6)) & 1);
                              HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 120 >> 2];
                              break label$1;
                             }
                             HEAP32[$5 + 116 >> 2] = 0;
                             $2 = HEAP32[$5 + 536 >> 2];
                             $0 = $5;
                             if (HEAP32[$5 + 520 >> 2] > 0) {
                              $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                             } else {
                              $1 = 0;
                             }
                             if (HEAP32[$5 + 520 >> 2] > 1) {
                              $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                             } else {
                              $3 = 0;
                             }
                             HEAP32[$0 + 116 >> 2] = jsvNewFromBool(FUNCTION_TABLE[$2]($1, $3) & 1);
                             HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 116 >> 2];
                             break label$1;
                            }
                            HEAP32[$5 + 112 >> 2] = 0;
                            $3 = HEAP32[$5 + 536 >> 2];
                            $0 = $5;
                            $2 = HEAP32[$5 + 528 >> 2];
                            if (HEAP32[$5 + 520 >> 2] > 0) {
                             $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                            } else {
                             $1 = 0;
                            }
                            if (HEAP32[$5 + 520 >> 2] > 1) {
                             $4 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                            } else {
                             $4 = 0;
                            }
                            HEAP32[$0 + 112 >> 2] = FUNCTION_TABLE[$3]($2, $1, jshGetPinFromVar($4) & 255);
                            HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 112 >> 2];
                            break label$1;
                           }
                           HEAP32[$5 + 108 >> 2] = 0;
                           $4 = HEAP32[$5 + 536 >> 2];
                           $1 = HEAP32[$5 + 528 >> 2];
                           if (HEAP32[$5 + 520 >> 2] > 0) {
                            $0 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                           } else {
                            $0 = 0;
                           }
                           if (HEAP32[$5 + 520 >> 2] > 1) {
                            $2 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                           } else {
                            $2 = 0;
                           }
                           $2 = jsvGetInteger($2);
                           if (HEAP32[$5 + 520 >> 2] > 2) {
                            $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
                           } else {
                            $3 = 0;
                           }
                           $3 = jsvGetInteger($3);
                           if (HEAP32[$5 + 520 >> 2] > 3) {
                            $6 = HEAP32[HEAP32[$5 + 524 >> 2] + 12 >> 2];
                           } else {
                            $6 = 0;
                           }
                           FUNCTION_TABLE[$4]($1, $0, $2, $3, jshGetPinFromVar($6) & 255);
                           HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 108 >> 2];
                           break label$1;
                          }
                          HEAP32[$5 + 104 >> 2] = 0;
                          $2 = HEAP32[$5 + 536 >> 2];
                          $0 = $5;
                          $1 = HEAP32[$5 + 528 >> 2];
                          if (HEAP32[$5 + 520 >> 2] > 0) {
                           $3 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                          } else {
                           $3 = 0;
                          }
                          HEAP32[$0 + 104 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$2]($1, jsvGetInteger($3)) | 0);
                          HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 104 >> 2];
                          break label$1;
                         }
                         HEAP32[$5 + 100 >> 2] = 0;
                         $3 = HEAP32[$5 + 536 >> 2];
                         $0 = $5;
                         $2 = HEAP32[$5 + 528 >> 2];
                         if (HEAP32[$5 + 520 >> 2] > 0) {
                          $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                         } else {
                          $1 = 0;
                         }
                         if (HEAP32[$5 + 520 >> 2] > 1) {
                          $4 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                         } else {
                          $4 = 0;
                         }
                         HEAP32[$0 + 100 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$3]($2, $1, $4) | 0);
                         HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 100 >> 2];
                         break label$1;
                        }
                        HEAP32[$5 + 96 >> 2] = 0;
                        $3 = HEAP32[$5 + 536 >> 2];
                        $0 = $5;
                        $2 = HEAP32[$5 + 528 >> 2];
                        if (HEAP32[$5 + 520 >> 2] > 0) {
                         $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                        } else {
                         $1 = 0;
                        }
                        if (HEAP32[$5 + 520 >> 2] > 1) {
                         $4 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                        } else {
                         $4 = 0;
                        }
                        HEAP32[$0 + 96 >> 2] = jsvNewFromBool(FUNCTION_TABLE[$3]($2, $1, $4) & 1);
                        HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 96 >> 2];
                        break label$1;
                       }
                       HEAP32[$5 + 92 >> 2] = 0;
                       $2 = HEAP32[$5 + 536 >> 2];
                       $0 = $5;
                       if (HEAP32[$5 + 520 >> 2] > 0) {
                        $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                       } else {
                        $1 = 0;
                       }
                       $1 = jsvGetInteger($1);
                       if (HEAP32[$5 + 520 >> 2] > 1) {
                        $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                       } else {
                        $3 = 0;
                       }
                       HEAP32[$0 + 92 >> 2] = FUNCTION_TABLE[$2]($1, $3);
                       HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 92 >> 2];
                       break label$1;
                      }
                      HEAP32[$5 + 88 >> 2] = 0;
                      $2 = HEAP32[$5 + 536 >> 2];
                      $0 = HEAP32[$5 + 528 >> 2];
                      if (HEAP32[$5 + 520 >> 2] > 0) {
                       $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                      } else {
                       $1 = 0;
                      }
                      $1 = jshGetPinFromVar($1) & 255;
                      if (HEAP32[$5 + 520 >> 2] > 1) {
                       $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                      } else {
                       $3 = 0;
                      }
                      $8 = jsvGetFloat($3);
                      if (HEAP32[$5 + 520 >> 2] > 2) {
                       $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
                      } else {
                       $3 = 0;
                      }
                      FUNCTION_TABLE[$2]($0, $1, $8, $3);
                      HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 88 >> 2];
                      break label$1;
                     }
                     HEAP32[$5 + 84 >> 2] = 0;
                     $1 = HEAP32[$5 + 536 >> 2];
                     $0 = $5;
                     if (HEAP32[$5 + 520 >> 2] > 0) {
                      $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                     } else {
                      $2 = 0;
                     }
                     HEAP32[$0 + 84 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$1](jsvGetFloat($2)));
                     HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 84 >> 2];
                     break label$1;
                    }
                    HEAP32[$5 + 80 >> 2] = 0;
                    $1 = HEAP32[$5 + 536 >> 2];
                    $0 = $5;
                    if (HEAP32[$5 + 520 >> 2] > 0) {
                     $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                    } else {
                     $2 = 0;
                    }
                    $8 = jsvGetFloat($2);
                    if (HEAP32[$5 + 520 >> 2] > 1) {
                     $2 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                    } else {
                     $2 = 0;
                    }
                    HEAP32[$0 + 80 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$1]($8, jsvGetFloat($2)));
                    HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 80 >> 2];
                    break label$1;
                   }
                   HEAP32[$5 + 76 >> 2] = 0;
                   $1 = HEAP32[$5 + 536 >> 2];
                   $0 = $5;
                   if (HEAP32[$5 + 520 >> 2] > 0) {
                    $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                   } else {
                    $2 = 0;
                   }
                   HEAP32[$0 + 76 >> 2] = FUNCTION_TABLE[$1](jsvGetFloat($2));
                   HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 76 >> 2];
                   break label$1;
                  }
                  HEAP32[$5 + 72 >> 2] = 0;
                  $0 = $5;
                  label$458 : {
                   if (HEAP32[$5 + 520 >> 2] > 0) {
                    $1 = jsvNewArray(HEAP32[$5 + 524 >> 2], HEAP32[$5 + 520 >> 2]);
                    break label$458;
                   }
                   $1 = jsvNewWithFlags(3);
                  }
                  HEAP32[$0 + 68 >> 2] = $1;
                  HEAP32[$5 + 72 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[HEAP32[$5 + 536 >> 2]](HEAP32[$5 + 68 >> 2]));
                  jsvUnLock(HEAP32[$5 + 68 >> 2]);
                  HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 72 >> 2];
                  break label$1;
                 }
                 HEAP32[$5 + 64 >> 2] = 0;
                 $4 = HEAP32[$5 + 536 >> 2];
                 $0 = $5;
                 if (HEAP32[$5 + 520 >> 2] > 0) {
                  $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                 } else {
                  $1 = 0;
                 }
                 $1 = jsvGetInteger($1);
                 if (HEAP32[$5 + 520 >> 2] > 1) {
                  $2 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
                 } else {
                  $2 = 0;
                 }
                 $2 = jsvGetInteger($2);
                 if (HEAP32[$5 + 520 >> 2] > 2) {
                  $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
                 } else {
                  $3 = 0;
                 }
                 $3 = jsvGetInteger($3);
                 if (HEAP32[$5 + 520 >> 2] > 3) {
                  $6 = HEAP32[HEAP32[$5 + 524 >> 2] + 12 >> 2];
                 } else {
                  $6 = 0;
                 }
                 HEAP32[$0 + 64 >> 2] = FUNCTION_TABLE[$4]($1, $2, $3, $6);
                 HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 64 >> 2];
                 break label$1;
                }
                HEAP32[$5 + 60 >> 2] = 0;
                $2 = HEAP32[$5 + 536 >> 2];
                $0 = $5;
                $1 = HEAP32[$5 + 528 >> 2];
                if (HEAP32[$5 + 520 >> 2] > 0) {
                 $3 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
                } else {
                 $3 = 0;
                }
                HEAP32[$0 + 60 >> 2] = FUNCTION_TABLE[$2]($1, jsvGetBool($3) & 1);
                HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 60 >> 2];
                break label$1;
               }
               HEAP32[$5 + 56 >> 2] = 0;
               $0 = HEAP32[$5 + 536 >> 2];
               $1 = $5;
               $3 = HEAP32[$5 + 528 >> 2];
               if (HEAP32[$5 + 520 >> 2] > 0) {
                $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
               } else {
                $2 = 0;
               }
               if (HEAP32[$5 + 520 >> 2] > 1) {
                $4 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
               } else {
                $4 = 0;
               }
               $4 = jsvGetInteger($4);
               if (HEAP32[$5 + 520 >> 2] > 2) {
                $6 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
               } else {
                $6 = 0;
               }
               $6 = jsvGetInteger($6);
               if (HEAP32[$5 + 520 >> 2] > 3) {
                $7 = HEAP32[HEAP32[$5 + 524 >> 2] + 12 >> 2];
               } else {
                $7 = 0;
               }
               HEAP32[$1 + 56 >> 2] = FUNCTION_TABLE[$0]($3, $2, $4, $6, jsvGetInteger($7));
               HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 56 >> 2];
               break label$1;
              }
              HEAP32[$5 + 52 >> 2] = 0;
              $4 = HEAP32[$5 + 536 >> 2];
              $0 = $5;
              $1 = HEAP32[$5 + 528 >> 2];
              if (HEAP32[$5 + 520 >> 2] > 0) {
               $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
              } else {
               $2 = 0;
              }
              $2 = jsvGetInteger($2);
              if (HEAP32[$5 + 520 >> 2] > 1) {
               $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
              } else {
               $3 = 0;
              }
              $3 = jsvGetInteger($3);
              if (HEAP32[$5 + 520 >> 2] > 2) {
               $6 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
              } else {
               $6 = 0;
              }
              HEAP32[$0 + 52 >> 2] = FUNCTION_TABLE[$4]($1, $2, $3, jsvGetInteger($6));
              HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 52 >> 2];
              break label$1;
             }
             HEAP32[$5 + 48 >> 2] = 0;
             $0 = HEAP32[$5 + 536 >> 2];
             $1 = $5;
             $2 = HEAP32[$5 + 528 >> 2];
             if (HEAP32[$5 + 520 >> 2] > 0) {
              $3 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
             } else {
              $3 = 0;
             }
             $3 = jsvGetInteger($3);
             if (HEAP32[$5 + 520 >> 2] > 1) {
              $4 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
             } else {
              $4 = 0;
             }
             $4 = jsvGetInteger($4);
             if (HEAP32[$5 + 520 >> 2] > 2) {
              $6 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
             } else {
              $6 = 0;
             }
             $6 = jsvGetInteger($6);
             if (HEAP32[$5 + 520 >> 2] > 3) {
              $7 = HEAP32[HEAP32[$5 + 524 >> 2] + 12 >> 2];
             } else {
              $7 = 0;
             }
             HEAP32[$1 + 48 >> 2] = FUNCTION_TABLE[$0]($2, $3, $4, $6, jsvGetInteger($7));
             HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 48 >> 2];
             break label$1;
            }
            HEAP32[$5 + 44 >> 2] = 0;
            $3 = HEAP32[$5 + 536 >> 2];
            $0 = $5;
            $1 = HEAP32[$5 + 528 >> 2];
            if (HEAP32[$5 + 520 >> 2] > 0) {
             $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
            } else {
             $2 = 0;
            }
            $2 = jsvGetInteger($2);
            if (HEAP32[$5 + 520 >> 2] > 1) {
             $4 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
            } else {
             $4 = 0;
            }
            HEAP32[$0 + 44 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$3]($1, $2, jsvGetInteger($4)) | 0);
            HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 44 >> 2];
            break label$1;
           }
           HEAP32[$5 + 40 >> 2] = 0;
           $4 = HEAP32[$5 + 536 >> 2];
           $0 = $5;
           $1 = HEAP32[$5 + 528 >> 2];
           if (HEAP32[$5 + 520 >> 2] > 0) {
            $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
           } else {
            $2 = 0;
           }
           $2 = jsvGetInteger($2);
           if (HEAP32[$5 + 520 >> 2] > 1) {
            $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
           } else {
            $3 = 0;
           }
           $3 = jsvGetInteger($3);
           if (HEAP32[$5 + 520 >> 2] > 2) {
            $6 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
           } else {
            $6 = 0;
           }
           HEAP32[$0 + 40 >> 2] = FUNCTION_TABLE[$4]($1, $2, $3, $6);
           HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 40 >> 2];
           break label$1;
          }
          HEAP32[$5 + 36 >> 2] = 0;
          $4 = HEAP32[$5 + 536 >> 2];
          $0 = $5;
          $3 = HEAP32[$5 + 528 >> 2];
          if (HEAP32[$5 + 520 >> 2] > 0) {
           $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
          } else {
           $1 = 0;
          }
          if (HEAP32[$5 + 520 >> 2] > 1) {
           $2 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
          } else {
           $2 = 0;
          }
          if (HEAP32[$5 + 520 >> 2] > 2) {
           $6 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
          } else {
           $6 = 0;
          }
          HEAP32[$0 + 36 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$4]($3, $1, $2, $6) | 0);
          HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 36 >> 2];
          break label$1;
         }
         HEAP32[$5 + 32 >> 2] = 0;
         $4 = HEAP32[$5 + 536 >> 2];
         $0 = $5;
         $3 = HEAP32[$5 + 528 >> 2];
         if (HEAP32[$5 + 520 >> 2] > 0) {
          $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
         } else {
          $1 = 0;
         }
         if (HEAP32[$5 + 520 >> 2] > 1) {
          $2 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
         } else {
          $2 = 0;
         }
         if (HEAP32[$5 + 520 >> 2] > 2) {
          $6 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
         } else {
          $6 = 0;
         }
         HEAP32[$0 + 32 >> 2] = FUNCTION_TABLE[$4]($3, $1, $2, $6);
         HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 32 >> 2];
         break label$1;
        }
        HEAP32[$5 + 28 >> 2] = 0;
        $0 = HEAP32[$5 + 536 >> 2];
        $1 = $5;
        $4 = HEAP32[$5 + 528 >> 2];
        if (HEAP32[$5 + 520 >> 2] > 0) {
         $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
        } else {
         $2 = 0;
        }
        if (HEAP32[$5 + 520 >> 2] > 1) {
         $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
        } else {
         $3 = 0;
        }
        $6 = jsvGetInteger($3);
        if (HEAP32[$5 + 520 >> 2] > 2) {
         $3 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
        } else {
         $3 = 0;
        }
        if (HEAP32[$5 + 520 >> 2] > 3) {
         $7 = HEAP32[HEAP32[$5 + 524 >> 2] + 12 >> 2];
        } else {
         $7 = 0;
        }
        HEAP32[$1 + 28 >> 2] = FUNCTION_TABLE[$0]($4, $2, $6, $3, jsvGetInteger($7));
        HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 28 >> 2];
        break label$1;
       }
       HEAP32[$5 + 24 >> 2] = 0;
       $2 = HEAP32[$5 + 536 >> 2];
       $0 = $5;
       $1 = HEAP32[$5 + 528 >> 2];
       if (HEAP32[$5 + 520 >> 2] > 0) {
        $3 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
       } else {
        $3 = 0;
       }
       HEAP32[$0 + 24 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$2]($1, $3) | 0);
       HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 24 >> 2];
       break label$1;
      }
      HEAP32[$5 + 20 >> 2] = 0;
      $0 = HEAP32[$5 + 536 >> 2];
      $1 = $5;
      $3 = HEAP32[$5 + 528 >> 2];
      if (HEAP32[$5 + 520 >> 2] > 0) {
       $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
      } else {
       $2 = 0;
      }
      if (HEAP32[$5 + 520 >> 2] > 1) {
       $4 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
      } else {
       $4 = 0;
      }
      $4 = jsvGetInteger($4);
      if (HEAP32[$5 + 520 >> 2] > 2) {
       $6 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
      } else {
       $6 = 0;
      }
      $6 = jsvGetInteger($6);
      if (HEAP32[$5 + 520 >> 2] > 3) {
       $7 = HEAP32[HEAP32[$5 + 524 >> 2] + 12 >> 2];
      } else {
       $7 = 0;
      }
      HEAP32[$1 + 20 >> 2] = FUNCTION_TABLE[$0]($3, $2, $4, $6, jsvGetBool($7) & 1);
      HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 20 >> 2];
      break label$1;
     }
     HEAP32[$5 + 16 >> 2] = 0;
     $3 = HEAP32[$5 + 536 >> 2];
     $0 = $5;
     $1 = HEAP32[$5 + 528 >> 2];
     if (HEAP32[$5 + 520 >> 2] > 0) {
      $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
     } else {
      $2 = 0;
     }
     $2 = jsvGetInteger($2);
     if (HEAP32[$5 + 520 >> 2] > 1) {
      $4 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
     } else {
      $4 = 0;
     }
     HEAP32[$0 + 16 >> 2] = FUNCTION_TABLE[$3]($1, $2, jsvGetInteger($4));
     HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 16 >> 2];
     break label$1;
    }
    HEAP32[$5 + 12 >> 2] = 0;
    $3 = HEAP32[$5 + 536 >> 2];
    $0 = $5;
    $2 = HEAP32[$5 + 528 >> 2];
    if (HEAP32[$5 + 520 >> 2] > 0) {
     $1 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
    } else {
     $1 = 0;
    }
    if (HEAP32[$5 + 520 >> 2] > 1) {
     $4 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
    } else {
     $4 = 0;
    }
    HEAP32[$0 + 12 >> 2] = FUNCTION_TABLE[$3]($2, $1, jsvGetBool($4) & 1);
    HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 12 >> 2];
    break label$1;
   }
   HEAP32[$5 + 8 >> 2] = 0;
   $0 = HEAP32[$5 + 536 >> 2];
   $1 = $5;
   $3 = HEAP32[$5 + 528 >> 2];
   if (HEAP32[$5 + 520 >> 2] > 0) {
    $2 = HEAP32[HEAP32[$5 + 524 >> 2] >> 2];
   } else {
    $2 = 0;
   }
   if (HEAP32[$5 + 520 >> 2] > 1) {
    $4 = HEAP32[HEAP32[$5 + 524 >> 2] + 4 >> 2];
   } else {
    $4 = 0;
   }
   $4 = jsvGetInteger($4);
   if (HEAP32[$5 + 520 >> 2] > 2) {
    $6 = HEAP32[HEAP32[$5 + 524 >> 2] + 8 >> 2];
   } else {
    $6 = 0;
   }
   $6 = jsvGetInteger($6);
   if (HEAP32[$5 + 520 >> 2] > 3) {
    $7 = HEAP32[HEAP32[$5 + 524 >> 2] + 12 >> 2];
   } else {
    $7 = 0;
   }
   HEAP32[$1 + 8 >> 2] = FUNCTION_TABLE[$0]($3, $2, $4, $6, $7);
   HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 8 >> 2];
   break label$1;
  }
  HEAP32[$5 >> 2] = HEAPU16[$5 + 534 >> 1];
  jsExceptionHere(1, 95192, $5);
  HEAP32[$5 + 540 >> 2] = 0;
 }
 global$0 = $5 + 544 | 0;
 return HEAP32[$5 + 540 >> 2];
}
function dlmalloc($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 $12 = global$0 - 16 | 0;
 global$0 = $12;
 label$1 : {
  label$2 : {
   label$3 : {
    label$4 : {
     if ($0 >>> 0 <= 244) {
      $4 = HEAP32[84259];
      $6 = $0 >>> 0 < 11 ? 16 : $0 + 11 & -8;
      $0 = $6 >>> 3;
      $1 = $4 >>> $0;
      if ($1 & 3) {
       $2 = $0 + (($1 ^ -1) & 1) | 0;
       $3 = $2 << 3;
       $1 = HEAP32[$3 + 337084 >> 2];
       $0 = HEAP32[$1 + 8 >> 2];
       $3 = $3 + 337076 | 0;
       label$7 : {
        if (($0 | 0) == ($3 | 0)) {
         HEAP32[84259] = __wasm_rotl_i32($2) & $4;
         break label$7;
        }
        if (($1 | 0) != HEAP32[$0 + 12 >> 2] | HEAPU32[84263] > $0 >>> 0) {
         break label$3;
        }
        HEAP32[$0 + 12 >> 2] = $3;
        HEAP32[$3 + 8 >> 2] = $0;
       }
       $0 = $1 + 8 | 0;
       $2 = $2 << 3;
       HEAP32[$1 + 4 >> 2] = $2 | 3;
       $1 = $1 + $2 | 0;
       HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] | 1;
       break label$1;
      }
      $9 = HEAP32[84261];
      if ($6 >>> 0 <= $9 >>> 0) {
       break label$4;
      }
      if ($1) {
       $2 = 2 << $0;
       $0 = (0 - $2 | $2) & $1 << $0;
       $0 = (0 - $0 & $0) + -1 | 0;
       $1 = $0 >>> 12 & 16;
       $2 = $1;
       $0 = $0 >>> $1;
       $1 = $0 >>> 5 & 8;
       $2 = $2 | $1;
       $0 = $0 >>> $1;
       $1 = $0 >>> 2 & 4;
       $2 = $2 | $1;
       $0 = $0 >>> $1;
       $1 = $0 >>> 1 & 2;
       $2 = $2 | $1;
       $0 = $0 >>> $1;
       $1 = $0 >>> 1 & 1;
       $2 = ($2 | $1) + ($0 >>> $1) | 0;
       $3 = $2 << 3;
       $1 = HEAP32[$3 + 337084 >> 2];
       $0 = HEAP32[$1 + 8 >> 2];
       $3 = $3 + 337076 | 0;
       label$10 : {
        if (($0 | 0) == ($3 | 0)) {
         $4 = __wasm_rotl_i32($2) & $4;
         HEAP32[84259] = $4;
         break label$10;
        }
        if (($1 | 0) != HEAP32[$0 + 12 >> 2] | HEAPU32[84263] > $0 >>> 0) {
         break label$3;
        }
        HEAP32[$0 + 12 >> 2] = $3;
        HEAP32[$3 + 8 >> 2] = $0;
       }
       HEAP32[$1 + 4 >> 2] = $6 | 3;
       $7 = $1 + $6 | 0;
       $0 = $2 << 3;
       $3 = $0 - $6 | 0;
       HEAP32[$7 + 4 >> 2] = $3 | 1;
       HEAP32[$0 + $1 >> 2] = $3;
       if ($9) {
        $5 = $9 >>> 3;
        $0 = ($5 << 3) + 337076 | 0;
        $2 = HEAP32[84264];
        $5 = 1 << $5;
        label$13 : {
         if (!($5 & $4)) {
          HEAP32[84259] = $5 | $4;
          $5 = $0;
          break label$13;
         }
         $5 = HEAP32[$0 + 8 >> 2];
         if (HEAPU32[84263] > $5 >>> 0) {
          break label$3;
         }
        }
        HEAP32[$0 + 8 >> 2] = $2;
        HEAP32[$5 + 12 >> 2] = $2;
        HEAP32[$2 + 12 >> 2] = $0;
        HEAP32[$2 + 8 >> 2] = $5;
       }
       $0 = $1 + 8 | 0;
       HEAP32[84264] = $7;
       HEAP32[84261] = $3;
       break label$1;
      }
      $10 = HEAP32[84260];
      if (!$10) {
       break label$4;
      }
      $0 = ($10 & 0 - $10) + -1 | 0;
      $1 = $0 >>> 12 & 16;
      $2 = $1;
      $0 = $0 >>> $1;
      $1 = $0 >>> 5 & 8;
      $2 = $2 | $1;
      $0 = $0 >>> $1;
      $1 = $0 >>> 2 & 4;
      $2 = $2 | $1;
      $0 = $0 >>> $1;
      $1 = $0 >>> 1 & 2;
      $2 = $2 | $1;
      $0 = $0 >>> $1;
      $1 = $0 >>> 1 & 1;
      $1 = HEAP32[(($2 | $1) + ($0 >>> $1) << 2) + 337340 >> 2];
      $3 = (HEAP32[$1 + 4 >> 2] & -8) - $6 | 0;
      $2 = $1;
      while (1) {
       label$16 : {
        $0 = HEAP32[$2 + 16 >> 2];
        if (!$0) {
         $0 = HEAP32[$2 + 20 >> 2];
         if (!$0) {
          break label$16;
         }
        }
        $5 = (HEAP32[$0 + 4 >> 2] & -8) - $6 | 0;
        $2 = $5 >>> 0 < $3 >>> 0;
        $3 = $2 ? $5 : $3;
        $1 = $2 ? $0 : $1;
        $2 = $0;
        continue;
       }
       break;
      }
      $13 = HEAP32[84263];
      if ($13 >>> 0 > $1 >>> 0) {
       break label$3;
      }
      $11 = $1 + $6 | 0;
      if ($11 >>> 0 <= $1 >>> 0) {
       break label$3;
      }
      $8 = HEAP32[$1 + 24 >> 2];
      $5 = HEAP32[$1 + 12 >> 2];
      label$18 : {
       if (($5 | 0) != ($1 | 0)) {
        $0 = HEAP32[$1 + 8 >> 2];
        if ($13 >>> 0 > $0 >>> 0 | HEAP32[$0 + 12 >> 2] != ($1 | 0) | HEAP32[$5 + 8 >> 2] != ($1 | 0)) {
         break label$3;
        }
        HEAP32[$0 + 12 >> 2] = $5;
        HEAP32[$5 + 8 >> 2] = $0;
        break label$18;
       }
       label$20 : {
        $2 = $1 + 20 | 0;
        $0 = HEAP32[$2 >> 2];
        if (!$0) {
         $0 = HEAP32[$1 + 16 >> 2];
         if (!$0) {
          break label$20;
         }
         $2 = $1 + 16 | 0;
        }
        while (1) {
         $7 = $2;
         $5 = $0;
         $2 = $0 + 20 | 0;
         $0 = HEAP32[$2 >> 2];
         if ($0) {
          continue;
         }
         $2 = $5 + 16 | 0;
         $0 = HEAP32[$5 + 16 >> 2];
         if ($0) {
          continue;
         }
         break;
        }
        if ($13 >>> 0 > $7 >>> 0) {
         break label$3;
        }
        HEAP32[$7 >> 2] = 0;
        break label$18;
       }
       $5 = 0;
      }
      label$23 : {
       if (!$8) {
        break label$23;
       }
       $0 = HEAP32[$1 + 28 >> 2];
       $2 = ($0 << 2) + 337340 | 0;
       label$24 : {
        if (HEAP32[$2 >> 2] == ($1 | 0)) {
         HEAP32[$2 >> 2] = $5;
         if ($5) {
          break label$24;
         }
         HEAP32[84260] = __wasm_rotl_i32($0) & $10;
         break label$23;
        }
        if (HEAPU32[84263] > $8 >>> 0) {
         break label$3;
        }
        HEAP32[$8 + (HEAP32[$8 + 16 >> 2] == ($1 | 0) ? 16 : 20) >> 2] = $5;
        if (!$5) {
         break label$23;
        }
       }
       $2 = HEAP32[84263];
       if ($2 >>> 0 > $5 >>> 0) {
        break label$3;
       }
       HEAP32[$5 + 24 >> 2] = $8;
       $0 = HEAP32[$1 + 16 >> 2];
       if ($0) {
        if ($2 >>> 0 > $0 >>> 0) {
         break label$3;
        }
        HEAP32[$5 + 16 >> 2] = $0;
        HEAP32[$0 + 24 >> 2] = $5;
       }
       $0 = HEAP32[$1 + 20 >> 2];
       if (!$0) {
        break label$23;
       }
       if (HEAPU32[84263] > $0 >>> 0) {
        break label$3;
       }
       HEAP32[$5 + 20 >> 2] = $0;
       HEAP32[$0 + 24 >> 2] = $5;
      }
      label$27 : {
       if ($3 >>> 0 <= 15) {
        $0 = $3 + $6 | 0;
        HEAP32[$1 + 4 >> 2] = $0 | 3;
        $0 = $0 + $1 | 0;
        HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] | 1;
        break label$27;
       }
       HEAP32[$1 + 4 >> 2] = $6 | 3;
       HEAP32[$11 + 4 >> 2] = $3 | 1;
       HEAP32[$3 + $11 >> 2] = $3;
       if ($9) {
        $5 = $9 >>> 3;
        $0 = ($5 << 3) + 337076 | 0;
        $2 = HEAP32[84264];
        $5 = 1 << $5;
        label$30 : {
         if (!($5 & $4)) {
          HEAP32[84259] = $5 | $4;
          $6 = $0;
          break label$30;
         }
         $6 = HEAP32[$0 + 8 >> 2];
         if (HEAPU32[84263] > $6 >>> 0) {
          break label$3;
         }
        }
        HEAP32[$0 + 8 >> 2] = $2;
        HEAP32[$6 + 12 >> 2] = $2;
        HEAP32[$2 + 12 >> 2] = $0;
        HEAP32[$2 + 8 >> 2] = $6;
       }
       HEAP32[84264] = $11;
       HEAP32[84261] = $3;
      }
      $0 = $1 + 8 | 0;
      break label$1;
     }
     $6 = -1;
     if ($0 >>> 0 > 4294967231) {
      break label$4;
     }
     $1 = $0 + 11 | 0;
     $6 = $1 & -8;
     $8 = HEAP32[84260];
     if (!$8) {
      break label$4;
     }
     $2 = 0 - $6 | 0;
     $1 = $1 >>> 8;
     $4 = 0;
     label$35 : {
      if (!$1) {
       break label$35;
      }
      $4 = 31;
      if ($6 >>> 0 > 16777215) {
       break label$35;
      }
      $3 = $1 + 1048320 >>> 16 & 8;
      $1 = $1 << $3;
      $0 = $1 + 520192 >>> 16 & 4;
      $4 = $1 << $0;
      $1 = $4 + 245760 >>> 16 & 2;
      $0 = ($4 << $1 >>> 15) - ($1 | ($0 | $3)) | 0;
      $4 = ($0 << 1 | $6 >>> $0 + 21 & 1) + 28 | 0;
     }
     $3 = HEAP32[($4 << 2) + 337340 >> 2];
     label$32 : {
      label$33 : {
       label$34 : {
        if (!$3) {
         $0 = 0;
         break label$34;
        }
        $1 = $6 << (($4 | 0) == 31 ? 0 : 25 - ($4 >>> 1) | 0);
        $0 = 0;
        while (1) {
         label$38 : {
          $7 = (HEAP32[$3 + 4 >> 2] & -8) - $6 | 0;
          if ($7 >>> 0 >= $2 >>> 0) {
           break label$38;
          }
          $5 = $3;
          $2 = $7;
          if ($2) {
           break label$38;
          }
          $2 = 0;
          $0 = $3;
          break label$33;
         }
         $7 = HEAP32[$3 + 20 >> 2];
         $3 = HEAP32[(($1 >>> 29 & 4) + $3 | 0) + 16 >> 2];
         $0 = $7 ? ($7 | 0) == ($3 | 0) ? $0 : $7 : $0;
         $1 = $1 << (($3 | 0) != 0);
         if ($3) {
          continue;
         }
         break;
        }
       }
       if (!($0 | $5)) {
        $0 = 2 << $4;
        $0 = (0 - $0 | $0) & $8;
        if (!$0) {
         break label$4;
        }
        $0 = ($0 & 0 - $0) + -1 | 0;
        $1 = $0 >>> 12 & 16;
        $3 = $1;
        $0 = $0 >>> $1;
        $1 = $0 >>> 5 & 8;
        $3 = $3 | $1;
        $0 = $0 >>> $1;
        $1 = $0 >>> 2 & 4;
        $3 = $3 | $1;
        $0 = $0 >>> $1;
        $1 = $0 >>> 1 & 2;
        $3 = $3 | $1;
        $0 = $0 >>> $1;
        $1 = $0 >>> 1 & 1;
        $0 = HEAP32[(($3 | $1) + ($0 >>> $1) << 2) + 337340 >> 2];
       }
       if (!$0) {
        break label$32;
       }
      }
      while (1) {
       $3 = (HEAP32[$0 + 4 >> 2] & -8) - $6 | 0;
       $1 = $3 >>> 0 < $2 >>> 0;
       $2 = $1 ? $3 : $2;
       $5 = $1 ? $0 : $5;
       $1 = HEAP32[$0 + 16 >> 2];
       if ($1) {
        $0 = $1;
       } else {
        $0 = HEAP32[$0 + 20 >> 2];
       }
       if ($0) {
        continue;
       }
       break;
      }
     }
     if (!$5 | $2 >>> 0 >= HEAP32[84261] - $6 >>> 0) {
      break label$4;
     }
     $10 = HEAP32[84263];
     if ($10 >>> 0 > $5 >>> 0) {
      break label$3;
     }
     $4 = $5 + $6 | 0;
     if ($4 >>> 0 <= $5 >>> 0) {
      break label$3;
     }
     $9 = HEAP32[$5 + 24 >> 2];
     $1 = HEAP32[$5 + 12 >> 2];
     label$43 : {
      if (($5 | 0) != ($1 | 0)) {
       $0 = HEAP32[$5 + 8 >> 2];
       if ($10 >>> 0 > $0 >>> 0 | HEAP32[$0 + 12 >> 2] != ($5 | 0) | HEAP32[$1 + 8 >> 2] != ($5 | 0)) {
        break label$3;
       }
       HEAP32[$0 + 12 >> 2] = $1;
       HEAP32[$1 + 8 >> 2] = $0;
       break label$43;
      }
      label$45 : {
       $3 = $5 + 20 | 0;
       $0 = HEAP32[$3 >> 2];
       if (!$0) {
        $0 = HEAP32[$5 + 16 >> 2];
        if (!$0) {
         break label$45;
        }
        $3 = $5 + 16 | 0;
       }
       while (1) {
        $7 = $3;
        $1 = $0;
        $3 = $0 + 20 | 0;
        $0 = HEAP32[$3 >> 2];
        if ($0) {
         continue;
        }
        $3 = $1 + 16 | 0;
        $0 = HEAP32[$1 + 16 >> 2];
        if ($0) {
         continue;
        }
        break;
       }
       if ($10 >>> 0 > $7 >>> 0) {
        break label$3;
       }
       HEAP32[$7 >> 2] = 0;
       break label$43;
      }
      $1 = 0;
     }
     label$48 : {
      if (!$9) {
       break label$48;
      }
      $0 = HEAP32[$5 + 28 >> 2];
      $3 = ($0 << 2) + 337340 | 0;
      label$49 : {
       if (HEAP32[$3 >> 2] == ($5 | 0)) {
        HEAP32[$3 >> 2] = $1;
        if ($1) {
         break label$49;
        }
        $8 = __wasm_rotl_i32($0) & $8;
        HEAP32[84260] = $8;
        break label$48;
       }
       if (HEAPU32[84263] > $9 >>> 0) {
        break label$3;
       }
       HEAP32[$9 + (HEAP32[$9 + 16 >> 2] == ($5 | 0) ? 16 : 20) >> 2] = $1;
       if (!$1) {
        break label$48;
       }
      }
      $3 = HEAP32[84263];
      if ($3 >>> 0 > $1 >>> 0) {
       break label$3;
      }
      HEAP32[$1 + 24 >> 2] = $9;
      $0 = HEAP32[$5 + 16 >> 2];
      if ($0) {
       if ($3 >>> 0 > $0 >>> 0) {
        break label$3;
       }
       HEAP32[$1 + 16 >> 2] = $0;
       HEAP32[$0 + 24 >> 2] = $1;
      }
      $0 = HEAP32[$5 + 20 >> 2];
      if (!$0) {
       break label$48;
      }
      if (HEAPU32[84263] > $0 >>> 0) {
       break label$3;
      }
      HEAP32[$1 + 20 >> 2] = $0;
      HEAP32[$0 + 24 >> 2] = $1;
     }
     label$52 : {
      if ($2 >>> 0 <= 15) {
       $0 = $2 + $6 | 0;
       HEAP32[$5 + 4 >> 2] = $0 | 3;
       $0 = $0 + $5 | 0;
       HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] | 1;
       break label$52;
      }
      HEAP32[$5 + 4 >> 2] = $6 | 3;
      HEAP32[$4 + 4 >> 2] = $2 | 1;
      HEAP32[$2 + $4 >> 2] = $2;
      if ($2 >>> 0 <= 255) {
       $1 = $2 >>> 3;
       $0 = ($1 << 3) + 337076 | 0;
       $2 = HEAP32[84259];
       $1 = 1 << $1;
       label$55 : {
        if (!($2 & $1)) {
         HEAP32[84259] = $1 | $2;
         $3 = $0;
         break label$55;
        }
        $3 = HEAP32[$0 + 8 >> 2];
        if (HEAPU32[84263] > $3 >>> 0) {
         break label$3;
        }
       }
       HEAP32[$0 + 8 >> 2] = $4;
       HEAP32[$3 + 12 >> 2] = $4;
       HEAP32[$4 + 12 >> 2] = $0;
       HEAP32[$4 + 8 >> 2] = $3;
       break label$52;
      }
      $1 = $4;
      $3 = $2 >>> 8;
      $0 = 0;
      label$57 : {
       if (!$3) {
        break label$57;
       }
       $0 = 31;
       if ($2 >>> 0 > 16777215) {
        break label$57;
       }
       $6 = $3 + 1048320 >>> 16 & 8;
       $3 = $3 << $6;
       $0 = $3 + 520192 >>> 16 & 4;
       $7 = $3 << $0;
       $3 = $7 + 245760 >>> 16 & 2;
       $0 = ($7 << $3 >>> 15) - ($3 | ($0 | $6)) | 0;
       $0 = ($0 << 1 | $2 >>> $0 + 21 & 1) + 28 | 0;
      }
      HEAP32[$1 + 28 >> 2] = $0;
      HEAP32[$4 + 16 >> 2] = 0;
      HEAP32[$4 + 20 >> 2] = 0;
      $1 = ($0 << 2) + 337340 | 0;
      label$58 : {
       $3 = 1 << $0;
       label$59 : {
        if (!($3 & $8)) {
         HEAP32[84260] = $3 | $8;
         HEAP32[$1 >> 2] = $4;
         break label$59;
        }
        $0 = $2 << (($0 | 0) == 31 ? 0 : 25 - ($0 >>> 1) | 0);
        $6 = HEAP32[$1 >> 2];
        while (1) {
         $1 = $6;
         if ((HEAP32[$1 + 4 >> 2] & -8) == ($2 | 0)) {
          break label$58;
         }
         $3 = $0 >>> 29;
         $0 = $0 << 1;
         $3 = (($3 & 4) + $1 | 0) + 16 | 0;
         $6 = HEAP32[$3 >> 2];
         if ($6) {
          continue;
         }
         break;
        }
        if (HEAPU32[84263] > $3 >>> 0) {
         break label$3;
        }
        HEAP32[$3 >> 2] = $4;
       }
       HEAP32[$4 + 24 >> 2] = $1;
       HEAP32[$4 + 12 >> 2] = $4;
       HEAP32[$4 + 8 >> 2] = $4;
       break label$52;
      }
      $2 = HEAP32[84263];
      $0 = HEAP32[$1 + 8 >> 2];
      if ($2 >>> 0 > $0 >>> 0 | $2 >>> 0 > $1 >>> 0) {
       break label$3;
      }
      HEAP32[$0 + 12 >> 2] = $4;
      HEAP32[$1 + 8 >> 2] = $4;
      HEAP32[$4 + 24 >> 2] = 0;
      HEAP32[$4 + 12 >> 2] = $1;
      HEAP32[$4 + 8 >> 2] = $0;
     }
     $0 = $5 + 8 | 0;
     break label$1;
    }
    $1 = HEAP32[84261];
    if ($1 >>> 0 >= $6 >>> 0) {
     $0 = HEAP32[84264];
     $2 = $1 - $6 | 0;
     label$63 : {
      if ($2 >>> 0 >= 16) {
       HEAP32[84261] = $2;
       $3 = $0 + $6 | 0;
       HEAP32[84264] = $3;
       HEAP32[$3 + 4 >> 2] = $2 | 1;
       HEAP32[$0 + $1 >> 2] = $2;
       HEAP32[$0 + 4 >> 2] = $6 | 3;
       break label$63;
      }
      HEAP32[84264] = 0;
      HEAP32[84261] = 0;
      HEAP32[$0 + 4 >> 2] = $1 | 3;
      $1 = $0 + $1 | 0;
      HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] | 1;
     }
     $0 = $0 + 8 | 0;
     break label$1;
    }
    $3 = HEAP32[84262];
    if ($3 >>> 0 > $6 >>> 0) {
     $1 = $3 - $6 | 0;
     HEAP32[84262] = $1;
     $0 = HEAP32[84265];
     $2 = $0 + $6 | 0;
     HEAP32[84265] = $2;
     HEAP32[$2 + 4 >> 2] = $1 | 1;
     HEAP32[$0 + 4 >> 2] = $6 | 3;
     $0 = $0 + 8 | 0;
     break label$1;
    }
    $0 = 0;
    $5 = $6 + 47 | 0;
    $2 = $5;
    if (HEAP32[84377]) {
     $1 = HEAP32[84379];
    } else {
     HEAP32[84380] = -1;
     HEAP32[84381] = -1;
     HEAP32[84378] = 4096;
     HEAP32[84379] = 4096;
     HEAP32[84377] = $12 + 12 & -16 ^ 1431655768;
     HEAP32[84382] = 0;
     HEAP32[84370] = 0;
     $1 = 4096;
    }
    $4 = $2 + $1 | 0;
    $7 = 0 - $1 | 0;
    $2 = $4 & $7;
    if ($2 >>> 0 <= $6 >>> 0) {
     break label$1;
    }
    $1 = HEAP32[84369];
    if ($1) {
     $8 = HEAP32[84367];
     $9 = $8 + $2 | 0;
     if ($9 >>> 0 <= $8 >>> 0 | $9 >>> 0 > $1 >>> 0) {
      break label$1;
     }
    }
    label$69 : {
     if (!(HEAPU8[337480] & 4)) {
      label$71 : {
       label$72 : {
        label$73 : {
         label$74 : {
          $1 = HEAP32[84265];
          if ($1) {
           $0 = 337484;
           while (1) {
            $8 = HEAP32[$0 >> 2];
            if ($8 + HEAP32[$0 + 4 >> 2] >>> 0 > $1 >>> 0 ? $8 >>> 0 <= $1 >>> 0 : 0) {
             break label$74;
            }
            $0 = HEAP32[$0 + 8 >> 2];
            if ($0) {
             continue;
            }
            break;
           }
          }
          $1 = sbrk(0);
          if (($1 | 0) == -1) {
           break label$71;
          }
          $4 = $2;
          $0 = HEAP32[84378];
          $3 = $0 + -1 | 0;
          if ($3 & $1) {
           $4 = ($2 - $1 | 0) + ($1 + $3 & 0 - $0) | 0;
          }
          if ($4 >>> 0 <= $6 >>> 0 | $4 >>> 0 > 2147483646) {
           break label$71;
          }
          $0 = HEAP32[84369];
          if ($0) {
           $3 = HEAP32[84367];
           $7 = $3 + $4 | 0;
           if ($7 >>> 0 <= $3 >>> 0 | $7 >>> 0 > $0 >>> 0) {
            break label$71;
           }
          }
          $0 = sbrk($4);
          if (($1 | 0) != ($0 | 0)) {
           break label$73;
          }
          break label$69;
         }
         $4 = $7 & $4 - $3;
         if ($4 >>> 0 > 2147483646) {
          break label$71;
         }
         $1 = sbrk($4);
         if (($1 | 0) == (HEAP32[$0 >> 2] + HEAP32[$0 + 4 >> 2] | 0)) {
          break label$72;
         }
         $0 = $1;
        }
        $1 = $0;
        if (!($6 + 48 >>> 0 <= $4 >>> 0 | $4 >>> 0 > 2147483646 | ($0 | 0) == -1)) {
         $0 = HEAP32[84379];
         $0 = $0 + ($5 - $4 | 0) & 0 - $0;
         if ($0 >>> 0 > 2147483646) {
          break label$69;
         }
         if ((sbrk($0) | 0) != -1) {
          $4 = $0 + $4 | 0;
          break label$69;
         }
         sbrk(0 - $4 | 0);
         break label$71;
        }
        if (($1 | 0) != -1) {
         break label$69;
        }
        break label$71;
       }
       if (($1 | 0) != -1) {
        break label$69;
       }
      }
      HEAP32[84370] = HEAP32[84370] | 4;
     }
     if ($2 >>> 0 > 2147483646) {
      break label$2;
     }
     $1 = sbrk($2);
     $0 = sbrk(0);
     if ($1 >>> 0 >= $0 >>> 0 | ($1 | 0) == -1 | ($0 | 0) == -1) {
      break label$2;
     }
     $4 = $0 - $1 | 0;
     if ($4 >>> 0 <= $6 + 40 >>> 0) {
      break label$2;
     }
    }
    $0 = HEAP32[84367] + $4 | 0;
    HEAP32[84367] = $0;
    if ($0 >>> 0 > HEAPU32[84368]) {
     HEAP32[84368] = $0;
    }
    label$83 : {
     label$84 : {
      label$85 : {
       $3 = HEAP32[84265];
       if ($3) {
        $0 = 337484;
        while (1) {
         $2 = HEAP32[$0 >> 2];
         $5 = HEAP32[$0 + 4 >> 2];
         if (($2 + $5 | 0) == ($1 | 0)) {
          break label$85;
         }
         $0 = HEAP32[$0 + 8 >> 2];
         if ($0) {
          continue;
         }
         break;
        }
        break label$84;
       }
       $0 = HEAP32[84263];
       if (!($1 >>> 0 >= $0 >>> 0 ? $0 : 0)) {
        HEAP32[84263] = $1;
       }
       $0 = 0;
       HEAP32[84372] = $4;
       HEAP32[84371] = $1;
       HEAP32[84267] = -1;
       HEAP32[84268] = HEAP32[84377];
       HEAP32[84374] = 0;
       while (1) {
        $2 = $0 << 3;
        $3 = $2 + 337076 | 0;
        HEAP32[$2 + 337084 >> 2] = $3;
        HEAP32[$2 + 337088 >> 2] = $3;
        $0 = $0 + 1 | 0;
        if (($0 | 0) != 32) {
         continue;
        }
        break;
       }
       $0 = $4 + -40 | 0;
       $2 = $1 + 8 & 7 ? -8 - $1 & 7 : 0;
       $3 = $0 - $2 | 0;
       HEAP32[84262] = $3;
       $2 = $1 + $2 | 0;
       HEAP32[84265] = $2;
       HEAP32[$2 + 4 >> 2] = $3 | 1;
       HEAP32[($0 + $1 | 0) + 4 >> 2] = 40;
       HEAP32[84266] = HEAP32[84381];
       break label$83;
      }
      if (HEAPU8[$0 + 12 | 0] & 8 | $1 >>> 0 <= $3 >>> 0 | $2 >>> 0 > $3 >>> 0) {
       break label$84;
      }
      HEAP32[$0 + 4 >> 2] = $5 + $4;
      $0 = $3 + 8 & 7 ? -8 - $3 & 7 : 0;
      $1 = $0 + $3 | 0;
      HEAP32[84265] = $1;
      $2 = HEAP32[84262] + $4 | 0;
      $0 = $2 - $0 | 0;
      HEAP32[84262] = $0;
      HEAP32[$1 + 4 >> 2] = $0 | 1;
      HEAP32[($2 + $3 | 0) + 4 >> 2] = 40;
      HEAP32[84266] = HEAP32[84381];
      break label$83;
     }
     $5 = HEAP32[84263];
     if ($1 >>> 0 < $5 >>> 0) {
      HEAP32[84263] = $1;
      $5 = $1;
     }
     $2 = $1 + $4 | 0;
     $0 = 337484;
     label$91 : {
      label$92 : {
       label$93 : {
        while (1) {
         if (($2 | 0) != HEAP32[$0 >> 2]) {
          $0 = HEAP32[$0 + 8 >> 2];
          if ($0) {
           continue;
          }
          break label$93;
         }
         break;
        }
        if (!(HEAPU8[$0 + 12 | 0] & 8)) {
         break label$92;
        }
       }
       $0 = 337484;
       while (1) {
        $2 = HEAP32[$0 >> 2];
        if ($2 >>> 0 <= $3 >>> 0) {
         $5 = $2 + HEAP32[$0 + 4 >> 2] | 0;
         if ($5 >>> 0 > $3 >>> 0) {
          break label$91;
         }
        }
        $0 = HEAP32[$0 + 8 >> 2];
        continue;
       }
      }
      HEAP32[$0 >> 2] = $1;
      HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + $4;
      $9 = ($1 + 8 & 7 ? -8 - $1 & 7 : 0) + $1 | 0;
      HEAP32[$9 + 4 >> 2] = $6 | 3;
      $1 = $2 + ($2 + 8 & 7 ? -8 - $2 & 7 : 0) | 0;
      $0 = ($1 - $9 | 0) - $6 | 0;
      $7 = $6 + $9 | 0;
      label$98 : {
       if (($1 | 0) == ($3 | 0)) {
        HEAP32[84265] = $7;
        $0 = HEAP32[84262] + $0 | 0;
        HEAP32[84262] = $0;
        HEAP32[$7 + 4 >> 2] = $0 | 1;
        break label$98;
       }
       if (HEAP32[84264] == ($1 | 0)) {
        HEAP32[84264] = $7;
        $0 = HEAP32[84261] + $0 | 0;
        HEAP32[84261] = $0;
        HEAP32[$7 + 4 >> 2] = $0 | 1;
        HEAP32[$0 + $7 >> 2] = $0;
        break label$98;
       }
       $10 = HEAP32[$1 + 4 >> 2];
       if (($10 & 3) == 1) {
        label$102 : {
         if ($10 >>> 0 <= 255) {
          $2 = HEAP32[$1 + 12 >> 2];
          $3 = HEAP32[$1 + 8 >> 2];
          $6 = $10 >>> 3;
          $4 = ($6 << 3) + 337076 | 0;
          if (HEAP32[$3 + 12 >> 2] != ($1 | 0) | $5 >>> 0 > $3 >>> 0 ? ($3 | 0) != ($4 | 0) : 0) {
           break label$3;
          }
          if (($2 | 0) == ($3 | 0)) {
           HEAP32[84259] = HEAP32[84259] & __wasm_rotl_i32($6);
           break label$102;
          }
          if (HEAP32[$2 + 8 >> 2] != ($1 | 0) | $5 >>> 0 > $2 >>> 0 ? ($2 | 0) != ($4 | 0) : 0) {
           break label$3;
          }
          HEAP32[$3 + 12 >> 2] = $2;
          HEAP32[$2 + 8 >> 2] = $3;
          break label$102;
         }
         $8 = HEAP32[$1 + 24 >> 2];
         $4 = HEAP32[$1 + 12 >> 2];
         label$107 : {
          if (($4 | 0) != ($1 | 0)) {
           $2 = HEAP32[$1 + 8 >> 2];
           if ($5 >>> 0 > $2 >>> 0 | HEAP32[$2 + 12 >> 2] != ($1 | 0) | HEAP32[$4 + 8 >> 2] != ($1 | 0)) {
            break label$3;
           }
           HEAP32[$2 + 12 >> 2] = $4;
           HEAP32[$4 + 8 >> 2] = $2;
           break label$107;
          }
          label$109 : {
           $3 = $1 + 20 | 0;
           $6 = HEAP32[$3 >> 2];
           if ($6) {
            break label$109;
           }
           $3 = $1 + 16 | 0;
           $6 = HEAP32[$3 >> 2];
           if ($6) {
            break label$109;
           }
           $4 = 0;
           break label$107;
          }
          while (1) {
           $2 = $3;
           $4 = $6;
           $3 = $4 + 20 | 0;
           $6 = HEAP32[$3 >> 2];
           if ($6) {
            continue;
           }
           $3 = $4 + 16 | 0;
           $6 = HEAP32[$4 + 16 >> 2];
           if ($6) {
            continue;
           }
           break;
          }
          if ($5 >>> 0 > $2 >>> 0) {
           break label$3;
          }
          HEAP32[$2 >> 2] = 0;
         }
         if (!$8) {
          break label$102;
         }
         $2 = HEAP32[$1 + 28 >> 2];
         $3 = ($2 << 2) + 337340 | 0;
         label$111 : {
          if (HEAP32[$3 >> 2] == ($1 | 0)) {
           HEAP32[$3 >> 2] = $4;
           if ($4) {
            break label$111;
           }
           HEAP32[84260] = HEAP32[84260] & __wasm_rotl_i32($2);
           break label$102;
          }
          if (HEAPU32[84263] > $8 >>> 0) {
           break label$3;
          }
          HEAP32[$8 + (HEAP32[$8 + 16 >> 2] == ($1 | 0) ? 16 : 20) >> 2] = $4;
          if (!$4) {
           break label$102;
          }
         }
         $3 = HEAP32[84263];
         if ($3 >>> 0 > $4 >>> 0) {
          break label$3;
         }
         HEAP32[$4 + 24 >> 2] = $8;
         $2 = HEAP32[$1 + 16 >> 2];
         if ($2) {
          if ($3 >>> 0 > $2 >>> 0) {
           break label$3;
          }
          HEAP32[$4 + 16 >> 2] = $2;
          HEAP32[$2 + 24 >> 2] = $4;
         }
         $2 = HEAP32[$1 + 20 >> 2];
         if (!$2) {
          break label$102;
         }
         if (HEAPU32[84263] > $2 >>> 0) {
          break label$3;
         }
         HEAP32[$4 + 20 >> 2] = $2;
         HEAP32[$2 + 24 >> 2] = $4;
        }
        $2 = $10 & -8;
        $0 = $2 + $0 | 0;
        $1 = $1 + $2 | 0;
       }
       HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] & -2;
       HEAP32[$7 + 4 >> 2] = $0 | 1;
       HEAP32[$0 + $7 >> 2] = $0;
       if ($0 >>> 0 <= 255) {
        $1 = $0 >>> 3;
        $0 = ($1 << 3) + 337076 | 0;
        $2 = HEAP32[84259];
        $1 = 1 << $1;
        label$115 : {
         if (!($2 & $1)) {
          HEAP32[84259] = $1 | $2;
          $3 = $0;
          break label$115;
         }
         $3 = HEAP32[$0 + 8 >> 2];
         if (HEAPU32[84263] > $3 >>> 0) {
          break label$3;
         }
        }
        HEAP32[$0 + 8 >> 2] = $7;
        HEAP32[$3 + 12 >> 2] = $7;
        HEAP32[$7 + 12 >> 2] = $0;
        HEAP32[$7 + 8 >> 2] = $3;
        break label$98;
       }
       $2 = $7;
       $3 = $0 >>> 8;
       $1 = 0;
       label$117 : {
        if (!$3) {
         break label$117;
        }
        $1 = 31;
        if ($0 >>> 0 > 16777215) {
         break label$117;
        }
        $5 = $3 + 1048320 >>> 16 & 8;
        $3 = $3 << $5;
        $1 = $3 + 520192 >>> 16 & 4;
        $6 = $3 << $1;
        $3 = $6 + 245760 >>> 16 & 2;
        $1 = ($6 << $3 >>> 15) - ($3 | ($1 | $5)) | 0;
        $1 = ($1 << 1 | $0 >>> $1 + 21 & 1) + 28 | 0;
       }
       HEAP32[$2 + 28 >> 2] = $1;
       HEAP32[$7 + 16 >> 2] = 0;
       HEAP32[$7 + 20 >> 2] = 0;
       $2 = ($1 << 2) + 337340 | 0;
       label$118 : {
        $3 = HEAP32[84260];
        $5 = 1 << $1;
        label$119 : {
         if (!($3 & $5)) {
          HEAP32[84260] = $3 | $5;
          HEAP32[$2 >> 2] = $7;
          break label$119;
         }
         $3 = $0 << (($1 | 0) == 31 ? 0 : 25 - ($1 >>> 1) | 0);
         $1 = HEAP32[$2 >> 2];
         while (1) {
          $2 = $1;
          if ((HEAP32[$1 + 4 >> 2] & -8) == ($0 | 0)) {
           break label$118;
          }
          $1 = $3 >>> 29;
          $3 = $3 << 1;
          $5 = (($1 & 4) + $2 | 0) + 16 | 0;
          $1 = HEAP32[$5 >> 2];
          if ($1) {
           continue;
          }
          break;
         }
         if (HEAPU32[84263] > $5 >>> 0) {
          break label$3;
         }
         HEAP32[$5 >> 2] = $7;
        }
        HEAP32[$7 + 24 >> 2] = $2;
        HEAP32[$7 + 12 >> 2] = $7;
        HEAP32[$7 + 8 >> 2] = $7;
        break label$98;
       }
       $1 = HEAP32[84263];
       $0 = HEAP32[$2 + 8 >> 2];
       if ($1 >>> 0 > $0 >>> 0 | $1 >>> 0 > $2 >>> 0) {
        break label$3;
       }
       HEAP32[$0 + 12 >> 2] = $7;
       HEAP32[$2 + 8 >> 2] = $7;
       HEAP32[$7 + 24 >> 2] = 0;
       HEAP32[$7 + 12 >> 2] = $2;
       HEAP32[$7 + 8 >> 2] = $0;
      }
      $0 = $9 + 8 | 0;
      break label$1;
     }
     $0 = $4 + -40 | 0;
     $2 = $1 + 8 & 7 ? -8 - $1 & 7 : 0;
     $7 = $0 - $2 | 0;
     HEAP32[84262] = $7;
     $2 = $1 + $2 | 0;
     HEAP32[84265] = $2;
     HEAP32[$2 + 4 >> 2] = $7 | 1;
     HEAP32[($0 + $1 | 0) + 4 >> 2] = 40;
     HEAP32[84266] = HEAP32[84381];
     $0 = ($5 + ($5 + -39 & 7 ? 39 - $5 & 7 : 0) | 0) + -47 | 0;
     $2 = $0 >>> 0 < $3 + 16 >>> 0 ? $3 : $0;
     HEAP32[$2 + 4 >> 2] = 27;
     $0 = HEAP32[84374];
     HEAP32[$2 + 16 >> 2] = HEAP32[84373];
     HEAP32[$2 + 20 >> 2] = $0;
     $0 = HEAP32[84372];
     HEAP32[$2 + 8 >> 2] = HEAP32[84371];
     HEAP32[$2 + 12 >> 2] = $0;
     HEAP32[84373] = $2 + 8;
     HEAP32[84372] = $4;
     HEAP32[84371] = $1;
     HEAP32[84374] = 0;
     $0 = $2 + 24 | 0;
     while (1) {
      HEAP32[$0 + 4 >> 2] = 7;
      $1 = $0 + 8 | 0;
      $0 = $0 + 4 | 0;
      if ($1 >>> 0 < $5 >>> 0) {
       continue;
      }
      break;
     }
     if (($2 | 0) == ($3 | 0)) {
      break label$83;
     }
     HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] & -2;
     $5 = $2 - $3 | 0;
     HEAP32[$3 + 4 >> 2] = $5 | 1;
     HEAP32[$2 >> 2] = $5;
     if ($5 >>> 0 <= 255) {
      $1 = $5 >>> 3;
      $0 = ($1 << 3) + 337076 | 0;
      $2 = HEAP32[84259];
      $1 = 1 << $1;
      label$124 : {
       if (!($2 & $1)) {
        HEAP32[84259] = $1 | $2;
        $2 = $0;
        break label$124;
       }
       $2 = HEAP32[$0 + 8 >> 2];
       if (HEAPU32[84263] > $2 >>> 0) {
        break label$3;
       }
      }
      HEAP32[$0 + 8 >> 2] = $3;
      HEAP32[$2 + 12 >> 2] = $3;
      HEAP32[$3 + 12 >> 2] = $0;
      HEAP32[$3 + 8 >> 2] = $2;
      break label$83;
     }
     HEAP32[$3 + 16 >> 2] = 0;
     HEAP32[$3 + 20 >> 2] = 0;
     $1 = $3;
     $2 = $5 >>> 8;
     $0 = 0;
     label$126 : {
      if (!$2) {
       break label$126;
      }
      $0 = 31;
      if ($5 >>> 0 > 16777215) {
       break label$126;
      }
      $4 = $2 + 1048320 >>> 16 & 8;
      $2 = $2 << $4;
      $0 = $2 + 520192 >>> 16 & 4;
      $7 = $2 << $0;
      $2 = $7 + 245760 >>> 16 & 2;
      $0 = ($7 << $2 >>> 15) - ($2 | ($0 | $4)) | 0;
      $0 = ($0 << 1 | $5 >>> $0 + 21 & 1) + 28 | 0;
     }
     HEAP32[$1 + 28 >> 2] = $0;
     $1 = ($0 << 2) + 337340 | 0;
     label$127 : {
      $2 = HEAP32[84260];
      $4 = 1 << $0;
      label$128 : {
       if (!($2 & $4)) {
        HEAP32[84260] = $2 | $4;
        HEAP32[$1 >> 2] = $3;
        HEAP32[$3 + 24 >> 2] = $1;
        break label$128;
       }
       $0 = $5 << (($0 | 0) == 31 ? 0 : 25 - ($0 >>> 1) | 0);
       $1 = HEAP32[$1 >> 2];
       while (1) {
        $2 = $1;
        if (($5 | 0) == (HEAP32[$1 + 4 >> 2] & -8)) {
         break label$127;
        }
        $1 = $0 >>> 29;
        $0 = $0 << 1;
        $4 = ($2 + ($1 & 4) | 0) + 16 | 0;
        $1 = HEAP32[$4 >> 2];
        if ($1) {
         continue;
        }
        break;
       }
       if (HEAPU32[84263] > $4 >>> 0) {
        break label$3;
       }
       HEAP32[$4 >> 2] = $3;
       HEAP32[$3 + 24 >> 2] = $2;
      }
      HEAP32[$3 + 12 >> 2] = $3;
      HEAP32[$3 + 8 >> 2] = $3;
      break label$83;
     }
     $1 = HEAP32[84263];
     $0 = HEAP32[$2 + 8 >> 2];
     if ($1 >>> 0 > $0 >>> 0 | $1 >>> 0 > $2 >>> 0) {
      break label$3;
     }
     HEAP32[$0 + 12 >> 2] = $3;
     HEAP32[$2 + 8 >> 2] = $3;
     HEAP32[$3 + 24 >> 2] = 0;
     HEAP32[$3 + 12 >> 2] = $2;
     HEAP32[$3 + 8 >> 2] = $0;
    }
    $0 = HEAP32[84262];
    if ($0 >>> 0 <= $6 >>> 0) {
     break label$2;
    }
    $1 = $0 - $6 | 0;
    HEAP32[84262] = $1;
    $0 = HEAP32[84265];
    $2 = $0 + $6 | 0;
    HEAP32[84265] = $2;
    HEAP32[$2 + 4 >> 2] = $1 | 1;
    HEAP32[$0 + 4 >> 2] = $6 | 3;
    $0 = $0 + 8 | 0;
    break label$1;
   }
   abort();
   abort();
  }
  HEAP32[84242] = 48;
  $0 = 0;
 }
 global$0 = $12 + 16 | 0;
 return $0 | 0;
}
function mbedtls_sha512_process($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
 $2 = global$0 - 736 | 0;
 global$0 = $2;
 HEAP32[$2 + 732 >> 2] = $0;
 HEAP32[$2 + 728 >> 2] = $1;
 HEAP32[$2 + 724 >> 2] = 0;
 while (1) {
  if (HEAP32[$2 + 724 >> 2] < 16) {
   $5 = HEAPU8[HEAP32[$2 + 728 >> 2] + ((HEAP32[$2 + 724 >> 2] << 3) + 3 | 0) | 0] | (HEAPU8[HEAP32[$2 + 728 >> 2] + (HEAP32[$2 + 724 >> 2] << 3) | 0] << 24 | HEAPU8[HEAP32[$2 + 728 >> 2] + ((HEAP32[$2 + 724 >> 2] << 3) + 1 | 0) | 0] << 16 | HEAPU8[HEAP32[$2 + 728 >> 2] + ((HEAP32[$2 + 724 >> 2] << 3) + 2 | 0) | 0] << 8);
   $3 = HEAPU8[HEAP32[$2 + 728 >> 2] + ((HEAP32[$2 + 724 >> 2] << 3) + 4 | 0) | 0];
   $0 = $3 >>> 8;
   $3 = $3 << 24;
   $7 = $0 | $5;
   $1 = $3;
   $3 = HEAPU8[HEAP32[$2 + 728 >> 2] + ((HEAP32[$2 + 724 >> 2] << 3) + 5 | 0) | 0];
   $0 = $3 >>> 16;
   $3 = $1 | $3 << 16;
   $7 = $0 | $7;
   $1 = ($2 - -64 | 0) + (HEAP32[$2 + 724 >> 2] << 3) | 0;
   $5 = $3;
   $3 = HEAPU8[HEAP32[$2 + 728 >> 2] + ((HEAP32[$2 + 724 >> 2] << 3) + 6 | 0) | 0];
   $0 = $3 >>> 24;
   HEAP32[$1 >> 2] = HEAPU8[HEAP32[$2 + 728 >> 2] + ((HEAP32[$2 + 724 >> 2] << 3) + 7 | 0) | 0] | ($5 | $3 << 8);
   HEAP32[$1 + 4 >> 2] = $0 | $7;
   HEAP32[$2 + 724 >> 2] = HEAP32[$2 + 724 >> 2] + 1;
   continue;
  }
  break;
 }
 while (1) {
  if (HEAP32[$2 + 724 >> 2] < 80) {
   $7 = $2 - -64 | 0;
   $1 = $7 + (HEAP32[$2 + 724 >> 2] << 3) | 0;
   $0 = $7 + (HEAP32[$2 + 724 >> 2] - 16 << 3) | 0;
   $11 = HEAP32[$0 >> 2];
   $6 = HEAP32[$0 + 4 >> 2];
   $0 = $7 + (HEAP32[$2 + 724 >> 2] - 7 << 3) | 0;
   $5 = HEAP32[$0 >> 2];
   $9 = HEAP32[$0 + 4 >> 2];
   $0 = $7 + (HEAP32[$2 + 724 >> 2] - 2 << 3) | 0;
   $0;
   $3 = HEAP32[$0 >> 2] << 13;
   $0 = $7 + (HEAP32[$2 + 724 >> 2] - 2 << 3) | 0;
   $4 = HEAP32[$0 + 4 >> 2];
   $8 = HEAP32[$0 >> 2];
   $0 = $4 >>> 19;
   $4 = ($4 & 524287) << 13 | $8 >>> 19;
   $8 = $0 | $3;
   $0 = $7 + (HEAP32[$2 + 724 >> 2] - 2 << 3) | 0;
   $10 = HEAP32[$0 + 4 >> 2];
   $3 = HEAP32[$0 >> 2];
   $0 = $10 << 3 | $3 >>> 29;
   $10 = $3 << 3;
   $3 = $4;
   $4 = HEAP32[($7 + (HEAP32[$2 + 724 >> 2] - 2 << 3) | 0) + 4 >> 2];
   $4 = $3 ^ ($4 >>> 29 | $10);
   $8 = $0 ^ $8;
   $12 = $4;
   $0 = $7 + (HEAP32[$2 + 724 >> 2] - 2 << 3) | 0;
   $3 = HEAP32[$0 + 4 >> 2];
   $4 = HEAP32[$0 >> 2];
   $0 = $3 >>> 6;
   $4 = $12 ^ (($3 & 63) << 26 | $4 >>> 6);
   $3 = $4 + $5 | 0;
   $0 = ($0 ^ $8) + $9 | 0;
   $9 = $3;
   $3 = $3 >>> 0 < $4 >>> 0 ? $0 + 1 | 0 : $0;
   $0 = $7 + (HEAP32[$2 + 724 >> 2] - 15 << 3) | 0;
   $0;
   $4 = HEAP32[$0 >> 2] << 31;
   $0 = $7 + (HEAP32[$2 + 724 >> 2] - 15 << 3) | 0;
   $5 = HEAP32[$0 + 4 >> 2];
   $8 = HEAP32[$0 >> 2];
   $0 = $5 >>> 1;
   $5 = ($5 & 1) << 31 | $8 >>> 1;
   $8 = $0 | $4;
   $0 = $7 + (HEAP32[$2 + 724 >> 2] - 15 << 3) | 0;
   $0;
   $4 = HEAP32[$0 >> 2] << 24;
   $12 = $5;
   $0 = $7 + (HEAP32[$2 + 724 >> 2] - 15 << 3) | 0;
   $5 = HEAP32[$0 + 4 >> 2];
   $10 = HEAP32[$0 >> 2];
   $0 = $5 >>> 8;
   $5 = $12 ^ (($5 & 255) << 24 | $10 >>> 8);
   $8 = ($0 | $4) ^ $8;
   $0 = $7 + (HEAP32[$2 + 724 >> 2] - 15 << 3) | 0;
   $4 = HEAP32[$0 + 4 >> 2];
   $7 = HEAP32[$0 >> 2];
   $0 = $4 >>> 7;
   $7 = (($4 & 127) << 25 | $7 >>> 7) ^ $5;
   $4 = $7 + $9 | 0;
   $0 = ($0 ^ $8) + $3 | 0;
   $0 = $4 >>> 0 < $7 >>> 0 ? $0 + 1 | 0 : $0;
   $3 = $4 + $11 | 0;
   $0 = $0 + $6 | 0;
   HEAP32[$1 >> 2] = $3;
   HEAP32[$1 + 4 >> 2] = $3 >>> 0 < $4 >>> 0 ? $0 + 1 | 0 : $0;
   HEAP32[$2 + 724 >> 2] = HEAP32[$2 + 724 >> 2] + 1;
   continue;
  }
  break;
 }
 $0 = HEAP32[$2 + 732 >> 2];
 $1 = HEAP32[$0 + 20 >> 2];
 HEAP32[$2 + 56 >> 2] = HEAP32[$0 + 16 >> 2];
 HEAP32[$2 + 60 >> 2] = $1;
 $0 = HEAP32[$2 + 732 >> 2];
 $1 = HEAP32[$0 + 28 >> 2];
 HEAP32[$2 + 48 >> 2] = HEAP32[$0 + 24 >> 2];
 HEAP32[$2 + 52 >> 2] = $1;
 $0 = HEAP32[$2 + 732 >> 2];
 $1 = HEAP32[$0 + 36 >> 2];
 HEAP32[$2 + 40 >> 2] = HEAP32[$0 + 32 >> 2];
 HEAP32[$2 + 44 >> 2] = $1;
 $0 = HEAP32[$2 + 732 >> 2];
 $1 = HEAP32[$0 + 44 >> 2];
 HEAP32[$2 + 32 >> 2] = HEAP32[$0 + 40 >> 2];
 HEAP32[$2 + 36 >> 2] = $1;
 $0 = HEAP32[$2 + 732 >> 2];
 $1 = HEAP32[$0 + 52 >> 2];
 HEAP32[$2 + 24 >> 2] = HEAP32[$0 + 48 >> 2];
 HEAP32[$2 + 28 >> 2] = $1;
 $0 = HEAP32[$2 + 732 >> 2];
 $1 = HEAP32[$0 + 60 >> 2];
 HEAP32[$2 + 16 >> 2] = HEAP32[$0 + 56 >> 2];
 HEAP32[$2 + 20 >> 2] = $1;
 $0 = HEAP32[$2 + 732 >> 2];
 $1 = HEAP32[$0 + 68 >> 2];
 HEAP32[$2 + 8 >> 2] = HEAP32[$0 + 64 >> 2];
 HEAP32[$2 + 12 >> 2] = $1;
 $0 = HEAP32[$2 + 732 >> 2];
 $1 = HEAP32[$0 + 76 >> 2];
 HEAP32[$2 >> 2] = HEAP32[$0 + 72 >> 2];
 HEAP32[$2 + 4 >> 2] = $1;
 HEAP32[$2 + 724 >> 2] = 0;
 while (1) {
  $7 = $2 - -64 | 0;
  $0 = $7 + (HEAP32[$2 + 724 >> 2] << 3) | 0;
  $5 = HEAP32[$0 >> 2];
  $11 = HEAP32[$0 + 4 >> 2];
  $0 = (HEAP32[$2 + 724 >> 2] << 3) + 108800 | 0;
  $6 = HEAP32[$0 >> 2];
  $9 = HEAP32[$0 + 4 >> 2];
  $3 = HEAP32[$2 + 24 >> 2];
  $13 = $3 << 23 | HEAP32[$2 + 28 >> 2] >>> 9;
  $14 = HEAP32[$2 + 28 >> 2] << 23 | $3 >>> 9;
  $3 = HEAP32[$2 + 24 >> 2] << 18;
  $4 = HEAP32[$2 + 28 >> 2];
  $0 = $4 >>> 14;
  $8 = ($4 & 16383) << 18 | HEAP32[$2 + 24 >> 2] >>> 14;
  $10 = $0 | $3;
  $4 = HEAP32[$2 + 24 >> 2] << 14;
  $15 = HEAP32[$2 + 8 >> 2];
  $1 = $5;
  $3 = $6;
  $5 = HEAP32[$2 + 28 >> 2];
  $0 = $5 >>> 18;
  $6 = (($5 & 262143) << 14 | HEAP32[$2 + 24 >> 2] >>> 18) ^ $8 ^ $13;
  $5 = $6 + HEAP32[$2 >> 2] | 0;
  $0 = HEAP32[$2 + 4 >> 2] + (($0 | $4) ^ $10 ^ $14) | 0;
  $0 = $5 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
  $4 = $5;
  $5 = HEAP32[$2 + 24 >> 2] & (HEAP32[$2 + 16 >> 2] ^ HEAP32[$2 + 8 >> 2]) ^ $15;
  $4 = $4 + $5 | 0;
  $0 = (HEAP32[$2 + 12 >> 2] ^ HEAP32[$2 + 28 >> 2] & (HEAP32[$2 + 20 >> 2] ^ HEAP32[$2 + 12 >> 2])) + $0 | 0;
  $0 = $4 >>> 0 < $5 >>> 0 ? $0 + 1 | 0 : $0;
  $3 = $3 + $4 | 0;
  $0 = $0 + $9 | 0;
  $0 = $3 >>> 0 < $4 >>> 0 ? $0 + 1 | 0 : $0;
  $4 = $3;
  $3 = $1 + $3 | 0;
  $0 = $0 + $11 | 0;
  $1 = $2;
  HEAP32[$2 + 712 >> 2] = $3;
  HEAP32[$2 + 716 >> 2] = $3 >>> 0 < $4 >>> 0 ? $0 + 1 | 0 : $0;
  $3 = HEAP32[$2 + 56 >> 2];
  $6 = $3 << 25 | HEAP32[$2 + 60 >> 2] >>> 7;
  $9 = HEAP32[$2 + 60 >> 2] << 25 | $3 >>> 7;
  $3 = HEAP32[$2 + 56 >> 2] << 4;
  $4 = HEAP32[$2 + 60 >> 2];
  $0 = $4 >>> 28;
  $4 = ($4 & 268435455) << 4 | HEAP32[$2 + 56 >> 2] >>> 28;
  $8 = $0 | $3;
  $3 = HEAP32[$2 + 56 >> 2];
  $10 = $3 << 30;
  $0 = (HEAP32[$2 + 60 >> 2] & HEAP32[$2 + 52 >> 2] | HEAP32[$2 + 44 >> 2] & (HEAP32[$2 + 60 >> 2] | HEAP32[$2 + 52 >> 2])) + ((HEAP32[$2 + 60 >> 2] << 30 | $3 >>> 2) ^ $8 ^ $9) | 0;
  $5 = (HEAP32[$2 + 60 >> 2] >>> 2 | $10) ^ $4 ^ $6;
  $4 = $5 + (HEAP32[$2 + 56 >> 2] & HEAP32[$2 + 48 >> 2] | HEAP32[$2 + 40 >> 2] & (HEAP32[$2 + 56 >> 2] | HEAP32[$2 + 48 >> 2])) | 0;
  if ($4 >>> 0 < $5 >>> 0) {
   $0 = $0 + 1 | 0;
  }
  HEAP32[$2 + 704 >> 2] = $4;
  HEAP32[$1 + 708 >> 2] = $0;
  $0 = HEAP32[$2 + 716 >> 2] + HEAP32[$2 + 36 >> 2] | 0;
  $3 = HEAP32[$2 + 32 >> 2];
  $4 = $3 + HEAP32[$2 + 712 >> 2] | 0;
  if ($4 >>> 0 < $3 >>> 0) {
   $0 = $0 + 1 | 0;
  }
  HEAP32[$2 + 32 >> 2] = $4;
  HEAP32[$1 + 36 >> 2] = $0;
  $0 = HEAP32[$2 + 716 >> 2] + HEAP32[$2 + 708 >> 2] | 0;
  $3 = HEAP32[$2 + 704 >> 2];
  $4 = $3 + HEAP32[$2 + 712 >> 2] | 0;
  if ($4 >>> 0 < $3 >>> 0) {
   $0 = $0 + 1 | 0;
  }
  HEAP32[$2 >> 2] = $4;
  HEAP32[$1 + 4 >> 2] = $0;
  HEAP32[$2 + 724 >> 2] = HEAP32[$2 + 724 >> 2] + 1;
  $0 = $7 + (HEAP32[$2 + 724 >> 2] << 3) | 0;
  $5 = HEAP32[$0 >> 2];
  $11 = HEAP32[$0 + 4 >> 2];
  $0 = (HEAP32[$2 + 724 >> 2] << 3) + 108800 | 0;
  $6 = HEAP32[$0 >> 2];
  $9 = HEAP32[$0 + 4 >> 2];
  $3 = HEAP32[$2 + 32 >> 2];
  $13 = $3 << 23 | HEAP32[$2 + 36 >> 2] >>> 9;
  $14 = HEAP32[$2 + 36 >> 2] << 23 | $3 >>> 9;
  $3 = HEAP32[$2 + 32 >> 2] << 18;
  $4 = HEAP32[$2 + 36 >> 2];
  $0 = $4 >>> 14;
  $8 = ($4 & 16383) << 18 | HEAP32[$2 + 32 >> 2] >>> 14;
  $10 = $0 | $3;
  $4 = HEAP32[$2 + 32 >> 2] << 14;
  $15 = HEAP32[$2 + 16 >> 2];
  $12 = $5;
  $3 = $6;
  $5 = HEAP32[$2 + 36 >> 2];
  $0 = $5 >>> 18;
  $6 = (($5 & 262143) << 14 | HEAP32[$2 + 32 >> 2] >>> 18) ^ $8 ^ $13;
  $5 = $6 + HEAP32[$2 + 8 >> 2] | 0;
  $0 = HEAP32[$2 + 12 >> 2] + (($0 | $4) ^ $10 ^ $14) | 0;
  $0 = $5 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
  $4 = $5;
  $5 = HEAP32[$2 + 32 >> 2] & (HEAP32[$2 + 24 >> 2] ^ HEAP32[$2 + 16 >> 2]) ^ $15;
  $4 = $4 + $5 | 0;
  $0 = (HEAP32[$2 + 20 >> 2] ^ HEAP32[$2 + 36 >> 2] & (HEAP32[$2 + 28 >> 2] ^ HEAP32[$2 + 20 >> 2])) + $0 | 0;
  $0 = $4 >>> 0 < $5 >>> 0 ? $0 + 1 | 0 : $0;
  $3 = $3 + $4 | 0;
  $0 = $0 + $9 | 0;
  $0 = $3 >>> 0 < $4 >>> 0 ? $0 + 1 | 0 : $0;
  $4 = $3;
  $3 = $12 + $3 | 0;
  $0 = $0 + $11 | 0;
  HEAP32[$2 + 712 >> 2] = $3;
  HEAP32[$1 + 716 >> 2] = $3 >>> 0 < $4 >>> 0 ? $0 + 1 | 0 : $0;
  $3 = HEAP32[$2 >> 2];
  $6 = $3 << 25 | HEAP32[$2 + 4 >> 2] >>> 7;
  $9 = HEAP32[$2 + 4 >> 2] << 25 | $3 >>> 7;
  $3 = HEAP32[$2 >> 2] << 4;
  $4 = HEAP32[$2 + 4 >> 2];
  $0 = $4 >>> 28;
  $4 = ($4 & 268435455) << 4 | HEAP32[$2 >> 2] >>> 28;
  $8 = $0 | $3;
  $3 = HEAP32[$2 >> 2];
  $10 = $3 << 30;
  $0 = (HEAP32[$2 + 4 >> 2] & HEAP32[$2 + 60 >> 2] | HEAP32[$2 + 52 >> 2] & (HEAP32[$2 + 4 >> 2] | HEAP32[$2 + 60 >> 2])) + ((HEAP32[$2 + 4 >> 2] << 30 | $3 >>> 2) ^ $8 ^ $9) | 0;
  $5 = (HEAP32[$2 + 4 >> 2] >>> 2 | $10) ^ $4 ^ $6;
  $4 = $5 + (HEAP32[$2 >> 2] & HEAP32[$2 + 56 >> 2] | HEAP32[$2 + 48 >> 2] & (HEAP32[$2 >> 2] | HEAP32[$2 + 56 >> 2])) | 0;
  if ($4 >>> 0 < $5 >>> 0) {
   $0 = $0 + 1 | 0;
  }
  HEAP32[$2 + 704 >> 2] = $4;
  HEAP32[$1 + 708 >> 2] = $0;
  $0 = HEAP32[$2 + 716 >> 2] + HEAP32[$2 + 44 >> 2] | 0;
  $3 = HEAP32[$2 + 40 >> 2];
  $4 = $3 + HEAP32[$2 + 712 >> 2] | 0;
  if ($4 >>> 0 < $3 >>> 0) {
   $0 = $0 + 1 | 0;
  }
  HEAP32[$2 + 40 >> 2] = $4;
  HEAP32[$1 + 44 >> 2] = $0;
  $0 = HEAP32[$2 + 716 >> 2] + HEAP32[$2 + 708 >> 2] | 0;
  $3 = HEAP32[$2 + 704 >> 2];
  $4 = $3 + HEAP32[$2 + 712 >> 2] | 0;
  if ($4 >>> 0 < $3 >>> 0) {
   $0 = $0 + 1 | 0;
  }
  HEAP32[$2 + 8 >> 2] = $4;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$2 + 724 >> 2] = HEAP32[$2 + 724 >> 2] + 1;
  $0 = $7 + (HEAP32[$2 + 724 >> 2] << 3) | 0;
  $5 = HEAP32[$0 >> 2];
  $11 = HEAP32[$0 + 4 >> 2];
  $0 = (HEAP32[$2 + 724 >> 2] << 3) + 108800 | 0;
  $6 = HEAP32[$0 >> 2];
  $9 = HEAP32[$0 + 4 >> 2];
  $3 = HEAP32[$2 + 40 >> 2];
  $13 = $3 << 23 | HEAP32[$2 + 44 >> 2] >>> 9;
  $14 = HEAP32[$2 + 44 >> 2] << 23 | $3 >>> 9;
  $3 = HEAP32[$2 + 40 >> 2] << 18;
  $4 = HEAP32[$2 + 44 >> 2];
  $0 = $4 >>> 14;
  $8 = ($4 & 16383) << 18 | HEAP32[$2 + 40 >> 2] >>> 14;
  $10 = $0 | $3;
  $4 = HEAP32[$2 + 40 >> 2] << 14;
  $15 = HEAP32[$2 + 24 >> 2];
  $12 = $5;
  $3 = $6;
  $5 = HEAP32[$2 + 44 >> 2];
  $0 = $5 >>> 18;
  $6 = (($5 & 262143) << 14 | HEAP32[$2 + 40 >> 2] >>> 18) ^ $8 ^ $13;
  $5 = $6 + HEAP32[$2 + 16 >> 2] | 0;
  $0 = HEAP32[$2 + 20 >> 2] + (($0 | $4) ^ $10 ^ $14) | 0;
  $0 = $5 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
  $4 = $5;
  $5 = HEAP32[$2 + 40 >> 2] & (HEAP32[$2 + 32 >> 2] ^ HEAP32[$2 + 24 >> 2]) ^ $15;
  $4 = $4 + $5 | 0;
  $0 = (HEAP32[$2 + 28 >> 2] ^ HEAP32[$2 + 44 >> 2] & (HEAP32[$2 + 36 >> 2] ^ HEAP32[$2 + 28 >> 2])) + $0 | 0;
  $0 = $4 >>> 0 < $5 >>> 0 ? $0 + 1 | 0 : $0;
  $3 = $3 + $4 | 0;
  $0 = $0 + $9 | 0;
  $0 = $3 >>> 0 < $4 >>> 0 ? $0 + 1 | 0 : $0;
  $4 = $3;
  $3 = $12 + $3 | 0;
  $0 = $0 + $11 | 0;
  HEAP32[$2 + 712 >> 2] = $3;
  HEAP32[$1 + 716 >> 2] = $3 >>> 0 < $4 >>> 0 ? $0 + 1 | 0 : $0;
  $3 = HEAP32[$2 + 8 >> 2];
  $6 = $3 << 25 | HEAP32[$2 + 12 >> 2] >>> 7;
  $9 = HEAP32[$2 + 12 >> 2] << 25 | $3 >>> 7;
  $3 = HEAP32[$2 + 8 >> 2] << 4;
  $4 = HEAP32[$2 + 12 >> 2];
  $0 = $4 >>> 28;
  $4 = ($4 & 268435455) << 4 | HEAP32[$2 + 8 >> 2] >>> 28;
  $8 = $0 | $3;
  $3 = HEAP32[$2 + 8 >> 2];
  $10 = $3 << 30;
  $0 = (HEAP32[$2 + 12 >> 2] & HEAP32[$2 + 4 >> 2] | HEAP32[$2 + 60 >> 2] & (HEAP32[$2 + 12 >> 2] | HEAP32[$2 + 4 >> 2])) + ((HEAP32[$2 + 12 >> 2] << 30 | $3 >>> 2) ^ $8 ^ $9) | 0;
  $5 = (HEAP32[$2 + 12 >> 2] >>> 2 | $10) ^ $4 ^ $6;
  $4 = $5 + (HEAP32[$2 + 8 >> 2] & HEAP32[$2 >> 2] | HEAP32[$2 + 56 >> 2] & (HEAP32[$2 + 8 >> 2] | HEAP32[$2 >> 2])) | 0;
  if ($4 >>> 0 < $5 >>> 0) {
   $0 = $0 + 1 | 0;
  }
  HEAP32[$2 + 704 >> 2] = $4;
  HEAP32[$1 + 708 >> 2] = $0;
  $0 = HEAP32[$2 + 716 >> 2] + HEAP32[$2 + 52 >> 2] | 0;
  $3 = HEAP32[$2 + 48 >> 2];
  $4 = $3 + HEAP32[$2 + 712 >> 2] | 0;
  if ($4 >>> 0 < $3 >>> 0) {
   $0 = $0 + 1 | 0;
  }
  HEAP32[$2 + 48 >> 2] = $4;
  HEAP32[$1 + 52 >> 2] = $0;
  $0 = HEAP32[$2 + 716 >> 2] + HEAP32[$2 + 708 >> 2] | 0;
  $3 = HEAP32[$2 + 704 >> 2];
  $4 = $3 + HEAP32[$2 + 712 >> 2] | 0;
  if ($4 >>> 0 < $3 >>> 0) {
   $0 = $0 + 1 | 0;
  }
  HEAP32[$2 + 16 >> 2] = $4;
  HEAP32[$1 + 20 >> 2] = $0;
  HEAP32[$2 + 724 >> 2] = HEAP32[$2 + 724 >> 2] + 1;
  $0 = $7 + (HEAP32[$2 + 724 >> 2] << 3) | 0;
  $5 = HEAP32[$0 >> 2];
  $11 = HEAP32[$0 + 4 >> 2];
  $0 = (HEAP32[$2 + 724 >> 2] << 3) + 108800 | 0;
  $6 = HEAP32[$0 >> 2];
  $9 = HEAP32[$0 + 4 >> 2];
  $3 = HEAP32[$2 + 48 >> 2];
  $13 = $3 << 23 | HEAP32[$2 + 52 >> 2] >>> 9;
  $14 = HEAP32[$2 + 52 >> 2] << 23 | $3 >>> 9;
  $3 = HEAP32[$2 + 48 >> 2] << 18;
  $4 = HEAP32[$2 + 52 >> 2];
  $0 = $4 >>> 14;
  $8 = ($4 & 16383) << 18 | HEAP32[$2 + 48 >> 2] >>> 14;
  $10 = $0 | $3;
  $4 = HEAP32[$2 + 48 >> 2] << 14;
  $15 = HEAP32[$2 + 32 >> 2];
  $12 = $5;
  $3 = $6;
  $5 = HEAP32[$2 + 52 >> 2];
  $0 = $5 >>> 18;
  $6 = (($5 & 262143) << 14 | HEAP32[$2 + 48 >> 2] >>> 18) ^ $8 ^ $13;
  $5 = $6 + HEAP32[$2 + 24 >> 2] | 0;
  $0 = HEAP32[$2 + 28 >> 2] + (($0 | $4) ^ $10 ^ $14) | 0;
  $0 = $5 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
  $4 = $5;
  $5 = HEAP32[$2 + 48 >> 2] & (HEAP32[$2 + 40 >> 2] ^ HEAP32[$2 + 32 >> 2]) ^ $15;
  $4 = $4 + $5 | 0;
  $0 = (HEAP32[$2 + 36 >> 2] ^ HEAP32[$2 + 52 >> 2] & (HEAP32[$2 + 44 >> 2] ^ HEAP32[$2 + 36 >> 2])) + $0 | 0;
  $0 = $4 >>> 0 < $5 >>> 0 ? $0 + 1 | 0 : $0;
  $3 = $3 + $4 | 0;
  $0 = $0 + $9 | 0;
  $0 = $3 >>> 0 < $4 >>> 0 ? $0 + 1 | 0 : $0;
  $4 = $3;
  $3 = $12 + $3 | 0;
  $0 = $0 + $11 | 0;
  HEAP32[$2 + 712 >> 2] = $3;
  HEAP32[$1 + 716 >> 2] = $3 >>> 0 < $4 >>> 0 ? $0 + 1 | 0 : $0;
  $3 = HEAP32[$2 + 16 >> 2];
  $6 = $3 << 25 | HEAP32[$2 + 20 >> 2] >>> 7;
  $9 = HEAP32[$2 + 20 >> 2] << 25 | $3 >>> 7;
  $3 = HEAP32[$2 + 16 >> 2] << 4;
  $4 = HEAP32[$2 + 20 >> 2];
  $0 = $4 >>> 28;
  $4 = ($4 & 268435455) << 4 | HEAP32[$2 + 16 >> 2] >>> 28;
  $8 = $0 | $3;
  $3 = HEAP32[$2 + 16 >> 2];
  $10 = $3 << 30;
  $0 = (HEAP32[$2 + 20 >> 2] & HEAP32[$2 + 12 >> 2] | HEAP32[$2 + 4 >> 2] & (HEAP32[$2 + 20 >> 2] | HEAP32[$2 + 12 >> 2])) + ((HEAP32[$2 + 20 >> 2] << 30 | $3 >>> 2) ^ $8 ^ $9) | 0;
  $5 = (HEAP32[$2 + 20 >> 2] >>> 2 | $10) ^ $4 ^ $6;
  $4 = $5 + (HEAP32[$2 + 16 >> 2] & HEAP32[$2 + 8 >> 2] | HEAP32[$2 >> 2] & (HEAP32[$2 + 16 >> 2] | HEAP32[$2 + 8 >> 2])) | 0;
  if ($4 >>> 0 < $5 >>> 0) {
   $0 = $0 + 1 | 0;
  }
  HEAP32[$2 + 704 >> 2] = $4;
  HEAP32[$1 + 708 >> 2] = $0;
  $0 = HEAP32[$2 + 716 >> 2] + HEAP32[$2 + 60 >> 2] | 0;
  $3 = HEAP32[$2 + 56 >> 2];
  $4 = $3 + HEAP32[$2 + 712 >> 2] | 0;
  if ($4 >>> 0 < $3 >>> 0) {
   $0 = $0 + 1 | 0;
  }
  HEAP32[$2 + 56 >> 2] = $4;
  HEAP32[$1 + 60 >> 2] = $0;
  $0 = HEAP32[$2 + 716 >> 2] + HEAP32[$2 + 708 >> 2] | 0;
  $3 = HEAP32[$2 + 704 >> 2];
  $4 = $3 + HEAP32[$2 + 712 >> 2] | 0;
  if ($4 >>> 0 < $3 >>> 0) {
   $0 = $0 + 1 | 0;
  }
  HEAP32[$2 + 24 >> 2] = $4;
  HEAP32[$1 + 28 >> 2] = $0;
  HEAP32[$2 + 724 >> 2] = HEAP32[$2 + 724 >> 2] + 1;
  $0 = $7 + (HEAP32[$2 + 724 >> 2] << 3) | 0;
  $5 = HEAP32[$0 >> 2];
  $11 = HEAP32[$0 + 4 >> 2];
  $0 = (HEAP32[$2 + 724 >> 2] << 3) + 108800 | 0;
  $6 = HEAP32[$0 >> 2];
  $9 = HEAP32[$0 + 4 >> 2];
  $3 = HEAP32[$2 + 56 >> 2];
  $13 = $3 << 23 | HEAP32[$2 + 60 >> 2] >>> 9;
  $14 = HEAP32[$2 + 60 >> 2] << 23 | $3 >>> 9;
  $3 = HEAP32[$2 + 56 >> 2] << 18;
  $4 = HEAP32[$2 + 60 >> 2];
  $0 = $4 >>> 14;
  $8 = ($4 & 16383) << 18 | HEAP32[$2 + 56 >> 2] >>> 14;
  $10 = $0 | $3;
  $4 = HEAP32[$2 + 56 >> 2] << 14;
  $15 = HEAP32[$2 + 40 >> 2];
  $12 = $5;
  $3 = $6;
  $5 = HEAP32[$2 + 60 >> 2];
  $0 = $5 >>> 18;
  $6 = (($5 & 262143) << 14 | HEAP32[$2 + 56 >> 2] >>> 18) ^ $8 ^ $13;
  $5 = $6 + HEAP32[$2 + 32 >> 2] | 0;
  $0 = HEAP32[$2 + 36 >> 2] + (($0 | $4) ^ $10 ^ $14) | 0;
  $0 = $5 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
  $4 = $5;
  $5 = HEAP32[$2 + 56 >> 2] & (HEAP32[$2 + 48 >> 2] ^ HEAP32[$2 + 40 >> 2]) ^ $15;
  $4 = $4 + $5 | 0;
  $0 = (HEAP32[$2 + 44 >> 2] ^ HEAP32[$2 + 60 >> 2] & (HEAP32[$2 + 52 >> 2] ^ HEAP32[$2 + 44 >> 2])) + $0 | 0;
  $0 = $4 >>> 0 < $5 >>> 0 ? $0 + 1 | 0 : $0;
  $3 = $3 + $4 | 0;
  $0 = $0 + $9 | 0;
  $0 = $3 >>> 0 < $4 >>> 0 ? $0 + 1 | 0 : $0;
  $4 = $3;
  $3 = $12 + $3 | 0;
  $0 = $0 + $11 | 0;
  HEAP32[$2 + 712 >> 2] = $3;
  HEAP32[$1 + 716 >> 2] = $3 >>> 0 < $4 >>> 0 ? $0 + 1 | 0 : $0;
  $3 = HEAP32[$2 + 24 >> 2];
  $6 = $3 << 25 | HEAP32[$2 + 28 >> 2] >>> 7;
  $9 = HEAP32[$2 + 28 >> 2] << 25 | $3 >>> 7;
  $3 = HEAP32[$2 + 24 >> 2] << 4;
  $4 = HEAP32[$2 + 28 >> 2];
  $0 = $4 >>> 28;
  $4 = ($4 & 268435455) << 4 | HEAP32[$2 + 24 >> 2] >>> 28;
  $8 = $0 | $3;
  $3 = HEAP32[$2 + 24 >> 2];
  $10 = $3 << 30;
  $0 = (HEAP32[$2 + 28 >> 2] & HEAP32[$2 + 20 >> 2] | HEAP32[$2 + 12 >> 2] & (HEAP32[$2 + 28 >> 2] | HEAP32[$2 + 20 >> 2])) + ((HEAP32[$2 + 28 >> 2] << 30 | $3 >>> 2) ^ $8 ^ $9) | 0;
  $5 = (HEAP32[$2 + 28 >> 2] >>> 2 | $10) ^ $4 ^ $6;
  $4 = $5 + (HEAP32[$2 + 24 >> 2] & HEAP32[$2 + 16 >> 2] | HEAP32[$2 + 8 >> 2] & (HEAP32[$2 + 24 >> 2] | HEAP32[$2 + 16 >> 2])) | 0;
  if ($4 >>> 0 < $5 >>> 0) {
   $0 = $0 + 1 | 0;
  }
  HEAP32[$2 + 704 >> 2] = $4;
  HEAP32[$1 + 708 >> 2] = $0;
  $0 = HEAP32[$2 + 716 >> 2] + HEAP32[$2 + 4 >> 2] | 0;
  $3 = HEAP32[$2 >> 2];
  $4 = $3 + HEAP32[$2 + 712 >> 2] | 0;
  if ($4 >>> 0 < $3 >>> 0) {
   $0 = $0 + 1 | 0;
  }
  HEAP32[$2 >> 2] = $4;
  HEAP32[$1 + 4 >> 2] = $0;
  $0 = HEAP32[$2 + 716 >> 2] + HEAP32[$2 + 708 >> 2] | 0;
  $3 = HEAP32[$2 + 704 >> 2];
  $4 = $3 + HEAP32[$2 + 712 >> 2] | 0;
  if ($4 >>> 0 < $3 >>> 0) {
   $0 = $0 + 1 | 0;
  }
  HEAP32[$2 + 32 >> 2] = $4;
  HEAP32[$1 + 36 >> 2] = $0;
  HEAP32[$2 + 724 >> 2] = HEAP32[$2 + 724 >> 2] + 1;
  $0 = $7 + (HEAP32[$2 + 724 >> 2] << 3) | 0;
  $5 = HEAP32[$0 >> 2];
  $11 = HEAP32[$0 + 4 >> 2];
  $0 = (HEAP32[$2 + 724 >> 2] << 3) + 108800 | 0;
  $6 = HEAP32[$0 >> 2];
  $9 = HEAP32[$0 + 4 >> 2];
  $3 = HEAP32[$2 >> 2];
  $13 = $3 << 23 | HEAP32[$2 + 4 >> 2] >>> 9;
  $14 = HEAP32[$2 + 4 >> 2] << 23 | $3 >>> 9;
  $3 = HEAP32[$2 >> 2] << 18;
  $4 = HEAP32[$2 + 4 >> 2];
  $0 = $4 >>> 14;
  $8 = ($4 & 16383) << 18 | HEAP32[$2 >> 2] >>> 14;
  $10 = $0 | $3;
  $4 = HEAP32[$2 >> 2] << 14;
  $15 = HEAP32[$2 + 48 >> 2];
  $12 = $5;
  $3 = $6;
  $5 = HEAP32[$2 + 4 >> 2];
  $0 = $5 >>> 18;
  $6 = (($5 & 262143) << 14 | HEAP32[$2 >> 2] >>> 18) ^ $8 ^ $13;
  $5 = $6 + HEAP32[$2 + 40 >> 2] | 0;
  $0 = HEAP32[$2 + 44 >> 2] + (($0 | $4) ^ $10 ^ $14) | 0;
  $0 = $5 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
  $4 = $5;
  $5 = HEAP32[$2 >> 2] & (HEAP32[$2 + 56 >> 2] ^ HEAP32[$2 + 48 >> 2]) ^ $15;
  $4 = $4 + $5 | 0;
  $0 = (HEAP32[$2 + 52 >> 2] ^ HEAP32[$2 + 4 >> 2] & (HEAP32[$2 + 60 >> 2] ^ HEAP32[$2 + 52 >> 2])) + $0 | 0;
  $0 = $4 >>> 0 < $5 >>> 0 ? $0 + 1 | 0 : $0;
  $3 = $3 + $4 | 0;
  $0 = $0 + $9 | 0;
  $0 = $3 >>> 0 < $4 >>> 0 ? $0 + 1 | 0 : $0;
  $4 = $3;
  $3 = $12 + $3 | 0;
  $0 = $0 + $11 | 0;
  HEAP32[$2 + 712 >> 2] = $3;
  HEAP32[$1 + 716 >> 2] = $3 >>> 0 < $4 >>> 0 ? $0 + 1 | 0 : $0;
  $3 = HEAP32[$2 + 32 >> 2];
  $6 = $3 << 25 | HEAP32[$2 + 36 >> 2] >>> 7;
  $9 = HEAP32[$2 + 36 >> 2] << 25 | $3 >>> 7;
  $3 = HEAP32[$2 + 32 >> 2] << 4;
  $4 = HEAP32[$2 + 36 >> 2];
  $0 = $4 >>> 28;
  $4 = ($4 & 268435455) << 4 | HEAP32[$2 + 32 >> 2] >>> 28;
  $8 = $0 | $3;
  $3 = HEAP32[$2 + 32 >> 2];
  $10 = $3 << 30;
  $0 = (HEAP32[$2 + 36 >> 2] & HEAP32[$2 + 28 >> 2] | HEAP32[$2 + 20 >> 2] & (HEAP32[$2 + 36 >> 2] | HEAP32[$2 + 28 >> 2])) + ((HEAP32[$2 + 36 >> 2] << 30 | $3 >>> 2) ^ $8 ^ $9) | 0;
  $5 = (HEAP32[$2 + 36 >> 2] >>> 2 | $10) ^ $4 ^ $6;
  $4 = $5 + (HEAP32[$2 + 32 >> 2] & HEAP32[$2 + 24 >> 2] | HEAP32[$2 + 16 >> 2] & (HEAP32[$2 + 32 >> 2] | HEAP32[$2 + 24 >> 2])) | 0;
  if ($4 >>> 0 < $5 >>> 0) {
   $0 = $0 + 1 | 0;
  }
  HEAP32[$2 + 704 >> 2] = $4;
  HEAP32[$1 + 708 >> 2] = $0;
  $0 = HEAP32[$2 + 716 >> 2] + HEAP32[$2 + 12 >> 2] | 0;
  $3 = HEAP32[$2 + 8 >> 2];
  $4 = $3 + HEAP32[$2 + 712 >> 2] | 0;
  if ($4 >>> 0 < $3 >>> 0) {
   $0 = $0 + 1 | 0;
  }
  HEAP32[$2 + 8 >> 2] = $4;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$2 + 716 >> 2] + HEAP32[$2 + 708 >> 2] | 0;
  $3 = HEAP32[$2 + 704 >> 2];
  $4 = $3 + HEAP32[$2 + 712 >> 2] | 0;
  if ($4 >>> 0 < $3 >>> 0) {
   $0 = $0 + 1 | 0;
  }
  HEAP32[$2 + 40 >> 2] = $4;
  HEAP32[$1 + 44 >> 2] = $0;
  HEAP32[$2 + 724 >> 2] = HEAP32[$2 + 724 >> 2] + 1;
  $0 = $7 + (HEAP32[$2 + 724 >> 2] << 3) | 0;
  $5 = HEAP32[$0 >> 2];
  $11 = HEAP32[$0 + 4 >> 2];
  $0 = (HEAP32[$2 + 724 >> 2] << 3) + 108800 | 0;
  $6 = HEAP32[$0 >> 2];
  $9 = HEAP32[$0 + 4 >> 2];
  $3 = HEAP32[$2 + 8 >> 2];
  $13 = $3 << 23 | HEAP32[$2 + 12 >> 2] >>> 9;
  $14 = HEAP32[$2 + 12 >> 2] << 23 | $3 >>> 9;
  $3 = HEAP32[$2 + 8 >> 2] << 18;
  $4 = HEAP32[$2 + 12 >> 2];
  $0 = $4 >>> 14;
  $8 = ($4 & 16383) << 18 | HEAP32[$2 + 8 >> 2] >>> 14;
  $10 = $0 | $3;
  $4 = HEAP32[$2 + 8 >> 2] << 14;
  $15 = HEAP32[$2 + 56 >> 2];
  $12 = $5;
  $3 = $6;
  $5 = HEAP32[$2 + 12 >> 2];
  $0 = $5 >>> 18;
  $6 = (($5 & 262143) << 14 | HEAP32[$2 + 8 >> 2] >>> 18) ^ $8 ^ $13;
  $5 = $6 + HEAP32[$2 + 48 >> 2] | 0;
  $0 = HEAP32[$2 + 52 >> 2] + (($0 | $4) ^ $10 ^ $14) | 0;
  $0 = $5 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
  $4 = $5;
  $5 = HEAP32[$2 + 8 >> 2] & (HEAP32[$2 >> 2] ^ HEAP32[$2 + 56 >> 2]) ^ $15;
  $4 = $4 + $5 | 0;
  $0 = (HEAP32[$2 + 60 >> 2] ^ HEAP32[$2 + 12 >> 2] & (HEAP32[$2 + 4 >> 2] ^ HEAP32[$2 + 60 >> 2])) + $0 | 0;
  $0 = $4 >>> 0 < $5 >>> 0 ? $0 + 1 | 0 : $0;
  $3 = $3 + $4 | 0;
  $0 = $0 + $9 | 0;
  $0 = $3 >>> 0 < $4 >>> 0 ? $0 + 1 | 0 : $0;
  $4 = $3;
  $3 = $12 + $3 | 0;
  $0 = $0 + $11 | 0;
  HEAP32[$2 + 712 >> 2] = $3;
  HEAP32[$1 + 716 >> 2] = $3 >>> 0 < $4 >>> 0 ? $0 + 1 | 0 : $0;
  $3 = HEAP32[$2 + 40 >> 2];
  $6 = $3 << 25 | HEAP32[$2 + 44 >> 2] >>> 7;
  $9 = HEAP32[$2 + 44 >> 2] << 25 | $3 >>> 7;
  $3 = HEAP32[$2 + 40 >> 2] << 4;
  $4 = HEAP32[$2 + 44 >> 2];
  $0 = $4 >>> 28;
  $4 = ($4 & 268435455) << 4 | HEAP32[$2 + 40 >> 2] >>> 28;
  $8 = $0 | $3;
  $3 = HEAP32[$2 + 40 >> 2];
  $10 = $3 << 30;
  $0 = (HEAP32[$2 + 44 >> 2] & HEAP32[$2 + 36 >> 2] | HEAP32[$2 + 28 >> 2] & (HEAP32[$2 + 44 >> 2] | HEAP32[$2 + 36 >> 2])) + ((HEAP32[$2 + 44 >> 2] << 30 | $3 >>> 2) ^ $8 ^ $9) | 0;
  $5 = (HEAP32[$2 + 44 >> 2] >>> 2 | $10) ^ $4 ^ $6;
  $4 = $5 + (HEAP32[$2 + 40 >> 2] & HEAP32[$2 + 32 >> 2] | HEAP32[$2 + 24 >> 2] & (HEAP32[$2 + 40 >> 2] | HEAP32[$2 + 32 >> 2])) | 0;
  if ($4 >>> 0 < $5 >>> 0) {
   $0 = $0 + 1 | 0;
  }
  HEAP32[$2 + 704 >> 2] = $4;
  HEAP32[$1 + 708 >> 2] = $0;
  $0 = HEAP32[$2 + 716 >> 2] + HEAP32[$2 + 20 >> 2] | 0;
  $3 = HEAP32[$2 + 16 >> 2];
  $4 = $3 + HEAP32[$2 + 712 >> 2] | 0;
  if ($4 >>> 0 < $3 >>> 0) {
   $0 = $0 + 1 | 0;
  }
  HEAP32[$2 + 16 >> 2] = $4;
  HEAP32[$1 + 20 >> 2] = $0;
  $0 = HEAP32[$2 + 716 >> 2] + HEAP32[$2 + 708 >> 2] | 0;
  $3 = HEAP32[$2 + 704 >> 2];
  $4 = $3 + HEAP32[$2 + 712 >> 2] | 0;
  if ($4 >>> 0 < $3 >>> 0) {
   $0 = $0 + 1 | 0;
  }
  HEAP32[$2 + 48 >> 2] = $4;
  HEAP32[$1 + 52 >> 2] = $0;
  HEAP32[$2 + 724 >> 2] = HEAP32[$2 + 724 >> 2] + 1;
  $0 = $7 + (HEAP32[$2 + 724 >> 2] << 3) | 0;
  $7 = HEAP32[$0 >> 2];
  $5 = HEAP32[$0 + 4 >> 2];
  $0 = (HEAP32[$2 + 724 >> 2] << 3) + 108800 | 0;
  $11 = HEAP32[$0 >> 2];
  $6 = HEAP32[$0 + 4 >> 2];
  $3 = HEAP32[$2 + 16 >> 2];
  $10 = $3 << 23 | HEAP32[$2 + 20 >> 2] >>> 9;
  $13 = HEAP32[$2 + 20 >> 2] << 23 | $3 >>> 9;
  $3 = HEAP32[$2 + 16 >> 2] << 18;
  $4 = HEAP32[$2 + 20 >> 2];
  $0 = $4 >>> 14;
  $14 = ($4 & 16383) << 18 | HEAP32[$2 + 16 >> 2] >>> 14;
  $8 = $0 | $3;
  $4 = HEAP32[$2 + 16 >> 2] << 14;
  $9 = HEAP32[$2 >> 2];
  $12 = $7;
  $3 = $11;
  $7 = HEAP32[$2 + 20 >> 2];
  $0 = $7 >>> 18;
  $11 = (($7 & 262143) << 14 | HEAP32[$2 + 16 >> 2] >>> 18) ^ $14 ^ $10;
  $7 = $11 + HEAP32[$2 + 56 >> 2] | 0;
  $0 = HEAP32[$2 + 60 >> 2] + (($0 | $4) ^ $8 ^ $13) | 0;
  $0 = $7 >>> 0 < $11 >>> 0 ? $0 + 1 | 0 : $0;
  $4 = $7;
  $7 = HEAP32[$2 + 16 >> 2] & (HEAP32[$2 + 8 >> 2] ^ HEAP32[$2 >> 2]) ^ $9;
  $4 = $4 + $7 | 0;
  $0 = (HEAP32[$2 + 4 >> 2] ^ HEAP32[$2 + 20 >> 2] & (HEAP32[$2 + 12 >> 2] ^ HEAP32[$2 + 4 >> 2])) + $0 | 0;
  $0 = $4 >>> 0 < $7 >>> 0 ? $0 + 1 | 0 : $0;
  $3 = $3 + $4 | 0;
  $0 = $0 + $6 | 0;
  $0 = $3 >>> 0 < $4 >>> 0 ? $0 + 1 | 0 : $0;
  $4 = $3;
  $3 = $12 + $3 | 0;
  $0 = $0 + $5 | 0;
  HEAP32[$2 + 712 >> 2] = $3;
  HEAP32[$1 + 716 >> 2] = $3 >>> 0 < $4 >>> 0 ? $0 + 1 | 0 : $0;
  $3 = HEAP32[$2 + 48 >> 2];
  $11 = $3 << 25 | HEAP32[$2 + 52 >> 2] >>> 7;
  $6 = HEAP32[$2 + 52 >> 2] << 25 | $3 >>> 7;
  $3 = HEAP32[$2 + 48 >> 2] << 4;
  $4 = HEAP32[$2 + 52 >> 2];
  $0 = $4 >>> 28;
  $4 = ($4 & 268435455) << 4 | HEAP32[$2 + 48 >> 2] >>> 28;
  $9 = $0 | $3;
  $3 = HEAP32[$2 + 48 >> 2];
  $8 = $3 << 30;
  $0 = (HEAP32[$2 + 52 >> 2] & HEAP32[$2 + 44 >> 2] | HEAP32[$2 + 36 >> 2] & (HEAP32[$2 + 52 >> 2] | HEAP32[$2 + 44 >> 2])) + ((HEAP32[$2 + 52 >> 2] << 30 | $3 >>> 2) ^ $9 ^ $6) | 0;
  $7 = (HEAP32[$2 + 52 >> 2] >>> 2 | $8) ^ $4 ^ $11;
  $4 = $7 + (HEAP32[$2 + 48 >> 2] & HEAP32[$2 + 40 >> 2] | HEAP32[$2 + 32 >> 2] & (HEAP32[$2 + 48 >> 2] | HEAP32[$2 + 40 >> 2])) | 0;
  if ($4 >>> 0 < $7 >>> 0) {
   $0 = $0 + 1 | 0;
  }
  HEAP32[$2 + 704 >> 2] = $4;
  HEAP32[$1 + 708 >> 2] = $0;
  $0 = HEAP32[$2 + 716 >> 2] + HEAP32[$2 + 28 >> 2] | 0;
  $3 = HEAP32[$2 + 24 >> 2];
  $4 = $3 + HEAP32[$2 + 712 >> 2] | 0;
  if ($4 >>> 0 < $3 >>> 0) {
   $0 = $0 + 1 | 0;
  }
  HEAP32[$2 + 24 >> 2] = $4;
  HEAP32[$1 + 28 >> 2] = $0;
  $0 = HEAP32[$2 + 716 >> 2] + HEAP32[$2 + 708 >> 2] | 0;
  $3 = HEAP32[$2 + 704 >> 2];
  $4 = $3 + HEAP32[$2 + 712 >> 2] | 0;
  if ($4 >>> 0 < $3 >>> 0) {
   $0 = $0 + 1 | 0;
  }
  HEAP32[$2 + 56 >> 2] = $4;
  HEAP32[$1 + 60 >> 2] = $0;
  HEAP32[$2 + 724 >> 2] = HEAP32[$2 + 724 >> 2] + 1;
  if (HEAP32[$2 + 724 >> 2] < 80) {
   continue;
  }
  break;
 }
 $1 = HEAP32[$2 + 732 >> 2];
 $3 = $1;
 $5 = $3;
 $0 = HEAP32[$2 + 60 >> 2] + HEAP32[$3 + 20 >> 2] | 0;
 $1 = HEAP32[$3 + 16 >> 2];
 $4 = $1 + HEAP32[$2 + 56 >> 2] | 0;
 if ($4 >>> 0 < $1 >>> 0) {
  $0 = $0 + 1 | 0;
 }
 HEAP32[$5 + 16 >> 2] = $4;
 HEAP32[$3 + 20 >> 2] = $0;
 $1 = HEAP32[$2 + 732 >> 2];
 $3 = $1;
 $5 = $3;
 $0 = HEAP32[$2 + 52 >> 2] + HEAP32[$3 + 28 >> 2] | 0;
 $1 = HEAP32[$3 + 24 >> 2];
 $4 = $1 + HEAP32[$2 + 48 >> 2] | 0;
 if ($4 >>> 0 < $1 >>> 0) {
  $0 = $0 + 1 | 0;
 }
 HEAP32[$5 + 24 >> 2] = $4;
 HEAP32[$3 + 28 >> 2] = $0;
 $1 = HEAP32[$2 + 732 >> 2];
 $3 = $1;
 $5 = $3;
 $0 = HEAP32[$2 + 44 >> 2] + HEAP32[$3 + 36 >> 2] | 0;
 $1 = HEAP32[$3 + 32 >> 2];
 $4 = $1 + HEAP32[$2 + 40 >> 2] | 0;
 if ($4 >>> 0 < $1 >>> 0) {
  $0 = $0 + 1 | 0;
 }
 HEAP32[$5 + 32 >> 2] = $4;
 HEAP32[$3 + 36 >> 2] = $0;
 $1 = HEAP32[$2 + 732 >> 2];
 $3 = $1;
 $5 = $3;
 $0 = HEAP32[$2 + 36 >> 2] + HEAP32[$3 + 44 >> 2] | 0;
 $1 = HEAP32[$3 + 40 >> 2];
 $4 = $1 + HEAP32[$2 + 32 >> 2] | 0;
 if ($4 >>> 0 < $1 >>> 0) {
  $0 = $0 + 1 | 0;
 }
 HEAP32[$5 + 40 >> 2] = $4;
 HEAP32[$3 + 44 >> 2] = $0;
 $1 = HEAP32[$2 + 732 >> 2];
 $3 = $1;
 $5 = $3;
 $0 = HEAP32[$2 + 28 >> 2] + HEAP32[$3 + 52 >> 2] | 0;
 $1 = HEAP32[$3 + 48 >> 2];
 $4 = $1 + HEAP32[$2 + 24 >> 2] | 0;
 if ($4 >>> 0 < $1 >>> 0) {
  $0 = $0 + 1 | 0;
 }
 HEAP32[$5 + 48 >> 2] = $4;
 HEAP32[$3 + 52 >> 2] = $0;
 $1 = HEAP32[$2 + 732 >> 2];
 $3 = $1;
 $5 = $3;
 $0 = HEAP32[$2 + 20 >> 2] + HEAP32[$3 + 60 >> 2] | 0;
 $1 = HEAP32[$3 + 56 >> 2];
 $4 = $1 + HEAP32[$2 + 16 >> 2] | 0;
 if ($4 >>> 0 < $1 >>> 0) {
  $0 = $0 + 1 | 0;
 }
 HEAP32[$5 + 56 >> 2] = $4;
 HEAP32[$3 + 60 >> 2] = $0;
 $1 = HEAP32[$2 + 732 >> 2];
 $3 = $1;
 $5 = $3;
 $0 = HEAP32[$2 + 12 >> 2] + HEAP32[$3 + 68 >> 2] | 0;
 $1 = HEAP32[$3 + 64 >> 2];
 $4 = $1 + HEAP32[$2 + 8 >> 2] | 0;
 if ($4 >>> 0 < $1 >>> 0) {
  $0 = $0 + 1 | 0;
 }
 HEAP32[$5 + 64 >> 2] = $4;
 HEAP32[$3 + 68 >> 2] = $0;
 $1 = HEAP32[$2 + 732 >> 2];
 $3 = $1;
 $5 = $3;
 $0 = HEAP32[$2 + 4 >> 2] + HEAP32[$3 + 76 >> 2] | 0;
 $1 = HEAP32[$3 + 72 >> 2];
 $4 = $1 + HEAP32[$2 >> 2] | 0;
 if ($4 >>> 0 < $1 >>> 0) {
  $0 = $0 + 1 | 0;
 }
 HEAP32[$5 + 72 >> 2] = $4;
 HEAP32[$3 + 76 >> 2] = $0;
 global$0 = $2 + 736 | 0;
}
function jsiIdle() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $0 = global$0 - 352 | 0;
 global$0 = $0;
 if (HEAPU8[322242] < 255) {
  HEAP8[322242] = HEAPU8[322242] + 1;
 }
 HEAP8[$0 + 351 | 0] = 0;
 HEAP32[$0 + 340 >> 2] = jshGetEventsUsed();
 while (1) {
  $1 = HEAP32[$0 + 340 >> 2];
  HEAP32[$0 + 340 >> 2] = $1 + -1;
  if (($1 | 0) > 0) {
   $2 = jshPopIOEvent($0 + 344 | 0);
  } else {
   $2 = 0;
  }
  if ($2 & 1) {
   jsiSetBusy(1, 1);
   HEAP8[$0 + 351 | 0] = 1;
   HEAP8[$0 + 339 | 0] = HEAPU8[$0 + 344 | 0] & 31;
   HEAP8[322242] = 0;
   label$6 : {
    if (HEAPU8[$0 + 339 | 0] == HEAPU8[141672]) {
     jsiHandleIOEventForConsole($0 + 344 | 0);
     break label$6;
    }
    label$8 : {
     if (!(HEAPU8[$0 + 339 | 0] < 17 | HEAPU8[$0 + 339 | 0] > 22)) {
      HEAP32[$0 + 332 >> 2] = jsvSkipNameAndUnLock(jsiGetClassNameFromDevice(HEAPU8[$0 + 339 | 0]));
      if (jsvIsObject(HEAP32[$0 + 332 >> 2]) & 1) {
       $1 = jsiHandleIOEventForSerial(HEAP32[$0 + 332 >> 2], $0 + 344 | 0);
       HEAP32[$0 + 340 >> 2] = HEAP32[$0 + 340 >> 2] - $1;
      }
      jsvUnLock(HEAP32[$0 + 332 >> 2]);
      break label$8;
     }
     label$11 : {
      if (!(HEAPU8[$0 + 339 | 0] < 23 | HEAPU8[$0 + 339 | 0] > 23)) {
       HEAP32[$0 + 328 >> 2] = jsvSkipNameAndUnLock(jsiGetClassNameFromDevice(HEAPU8[$0 + 344 | 0] + -1 & 31));
       if (jsvIsObject(HEAP32[$0 + 328 >> 2]) & 1) {
        if (HEAPU8[$0 + 344 | 0] & 32) {
         jsiExecuteObjectCallbacks(HEAP32[$0 + 328 >> 2], 81853);
        }
        if (HEAPU8[$0 + 344 | 0] & 64) {
         jsiExecuteObjectCallbacks(HEAP32[$0 + 328 >> 2], 81864);
        }
       }
       jsvUnLock(HEAP32[$0 + 328 >> 2]);
       break label$11;
      }
      if (!(HEAPU8[$0 + 339 | 0] < 1 | HEAPU8[$0 + 339 | 0] > 16)) {
       $1 = $0 + 320 | 0;
       HEAP32[$0 + 324 >> 2] = jsvLock(HEAPU16[161111]);
       jsvObjectIteratorNew($1, HEAP32[$0 + 324 >> 2]);
       while (1) {
        if (jsvObjectIteratorHasValue($0 + 320 | 0) & 1) {
         $1 = $0 + 344 | 0;
         HEAP8[$0 + 319 | 0] = 0;
         HEAP32[$0 + 312 >> 2] = jsvObjectIteratorGetValue($0 + 320 | 0);
         HEAP8[$0 + 311 | 0] = jshGetPinFromVarAndUnLock(jsvObjectGetChild(HEAP32[$0 + 312 >> 2], 81100, 0));
         if (jshIsEventForPin($1, HEAPU8[$0 + 311 | 0]) & 1) {
          HEAP32[$0 + 296 >> 2] = jshGetSystemTime();
          HEAP32[$0 + 300 >> 2] = i64toi32_i32$HIGH_BITS;
          if (HEAPU32[$0 + 296 >> 2] < (HEAPU8[$0 + 345 | 0] | HEAPU8[$0 + 346 | 0] << 8 | (HEAPU8[$0 + 347 | 0] << 16 | HEAPU8[$0 + 348 | 0] << 24)) >>> 0) {
           $1 = HEAP32[$0 + 296 >> 2];
           $2 = HEAP32[$0 + 300 >> 2] - (($1 >>> 0 < 0) + 1 | 0) | 0;
           HEAP32[$0 + 296 >> 2] = $1;
           HEAP32[$0 + 300 >> 2] = $2;
          }
          $1 = HEAP32[$0 + 300 >> 2];
          HEAP32[$0 + 288 >> 2] = HEAPU8[$0 + 345 | 0] | HEAPU8[$0 + 346 | 0] << 8 | (HEAPU8[$0 + 347 | 0] << 16 | HEAPU8[$0 + 348 | 0] << 24);
          HEAP32[$0 + 292 >> 2] = $1;
          HEAP8[$0 + 287 | 0] = (HEAPU8[$0 + 344 | 0] & 32) != 0;
          HEAP8[$0 + 286 | 0] = 0;
          HEAP32[$0 + 280 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$0 + 312 >> 2], 81874, 0));
          label$21 : {
           if (HEAP32[$0 + 280 >> 2] <= 0) {
            HEAP8[$0 + 286 | 0] = 1;
            break label$21;
           }
           HEAP8[$0 + 279 | 0] = jsvGetBoolAndUnLock(jsvObjectGetChild(HEAP32[$0 + 312 >> 2], 81883, 0)) & 1;
           HEAP32[$0 + 272 >> 2] = jsvObjectGetChild(HEAP32[$0 + 312 >> 2], 81889, 0);
           label$23 : {
            if (HEAP32[$0 + 272 >> 2]) {
             $4 = HEAP32[80572];
             $3 = HEAP32[80573];
             $1 = jsvGetLongIntegerAndUnLock(jsvObjectGetChild(HEAP32[$0 + 272 >> 2], 81897, 0));
             $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
             $4 = $1 + $4 | 0;
             if ($4 >>> 0 < $1 >>> 0) {
              $3 = $3 + 1 | 0;
             }
             HEAP32[$0 + 264 >> 2] = $4;
             HEAP32[$0 + 268 >> 2] = $3;
             $1 = HEAP32[$0 + 280 >> 2];
             $3 = HEAP32[$0 + 288 >> 2];
             $4 = HEAP32[80572];
             $5 = $3 - $4 | 0;
             $2 = $1 + $5 | 0;
             $1 = (HEAP32[$0 + 292 >> 2] - (HEAP32[80573] + ($3 >>> 0 < $4 >>> 0) | 0) | 0) + ($1 >> 31) | 0;
             jsvUnLock(jsvObjectSetChild(HEAP32[$0 + 272 >> 2], 81897, jsvNewFromLongInteger($2, $2 >>> 0 < $5 >>> 0 ? $1 + 1 | 0 : $1)));
             jsvObjectSetChildAndUnLock(HEAP32[$0 + 272 >> 2], 81883, jsvNewFromBool(HEAP8[$0 + 287 | 0] & 1));
             $1 = HEAP32[$0 + 292 >> 2];
             $2 = HEAP32[$0 + 268 >> 2];
             if (!((HEAP8[$0 + 287 | 0] & 1) == (HEAP8[$0 + 279 | 0] & 1) | (($1 | 0) < ($2 | 0) ? 1 : ($1 | 0) <= ($2 | 0) ? HEAPU32[$0 + 288 >> 2] > HEAPU32[$0 + 264 >> 2] ? 0 : 1 : 0))) {
              $2 = $0 + 272 | 0;
              HEAP8[$0 + 286 | 0] = 1;
              $3 = HEAP32[$0 + 280 >> 2];
              $1 = $3;
              $3 = HEAP32[$0 + 264 >> 2];
              $4 = HEAP32[$0 + 268 >> 2] - (($1 >> 31) + ($3 >>> 0 < $1 >>> 0) | 0) | 0;
              HEAP32[$0 + 288 >> 2] = $3 - $1;
              HEAP32[$0 + 292 >> 2] = $4;
              jsvObjectSetChildAndUnLock(HEAP32[$0 + 312 >> 2], 81883, jsvNewFromBool(HEAP8[$0 + 287 | 0] & 1));
              HEAP32[$0 + 260 >> 2] = jsvNewArray($2, 1);
              jswrap_interface_clearTimeout(HEAP32[$0 + 260 >> 2]);
              jsvUnLock(HEAP32[$0 + 260 >> 2]);
              jsvObjectRemoveChild(HEAP32[$0 + 312 >> 2], 81889);
             }
             break label$23;
            }
            if ((HEAP8[$0 + 287 | 0] & 1) != (HEAP8[$0 + 279 | 0] & 1)) {
             HEAP32[$0 + 272 >> 2] = jsvNewWithFlags(5);
             if (HEAP32[$0 + 272 >> 2]) {
              jsvObjectSetChild(HEAP32[$0 + 272 >> 2], 81902, HEAP32[$0 + 312 >> 2]);
              $2 = HEAP32[$0 + 280 >> 2];
              $3 = HEAP32[$0 + 288 >> 2];
              $4 = HEAP32[80572];
              $5 = $3 - $4 | 0;
              $1 = $2 + $5 | 0;
              $3 = (HEAP32[$0 + 292 >> 2] - (HEAP32[80573] + ($3 >>> 0 < $4 >>> 0) | 0) | 0) + ($2 >> 31) | 0;
              jsvObjectSetChildAndUnLock(HEAP32[$0 + 272 >> 2], 81897, jsvNewFromLongInteger($1, $1 >>> 0 < $5 >>> 0 ? $3 + 1 | 0 : $3));
              jsvObjectSetChildAndUnLock(HEAP32[$0 + 272 >> 2], 81908, jsvObjectGetChild(HEAP32[$0 + 312 >> 2], 81908, 0));
              jsvObjectSetChildAndUnLock(HEAP32[$0 + 272 >> 2], 81917, jsvObjectGetChild(HEAP32[$0 + 312 >> 2], 81917, 0));
              jsvObjectSetChildAndUnLock(HEAP32[$0 + 272 >> 2], 81100, jsvNewFromPin(HEAPU8[$0 + 311 | 0]));
              jsvObjectSetChildAndUnLock(HEAP32[$0 + 272 >> 2], 81883, jsvNewFromBool(HEAP8[$0 + 287 | 0] & 1));
              jsiTimerAdd(HEAP32[$0 + 272 >> 2]);
              jsvObjectSetChild(HEAP32[$0 + 312 >> 2], 81889, HEAP32[$0 + 272 >> 2]);
             }
            }
           }
           jsvUnLock(HEAP32[$0 + 272 >> 2]);
          }
          if (HEAP8[$0 + 286 | 0] & 1) {
           HEAP32[$0 + 256 >> 2] = jsvNewFromFloat(jshGetMillisecondsFromTime(HEAP32[$0 + 288 >> 2], HEAP32[$0 + 292 >> 2]) / 1e3);
           if (jsiShouldExecuteWatch(HEAP32[$0 + 312 >> 2], HEAP8[$0 + 287 | 0] & 1) & 1) {
            HEAP32[$0 + 252 >> 2] = jsvObjectGetChild(HEAP32[$0 + 312 >> 2], 81908, 0);
            HEAP8[$0 + 251 | 0] = jsvGetBoolAndUnLock(jsvObjectGetChild(HEAP32[$0 + 312 >> 2], 81926, 0)) & 1;
            HEAP32[$0 + 244 >> 2] = jsvNewWithFlags(5);
            if (HEAP32[$0 + 244 >> 2]) {
             jsvObjectSetChildAndUnLock(HEAP32[$0 + 244 >> 2], 81883, jsvNewFromBool(HEAP8[$0 + 287 | 0] & 1));
             jsvObjectSetChildAndUnLock(HEAP32[$0 + 244 >> 2], 81917, jsvObjectGetChild(HEAP32[$0 + 312 >> 2], 81917, 0));
             jsvObjectSetChild(HEAP32[$0 + 244 >> 2], 81897, HEAP32[$0 + 256 >> 2]);
             jsvObjectSetChildAndUnLock(HEAP32[$0 + 244 >> 2], 81100, jsvNewFromPin(HEAPU8[$0 + 311 | 0]));
             HEAP8[$0 + 243 | 0] = jshGetEventDataPin(HEAPU8[$0 + 339 | 0]);
             if (jshIsPinValid(HEAPU8[$0 + 243 | 0]) & 1) {
              jsvObjectSetChildAndUnLock(HEAP32[$0 + 244 >> 2], 81932, jsvNewFromBool((HEAPU8[$0 + 344 | 0] & 64) != 0));
             }
            }
            if (!(jsiExecuteEventCallback(0, HEAP32[$0 + 252 >> 2], 1, $0 + 244 | 0) & 1 | !(HEAP8[$0 + 251 | 0] & 1))) {
             jsError(81937, 0);
             HEAP8[322179] = HEAPU8[322179] | 4;
             HEAP8[$0 + 251 | 0] = 0;
            }
            jsvUnLock(HEAP32[$0 + 244 >> 2]);
            if (!(HEAP8[$0 + 251 | 0] & 1)) {
             jsvObjectIteratorRemoveAndGotoNext($0 + 320 | 0, HEAP32[$0 + 324 >> 2]);
             HEAP8[$0 + 319 | 0] = 1;
             if (!(jsiIsWatchingPin(HEAPU8[$0 + 311 | 0]) & 1)) {
              jshPinWatch(HEAPU8[$0 + 311 | 0], 0);
             }
            }
            jsvUnLock(HEAP32[$0 + 252 >> 2]);
           }
           jsvObjectSetChildAndUnLock(HEAP32[$0 + 312 >> 2], 81917, HEAP32[$0 + 256 >> 2]);
          }
         }
         jsvUnLock(HEAP32[$0 + 312 >> 2]);
         if (!(HEAP8[$0 + 319 | 0] & 1)) {
          jsvObjectIteratorNext($0 + 320 | 0);
         }
         continue;
        }
        break;
       }
       jsvObjectIteratorFree($0 + 320 | 0);
       jsvUnLock(HEAP32[$0 + 324 >> 2]);
      }
     }
    }
   }
   continue;
  }
  break;
 }
 if ((jshGetEventsUsed() | 0) < 95) {
  jshSetFlowControlAllReady();
 }
 HEAP32[$0 + 232 >> 2] = -1;
 HEAP32[$0 + 236 >> 2] = 2147483647;
 HEAP32[$0 + 224 >> 2] = jshGetSystemTime();
 HEAP32[$0 + 228 >> 2] = i64toi32_i32$HIGH_BITS;
 $1 = HEAP32[$0 + 224 >> 2];
 $2 = HEAP32[80572];
 $3 = HEAP32[$0 + 228 >> 2] - (HEAP32[80573] + ($1 >>> 0 < $2 >>> 0) | 0) | 0;
 HEAP32[$0 + 216 >> 2] = $1 - $2;
 HEAP32[$0 + 220 >> 2] = $3;
 $1 = HEAP32[$0 + 228 >> 2];
 HEAP32[80572] = HEAP32[$0 + 224 >> 2];
 HEAP32[80573] = $1;
 HEAP32[$0 + 212 >> 2] = HEAP32[80574];
 HEAP32[80574] = HEAP32[80574] + HEAP32[$0 + 216 >> 2];
 if (HEAPU32[$0 + 212 >> 2] > HEAPU32[80574]) {
  HEAP32[80574] = -1;
 }
 $1 = $0 + 200 | 0;
 HEAP32[$0 + 208 >> 2] = jsvLock(HEAPU16[161110]);
 jsvObjectIteratorNew($1, HEAP32[$0 + 208 >> 2]);
 while (1) {
  if (jsvObjectIteratorHasValue($0 + 200 | 0) & 1) {
   $1 = $0 + 200 | 0;
   HEAP32[$0 + 196 >> 2] = jsvObjectIteratorGetValue($1);
   HEAP32[$0 + 184 >> 2] = jsvGetLongIntegerAndUnLock(jsvObjectGetChild(HEAP32[$0 + 196 >> 2], 81897, 0));
   HEAP32[$0 + 188 >> 2] = i64toi32_i32$HIGH_BITS;
   $2 = HEAP32[$0 + 184 >> 2];
   $3 = HEAP32[$0 + 216 >> 2];
   $4 = HEAP32[$0 + 188 >> 2] - (HEAP32[$0 + 220 >> 2] + ($2 >>> 0 < $3 >>> 0) | 0) | 0;
   HEAP32[$0 + 176 >> 2] = $2 - $3;
   HEAP32[$0 + 180 >> 2] = $4;
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 196 >> 2], 81897, jsvNewFromLongInteger(HEAP32[$0 + 176 >> 2], HEAP32[$0 + 180 >> 2]));
   jsvUnLock(HEAP32[$0 + 196 >> 2]);
   jsvObjectIteratorNext($1);
   continue;
  }
  break;
 }
 jsvObjectIteratorFree($0 + 200 | 0);
 while (1) {
  HEAP16[161112] = HEAPU16[161112] & -5;
  jsvObjectIteratorNew($0 + 200 | 0, HEAP32[$0 + 208 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue($0 + 200 | 0) & 1) {
    $2 = (HEAPU16[161112] & 4) != 0 ^ -1;
   } else {
    $2 = 0;
   }
   if ($2 & 1) {
    HEAP8[$0 + 175 | 0] = 0;
    HEAP32[$0 + 168 >> 2] = jsvObjectIteratorGetValue($0 + 200 | 0);
    HEAP32[$0 + 160 >> 2] = jsvGetLongIntegerAndUnLock(jsvObjectGetChild(HEAP32[$0 + 168 >> 2], 81897, 0));
    HEAP32[$0 + 164 >> 2] = i64toi32_i32$HIGH_BITS;
    $1 = HEAP32[$0 + 164 >> 2];
    if (($1 | 0) < 0 ? 1 : ($1 | 0) <= 0 ? HEAPU32[$0 + 160 >> 2] > 0 ? 0 : 1 : 0) {
     jsiSetBusy(1, 1);
     HEAP8[$0 + 351 | 0] = 1;
     HEAP32[$0 + 156 >> 2] = jsvObjectGetChild(HEAP32[$0 + 168 >> 2], 81908, 0);
     HEAP32[$0 + 152 >> 2] = jsvObjectGetChild(HEAP32[$0 + 168 >> 2], 81902, 0);
     HEAP8[$0 + 151 | 0] = 1;
     HEAP32[$0 + 144 >> 2] = 0;
     if (HEAP32[$0 + 152 >> 2]) {
      HEAP8[$0 + 143 | 0] = jsvGetBoolAndUnLock(jsvObjectGetChild(HEAP32[$0 + 152 >> 2], 81883, 0)) & 1;
      HEAP8[$0 + 142 | 0] = jsvGetBoolAndUnLock(jsvObjectGetChild(HEAP32[$0 + 168 >> 2], 81883, 0)) & 1;
      jsvObjectSetChildAndUnLock(HEAP32[$0 + 152 >> 2], 81883, jsvNewFromBool(HEAP8[$0 + 142 | 0] & 1));
      HEAP8[$0 + 151 | 0] = 0;
      if ((HEAP8[$0 + 143 | 0] & 1) != (HEAP8[$0 + 142 | 0] & 1)) {
       HEAP32[$0 + 136 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$0 + 152 >> 2], 81874, 0));
       $4 = $0;
       $1 = HEAP32[80573] + HEAP32[$0 + 164 >> 2] | 0;
       $2 = HEAP32[$0 + 160 >> 2];
       $3 = $2 + HEAP32[80572] | 0;
       if ($3 >>> 0 < $2 >>> 0) {
        $1 = $1 + 1 | 0;
       }
       $2 = $3;
       $3 = HEAP32[$0 + 136 >> 2];
       HEAP32[$4 + 132 >> 2] = jsvNewFromFloat(jshGetMillisecondsFromTime($2 - $3 | 0, $1 - (($3 >> 31) + ($2 >>> 0 < $3 >>> 0) | 0) | 0) / 1e3);
       if (jsiShouldExecuteWatch(HEAP32[$0 + 152 >> 2], HEAP8[$0 + 142 | 0] & 1) & 1) {
        HEAP32[$0 + 144 >> 2] = jsvNewWithFlags(5);
        if (HEAP32[$0 + 144 >> 2]) {
         HEAP8[$0 + 151 | 0] = 1;
         jsvObjectSetChildAndUnLock(HEAP32[$0 + 144 >> 2], 81883, jsvNewFromBool(HEAP8[$0 + 142 | 0] & 1));
         jsvObjectSetChildAndUnLock(HEAP32[$0 + 144 >> 2], 81917, jsvObjectGetChild(HEAP32[$0 + 152 >> 2], 81917, 0));
         jsvObjectSetChild(HEAP32[$0 + 144 >> 2], 81897, HEAP32[$0 + 132 >> 2]);
         jsvObjectSetChildAndUnLock(HEAP32[$0 + 144 >> 2], 81100, jsvObjectGetChild(HEAP32[$0 + 152 >> 2], 81100, 0));
        }
       }
       jsvObjectSetChildAndUnLock(HEAP32[$0 + 152 >> 2], 81917, HEAP32[$0 + 132 >> 2]);
      }
     }
     HEAP8[$0 + 131 | 0] = 0;
     if (HEAP8[$0 + 151 | 0] & 1) {
      label$51 : {
       if (HEAP32[$0 + 144 >> 2]) {
        HEAP8[$0 + 130 | 0] = jsiExecuteEventCallback(0, HEAP32[$0 + 156 >> 2], 1, $0 + 144 | 0) & 1;
        break label$51;
       }
       HEAP32[$0 + 124 >> 2] = jsvObjectGetChild(HEAP32[$0 + 168 >> 2], 81798, 0);
       HEAP8[$0 + 130 | 0] = jsiExecuteEventCallbackArgsArray(0, HEAP32[$0 + 156 >> 2], HEAP32[$0 + 124 >> 2]) & 1;
       jsvUnLock(HEAP32[$0 + 124 >> 2]);
      }
      if (!(HEAP8[$0 + 130 | 0] & 1)) {
       HEAP32[$0 + 120 >> 2] = jsvObjectGetChild(HEAP32[$0 + 168 >> 2], 81982, 0);
       if (HEAP32[$0 + 120 >> 2]) {
        jsvUnLock(HEAP32[$0 + 120 >> 2]);
        jsError(81991, 0);
        HEAP8[322179] = HEAPU8[322179] | 4;
        HEAP8[$0 + 131 | 0] = 1;
       }
      }
     }
     jsvUnLock(HEAP32[$0 + 144 >> 2]);
     if (HEAP32[$0 + 152 >> 2]) {
      jsvObjectRemoveChild(HEAP32[$0 + 152 >> 2], 81889);
      if (HEAP8[$0 + 151 | 0] & 1) {
       HEAP8[$0 + 119 | 0] = jsvGetBoolAndUnLock(jsvObjectGetChild(HEAP32[$0 + 152 >> 2], 81926, 0)) & 1;
       if (!(HEAP8[$0 + 119 | 0] & 1)) {
        HEAP32[$0 + 112 >> 2] = jsvLock(HEAPU16[161111]);
        HEAP32[$0 + 108 >> 2] = jsvGetIndexOf(HEAP32[$0 + 112 >> 2], HEAP32[$0 + 152 >> 2], 1);
        if (HEAP32[$0 + 108 >> 2]) {
         jsvRemoveChild(HEAP32[$0 + 112 >> 2], HEAP32[$0 + 108 >> 2]);
         jsvUnLock(HEAP32[$0 + 108 >> 2]);
        }
        jsvUnLock(HEAP32[$0 + 112 >> 2]);
        HEAP8[$0 + 107 | 0] = jshGetPinFromVarAndUnLock(jsvObjectGetChild(HEAP32[$0 + 152 >> 2], 81100, 0));
        if (!(jsiIsWatchingPin(HEAPU8[$0 + 107 | 0]) & 1)) {
         jshPinWatch(HEAPU8[$0 + 107 | 0], 0);
        }
       }
      }
      jsvUnLock(HEAP32[$0 + 152 >> 2]);
     }
     HEAP32[$0 + 100 >> 2] = jsvObjectGetChild(HEAP32[$0 + 168 >> 2], 81982, 0);
     label$60 : {
      if (!(!HEAP32[$0 + 100 >> 2] | HEAP8[$0 + 131 | 0] & 1)) {
       $4 = HEAP32[$0 + 160 >> 2];
       $3 = HEAP32[$0 + 164 >> 2];
       $1 = jsvGetLongInteger(HEAP32[$0 + 100 >> 2]);
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $4 = $1 + $4 | 0;
       if ($4 >>> 0 < $1 >>> 0) {
        $3 = $3 + 1 | 0;
       }
       HEAP32[$0 + 160 >> 2] = $4;
       HEAP32[$0 + 164 >> 2] = $3;
       jsvObjectSetChildAndUnLock(HEAP32[$0 + 168 >> 2], 81897, jsvNewFromLongInteger(HEAP32[$0 + 160 >> 2], HEAP32[$0 + 164 >> 2]));
       break label$60;
      }
      jsvObjectIteratorRemoveAndGotoNext($0 + 200 | 0, HEAP32[$0 + 208 >> 2]);
      HEAP8[$0 + 175 | 0] = 1;
      HEAP32[$0 + 160 >> 2] = -1;
      HEAP32[$0 + 164 >> 2] = -1;
     }
     jsvUnLock2(HEAP32[$0 + 156 >> 2], HEAP32[$0 + 100 >> 2]);
    }
    $1 = HEAP32[$0 + 164 >> 2];
    label$62 : {
     if (($1 | 0) < 0 ? 1 : ($1 | 0) <= 0 ? HEAPU32[$0 + 160 >> 2] >= 0 ? 0 : 1 : 0) {
      break label$62;
     }
     $1 = HEAP32[$0 + 164 >> 2];
     $2 = HEAP32[$0 + 236 >> 2];
     if (($1 | 0) > ($2 | 0) ? 1 : ($1 | 0) >= ($2 | 0) ? HEAPU32[$0 + 160 >> 2] < HEAPU32[$0 + 232 >> 2] ? 0 : 1 : 0) {
      break label$62;
     }
     $1 = HEAP32[$0 + 164 >> 2];
     HEAP32[$0 + 232 >> 2] = HEAP32[$0 + 160 >> 2];
     HEAP32[$0 + 236 >> 2] = $1;
    }
    if (!(HEAP8[$0 + 175 | 0] & 1)) {
     jsvObjectIteratorNext($0 + 200 | 0);
    }
    jsvUnLock(HEAP32[$0 + 168 >> 2]);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree($0 + 200 | 0);
  if (HEAPU16[161112] & 4) {
   continue;
  }
  break;
 }
 jsvUnLock(HEAP32[$0 + 208 >> 2]);
 if (jswIdle() & 1) {
  HEAP8[$0 + 351 | 0] = 1;
 }
 label$65 : {
  if (!(HEAP8[$0 + 351 | 0] & 1)) {
   if (jsvArrayIsEmpty(HEAP32[80554]) & 1) {
    break label$65;
   }
  }
  HEAP8[322242] = 0;
 }
 if (HEAP8[$0 + 351 | 0] & 1) {
  jsiSetBusy(1, 0);
 }
 if (!(jspIsInterrupted() & 1)) {
  jsiExecuteEvents();
 }
 if (HEAPU16[161112] & 224) {
  jsiSetBusy(1, 1);
  HEAP16[$0 + 98 >> 1] = HEAPU16[161112];
  if ((HEAPU16[$0 + 98 >> 1] & 128) == 128) {
   jsiKill();
   jshResetDevices();
   jsvInit();
   jsiSemiInit(0);
   HEAP16[161112] = HEAPU16[161112] & 65407;
  }
  if ((HEAPU16[$0 + 98 >> 1] & 32) == 32) {
   jsvGarbageCollect();
   jsiSoftKill();
   jspSoftKill();
   jsvClearEmptyVarList();
   jsiConsolePrintString(78181);
   jshResetDevices();
   jsvCreateEmptyVarList();
   jspSoftInit();
   jsiSoftInit(0);
   HEAP16[161112] = HEAPU16[161112] & 65503;
  }
  if ((HEAPU16[$0 + 98 >> 1] & 64) == 64) {
   HEAP32[$0 + 92 >> 2] = jsvObjectGetChild(HEAP32[80546], 82039, 0);
   label$73 : {
    if (HEAP32[$0 + 92 >> 2]) {
     jsfNameFromVarAndUnLock($0 - -64 | 0, HEAP32[$0 + 92 >> 2]);
     jsiKill();
     jshResetDevices();
     jsvInit();
     $1 = HEAP32[80545];
     HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 88 >> 2];
     $2 = HEAP32[$0 + 84 >> 2];
     HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 80 >> 2];
     HEAP32[$0 + 20 >> 2] = $2;
     $2 = HEAP32[$0 + 76 >> 2];
     HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 72 >> 2];
     HEAP32[$0 + 12 >> 2] = $2;
     $2 = HEAP32[$0 + 68 >> 2];
     HEAP32[$0 >> 2] = HEAP32[$0 + 64 >> 2];
     HEAP32[$0 + 4 >> 2] = $2;
     jsvObjectSetChildAndUnLock($1, 82044, jsfVarFromName($0));
     jsiSemiInit(0);
     HEAP32[$0 + 56 >> 2] = HEAP32[$0 + 88 >> 2];
     $1 = HEAP32[$0 + 84 >> 2];
     HEAP32[$0 + 48 >> 2] = HEAP32[$0 + 80 >> 2];
     HEAP32[$0 + 52 >> 2] = $1;
     $1 = HEAP32[$0 + 76 >> 2];
     HEAP32[$0 + 40 >> 2] = HEAP32[$0 + 72 >> 2];
     HEAP32[$0 + 44 >> 2] = $1;
     $1 = HEAP32[$0 + 68 >> 2];
     HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 64 >> 2];
     HEAP32[$0 + 36 >> 2] = $1;
     HEAP32[$0 + 60 >> 2] = jsfReadFile($0 + 32 | 0, 0, 0);
     if (HEAP32[$0 + 60 >> 2]) {
      jsvUnLock2(jspEvaluateVar(HEAP32[$0 + 60 >> 2], 0, 0), HEAP32[$0 + 60 >> 2]);
     }
     break label$73;
    }
    jsiSoftKill();
    jspSoftKill();
    jsvClearEmptyVarList();
    jshResetDevices();
    jsvInit();
    jsvCreateEmptyVarList();
    jspSoftInit();
    jsiSoftInit(0);
   }
   HEAP16[161112] = HEAPU16[161112] & 65471;
  }
  jsiSetBusy(1, 0);
 }
 label$76 : {
  label$77 : {
   if (HEAPU8[322242] != 1) {
    break label$77;
   }
   $1 = HEAP32[$0 + 236 >> 2];
   $3 = HEAPU32[$0 + 232 >> 2] > jshGetTimeFromMilliseconds(10) >>> 0 ? 0 : 1;
   $2 = i64toi32_i32$HIGH_BITS;
   if (($1 | 0) < ($2 | 0) ? 1 : ($1 | 0) <= ($2 | 0) ? $3 : 0) {
    break label$77;
   }
   if (jsvMoreFreeVariablesThan() & 1) {
    break label$77;
   }
   jsiSetBusy(1, 1);
   jsvGarbageCollect();
   jsiSetBusy(1, 0);
   break label$76;
  }
  if (HEAPU8[322242] < 1) {
   break label$76;
  }
  if (jshHasEvents() & 1) {
   break label$76;
  }
  jshSleep(HEAP32[$0 + 232 >> 2], HEAP32[$0 + 236 >> 2]);
 }
 global$0 = $0 + 352 | 0;
}
function printf_core($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0;
 $5 = global$0 - 80 | 0;
 global$0 = $5;
 HEAP32[$5 + 76 >> 2] = 138620;
 $19 = $5 + 55 | 0;
 $16 = $5 + 56 | 0;
 label$1 : {
  label$2 : {
   label$3 : while (1) {
    label$4 : {
     if (($14 | 0) < 0) {
      break label$4;
     }
     if (($4 | 0) > (2147483647 - $14 | 0)) {
      HEAP32[84242] = 61;
      $14 = -1;
      break label$4;
     }
     $14 = $4 + $14 | 0;
    }
    label$6 : {
     label$7 : {
      label$8 : {
       label$9 : {
        label$10 : {
         label$11 : {
          label$12 : {
           label$13 : {
            label$14 : {
             label$15 : {
              label$16 : {
               label$17 : {
                label$18 : {
                 $9 = HEAP32[$5 + 76 >> 2];
                 $4 = $9;
                 $8 = HEAPU8[$4 | 0];
                 if ($8) {
                  while (1) {
                   label$21 : {
                    label$22 : {
                     $6 = $8 & 255;
                     label$23 : {
                      if (!$6) {
                       $8 = $4;
                       break label$23;
                      }
                      if (($6 | 0) != 37) {
                       break label$22;
                      }
                      $8 = $4;
                      while (1) {
                       if (HEAPU8[$4 + 1 | 0] != 37) {
                        break label$23;
                       }
                       $6 = $4 + 2 | 0;
                       HEAP32[$5 + 76 >> 2] = $6;
                       $8 = $8 + 1 | 0;
                       $7 = HEAPU8[$4 + 2 | 0];
                       $4 = $6;
                       if (($7 | 0) == 37) {
                        continue;
                       }
                       break;
                      }
                     }
                     $4 = $8 - $9 | 0;
                     if ($0) {
                      out($0, $9, $4);
                     }
                     if ($4) {
                      continue label$3;
                     }
                     $6 = isdigit(HEAP8[HEAP32[$5 + 76 >> 2] + 1 | 0]);
                     $15 = -1;
                     $8 = 1;
                     $10 = $5;
                     $4 = HEAP32[$5 + 76 >> 2];
                     if (!(!$6 | HEAPU8[$4 + 2 | 0] != 36)) {
                      $15 = HEAP8[$4 + 1 | 0] + -48 | 0;
                      $17 = 1;
                      $8 = 3;
                     }
                     $4 = $8 + $4 | 0;
                     HEAP32[$10 + 76 >> 2] = $4;
                     $8 = 0;
                     $12 = HEAP8[$4 | 0];
                     $7 = $12 + -32 | 0;
                     label$28 : {
                      if ($7 >>> 0 > 31) {
                       $6 = $4;
                       break label$28;
                      }
                      $6 = $4;
                      $7 = 1 << $7;
                      if (!($7 & 75913)) {
                       break label$28;
                      }
                      while (1) {
                       $6 = $4 + 1 | 0;
                       HEAP32[$5 + 76 >> 2] = $6;
                       $8 = $7 | $8;
                       $12 = HEAP8[$4 + 1 | 0];
                       $7 = $12 + -32 | 0;
                       if ($7 >>> 0 > 31) {
                        break label$28;
                       }
                       $4 = $6;
                       $7 = 1 << $7;
                       if ($7 & 75913) {
                        continue;
                       }
                       break;
                      }
                     }
                     label$31 : {
                      if (($12 | 0) == 42) {
                       $10 = $5;
                       label$33 : {
                        label$34 : {
                         if (!isdigit(HEAP8[$6 + 1 | 0])) {
                          break label$34;
                         }
                         $4 = HEAP32[$5 + 76 >> 2];
                         if (HEAPU8[$4 + 2 | 0] != 36) {
                          break label$34;
                         }
                         HEAP32[((HEAP8[$4 + 1 | 0] << 2) + $3 | 0) + -192 >> 2] = 10;
                         $13 = HEAP32[((HEAP8[$4 + 1 | 0] << 3) + $2 | 0) + -384 >> 2];
                         $17 = 1;
                         $4 = $4 + 3 | 0;
                         break label$33;
                        }
                        if ($17) {
                         break label$2;
                        }
                        $17 = 0;
                        $13 = 0;
                        if ($0) {
                         $4 = HEAP32[$1 >> 2];
                         HEAP32[$1 >> 2] = $4 + 4;
                         $13 = HEAP32[$4 >> 2];
                        }
                        $4 = HEAP32[$5 + 76 >> 2] + 1 | 0;
                       }
                       HEAP32[$10 + 76 >> 2] = $4;
                       if (($13 | 0) > -1) {
                        break label$31;
                       }
                       $13 = 0 - $13 | 0;
                       $8 = $8 | 8192;
                       break label$31;
                      }
                      $13 = getint($5 + 76 | 0);
                      if (($13 | 0) < 0) {
                       break label$2;
                      }
                      $4 = HEAP32[$5 + 76 >> 2];
                     }
                     $7 = -1;
                     label$36 : {
                      if (HEAPU8[$4 | 0] != 46) {
                       break label$36;
                      }
                      if (HEAPU8[$4 + 1 | 0] == 42) {
                       label$38 : {
                        if (!isdigit(HEAP8[$4 + 2 | 0])) {
                         break label$38;
                        }
                        $4 = HEAP32[$5 + 76 >> 2];
                        if (HEAPU8[$4 + 3 | 0] != 36) {
                         break label$38;
                        }
                        HEAP32[((HEAP8[$4 + 2 | 0] << 2) + $3 | 0) + -192 >> 2] = 10;
                        $7 = HEAP32[((HEAP8[$4 + 2 | 0] << 3) + $2 | 0) + -384 >> 2];
                        $4 = $4 + 4 | 0;
                        HEAP32[$5 + 76 >> 2] = $4;
                        break label$36;
                       }
                       if ($17) {
                        break label$2;
                       }
                       if ($0) {
                        $4 = HEAP32[$1 >> 2];
                        HEAP32[$1 >> 2] = $4 + 4;
                        $7 = HEAP32[$4 >> 2];
                       } else {
                        $7 = 0;
                       }
                       $4 = HEAP32[$5 + 76 >> 2] + 2 | 0;
                       HEAP32[$5 + 76 >> 2] = $4;
                       break label$36;
                      }
                      HEAP32[$5 + 76 >> 2] = $4 + 1;
                      $7 = getint($5 + 76 | 0);
                      $4 = HEAP32[$5 + 76 >> 2];
                     }
                     $6 = 0;
                     while (1) {
                      $18 = $6;
                      $11 = -1;
                      if (HEAP8[$4 | 0] + -65 >>> 0 > 57) {
                       break label$1;
                      }
                      $12 = $4 + 1 | 0;
                      HEAP32[$5 + 76 >> 2] = $12;
                      $6 = HEAP8[$4 | 0];
                      $4 = $12;
                      $6 = HEAPU8[($6 + Math_imul($18, 58) | 0) + 138031 | 0];
                      if ($6 + -1 >>> 0 < 8) {
                       continue;
                      }
                      break;
                     }
                     if (!$6) {
                      break label$1;
                     }
                     label$42 : {
                      label$43 : {
                       label$44 : {
                        if (($6 | 0) == 19) {
                         if (($15 | 0) <= -1) {
                          break label$44;
                         }
                         break label$1;
                        }
                        if (($15 | 0) < 0) {
                         break label$43;
                        }
                        HEAP32[($15 << 2) + $3 >> 2] = $6;
                        $4 = ($15 << 3) + $2 | 0;
                        $6 = HEAP32[$4 + 4 >> 2];
                        HEAP32[$5 + 64 >> 2] = HEAP32[$4 >> 2];
                        HEAP32[$5 + 68 >> 2] = $6;
                       }
                       $4 = 0;
                       if (!$0) {
                        continue label$3;
                       }
                       break label$42;
                      }
                      if (!$0) {
                       break label$6;
                      }
                      pop_arg($5 - -64 | 0, $6, $1);
                      $12 = HEAP32[$5 + 76 >> 2];
                     }
                     $10 = $8 & -65537;
                     $8 = $8 & 8192 ? $10 : $8;
                     $11 = 0;
                     $15 = 138071;
                     $6 = $16;
                     $4 = HEAP8[$12 + -1 | 0];
                     $4 = $18 ? ($4 & 15) == 3 ? $4 & -33 : $4 : $4;
                     $12 = $4 + -88 | 0;
                     if ($12 >>> 0 <= 32) {
                      break label$21;
                     }
                     label$46 : {
                      label$47 : {
                       label$48 : {
                        label$49 : {
                         $10 = $4 + -65 | 0;
                         if ($10 >>> 0 > 6) {
                          if (($4 | 0) != 83) {
                           break label$7;
                          }
                          if (!$7) {
                           break label$49;
                          }
                          $6 = HEAP32[$5 + 64 >> 2];
                          break label$47;
                         }
                         switch ($10 - 1 | 0) {
                         case 1:
                          break label$48;
                         case 0:
                         case 2:
                          break label$7;
                         default:
                          break label$18;
                         }
                        }
                        $4 = 0;
                        pad($0, 32, $13, 0, $8);
                        break label$46;
                       }
                       HEAP32[$5 + 12 >> 2] = 0;
                       HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 64 >> 2];
                       HEAP32[$5 + 64 >> 2] = $5 + 8;
                       $7 = -1;
                       $6 = $5 + 8 | 0;
                      }
                      $4 = 0;
                      label$51 : {
                       while (1) {
                        $9 = HEAP32[$6 >> 2];
                        if (!$9) {
                         break label$51;
                        }
                        $9 = wctomb($5 + 4 | 0, $9);
                        $10 = ($9 | 0) < 0;
                        if (!($10 | $9 >>> 0 > $7 - $4 >>> 0)) {
                         $6 = $6 + 4 | 0;
                         $4 = $4 + $9 | 0;
                         if ($7 >>> 0 > $4 >>> 0) {
                          continue;
                         }
                         break label$51;
                        }
                        break;
                       }
                       $11 = -1;
                       if ($10) {
                        break label$1;
                       }
                      }
                      pad($0, 32, $13, $4, $8);
                      if (!$4) {
                       $4 = 0;
                       break label$46;
                      }
                      $7 = 0;
                      $6 = HEAP32[$5 + 64 >> 2];
                      while (1) {
                       $9 = HEAP32[$6 >> 2];
                       if (!$9) {
                        break label$46;
                       }
                       $9 = wctomb($5 + 4 | 0, $9);
                       $7 = $9 + $7 | 0;
                       if (($7 | 0) > ($4 | 0)) {
                        break label$46;
                       }
                       out($0, $5 + 4 | 0, $9);
                       $6 = $6 + 4 | 0;
                       if ($7 >>> 0 < $4 >>> 0) {
                        continue;
                       }
                       break;
                      }
                     }
                     pad($0, 32, $13, $4, $8 ^ 8192);
                     $4 = ($13 | 0) > ($4 | 0) ? $13 : $4;
                     continue label$3;
                    }
                    $6 = $4 + 1 | 0;
                    HEAP32[$5 + 76 >> 2] = $6;
                    $8 = HEAPU8[$4 + 1 | 0];
                    $4 = $6;
                    continue;
                   }
                   break;
                  }
                  switch ($12 - 1 | 0) {
                  case 28:
                   break label$10;
                  case 21:
                   break label$11;
                  case 23:
                   break label$13;
                  case 22:
                   break label$14;
                  case 11:
                  case 16:
                   break label$15;
                  case 10:
                   break label$16;
                  case 26:
                   break label$17;
                  case 8:
                  case 12:
                  case 13:
                  case 14:
                   break label$18;
                  case 0:
                  case 1:
                  case 2:
                  case 3:
                  case 4:
                  case 5:
                  case 6:
                  case 7:
                  case 9:
                  case 15:
                  case 17:
                  case 18:
                  case 19:
                  case 20:
                  case 24:
                  case 25:
                  case 27:
                  case 29:
                  case 30:
                   break label$7;
                  default:
                   break label$12;
                  }
                 }
                 $11 = $14;
                 if ($0) {
                  break label$1;
                 }
                 if (!$17) {
                  break label$6;
                 }
                 $4 = 1;
                 while (1) {
                  $0 = HEAP32[($4 << 2) + $3 >> 2];
                  if ($0) {
                   pop_arg(($4 << 3) + $2 | 0, $0, $1);
                   $11 = 1;
                   $4 = $4 + 1 | 0;
                   if (($4 | 0) != 10) {
                    continue;
                   }
                   break label$1;
                  }
                  break;
                 }
                 $11 = 1;
                 if ($4 >>> 0 > 9) {
                  break label$1;
                 }
                 $11 = -1;
                 if (HEAP32[($4 << 2) + $3 >> 2]) {
                  break label$1;
                 }
                 while (1) {
                  $4 = $4 + 1 | 0;
                  if (HEAP32[($4 << 2) + $3 >> 2] ? 0 : ($4 | 0) != 10) {
                   continue;
                  }
                  break;
                 }
                 $11 = $4 >>> 0 < 10 ? -1 : 1;
                 break label$1;
                }
                $4 = FUNCTION_TABLE[688]($0, HEAPF64[$5 + 64 >> 3], $13, $7, $8, $4) | 0;
                continue;
               }
               $4 = HEAP32[$5 + 64 >> 2];
               $9 = $4 ? $4 : 138081;
               $4 = memchr($9, $7);
               $6 = $4 ? $4 : $7 + $9 | 0;
               $8 = $10;
               $7 = $4 ? $4 - $9 | 0 : $7;
               break label$7;
              }
              HEAP8[$5 + 55 | 0] = HEAP32[$5 + 64 >> 2];
              $7 = 1;
              $9 = $19;
              $8 = $10;
              break label$7;
             }
             $10 = HEAP32[$5 + 68 >> 2];
             $4 = $10;
             $9 = HEAP32[$5 + 64 >> 2];
             if (($4 | 0) < -1 ? 1 : ($4 | 0) <= -1 ? $9 >>> 0 > 4294967295 ? 0 : 1 : 0) {
              $4 = 0 - ($4 + (0 < $9 >>> 0) | 0) | 0;
              $9 = 0 - $9 | 0;
              HEAP32[$5 + 64 >> 2] = $9;
              HEAP32[$5 + 68 >> 2] = $4;
              $11 = 1;
              $15 = 138071;
              break label$9;
             }
             if ($8 & 2048) {
              $11 = 1;
              $15 = 138072;
              break label$9;
             }
             $11 = $8 & 1;
             $15 = $11 ? 138073 : 138071;
             break label$9;
            }
            $9 = fmt_o(HEAP32[$5 + 64 >> 2], HEAP32[$5 + 68 >> 2], $16);
            if (!($8 & 8)) {
             break label$8;
            }
            $4 = $16 - $9 | 0;
            $7 = ($7 | 0) > ($4 | 0) ? $7 : $4 + 1 | 0;
            break label$8;
           }
           $7 = $7 >>> 0 > 8 ? $7 : 8;
           $8 = $8 | 8;
           $4 = 120;
          }
          $9 = fmt_x(HEAP32[$5 + 64 >> 2], HEAP32[$5 + 68 >> 2], $16, $4 & 32);
          if (!($8 & 8) | !(HEAP32[$5 + 64 >> 2] | HEAP32[$5 + 68 >> 2])) {
           break label$8;
          }
          $15 = ($4 >>> 4) + 138071 | 0;
          $11 = 2;
          break label$8;
         }
         $4 = 0;
         $6 = $18 & 255;
         if ($6 >>> 0 > 7) {
          continue;
         }
         label$62 : {
          switch ($6 - 1 | 0) {
          default:
           HEAP32[HEAP32[$5 + 64 >> 2] >> 2] = $14;
           continue;
          case 0:
           HEAP32[HEAP32[$5 + 64 >> 2] >> 2] = $14;
           continue;
          case 1:
           $6 = HEAP32[$5 + 64 >> 2];
           HEAP32[$6 >> 2] = $14;
           HEAP32[$6 + 4 >> 2] = $14 >> 31;
           continue;
          case 2:
           HEAP16[HEAP32[$5 + 64 >> 2] >> 1] = $14;
           continue;
          case 3:
           HEAP8[HEAP32[$5 + 64 >> 2]] = $14;
           continue;
          case 5:
           HEAP32[HEAP32[$5 + 64 >> 2] >> 2] = $14;
           continue;
          case 4:
           continue;
          case 6:
           break label$62;
          }
         }
         $6 = HEAP32[$5 + 64 >> 2];
         HEAP32[$6 >> 2] = $14;
         HEAP32[$6 + 4 >> 2] = $14 >> 31;
         continue;
        }
        $9 = HEAP32[$5 + 64 >> 2];
        $4 = HEAP32[$5 + 68 >> 2];
        $15 = 138071;
       }
       $9 = fmt_u($9, $4, $16);
      }
      $8 = ($7 | 0) > -1 ? $8 & -65537 : $8;
      $4 = HEAP32[$5 + 68 >> 2];
      $10 = $4;
      $12 = HEAP32[$5 + 64 >> 2];
      label$69 : {
       if (!(!!($4 | $12) | $7)) {
        $9 = $16;
        $7 = 0;
        break label$69;
       }
       $4 = !($10 | $12) + ($16 - $9 | 0) | 0;
       $7 = ($7 | 0) > ($4 | 0) ? $7 : $4;
      }
     }
     $10 = $6 - $9 | 0;
     $7 = ($7 | 0) < ($10 | 0) ? $10 : $7;
     $6 = $7 + $11 | 0;
     $4 = ($13 | 0) < ($6 | 0) ? $6 : $13;
     pad($0, 32, $4, $6, $8);
     out($0, $15, $11);
     pad($0, 48, $4, $6, $8 ^ 65536);
     pad($0, 48, $7, $10, 0);
     out($0, $9, $10);
     pad($0, 32, $4, $6, $8 ^ 8192);
     continue;
    }
    break;
   }
   $11 = 0;
   break label$1;
  }
  $11 = -1;
 }
 global$0 = $5 + 80 | 0;
 return $11;
}
function jsvMathsOp($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $3 = global$0 - 80 | 0;
 global$0 = $3;
 HEAP32[$3 + 72 >> 2] = $0;
 HEAP32[$3 + 68 >> 2] = $1;
 HEAP32[$3 + 64 >> 2] = $2;
 label$1 : {
  if (!(HEAP32[$3 + 64 >> 2] != 141 ? HEAP32[$3 + 64 >> 2] != 139 : 0)) {
   HEAP8[$3 + 63 | 0] = jsvMathsOpTypeEqual(HEAP32[$3 + 72 >> 2], HEAP32[$3 + 68 >> 2]) & 1;
   if (HEAP32[$3 + 64 >> 2] == 139) {
    HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP8[$3 + 63 | 0] & 1);
    break label$1;
   }
   HEAP32[$3 + 76 >> 2] = jsvNewFromBool((HEAPU8[$3 + 63 | 0] ^ -1) & 1);
   break label$1;
  }
  $0 = $3;
  $1 = 1;
  label$5 : {
   if (HEAP32[$3 + 64 >> 2] == 38) {
    break label$5;
   }
   $1 = 1;
   if (HEAP32[$3 + 64 >> 2] == 124) {
    break label$5;
   }
   $1 = 1;
   if (HEAP32[$3 + 64 >> 2] == 94) {
    break label$5;
   }
   $1 = 1;
   if (HEAP32[$3 + 64 >> 2] == 143) {
    break label$5;
   }
   $1 = 1;
   if (HEAP32[$3 + 64 >> 2] == 146) {
    break label$5;
   }
   $1 = HEAP32[$3 + 64 >> 2] == 147;
  }
  HEAP8[$0 + 62 | 0] = $1;
  $0 = $3;
  $1 = 1;
  label$6 : {
   if (HEAP8[$3 + 62 | 0] & 1) {
    break label$6;
   }
   $1 = 1;
   if (HEAP32[$3 + 64 >> 2] == 42) {
    break label$6;
   }
   $1 = 1;
   if (HEAP32[$3 + 64 >> 2] == 47) {
    break label$6;
   }
   $1 = 1;
   if (HEAP32[$3 + 64 >> 2] == 37) {
    break label$6;
   }
   $1 = HEAP32[$3 + 64 >> 2] == 45;
  }
  HEAP8[$0 + 61 | 0] = $1;
  $0 = $3;
  $1 = 1;
  label$7 : {
   if (HEAP32[$3 + 64 >> 2] == 138) {
    break label$7;
   }
   $1 = 1;
   if (HEAP32[$3 + 64 >> 2] == 140) {
    break label$7;
   }
   $1 = 1;
   if (HEAP32[$3 + 64 >> 2] == 60) {
    break label$7;
   }
   $1 = 1;
   if (HEAP32[$3 + 64 >> 2] == 142) {
    break label$7;
   }
   $1 = 1;
   if (HEAP32[$3 + 64 >> 2] == 62) {
    break label$7;
   }
   $1 = HEAP32[$3 + 64 >> 2] == 145;
  }
  HEAP8[$0 + 60 | 0] = $1;
  if (HEAP8[$3 + 60 | 0] & 1) {
   label$9 : {
    label$10 : {
     if (!(jsvIsNumeric(HEAP32[$3 + 72 >> 2]) & 1)) {
      break label$10;
     }
     if (!(jsvIsString(HEAP32[$3 + 68 >> 2]) & 1)) {
      break label$10;
     }
     HEAP8[$3 + 61 | 0] = 1;
     $1 = jsvIsIntegerish(HEAP32[$3 + 72 >> 2]) & 1;
     $0 = $3;
     if ($1) {
      $1 = jsvIsStringNumericInt(HEAP32[$3 + 68 >> 2], 0);
     } else {
      $1 = 0;
     }
     HEAP8[$0 + 62 | 0] = $1 & 1;
     break label$9;
    }
    label$13 : {
     if (!(jsvIsNumeric(HEAP32[$3 + 68 >> 2]) & 1)) {
      break label$13;
     }
     if (!(jsvIsString(HEAP32[$3 + 72 >> 2]) & 1)) {
      break label$13;
     }
     HEAP8[$3 + 61 | 0] = 1;
     $1 = jsvIsIntegerish(HEAP32[$3 + 68 >> 2]) & 1;
     $0 = $3;
     if ($1) {
      $1 = jsvIsStringNumericInt(HEAP32[$3 + 72 >> 2], 0);
     } else {
      $1 = 0;
     }
     HEAP8[$0 + 62 | 0] = $1 & 1;
    }
   }
  }
  label$16 : {
   if (!(jsvIsUndefined(HEAP32[$3 + 72 >> 2]) & 1)) {
    break label$16;
   }
   if (!(jsvIsUndefined(HEAP32[$3 + 68 >> 2]) & 1)) {
    break label$16;
   }
   if (HEAP32[$3 + 64 >> 2] == 138) {
    HEAP32[$3 + 76 >> 2] = jsvNewFromBool(1);
    break label$1;
   }
   if (HEAP32[$3 + 64 >> 2] == 140) {
    HEAP32[$3 + 76 >> 2] = jsvNewFromBool(0);
    break label$1;
   }
   HEAP32[$3 + 76 >> 2] = 0;
   break label$1;
  }
  label$19 : {
   label$20 : {
    if (HEAP8[$3 + 61 | 0] & 1) {
     break label$20;
    }
    label$21 : {
     if (jsvIsNumeric(HEAP32[$3 + 72 >> 2]) & 1) {
      break label$21;
     }
     if (jsvIsUndefined(HEAP32[$3 + 72 >> 2]) & 1) {
      break label$21;
     }
     if (!(jsvIsNull(HEAP32[$3 + 72 >> 2]) & 1)) {
      break label$19;
     }
    }
    if (jsvIsNumeric(HEAP32[$3 + 68 >> 2]) & 1) {
     break label$20;
    }
    if (jsvIsUndefined(HEAP32[$3 + 68 >> 2]) & 1) {
     break label$20;
    }
    if (!(jsvIsNull(HEAP32[$3 + 68 >> 2]) & 1)) {
     break label$19;
    }
   }
   label$22 : {
    if (!(HEAP8[$3 + 62 | 0] & 1)) {
     if (!(jsvIsIntegerish(HEAP32[$3 + 72 >> 2]) & 1)) {
      break label$22;
     }
     if (!(jsvIsIntegerish(HEAP32[$3 + 68 >> 2]) & 1)) {
      break label$22;
     }
    }
    HEAP32[$3 + 56 >> 2] = jsvGetInteger(HEAP32[$3 + 72 >> 2]);
    HEAP32[$3 + 52 >> 2] = jsvGetInteger(HEAP32[$3 + 68 >> 2]);
    label$24 : {
     $0 = HEAP32[$3 + 64 >> 2] + -37 | 0;
     if ($0 >>> 0 > 110) {
      break label$24;
     }
     label$25 : {
      switch ($0 - 1 | 0) {
      case 5:
       $0 = HEAP32[$3 + 56 >> 2];
       $2 = HEAP32[$3 + 52 >> 2];
       $1 = $0 + $2 | 0;
       $0 = ($0 >> 31) + ($2 >> 31) | 0;
       HEAP32[$3 + 76 >> 2] = jsvNewFromLongInteger($1, $1 >>> 0 < $2 >>> 0 ? $0 + 1 | 0 : $0);
       break label$1;
      case 7:
       $0 = HEAP32[$3 + 56 >> 2];
       $2 = HEAP32[$3 + 52 >> 2];
       HEAP32[$3 + 76 >> 2] = jsvNewFromLongInteger($0 - $2 | 0, ($0 >> 31) - (($2 >> 31) + ($0 >>> 0 < $2 >>> 0) | 0) | 0);
       break label$1;
      case 4:
       $0 = HEAP32[$3 + 56 >> 2];
       $1 = $0;
       $2 = $0 >> 31;
       $0 = HEAP32[$3 + 52 >> 2];
       HEAP32[$3 + 76 >> 2] = jsvNewFromLongInteger(__wasm_i64_mul($1, $2, $0, $0 >> 31), i64toi32_i32$HIGH_BITS);
       break label$1;
      case 9:
       HEAP32[$3 + 76 >> 2] = jsvNewFromFloat(+HEAP32[$3 + 56 >> 2] / +HEAP32[$3 + 52 >> 2]);
       break label$1;
      case 0:
       HEAP32[$3 + 76 >> 2] = jsvNewFromInteger(HEAP32[$3 + 56 >> 2] & HEAP32[$3 + 52 >> 2]);
       break label$1;
      case 86:
       HEAP32[$3 + 76 >> 2] = jsvNewFromInteger(HEAP32[$3 + 56 >> 2] | HEAP32[$3 + 52 >> 2]);
       break label$1;
      case 56:
       HEAP32[$3 + 76 >> 2] = jsvNewFromInteger(HEAP32[$3 + 56 >> 2] ^ HEAP32[$3 + 52 >> 2]);
       break label$1;
      default:
       if (HEAP32[$3 + 52 >> 2] < 0) {
        HEAP32[$3 + 52 >> 2] = 0 - HEAP32[$3 + 52 >> 2];
       }
       $0 = $3;
       label$43 : {
        if (HEAP32[$3 + 52 >> 2]) {
         $1 = jsvNewFromInteger(HEAP32[$3 + 56 >> 2] % HEAP32[$3 + 52 >> 2] | 0);
         break label$43;
        }
        $1 = jsvNewFromFloat(nan);
       }
       HEAP32[$0 + 76 >> 2] = $1;
       break label$1;
      case 105:
       HEAP32[$3 + 76 >> 2] = jsvNewFromInteger(HEAP32[$3 + 56 >> 2] << HEAP32[$3 + 52 >> 2]);
       break label$1;
      case 108:
       HEAP32[$3 + 76 >> 2] = jsvNewFromInteger(HEAP32[$3 + 56 >> 2] >> HEAP32[$3 + 52 >> 2]);
       break label$1;
      case 109:
       HEAP32[$3 + 76 >> 2] = jsvNewFromLongInteger(HEAP32[$3 + 56 >> 2] >>> HEAP32[$3 + 52 >> 2], 0);
       break label$1;
      case 100:
       $0 = $3;
       if (HEAP32[$3 + 56 >> 2] == HEAP32[$3 + 52 >> 2]) {
        $1 = (jsvIsNull(HEAP32[$3 + 72 >> 2]) & 1) == (jsvIsNull(HEAP32[$3 + 68 >> 2]) & 1);
       } else {
        $1 = 0;
       }
       HEAP32[$0 + 76 >> 2] = jsvNewFromBool($1);
       break label$1;
      case 102:
       $0 = $3;
       if (HEAP32[$3 + 56 >> 2] == HEAP32[$3 + 52 >> 2]) {
        $1 = (jsvIsNull(HEAP32[$3 + 72 >> 2]) & 1) != (jsvIsNull(HEAP32[$3 + 68 >> 2]) & 1);
       } else {
        $1 = 1;
       }
       HEAP32[$0 + 76 >> 2] = jsvNewFromBool($1);
       break label$1;
      case 22:
       HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP32[$3 + 56 >> 2] < HEAP32[$3 + 52 >> 2]);
       break label$1;
      case 104:
       HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP32[$3 + 56 >> 2] <= HEAP32[$3 + 52 >> 2]);
       break label$1;
      case 24:
       HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP32[$3 + 56 >> 2] > HEAP32[$3 + 52 >> 2]);
       break label$1;
      case 1:
      case 2:
      case 3:
      case 6:
      case 8:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
      case 23:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 30:
      case 31:
      case 32:
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 57:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 65:
      case 66:
      case 67:
      case 68:
      case 69:
      case 70:
      case 71:
      case 72:
      case 73:
      case 74:
      case 75:
      case 76:
      case 77:
      case 78:
      case 79:
      case 80:
      case 81:
      case 82:
      case 83:
      case 84:
      case 85:
      case 87:
      case 88:
      case 89:
      case 90:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 97:
      case 98:
      case 99:
      case 101:
      case 103:
      case 106:
       break label$24;
      case 107:
       break label$25;
      }
     }
     HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP32[$3 + 56 >> 2] >= HEAP32[$3 + 52 >> 2]);
     break label$1;
    }
    HEAP32[$3 + 76 >> 2] = jsvMathsOpError(HEAP32[$3 + 64 >> 2], 78790);
    break label$1;
   }
   HEAPF64[$3 + 40 >> 3] = jsvGetFloat(HEAP32[$3 + 72 >> 2]);
   HEAPF64[$3 + 32 >> 3] = jsvGetFloat(HEAP32[$3 + 68 >> 2]);
   label$49 : {
    $0 = HEAP32[$3 + 64 >> 2] + -37 | 0;
    if ($0 >>> 0 > 108) {
     break label$49;
    }
    label$50 : {
     switch ($0 - 1 | 0) {
     case 5:
      HEAP32[$3 + 76 >> 2] = jsvNewFromFloat(HEAPF64[$3 + 40 >> 3] + HEAPF64[$3 + 32 >> 3]);
      break label$1;
     case 7:
      HEAP32[$3 + 76 >> 2] = jsvNewFromFloat(HEAPF64[$3 + 40 >> 3] - HEAPF64[$3 + 32 >> 3]);
      break label$1;
     case 4:
      HEAP32[$3 + 76 >> 2] = jsvNewFromFloat(HEAPF64[$3 + 40 >> 3] * HEAPF64[$3 + 32 >> 3]);
      break label$1;
     case 9:
      HEAP32[$3 + 76 >> 2] = jsvNewFromFloat(HEAPF64[$3 + 40 >> 3] / HEAPF64[$3 + 32 >> 3]);
      break label$1;
     default:
      HEAP32[$3 + 76 >> 2] = jsvNewFromFloat(jswrap_math_mod(HEAPF64[$3 + 40 >> 3], HEAPF64[$3 + 32 >> 3]));
      break label$1;
     case 100:
     case 102:
      $0 = $3;
      if (HEAPF64[$3 + 40 >> 3] == HEAPF64[$3 + 32 >> 3]) {
       $1 = (jsvIsNull(HEAP32[$3 + 72 >> 2]) & 1) == (jsvIsNull(HEAP32[$3 + 68 >> 2]) & 1);
      } else {
       $1 = 0;
      }
      HEAP8[$0 + 31 | 0] = $1;
      label$62 : {
       label$63 : {
        if (jsvIsNull(HEAP32[$3 + 72 >> 2]) & 1) {
         if (jsvIsUndefined(HEAP32[$3 + 68 >> 2]) & 1) {
          break label$63;
         }
        }
        if (!(jsvIsNull(HEAP32[$3 + 68 >> 2]) & 1)) {
         break label$62;
        }
        if (!(jsvIsUndefined(HEAP32[$3 + 72 >> 2]) & 1)) {
         break label$62;
        }
       }
       HEAP8[$3 + 31 | 0] = 1;
      }
      $0 = $3;
      if (HEAP32[$3 + 64 >> 2] == 138) {
       $1 = HEAP8[$3 + 31 | 0] & 1;
      } else {
       $1 = (HEAPU8[$3 + 31 | 0] ^ -1) & 1;
      }
      HEAP32[$0 + 76 >> 2] = jsvNewFromBool(($1 | 0) != 0);
      break label$1;
     case 22:
      HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAPF64[$3 + 40 >> 3] < HEAPF64[$3 + 32 >> 3]);
      break label$1;
     case 104:
      HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAPF64[$3 + 40 >> 3] <= HEAPF64[$3 + 32 >> 3]);
      break label$1;
     case 24:
      HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAPF64[$3 + 40 >> 3] > HEAPF64[$3 + 32 >> 3]);
      break label$1;
     case 0:
     case 1:
     case 2:
     case 3:
     case 6:
     case 8:
     case 10:
     case 11:
     case 12:
     case 13:
     case 14:
     case 15:
     case 16:
     case 17:
     case 18:
     case 19:
     case 20:
     case 21:
     case 23:
     case 25:
     case 26:
     case 27:
     case 28:
     case 29:
     case 30:
     case 31:
     case 32:
     case 33:
     case 34:
     case 35:
     case 36:
     case 37:
     case 38:
     case 39:
     case 40:
     case 41:
     case 42:
     case 43:
     case 44:
     case 45:
     case 46:
     case 47:
     case 48:
     case 49:
     case 50:
     case 51:
     case 52:
     case 53:
     case 54:
     case 55:
     case 56:
     case 57:
     case 58:
     case 59:
     case 60:
     case 61:
     case 62:
     case 63:
     case 64:
     case 65:
     case 66:
     case 67:
     case 68:
     case 69:
     case 70:
     case 71:
     case 72:
     case 73:
     case 74:
     case 75:
     case 76:
     case 77:
     case 78:
     case 79:
     case 80:
     case 81:
     case 82:
     case 83:
     case 84:
     case 85:
     case 86:
     case 87:
     case 88:
     case 89:
     case 90:
     case 91:
     case 92:
     case 93:
     case 94:
     case 95:
     case 96:
     case 97:
     case 98:
     case 99:
     case 101:
     case 103:
     case 105:
     case 106:
      break label$49;
     case 107:
      break label$50;
     }
    }
    HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAPF64[$3 + 40 >> 3] >= HEAPF64[$3 + 32 >> 3]);
    break label$1;
   }
   HEAP32[$3 + 76 >> 2] = jsvMathsOpError(HEAP32[$3 + 64 >> 2], 78798);
   break label$1;
  }
  label$67 : {
   label$68 : {
    if (jsvIsArray(HEAP32[$3 + 72 >> 2]) & 1) {
     break label$68;
    }
    if (jsvIsObject(HEAP32[$3 + 72 >> 2]) & 1) {
     break label$68;
    }
    if (jsvIsFunction(HEAP32[$3 + 72 >> 2]) & 1) {
     break label$68;
    }
    if (jsvIsArray(HEAP32[$3 + 68 >> 2]) & 1) {
     break label$68;
    }
    if (jsvIsObject(HEAP32[$3 + 68 >> 2]) & 1) {
     break label$68;
    }
    if (!(jsvIsFunction(HEAP32[$3 + 68 >> 2]) & 1)) {
     break label$67;
    }
   }
   if ((jsvIsArray(HEAP32[$3 + 72 >> 2]) & 1) != (jsvIsArray(HEAP32[$3 + 68 >> 2]) & 1) | (HEAP32[$3 + 64 >> 2] != 140 ? HEAP32[$3 + 64 >> 2] != 138 : 0)) {
    break label$67;
   }
   HEAP8[$3 + 30 | 0] = HEAP32[$3 + 72 >> 2] == HEAP32[$3 + 68 >> 2];
   label$70 : {
    if (!(jsvIsNativeFunction(HEAP32[$3 + 72 >> 2]) & 1)) {
     if (!(jsvIsNativeFunction(HEAP32[$3 + 68 >> 2]) & 1)) {
      break label$70;
     }
    }
    $0 = $3;
    $1 = 0;
    label$72 : {
     if (!HEAP32[$3 + 72 >> 2]) {
      break label$72;
     }
     $1 = 0;
     if (!HEAP32[$3 + 68 >> 2]) {
      break label$72;
     }
     $2 = HEAP32[$3 + 72 >> 2];
     $4 = HEAPU8[$2 | 0] | HEAPU8[$2 + 1 | 0] << 8 | (HEAPU8[$2 + 2 | 0] << 16 | HEAPU8[$2 + 3 | 0] << 24);
     $2 = HEAP32[$3 + 68 >> 2];
     $1 = 0;
     if (($4 | 0) != (HEAPU8[$2 | 0] | HEAPU8[$2 + 1 | 0] << 8 | (HEAPU8[$2 + 2 | 0] << 16 | HEAPU8[$2 + 3 | 0] << 24))) {
      break label$72;
     }
     $2 = HEAP32[$3 + 72 >> 2];
     $4 = HEAPU8[$2 + 4 | 0] | HEAPU8[$2 + 5 | 0] << 8;
     $2 = HEAP32[$3 + 68 >> 2];
     $1 = 0;
     if (($4 | 0) != (HEAPU8[$2 + 4 | 0] | HEAPU8[$2 + 5 | 0] << 8)) {
      break label$72;
     }
     $1 = (jsvGetFirstChild(HEAP32[$3 + 72 >> 2]) & 65535) == (jsvGetFirstChild(HEAP32[$3 + 68 >> 2]) & 65535);
    }
    HEAP8[$0 + 30 | 0] = $1;
   }
   label$73 : {
    $0 = HEAP32[$3 + 64 >> 2] + -138 | 0;
    if ($0 >>> 0 > 2) {
     break label$73;
    }
    label$74 : {
     switch ($0 - 1 | 0) {
     default:
      HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP8[$3 + 30 | 0] & 1);
      break label$1;
     case 0:
      break label$73;
     case 1:
      break label$74;
     }
    }
    HEAP32[$3 + 76 >> 2] = jsvNewFromBool((HEAPU8[$3 + 30 | 0] ^ -1) & 1);
    break label$1;
   }
   HEAP32[$3 + 76 >> 2] = jsvMathsOpError(HEAP32[$3 + 64 >> 2], jsvIsArray(HEAP32[$3 + 72 >> 2]) & 1 ? 78805 : 78811);
   break label$1;
  }
  HEAP32[$3 + 24 >> 2] = jsvAsString(HEAP32[$3 + 72 >> 2]);
  HEAP32[$3 + 20 >> 2] = jsvAsString(HEAP32[$3 + 68 >> 2]);
  if (!(HEAP32[$3 + 20 >> 2] ? HEAP32[$3 + 24 >> 2] : 0)) {
   jsvUnLock2(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
   HEAP32[$3 + 76 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$3 + 64 >> 2] == 43) {
   label$79 : {
    label$80 : {
     if (!(jsvIsBasicString(HEAP32[$3 + 24 >> 2]) & 1)) {
      break label$80;
     }
     if ((jsvGetLocks(HEAP32[$3 + 24 >> 2]) & 255) != 1) {
      break label$80;
     }
     if (jsvGetRefs(HEAP32[$3 + 24 >> 2]) & 255) {
      break label$80;
     }
     HEAP32[$3 + 16 >> 2] = jsvLockAgain(HEAP32[$3 + 24 >> 2]);
     break label$79;
    }
    HEAP32[$3 + 16 >> 2] = jsvCopy(HEAP32[$3 + 24 >> 2], 0);
   }
   if (HEAP32[$3 + 16 >> 2]) {
    jsvAppendStringVarComplete(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 20 >> 2]);
   }
   jsvUnLock2(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
   HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 16 >> 2];
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = jsvCompareString(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], 0, 0);
  jsvUnLock2(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
  label$82 : {
   label$83 : {
    label$84 : {
     label$85 : {
      $0 = HEAP32[$3 + 64 >> 2];
      if (($0 | 0) != 60) {
       if (($0 | 0) == 62) {
        break label$84;
       }
       label$87 : {
        if (($0 | 0) != 138) {
         switch ($0 - 140 | 0) {
         case 5:
          break label$83;
         case 2:
          break label$85;
         case 0:
          break label$87;
         default:
          break label$82;
         }
        }
        HEAP32[$3 + 76 >> 2] = jsvNewFromBool(!HEAP32[$3 + 12 >> 2]);
        break label$1;
       }
       HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP32[$3 + 12 >> 2] != 0);
       break label$1;
      }
      HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP32[$3 + 12 >> 2] < 0);
      break label$1;
     }
     HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP32[$3 + 12 >> 2] <= 0);
     break label$1;
    }
    HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP32[$3 + 12 >> 2] > 0);
    break label$1;
   }
   HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP32[$3 + 12 >> 2] >= 0);
   break label$1;
  }
  HEAP32[$3 + 76 >> 2] = jsvMathsOpError(HEAP32[$3 + 64 >> 2], 78818);
 }
 global$0 = $3 + 80 | 0;
 return HEAP32[$3 + 76 >> 2];
}
function jspeFunctionCall($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0, $7 = 0;
 $7 = global$0 - 416 | 0;
 $6 = $7;
 global$0 = $6;
 HEAP32[$6 + 408 >> 2] = $0;
 HEAP32[$6 + 404 >> 2] = $1;
 HEAP32[$6 + 400 >> 2] = $2;
 HEAP8[$6 + 399 | 0] = $3;
 HEAP32[$6 + 392 >> 2] = $4;
 HEAP32[$6 + 388 >> 2] = $5;
 label$1 : {
  if (!(HEAP32[$6 + 408 >> 2] | (HEAP32[80549] & 63) != 1)) {
   label$3 : {
    if (HEAP32[$6 + 404 >> 2]) {
     HEAP32[$6 + 64 >> 2] = HEAP32[$6 + 404 >> 2];
     jsExceptionHere(1, 79704, $6 - -64 | 0);
     break label$3;
    }
    HEAP32[$6 + 80 >> 2] = HEAP32[$6 + 404 >> 2];
    jsExceptionHere(1, 79727, $6 + 80 | 0);
   }
   HEAP32[$6 + 412 >> 2] = 0;
   break label$1;
  }
  if ((HEAP32[80549] & 63) == 1) {
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$6 + 412 >> 2] = 0;
    break label$1;
   }
  }
  if (!(!HEAP32[$6 + 408 >> 2] | (HEAP32[80549] & 63) != 1)) {
   HEAP32[$6 + 384 >> 2] = 0;
   if (!(jsvIsFunction(HEAP32[$6 + 408 >> 2]) & 1)) {
    HEAP32[$6 + 48 >> 2] = HEAP32[$6 + 408 >> 2];
    jsExceptionHere(1, 79747, $6 + 48 | 0);
    HEAP32[$6 + 412 >> 2] = 0;
    break label$1;
   }
   HEAP32[$6 + 380 >> 2] = jsvLockAgainSafe(HEAP32[$6 + 400 >> 2]);
   if (HEAP8[$6 + 399 | 0] & 1) {
    if (!(jslMatch(40) & 1)) {
     HEAP32[$6 + 412 >> 2] = 0;
     break label$1;
    }
   }
   label$11 : {
    if (jsvIsNative(HEAP32[$6 + 408 >> 2]) & 1) {
     HEAP32[$6 + 376 >> 2] = 0;
     HEAP32[$6 + 372 >> 2] = 0;
     $0 = $6 + 368 | 0;
     jsvObjectIteratorNew($0, HEAP32[$6 + 408 >> 2]);
     HEAP32[$6 + 364 >> 2] = jsvObjectIteratorGetKey($0);
     while (1) {
      if (jsvIsFunctionParameter(HEAP32[$6 + 364 >> 2]) & 1) {
       if (HEAPU32[$6 + 392 >> 2] >= HEAPU32[$6 + 376 >> 2]) {
        $0 = $6;
        if (HEAP32[$6 + 376 >> 2]) {
         $1 = HEAP32[$6 + 376 >> 2];
        } else {
         $1 = HEAP32[$6 + 392 >> 2];
        }
        HEAP32[$0 + 360 >> 2] = $1 << 2;
        HEAP32[$6 + 356 >> 2] = HEAP32[$6 + 360 >> 2] << 2;
        if (1e6 < HEAP32[$6 + 356 >> 2] + 256 >>> 0) {
         jsExceptionHere(1, 79784, 0);
         jsvUnLock(HEAP32[$6 + 380 >> 2]);
         HEAP32[$6 + 412 >> 2] = 0;
         break label$1;
        }
        $0 = $7 - (HEAP32[$6 + 356 >> 2] + 15 & -16) | 0;
        $7 = $0;
        global$0 = $0;
        HEAP32[$6 + 352 >> 2] = $0;
        memcpy(HEAP32[$6 + 352 >> 2], HEAP32[$6 + 388 >> 2], HEAP32[$6 + 392 >> 2] << 2);
        HEAP32[$6 + 388 >> 2] = HEAP32[$6 + 352 >> 2];
        HEAP32[$6 + 376 >> 2] = HEAP32[$6 + 360 >> 2];
       }
       HEAP32[$6 + 348 >> 2] = HEAP32[$6 + 392 >> 2] - 1;
       while (1) {
        if (HEAP32[$6 + 348 >> 2] >= HEAP32[$6 + 372 >> 2]) {
         HEAP32[HEAP32[$6 + 388 >> 2] + (HEAP32[$6 + 348 >> 2] + 1 << 2) >> 2] = HEAP32[HEAP32[$6 + 388 >> 2] + (HEAP32[$6 + 348 >> 2] << 2) >> 2];
         HEAP32[$6 + 348 >> 2] = HEAP32[$6 + 348 >> 2] + -1;
         continue;
        }
        break;
       }
       $0 = $6 + 368 | 0;
       $1 = jsvSkipName(HEAP32[$6 + 364 >> 2]);
       HEAP32[HEAP32[$6 + 388 >> 2] + (HEAP32[$6 + 372 >> 2] << 2) >> 2] = $1;
       HEAP32[$6 + 392 >> 2] = HEAP32[$6 + 392 >> 2] + 1;
       HEAP32[$6 + 372 >> 2] = HEAP32[$6 + 372 >> 2] + 1;
       jsvUnLock(HEAP32[$6 + 364 >> 2]);
       jsvObjectIteratorNext($0);
       HEAP32[$6 + 364 >> 2] = jsvObjectIteratorGetKey($0);
       continue;
      }
      break;
     }
     while (1) {
      label$22 : {
       if (!HEAP32[$6 + 364 >> 2]) {
        break label$22;
       }
       if (jsvIsStringEqual(HEAP32[$6 + 364 >> 2], 79827) & 1) {
        jsvUnLock(HEAP32[$6 + 380 >> 2]);
        HEAP32[$6 + 380 >> 2] = jsvSkipName(HEAP32[$6 + 364 >> 2]);
        break label$22;
       }
       $0 = $6 + 368 | 0;
       jsvUnLock(HEAP32[$6 + 364 >> 2]);
       jsvObjectIteratorNext($0);
       HEAP32[$6 + 364 >> 2] = jsvObjectIteratorGetKey($0);
       continue;
      }
      break;
     }
     $0 = $6 + 368 | 0;
     jsvUnLock(HEAP32[$6 + 364 >> 2]);
     jsvObjectIteratorFree($0);
     HEAP32[$6 + 344 >> 2] = HEAP32[$6 + 372 >> 2];
     if (HEAP8[$6 + 399 | 0] & 1) {
      while (1) {
       $0 = 0;
       label$26 : {
        if (HEAP32[80549] & 112) {
         break label$26;
        }
        $0 = 0;
        if (HEAP16[HEAP32[35539] + 2 >> 1] == 41) {
         break label$26;
        }
        $0 = HEAP16[HEAP32[35539] + 2 >> 1];
       }
       if ($0) {
        if (HEAPU32[$6 + 392 >> 2] >= HEAPU32[$6 + 376 >> 2]) {
         $0 = $6;
         if (HEAP32[$6 + 376 >> 2]) {
          $1 = HEAP32[$6 + 376 >> 2] << 2;
         } else {
          $1 = 16;
         }
         HEAP32[$0 + 340 >> 2] = $1;
         $0 = $7 - ((HEAP32[$6 + 340 >> 2] << 2) + 15 & -16) | 0;
         $7 = $0;
         global$0 = $0;
         HEAP32[$6 + 336 >> 2] = $0;
         memcpy(HEAP32[$6 + 336 >> 2], HEAP32[$6 + 388 >> 2], HEAP32[$6 + 392 >> 2] << 2);
         HEAP32[$6 + 388 >> 2] = HEAP32[$6 + 336 >> 2];
         HEAP32[$6 + 376 >> 2] = HEAP32[$6 + 340 >> 2];
        }
        $0 = jsvSkipNameAndUnLock(__jspeAssignmentExpression(jspeConditionalExpression()));
        $1 = HEAP32[$6 + 388 >> 2];
        $2 = HEAP32[$6 + 392 >> 2];
        HEAP32[$6 + 392 >> 2] = $2 + 1;
        HEAP32[$1 + ($2 << 2) >> 2] = $0;
        if (HEAP16[HEAP32[35539] + 2 >> 1] != 41) {
         if (!(jslMatch(44) & 1)) {
          jsvUnLockMany(HEAP32[$6 + 392 >> 2], HEAP32[$6 + 388 >> 2]);
          jsvUnLock(HEAP32[$6 + 380 >> 2]);
          HEAP32[$6 + 412 >> 2] = 0;
          break label$1;
         }
        }
        continue;
       }
       break;
      }
      if (!(jslMatch(41) & 1)) {
       HEAP32[$6 + 412 >> 2] = 0;
       break label$1;
      }
      HEAP32[$6 + 344 >> 2] = HEAP32[$6 + 392 >> 2];
     }
     HEAP32[$6 + 332 >> 2] = jsvGetNativeFunctionPtr(HEAP32[$6 + 408 >> 2]);
     HEAP32[$6 + 328 >> 2] = HEAP32[80548];
     label$34 : {
      if (HEAP32[$6 + 380 >> 2]) {
       HEAP32[80548] = jsvRef(HEAP32[$6 + 380 >> 2]);
       break label$34;
      }
      label$36 : {
       if (HEAP32[$6 + 332 >> 2] == 9) {
        if (HEAP32[80548]) {
         HEAP32[80548] = jsvRef(HEAP32[80548]);
        }
        break label$36;
       }
       HEAP32[80548] = jsvRef(HEAP32[80545]);
      }
     }
     label$39 : {
      if (!(!HEAP32[$6 + 332 >> 2] | HEAP32[80549] & 112)) {
       $0 = HEAP32[$6 + 408 >> 2];
       HEAP32[$6 + 384 >> 2] = jsnCallFunction(HEAP32[$6 + 332 >> 2], HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8, HEAP32[$6 + 380 >> 2], HEAP32[$6 + 388 >> 2], HEAP32[$6 + 392 >> 2]);
       break label$39;
      }
      HEAP32[$6 + 384 >> 2] = 0;
     }
     jsvUnLockMany(HEAP32[$6 + 344 >> 2], HEAP32[$6 + 388 >> 2]);
     if (HEAP32[80548]) {
      jsvUnRef(HEAP32[80548]);
     }
     HEAP32[80548] = HEAP32[$6 + 328 >> 2];
     break label$11;
    }
    HEAP32[$6 + 324 >> 2] = jsvNewWithFlags(7);
    if (!HEAP32[$6 + 324 >> 2]) {
     jspSetError();
     jsvUnLock(HEAP32[$6 + 380 >> 2]);
     HEAP32[$6 + 412 >> 2] = 0;
     break label$1;
    }
    HEAP32[$6 + 320 >> 2] = 0;
    HEAP32[$6 + 316 >> 2] = 0;
    HEAP32[$6 + 312 >> 2] = 0;
    $0 = $6 + 304 | 0;
    jsvObjectIteratorNew($0, HEAP32[$6 + 408 >> 2]);
    HEAP32[$6 + 300 >> 2] = jsvObjectIteratorGetKey($0);
    HEAP32[$6 + 296 >> 2] = jsvObjectIteratorGetValue($0);
    while (1) {
     if (jsvIsFunctionParameter(HEAP32[$6 + 300 >> 2]) & 1) {
      $0 = HEAP32[$6 + 296 >> 2];
     } else {
      $0 = 0;
     }
     if ($0) {
      $0 = $6 + 304 | 0;
      jsvAddFunctionParameter(HEAP32[$6 + 324 >> 2], jsvNewFromStringVar(HEAP32[$6 + 300 >> 2], 1, 2147483647), HEAP32[$6 + 296 >> 2]);
      jsvUnLock2(HEAP32[$6 + 296 >> 2], HEAP32[$6 + 300 >> 2]);
      jsvObjectIteratorNext($0);
      HEAP32[$6 + 300 >> 2] = jsvObjectIteratorGetKey($0);
      HEAP32[$6 + 296 >> 2] = jsvObjectIteratorGetValue($0);
      continue;
     }
     break;
    }
    jsvUnLock2(HEAP32[$6 + 296 >> 2], HEAP32[$6 + 300 >> 2]);
    label$47 : {
     if (HEAP8[$6 + 399 | 0] & 1) {
      HEAP32[$6 + 292 >> 2] = 0;
      while (1) {
       if (HEAP32[80549] & 80 ? 0 : HEAP16[HEAP32[35539] + 2 >> 1] != 41) {
        HEAP32[$6 + 288 >> 2] = jsvObjectIteratorGetKey($6 + 304 | 0);
        HEAP8[$6 + 287 | 0] = jsvIsFunctionParameter(HEAP32[$6 + 288 >> 2]) & 1;
        if (!(HEAP8[$6 + 287 | 0] & 1 ? 0 : HEAP16[HEAP32[35539] + 2 >> 1] == 41)) {
         HEAP32[$6 + 292 >> 2] = HEAP32[$6 + 292 >> 2] + 1;
         HEAP32[$6 + 280 >> 2] = 0;
         if (HEAP16[HEAP32[35539] + 2 >> 1] != 41) {
          HEAP32[$6 + 280 >> 2] = __jspeAssignmentExpression(jspeConditionalExpression());
         }
         HEAP32[$6 + 280 >> 2] = jsvSkipNameAndUnLock(HEAP32[$6 + 280 >> 2]);
         $1 = HEAP32[$6 + 324 >> 2];
         label$56 : {
          if (HEAP8[$6 + 287 | 0] & 1) {
           $0 = jsvNewFromStringVar(HEAP32[$6 + 288 >> 2], 1, 2147483647);
           break label$56;
          }
          $0 = 0;
         }
         jsvAddFunctionParameter($1, $0, HEAP32[$6 + 280 >> 2]);
         jsvUnLock(HEAP32[$6 + 280 >> 2]);
         if (HEAP16[HEAP32[35539] + 2 >> 1] != 41) {
          if (!(jslMatch(44) & 1)) {
           HEAP32[$6 + 412 >> 2] = 0;
           break label$1;
          }
         }
        }
        jsvUnLock(HEAP32[$6 + 288 >> 2]);
        if (HEAP8[$6 + 287 | 0] & 1) {
         jsvObjectIteratorNext($6 + 304 | 0);
        }
        continue;
       }
       break;
      }
      if (!(jslMatch(41) & 1)) {
       HEAP32[$6 + 412 >> 2] = 0;
       break label$1;
      }
      break label$47;
     }
     HEAP32[$6 + 276 >> 2] = 0;
     while (1) {
      if (HEAP32[$6 + 276 >> 2] < HEAP32[$6 + 392 >> 2]) {
       HEAP32[$6 + 272 >> 2] = jsvObjectIteratorGetKey($6 + 304 | 0);
       HEAP8[$6 + 271 | 0] = jsvIsFunctionParameter(HEAP32[$6 + 272 >> 2]) & 1;
       $1 = HEAP32[$6 + 324 >> 2];
       label$64 : {
        if (HEAP8[$6 + 271 | 0] & 1) {
         $0 = jsvNewFromStringVar(HEAP32[$6 + 272 >> 2], 1, 2147483647);
         break label$64;
        }
        $0 = 0;
       }
       jsvAddFunctionParameter($1, $0, HEAP32[HEAP32[$6 + 388 >> 2] + (HEAP32[$6 + 276 >> 2] << 2) >> 2]);
       HEAP32[$6 + 276 >> 2] = HEAP32[$6 + 276 >> 2] + 1;
       jsvUnLock(HEAP32[$6 + 272 >> 2]);
       if (HEAP8[$6 + 271 | 0] & 1) {
        jsvObjectIteratorNext($6 + 304 | 0);
       }
       continue;
      }
      break;
     }
    }
    while (1) {
     if (jsvObjectIteratorHasValue($6 + 304 | 0) & 1) {
      HEAP32[$6 + 264 >> 2] = jsvObjectIteratorGetKey($6 + 304 | 0);
      if (jsvIsString(HEAP32[$6 + 264 >> 2]) & 1) {
       label$70 : {
        if (jsvIsStringEqual(HEAP32[$6 + 264 >> 2], 79694) & 1) {
         HEAP32[$6 + 320 >> 2] = jsvSkipName(HEAP32[$6 + 264 >> 2]);
         break label$70;
        }
        label$72 : {
         if (jsvIsStringEqual(HEAP32[$6 + 264 >> 2], 79689) & 1) {
          HEAP32[$6 + 316 >> 2] = jsvSkipName(HEAP32[$6 + 264 >> 2]);
          break label$72;
         }
         label$74 : {
          if (jsvIsStringEqual(HEAP32[$6 + 264 >> 2], 79699) & 1) {
           HEAP32[$6 + 312 >> 2] = jsvSkipName(HEAP32[$6 + 264 >> 2]);
           break label$74;
          }
          label$76 : {
           if (jsvIsStringEqual(HEAP32[$6 + 264 >> 2], 79827) & 1) {
            jsvUnLock(HEAP32[$6 + 380 >> 2]);
            HEAP32[$6 + 380 >> 2] = jsvSkipName(HEAP32[$6 + 264 >> 2]);
            break label$76;
           }
           if (jsvIsFunctionParameter(HEAP32[$6 + 264 >> 2]) & 1) {
            HEAP32[$6 + 260 >> 2] = jsvSkipName(HEAP32[$6 + 264 >> 2]);
            jsvAddFunctionParameter(HEAP32[$6 + 324 >> 2], jsvNewFromStringVar(HEAP32[$6 + 264 >> 2], 1, 2147483647), HEAP32[$6 + 260 >> 2]);
            jsvUnLock(HEAP32[$6 + 260 >> 2]);
           }
          }
         }
        }
       }
      }
      $0 = $6 + 304 | 0;
      jsvUnLock(HEAP32[$6 + 264 >> 2]);
      jsvObjectIteratorNext($0);
      continue;
     }
     break;
    }
    jsvObjectIteratorFree($6 + 304 | 0);
    if (HEAP32[$6 + 312 >> 2]) {
     HEAP32[$6 + 256 >> 2] = jsvMakeIntoVariableName(jsvNewFromStringVar(HEAP32[$6 + 312 >> 2], 0, 2147483647), HEAP32[$6 + 408 >> 2]);
     jsvAddName(HEAP32[$6 + 324 >> 2], HEAP32[$6 + 256 >> 2]);
     jsvUnLock2(HEAP32[$6 + 256 >> 2], HEAP32[$6 + 312 >> 2]);
    }
    if (!(HEAP32[80549] & 112)) {
     HEAP32[$6 + 252 >> 2] = HEAP32[80547];
     HEAP32[80547] = 0;
     if (HEAP32[$6 + 320 >> 2]) {
      jspeiLoadScopesFromVar(HEAP32[$6 + 320 >> 2]);
      jsvUnLock(HEAP32[$6 + 320 >> 2]);
     }
     if (jspeiAddScope(HEAP32[$6 + 324 >> 2]) & 1) {
      HEAP32[$6 + 248 >> 2] = HEAP32[80548];
      label$83 : {
       if (HEAP32[$6 + 380 >> 2]) {
        HEAP32[80548] = jsvRef(HEAP32[$6 + 380 >> 2]);
        break label$83;
       }
       HEAP32[80548] = jsvRef(HEAP32[80545]);
      }
      if (HEAP32[$6 + 316 >> 2]) {
       HEAP8[$6 + 247 | 0] = 0;
       label$86 : {
        if (HEAP32[80549] & 16384) {
         if (HEAP32[$6 + 404 >> 2]) {
          HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 404 >> 2];
          jsiConsolePrintf(79832, $6 + 16 | 0);
          break label$86;
         }
         HEAP32[$6 + 32 >> 2] = HEAP32[$6 + 404 >> 2];
         jsiConsolePrintf(79850, $6 + 32 | 0);
         break label$86;
        }
        HEAP8[$6 + 247 | 0] = (HEAP32[80549] & 8192) != 0;
        if (HEAP8[$6 + 247 | 0] & 1) {
         HEAP32[80549] = HEAP32[80549] & -8193;
        }
       }
       HEAP32[$6 + 116 >> 2] = jslSetLex($6 + 120 | 0);
       jslInit(HEAP32[$6 + 316 >> 2]);
       HEAP32[$6 + 112 >> 2] = HEAP32[80549];
       HEAP32[80549] = HEAP32[80549] & 14448 | 1;
       label$90 : {
        if (jsvIsFunctionReturn(HEAP32[$6 + 408 >> 2]) & 1) {
         if (!(!(HEAP32[80549] & 8192) | (HEAP32[80549] & 63) != 1)) {
          HEAP32[HEAP32[35539] + 8 >> 2] = HEAP32[HEAP32[35539] + 4 >> 2];
          jsiDebuggerLoop();
         }
         if (!(HEAP16[HEAP32[35539] + 2 >> 1] == 59 | HEAP16[HEAP32[35539] + 2 >> 1] == 125)) {
          HEAP32[$6 + 384 >> 2] = jsvSkipNameAndUnLock(jspeExpression());
         }
         break label$90;
        }
        HEAP32[$6 + 108 >> 2] = jsvAddNamedChild(HEAP32[$6 + 324 >> 2], 0, 79874);
        jspeBlockNoBrackets();
        HEAP32[$6 + 384 >> 2] = jsvSkipNameAndUnLock(HEAP32[$6 + 108 >> 2]);
        if (HEAP32[$6 + 108 >> 2]) {
         jsvSetValueOfName(HEAP32[$6 + 108 >> 2], 0);
        }
       }
       HEAP32[$6 + 104 >> 2] = HEAP32[80549] & 112;
       HEAP32[80549] = HEAP32[80549] & -1664 | HEAP32[$6 + 112 >> 2] & 1663;
       HEAP8[$6 + 103 | 0] = 0;
       if (HEAP32[80549] & 57344) {
        jsiConsolePrintString(79881);
        jsfPrintJSON(HEAP32[$6 + 384 >> 2], 45);
        jsiConsolePrintChar(10);
        if (HEAP32[80549] & 32768) {
         HEAP8[$6 + 103 | 0] = 1;
         jsiDebuggerLoop();
        }
       }
       if (!(!(HEAP8[$6 + 247 | 0] & 1) | HEAP8[$6 + 103 | 0] & 1)) {
        HEAP32[80549] = HEAP32[80549] | 8192;
       }
       jslKill();
       jslSetLex(HEAP32[$6 + 116 >> 2]);
       if (HEAP32[$6 + 104 >> 2]) {
        HEAP32[80549] = HEAP32[$6 + 104 >> 2] | HEAP32[80549];
        HEAP32[$6 + 96 >> 2] = jsvObjectGetChild(HEAP32[80546], 79602, 27);
        if (HEAP32[$6 + 96 >> 2]) {
         $0 = HEAP32[$6 + 96 >> 2];
         $1 = jsvIsString(HEAP32[$6 + 404 >> 2]);
         HEAP32[$6 >> 2] = HEAP32[$6 + 404 >> 2];
         jsvAppendPrintf($0, $1 & 1 ? 79901 : 79929, $6);
         label$100 : {
          if (HEAP32[35539]) {
           jspAppendStackTrace(HEAP32[$6 + 96 >> 2]);
           break label$100;
          }
          jsvAppendPrintf(HEAP32[$6 + 96 >> 2], 79954, 0);
         }
         jsvUnLock(HEAP32[$6 + 96 >> 2]);
        }
       }
      }
      if (HEAP32[80548]) {
       jsvUnRef(HEAP32[80548]);
      }
      HEAP32[80548] = HEAP32[$6 + 248 >> 2];
      jspeiRemoveScope();
     }
     jsvUnLock(HEAP32[80547]);
     HEAP32[80547] = HEAP32[$6 + 252 >> 2];
    }
    jsvUnLock(HEAP32[$6 + 316 >> 2]);
    jsvUnLock(HEAP32[$6 + 324 >> 2]);
   }
   jsvUnLock(HEAP32[$6 + 380 >> 2]);
   HEAP32[$6 + 412 >> 2] = HEAP32[$6 + 384 >> 2];
   break label$1;
  }
  if (HEAP8[$6 + 399 | 0] & 1) {
   jspeParseFunctionCallBrackets();
   HEAP32[$6 + 412 >> 2] = 0;
   break label$1;
  }
  HEAP32[$6 + 412 >> 2] = 0;
 }
 global$0 = $6 + 416 | 0;
 return HEAP32[$6 + 412 >> 2];
}
function jsfGetJSONWithCallback($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = global$0 - 336 | 0;
 global$0 = $6;
 HEAP32[$6 + 332 >> 2] = $0;
 HEAP32[$6 + 328 >> 2] = $1;
 HEAP32[$6 + 324 >> 2] = $2;
 HEAP32[$6 + 320 >> 2] = $3;
 HEAP32[$6 + 316 >> 2] = $4;
 HEAP32[$6 + 312 >> 2] = $5;
 HEAP32[$6 + 308 >> 2] = HEAP32[$6 + 324 >> 2] + 4096;
 if (!HEAP32[$6 + 320 >> 2]) {
  HEAP32[$6 + 320 >> 2] = 122732;
 }
 label$2 : {
  if (jsvIsUndefined(HEAP32[$6 + 332 >> 2]) & 1) {
   cbprintf(HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2], 122735, 0);
   break label$2;
  }
  label$4 : {
   $0 = HEAP32[$6 + 332 >> 2];
   if (!((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 256)) {
    if (!(jspIsInterrupted() & 1)) {
     break label$4;
    }
   }
   cbprintf(HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2], 122631, 0);
   break label$2;
  }
  $0 = HEAP32[$6 + 332 >> 2];
  $1 = HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8 | 256;
  HEAP8[$0 + 13 | 0] = $1;
  HEAP8[$0 + 14 | 0] = $1 >>> 8;
  label$6 : {
   if (jsvIsArray(HEAP32[$6 + 332 >> 2]) & 1) {
    HEAP32[$6 + 304 >> 2] = jsvGetArrayLength(HEAP32[$6 + 332 >> 2]);
    HEAP8[$6 + 303 | 0] = HEAP32[$6 + 324 >> 2] & 8 ? HEAP32[$6 + 304 >> 2] > 15 : 0;
    HEAP8[$6 + 302 | 0] = 0;
    cbprintf(HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2], HEAP32[$6 + 324 >> 2] & 4 ? 122745 : 122748, 0);
    HEAP32[$6 + 296 >> 2] = -1;
    HEAP8[$6 + 295 | 0] = 1;
    HEAP8[$6 + 294 | 0] = 1;
    jsvObjectIteratorNew($6 + 288 | 0, HEAP32[$6 + 332 >> 2]);
    while (1) {
     $0 = 0;
     label$11 : {
      if ((HEAP32[$6 + 296 >> 2] + 1 | 0) >= HEAP32[$6 + 304 >> 2]) {
       break label$11;
      }
      $0 = 0;
      if (!(HEAP8[$6 + 295 | 0] & 1)) {
       break label$11;
      }
      $0 = jspIsInterrupted() ^ -1;
     }
     if ($0 & 1) {
      $0 = $6 + 288 | 0;
      HEAP32[$6 + 284 >> 2] = jsvObjectIteratorGetKey($0);
      label$13 : {
       label$14 : {
        if (jsvObjectIteratorHasValue($0) & 1) {
         if (!(jsvIsNumeric(HEAP32[$6 + 284 >> 2]) & 1)) {
          break label$14;
         }
        }
        $0 = $6;
        label$16 : {
         if (jsvObjectIteratorHasValue($6 + 288 | 0) & 1) {
          $1 = jsvGetInteger(HEAP32[$6 + 284 >> 2]);
          break label$16;
         }
         $1 = HEAP32[$6 + 304 >> 2] - 1 | 0;
        }
        HEAP32[$0 + 280 >> 2] = $1;
        HEAP32[$6 + 276 >> 2] = jsvObjectIteratorGetValue($6 + 288 | 0);
        while (1) {
         if (HEAP32[$6 + 296 >> 2] < HEAP32[$6 + 280 >> 2]) {
          HEAP32[$6 + 296 >> 2] = HEAP32[$6 + 296 >> 2] + 1;
          if (!(HEAP32[$6 + 296 >> 2] < (HEAP32[$6 + 304 >> 2] - 5 | 0) ? !(!(HEAP8[$6 + 303 | 0] & 1) | HEAP32[$6 + 296 >> 2] < 5) : 0)) {
           if (!(HEAP8[$6 + 294 | 0] & 1)) {
            cbprintf(HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2], HEAP32[$6 + 324 >> 2] & 4 ? 122750 : 122671, 0);
           }
           HEAP8[$6 + 294 | 0] = 0;
           if (!(!(HEAP8[$6 + 303 | 0] & 1) | HEAP32[$6 + 296 >> 2] != (HEAP32[$6 + 304 >> 2] - 5 | 0))) {
            cbprintf(HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2], HEAP32[35430], 0);
           }
           $0 = $6;
           if (HEAP32[$6 + 324 >> 2] & 1) {
            $1 = jsonNeedsNewLine(HEAP32[$6 + 276 >> 2]);
           } else {
            $1 = 0;
           }
           HEAP8[$0 + 275 | 0] = $1 & 1;
           if (HEAP32[$6 + 324 >> 2] & 2) {
            HEAP8[$6 + 302 | 0] = 1;
            HEAP8[$6 + 275 | 0] = 1;
           }
           if (!(HEAP8[$6 + 275 | 0] & 1 ? 0 : !(HEAP8[$6 + 302 | 0] & 1))) {
            jsonNewLine(HEAP32[$6 + 308 >> 2], HEAP32[$6 + 320 >> 2], HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2]);
            HEAP8[$6 + 302 | 0] = 0;
           }
           label$29 : {
            if (HEAP32[$6 + 296 >> 2] == HEAP32[$6 + 280 >> 2]) {
             HEAP32[$6 + 268 >> 2] = jsvNewFromInteger(HEAP32[$6 + 280 >> 2]);
             jsfGetJSONWithCallback(HEAP32[$6 + 276 >> 2], HEAP32[$6 + 268 >> 2], HEAP32[$6 + 308 >> 2], HEAP32[$6 + 320 >> 2], HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2]);
             jsvUnLock(HEAP32[$6 + 268 >> 2]);
             break label$29;
            }
            cbprintf(HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2], HEAP32[$6 + 324 >> 2] & 64 ? 122753 : 122735, 0);
           }
           HEAP8[$6 + 302 | 0] = HEAP8[$6 + 275 | 0] & 1;
          }
          continue;
         }
         break;
        }
        $0 = $6 + 288 | 0;
        jsvUnLock(HEAP32[$6 + 276 >> 2]);
        jsvObjectIteratorNext($0);
        break label$13;
       }
       HEAP8[$6 + 295 | 0] = 0;
      }
      jsvUnLock(HEAP32[$6 + 284 >> 2]);
      continue;
     }
     break;
    }
    if (HEAP32[$6 + 324 >> 2] & 4) {
     jsfGetJSONForObjectItWithCallback($6 + 288 | 0, HEAP32[$6 + 324 >> 2], HEAP32[$6 + 320 >> 2], HEAP32[$6 + 308 >> 2], HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2], HEAP8[$6 + 294 | 0] & 1);
    }
    jsvObjectIteratorFree($6 + 288 | 0);
    if (HEAP8[$6 + 302 | 0] & 1) {
     jsonNewLine(HEAP32[$6 + 324 >> 2], HEAP32[$6 + 320 >> 2], HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2]);
    }
    cbprintf(HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2], HEAP32[$6 + 324 >> 2] & 4 ? 122758 : 122761, 0);
    break label$6;
   }
   label$33 : {
    if (jsvIsArrayBuffer(HEAP32[$6 + 332 >> 2]) & 1) {
     HEAP8[$6 + 207 | 0] = 1;
     jsvArrayBufferIteratorNew($6 + 208 | 0, HEAP32[$6 + 332 >> 2], 0);
     while (1) {
      if (jsvArrayBufferIteratorHasElement($6 + 208 | 0) & 1) {
       if (jsvArrayBufferIteratorGetFloatValue($6 + 208 | 0) != 0) {
        HEAP8[$6 + 207 | 0] = 0;
       }
       jsvArrayBufferIteratorNext($6 + 208 | 0);
       continue;
      }
      break;
     }
     jsvArrayBufferIteratorFree($6 + 208 | 0);
     HEAP8[$6 + 206 | 0] = (HEAP32[$6 + 324 >> 2] & 128) != 0;
     label$38 : {
      if (!(!(HEAP8[$6 + 207 | 0] & 1) | HEAP8[$6 + 206 | 0] & 1)) {
       $0 = HEAP32[$6 + 316 >> 2];
       $1 = HEAP32[$6 + 312 >> 2];
       $2 = jswGetBasicObjectName(HEAP32[$6 + 332 >> 2]);
       HEAP32[$6 + 20 >> 2] = jsvGetArrayBufferLength(HEAP32[$6 + 332 >> 2]);
       HEAP32[$6 + 16 >> 2] = $2;
       cbprintf($0, $1, 122763, $6 + 16 | 0);
       break label$38;
      }
      HEAP32[$6 + 200 >> 2] = jswGetBasicObjectName(HEAP32[$6 + 332 >> 2]);
      HEAP8[$6 + 199 | 0] = !strcmp(HEAP32[$6 + 200 >> 2], 122774);
      if (HEAP8[$6 + 199 | 0] & 1) {
       HEAP32[$6 + 200 >> 2] = 122786;
      }
      $0 = HEAP32[$6 + 316 >> 2];
      $1 = HEAP32[$6 + 312 >> 2];
      $2 = HEAP8[$6 + 206 | 0] & 1 ? 122748 : 122797;
      HEAP32[$6 >> 2] = HEAP32[$6 + 200 >> 2];
      cbprintf($0, $1, $2, $6);
      if (HEAP32[$6 + 324 >> 2] & 2) {
       jsonNewLine(HEAP32[$6 + 308 >> 2], HEAP32[$6 + 320 >> 2], HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2]);
      }
      HEAP32[$6 + 192 >> 2] = jsvGetArrayBufferLength(HEAP32[$6 + 332 >> 2]);
      HEAP8[$6 + 191 | 0] = HEAP32[$6 + 324 >> 2] & 8 ? HEAPU32[$6 + 192 >> 2] > 15 : 0;
      jsvArrayBufferIteratorNew($6 + 208 | 0, HEAP32[$6 + 332 >> 2], 0);
      while (1) {
       if (jsvArrayBufferIteratorHasElement($6 + 208 | 0) & 1) {
        $0 = jspIsInterrupted() ^ -1;
       } else {
        $0 = 0;
       }
       if ($0 & 1) {
        if (!(HEAPU32[$6 + 256 >> 2] < HEAP32[$6 + 192 >> 2] - 5 >>> 0 ? !(!(HEAP8[$6 + 191 | 0] & 1) | HEAPU32[$6 + 256 >> 2] < 5) : 0)) {
         if (HEAPU32[$6 + 256 >> 2] > 0) {
          cbprintf(HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2], HEAP32[$6 + 324 >> 2] & 4 ? 122750 : 122671, 0);
         }
         if (HEAP32[$6 + 324 >> 2] & 2) {
          jsonNewLine(HEAP32[$6 + 308 >> 2], HEAP32[$6 + 320 >> 2], HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2]);
         }
         if (!(!(HEAP8[$6 + 191 | 0] & 1) | HEAP32[$6 + 256 >> 2] != (HEAP32[$6 + 192 >> 2] - 5 | 0))) {
          cbprintf(HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2], HEAP32[35430], 0);
         }
         HEAP32[$6 + 184 >> 2] = jsvArrayBufferIteratorGetValue($6 + 208 | 0);
         jsfGetJSONWithCallback(HEAP32[$6 + 184 >> 2], 0, HEAP32[$6 + 308 >> 2], HEAP32[$6 + 320 >> 2], HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2]);
         jsvUnLock(HEAP32[$6 + 184 >> 2]);
        }
        jsvArrayBufferIteratorNext($6 + 208 | 0);
        continue;
       }
       break;
      }
      if (HEAP32[$6 + 324 >> 2] & 2) {
       jsonNewLine(HEAP32[$6 + 324 >> 2], HEAP32[$6 + 320 >> 2], HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2]);
      }
      jsvArrayBufferIteratorFree($6 + 208 | 0);
      cbprintf(HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2], HEAP8[$6 + 206 | 0] & 1 ? 122761 : 122806, 0);
      if (!(!(HEAP8[$6 + 199 | 0] & 1) | HEAP8[$6 + 206 | 0] & 1)) {
       cbprintf(HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2], 122809, 0);
      }
     }
     break label$33;
    }
    label$55 : {
     if (jsvIsObject(HEAP32[$6 + 332 >> 2]) & 1) {
      $0 = $6;
      label$57 : {
       if (HEAP32[$6 + 324 >> 2] & 32) {
        $1 = jsiGetDeviceFromClass(HEAP32[$6 + 332 >> 2]) & 255;
        break label$57;
       }
       $1 = 0;
      }
      HEAP8[$0 + 183 | 0] = $1;
      label$59 : {
       if (HEAPU8[$6 + 183 | 0]) {
        $0 = HEAP32[$6 + 316 >> 2];
        $1 = HEAP32[$6 + 312 >> 2];
        HEAP32[$6 + 32 >> 2] = jshGetDeviceString(HEAPU8[$6 + 183 | 0]);
        cbprintf($0, $1, 122817, $6 + 32 | 0);
        break label$59;
       }
       HEAP8[$6 + 182 | 0] = 1;
       if (HEAP32[$6 + 324 >> 2] & 256) {
        HEAP32[$6 + 176 >> 2] = jsvObjectGetChild(HEAP32[$6 + 332 >> 2], 122820, 0);
        if (jsvHasChildren(HEAP32[$6 + 176 >> 2]) & 1) {
         HEAP32[$6 + 172 >> 2] = jsvObjectGetChild(HEAP32[$6 + 176 >> 2], 122830, 0);
         if (HEAP32[$6 + 172 >> 2]) {
          HEAP32[$6 + 168 >> 2] = jsvGetIndexOf(HEAP32[80545], HEAP32[$6 + 172 >> 2], 1);
          if (HEAP32[$6 + 168 >> 2]) {
           $0 = HEAP32[$6 + 316 >> 2];
           $1 = HEAP32[$6 + 312 >> 2];
           HEAP32[$6 + 64 >> 2] = HEAP32[$6 + 168 >> 2];
           cbprintf($0, $1, 122842, $6 - -64 | 0);
          }
          jsvUnLock2(HEAP32[$6 + 168 >> 2], HEAP32[$6 + 172 >> 2]);
          HEAP32[$6 + 164 >> 2] = jspGetNamedField(HEAP32[$6 + 332 >> 2], 122847, 0);
          label$65 : {
           if (!(jsvIsFunction(HEAP32[$6 + 164 >> 2]) & 1)) {
            break label$65;
           }
           $0 = HEAP32[$6 + 164 >> 2];
           if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 1) {
            break label$65;
           }
           HEAP32[$6 + 160 >> 2] = jspExecuteFunction(HEAP32[$6 + 164 >> 2], HEAP32[$6 + 332 >> 2], 0, 0);
           $0 = HEAP32[$6 + 316 >> 2];
           $1 = HEAP32[$6 + 312 >> 2];
           HEAP32[$6 + 48 >> 2] = HEAP32[$6 + 160 >> 2];
           cbprintf($0, $1, 122673, $6 + 48 | 0);
           jsvUnLock(HEAP32[$6 + 160 >> 2]);
           HEAP8[$6 + 182 | 0] = 0;
          }
          jsvUnLock(HEAP32[$6 + 164 >> 2]);
         }
        }
        jsvUnLock(HEAP32[$6 + 176 >> 2]);
       }
       if (HEAP8[$6 + 182 | 0] & 1) {
        HEAP32[$6 + 156 >> 2] = 0;
        if (HEAP32[$6 + 324 >> 2] & 2048) {
         HEAP32[$6 + 156 >> 2] = jspGetNamedField(HEAP32[$6 + 332 >> 2], 122856, 0);
        }
        label$68 : {
         if (jsvIsFunction(HEAP32[$6 + 156 >> 2]) & 1) {
          $0 = $6;
          label$70 : {
           if (HEAP32[$6 + 328 >> 2]) {
            $1 = jsvAsString(HEAP32[$6 + 328 >> 2]);
            break label$70;
           }
           $1 = 0;
          }
          HEAP32[$0 + 152 >> 2] = $1;
          HEAP32[$6 + 148 >> 2] = jspExecuteFunction(HEAP32[$6 + 156 >> 2], HEAP32[$6 + 332 >> 2], 1, $6 + 152 | 0);
          jsvUnLock(HEAP32[$6 + 152 >> 2]);
          if (HEAP32[$6 + 148 >> 2] == HEAP32[$6 + 332 >> 2]) {
           $0 = HEAP32[$6 + 332 >> 2];
           $1 = (HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & -257;
           HEAP8[$0 + 13 | 0] = $1;
           HEAP8[$0 + 14 | 0] = $1 >>> 8;
          }
          jsfGetJSONWithCallback(HEAP32[$6 + 148 >> 2], 0, HEAP32[$6 + 324 >> 2] & -2049, HEAP32[$6 + 320 >> 2], HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2]);
          jsvUnLock(HEAP32[$6 + 148 >> 2]);
          break label$68;
         }
         jsvObjectIteratorNew($6 + 144 | 0, HEAP32[$6 + 332 >> 2]);
         cbprintf(HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2], HEAP32[$6 + 324 >> 2] & 4 ? 122863 : 122712, 0);
         $0 = $6 + 144 | 0;
         HEAP8[$6 + 143 | 0] = jsfGetJSONForObjectItWithCallback($0, HEAP32[$6 + 324 >> 2], HEAP32[$6 + 320 >> 2], HEAP32[$6 + 308 >> 2], HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2], 1) & 1;
         jsvObjectIteratorFree($0);
         if (HEAP8[$6 + 143 | 0] & 1) {
          jsonNewLine(HEAP32[$6 + 324 >> 2], HEAP32[$6 + 320 >> 2], HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2]);
         }
         cbprintf(HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2], HEAP32[$6 + 324 >> 2] & 4 ? 122866 : 122725, 0);
        }
        jsvUnLock(HEAP32[$6 + 156 >> 2]);
       }
      }
      break label$55;
     }
     label$74 : {
      if (jsvIsFunction(HEAP32[$6 + 332 >> 2]) & 1) {
       if (HEAP32[$6 + 324 >> 2] & 16) {
        cbprintf(HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2], 122735, 0);
        break label$74;
       }
       cbprintf(HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2], 122869, 0);
       jsfGetJSONForFunctionWithCallback(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 308 >> 2], HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2]);
       break label$74;
      }
      label$77 : {
       label$78 : {
        if (!(jsvIsString(HEAP32[$6 + 332 >> 2]) & 1)) {
         break label$78;
        }
        if (jsvIsName(HEAP32[$6 + 332 >> 2]) & 1) {
         break label$78;
        }
        label$79 : {
         label$80 : {
          if (!(HEAP32[$6 + 324 >> 2] & 8)) {
           break label$80;
          }
          if (jsvGetStringLength(HEAP32[$6 + 332 >> 2]) >>> 0 <= 40) {
           break label$80;
          }
          HEAP32[$6 + 136 >> 2] = jsvNewFromStringVar(HEAP32[$6 + 332 >> 2], 0, 17);
          HEAP32[$6 + 132 >> 2] = jsvNewFromStringVar(HEAP32[$6 + 332 >> 2], jsvGetStringLength(HEAP32[$6 + 332 >> 2]) - 17 | 0, 17);
          $0 = HEAP32[$6 + 316 >> 2];
          $1 = HEAP32[$6 + 312 >> 2];
          $2 = HEAP32[$6 + 136 >> 2];
          $3 = HEAP32[35430];
          HEAP32[$6 + 120 >> 2] = HEAP32[$6 + 132 >> 2];
          HEAP32[$6 + 116 >> 2] = $3;
          HEAP32[$6 + 112 >> 2] = $2;
          cbprintf($0, $1, 122879, $6 + 112 | 0);
          jsvUnLock2(HEAP32[$6 + 136 >> 2], HEAP32[$6 + 132 >> 2]);
          break label$79;
         }
         $0 = HEAP32[$6 + 316 >> 2];
         $1 = HEAP32[$6 + 312 >> 2];
         $2 = HEAP32[$6 + 324 >> 2] & 1024 ? 122886 : 122889;
         HEAP32[$6 + 128 >> 2] = HEAP32[$6 + 332 >> 2];
         cbprintf($0, $1, $2, $6 + 128 | 0);
        }
        break label$77;
       }
       label$81 : {
        label$82 : {
         if (!(HEAP32[$6 + 324 >> 2] & 1024)) {
          break label$82;
         }
         if (!(jsvIsFloat(HEAP32[$6 + 332 >> 2]) & 1)) {
          break label$82;
         }
         $0 = __DOUBLE_BITS(jsvGetFloat(HEAP32[$6 + 332 >> 2]));
         $1 = i64toi32_i32$HIGH_BITS & 2147483647;
         if (($1 | 0) == 2146435072 & $0 >>> 0 < 0 | $1 >>> 0 < 2146435072) {
          break label$82;
         }
         cbprintf(HEAP32[$6 + 316 >> 2], HEAP32[$6 + 312 >> 2], 122753, 0);
         break label$81;
        }
        $0 = HEAP32[$6 + 316 >> 2];
        $1 = HEAP32[$6 + 312 >> 2];
        HEAP32[$6 + 80 >> 2] = HEAP32[$6 + 332 >> 2];
        cbprintf($0, $1, 122673, $6 + 80 | 0);
       }
      }
     }
    }
   }
  }
  $0 = HEAP32[$6 + 332 >> 2];
  $1 = (HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & -257;
  HEAP8[$0 + 13 | 0] = $1;
  HEAP8[$0 + 14 | 0] = $1 >>> 8;
 }
 global$0 = $6 + 336 | 0;
}
function jslGetNextToken() {
 var $0 = 0, $1 = 0, $2 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 jslSkipWhiteSpace();
 HEAP32[$0 + 12 >> 2] = HEAP16[HEAP32[35539] + 2 >> 1];
 HEAP16[HEAP32[35539] + 2 >> 1] = 0;
 HEAP8[HEAP32[35539] + 80 | 0] = 0;
 if (HEAP32[HEAP32[35539] + 76 >> 2]) {
  jsvUnLock(HEAP32[HEAP32[35539] + 76 >> 2]);
  HEAP32[HEAP32[35539] + 76 >> 2] = 0;
 }
 HEAP32[HEAP32[35539] + 8 >> 2] = HEAP32[HEAP32[35539] + 4 >> 2];
 $1 = jsvStringIteratorGetIndex(HEAP32[35539] + 88 | 0);
 HEAP32[HEAP32[35539] + 4 >> 2] = $1 - 1;
 label$2 : {
  if (!(HEAPU8[HEAP32[35539]] <= 124 ? HEAPU8[HEAP32[35539]] >= 33 : 0)) {
   jslSingleChar();
   break label$2;
  }
  $1 = HEAPU8[HEAPU8[HEAP32[35539]] + 77103 | 0];
  label$5 : {
   if ($1 >>> 0 > 15) {
    break label$5;
   }
   label$6 : {
    switch ($1 - 1 | 0) {
    default:
     while (1) {
      $1 = isAlpha(HEAP8[HEAP32[35539]]) & 1;
      $2 = 1;
      label$23 : {
       if ($1) {
        break label$23;
       }
       $1 = isNumeric(HEAP8[HEAP32[35539]]) & 1;
       $2 = 1;
       if ($1) {
        break label$23;
       }
       $2 = HEAP8[HEAP32[35539]] == 36;
      }
      if ($2) {
       jslTokenAppendChar(HEAP8[HEAP32[35539]]);
       jslGetNextCh();
       continue;
      }
      break;
     }
     HEAP16[HEAP32[35539] + 2 >> 1] = 128;
     $1 = HEAP8[HEAP32[35539] + 12 | 0] + -98 | 0;
     label$25 : {
      if ($1 >>> 0 > 21) {
       break label$25;
      }
      label$26 : {
       switch ($1 - 1 | 0) {
       default:
        if (jslIsToken(77228) & 1) {
         HEAP16[HEAP32[35539] + 2 >> 1] = 168;
        }
        break label$25;
       case 0:
        label$42 : {
         if (jslIsToken(77234) & 1) {
          HEAP16[HEAP32[35539] + 2 >> 1] = 188;
          break label$42;
         }
         label$44 : {
          if (jslIsToken(77239) & 1) {
           HEAP16[HEAP32[35539] + 2 >> 1] = 178;
           break label$44;
          }
          label$46 : {
           if (jslIsToken(77245) & 1) {
            HEAP16[HEAP32[35539] + 2 >> 1] = 194;
            break label$46;
           }
           label$48 : {
            if (jslIsToken(77251) & 1) {
             HEAP16[HEAP32[35539] + 2 >> 1] = 174;
             break label$48;
            }
            if (jslIsToken(77257) & 1) {
             HEAP16[HEAP32[35539] + 2 >> 1] = 169;
            }
           }
          }
         }
        }
        break label$25;
       case 1:
        label$51 : {
         if (jslIsToken(77266) & 1) {
          HEAP16[HEAP32[35539] + 2 >> 1] = 189;
          break label$51;
         }
         label$53 : {
          if (jslIsToken(77274) & 1) {
           HEAP16[HEAP32[35539] + 2 >> 1] = 190;
           break label$53;
          }
          label$55 : {
           if (jslIsToken(77281) & 1) {
            HEAP16[HEAP32[35539] + 2 >> 1] = 165;
            break label$55;
           }
           if (jslIsToken(77284) & 1) {
            HEAP16[HEAP32[35539] + 2 >> 1] = 193;
           }
          }
         }
        }
        break label$25;
       case 2:
        label$58 : {
         if (jslIsToken(77293) & 1) {
          HEAP16[HEAP32[35539] + 2 >> 1] = 164;
          break label$58;
         }
         if (jslIsToken(77298) & 1) {
          HEAP16[HEAP32[35539] + 2 >> 1] = 195;
         }
        }
        break label$25;
       case 3:
        label$61 : {
         if (jslIsToken(77306) & 1) {
          HEAP16[HEAP32[35539] + 2 >> 1] = 181;
          break label$61;
         }
         label$63 : {
          if (jslIsToken(77312) & 1) {
           HEAP16[HEAP32[35539] + 2 >> 1] = 179;
           break label$63;
          }
          label$65 : {
           if (jslIsToken(77320) & 1) {
            HEAP16[HEAP32[35539] + 2 >> 1] = 167;
            break label$65;
           }
           if (jslIsToken(77324) & 1) {
            HEAP16[HEAP32[35539] + 2 >> 1] = 170;
           }
          }
         }
        }
        break label$25;
       case 6:
        label$68 : {
         if (jslIsToken(77333) & 1) {
          HEAP16[HEAP32[35539] + 2 >> 1] = 163;
          break label$68;
         }
         label$70 : {
          if (jslIsToken(77336) & 1) {
           HEAP16[HEAP32[35539] + 2 >> 1] = 185;
           break label$70;
          }
          if (jslIsToken(77339) & 1) {
           HEAP16[HEAP32[35539] + 2 >> 1] = 186;
          }
         }
        }
        break label$25;
       case 9:
        if (jslIsToken(77350) & 1) {
         HEAP16[HEAP32[35539] + 2 >> 1] = 173;
        }
        break label$25;
       case 11:
        label$74 : {
         if (jslIsToken(77354) & 1) {
          HEAP16[HEAP32[35539] + 2 >> 1] = 184;
          break label$74;
         }
         if (jslIsToken(77358) & 1) {
          HEAP16[HEAP32[35539] + 2 >> 1] = 182;
         }
        }
        break label$25;
       case 12:
        if (jslIsToken(77363) & 1) {
         HEAP16[HEAP32[35539] + 2 >> 1] = 198;
        }
        break label$25;
       case 15:
        if (jslIsToken(77366) & 1) {
         HEAP16[HEAP32[35539] + 2 >> 1] = 171;
        }
        break label$25;
       case 16:
        label$79 : {
         if (jslIsToken(77373) & 1) {
          HEAP16[HEAP32[35539] + 2 >> 1] = 197;
          break label$79;
         }
         label$81 : {
          if (jslIsToken(77380) & 1) {
           HEAP16[HEAP32[35539] + 2 >> 1] = 196;
           break label$81;
          }
          if (jslIsToken(77386) & 1) {
           HEAP16[HEAP32[35539] + 2 >> 1] = 187;
          }
         }
        }
        break label$25;
       case 17:
        label$84 : {
         if (jslIsToken(77393) & 1) {
          HEAP16[HEAP32[35539] + 2 >> 1] = 175;
          break label$84;
         }
         label$86 : {
          if (jslIsToken(77398) & 1) {
           HEAP16[HEAP32[35539] + 2 >> 1] = 176;
           break label$86;
          }
          label$88 : {
           if (jslIsToken(77404) & 1) {
            HEAP16[HEAP32[35539] + 2 >> 1] = 180;
            break label$88;
           }
           label$90 : {
            if (jslIsToken(77409) & 1) {
             HEAP16[HEAP32[35539] + 2 >> 1] = 177;
             break label$90;
            }
            if (jslIsToken(77413) & 1) {
             HEAP16[HEAP32[35539] + 2 >> 1] = 191;
            }
           }
          }
         }
        }
        break label$25;
       case 18:
        if (jslIsToken(77420) & 1) {
         HEAP16[HEAP32[35539] + 2 >> 1] = 183;
        }
        break label$25;
       case 20:
        if (jslIsToken(77430) & 1) {
         HEAP16[HEAP32[35539] + 2 >> 1] = 166;
        }
        break label$25;
       case 4:
       case 5:
       case 7:
       case 8:
       case 10:
       case 13:
       case 14:
        break label$25;
       case 19:
        break label$26;
       }
      }
      label$95 : {
       if (jslIsToken(77436) & 1) {
        HEAP16[HEAP32[35539] + 2 >> 1] = 172;
        break label$95;
       }
       if (jslIsToken(77440) & 1) {
        HEAP16[HEAP32[35539] + 2 >> 1] = 192;
       }
      }
     }
     break label$5;
    case 0:
     HEAP8[$0 + 11 | 0] = 1;
     label$98 : {
      if (HEAP8[HEAP32[35539]] == 46) {
       jslGetNextCh();
       label$100 : {
        if (isNumeric(HEAP8[HEAP32[35539]]) & 1) {
         HEAP16[HEAP32[35539] + 2 >> 1] = 130;
         jslTokenAppendChar(46);
         break label$100;
        }
        HEAP16[HEAP32[35539] + 2 >> 1] = 46;
        break label$5;
       }
       break label$98;
      }
      if (HEAP8[HEAP32[35539]] == 48) {
       jslTokenAppendChar(HEAP8[HEAP32[35539]]);
       jslGetNextCh();
       label$103 : {
        label$104 : {
         if (HEAP8[HEAP32[35539]] == 120 | HEAP8[HEAP32[35539]] == 88 | (HEAP8[HEAP32[35539]] == 98 | HEAP8[HEAP32[35539]] == 66)) {
          break label$104;
         }
         if (HEAP8[HEAP32[35539]] == 111) {
          break label$104;
         }
         if (HEAP8[HEAP32[35539]] != 79) {
          break label$103;
         }
        }
        HEAP8[$0 + 11 | 0] = 0;
        jslTokenAppendChar(HEAP8[HEAP32[35539]]);
        jslGetNextCh();
       }
      }
      HEAP16[HEAP32[35539] + 2 >> 1] = 129;
      while (1) {
       if (isNumeric(HEAP8[HEAP32[35539]]) & 1) {
        $1 = 1;
       } else {
        if (HEAP8[$0 + 11 | 0] & 1) {
         $1 = 0;
        } else {
         $1 = isHexadecimal(HEAP8[HEAP32[35539]]);
        }
       }
       if ($1 & 1) {
        jslTokenAppendChar(HEAP8[HEAP32[35539]]);
        jslGetNextCh();
        continue;
       }
       break;
      }
      if (!(!(HEAP8[$0 + 11 | 0] & 1) | HEAP8[HEAP32[35539]] != 46)) {
       HEAP16[HEAP32[35539] + 2 >> 1] = 130;
       jslTokenAppendChar(46);
       jslGetNextCh();
      }
     }
     if (HEAP16[HEAP32[35539] + 2 >> 1] == 130) {
      while (1) {
       if (isNumeric(HEAP8[HEAP32[35539]]) & 1) {
        jslTokenAppendChar(HEAP8[HEAP32[35539]]);
        jslGetNextCh();
        continue;
       }
       break;
      }
     }
     if (!(!(HEAP8[$0 + 11 | 0] & 1) | (HEAP8[HEAP32[35539]] != 69 ? HEAP8[HEAP32[35539]] != 101 : 0))) {
      HEAP16[HEAP32[35539] + 2 >> 1] = 130;
      jslTokenAppendChar(HEAP8[HEAP32[35539]]);
      jslGetNextCh();
      if (!(HEAP8[HEAP32[35539]] != 43 ? HEAP8[HEAP32[35539]] != 45 : 0)) {
       jslTokenAppendChar(HEAP8[HEAP32[35539]]);
       jslGetNextCh();
      }
      while (1) {
       if (isNumeric(HEAP8[HEAP32[35539]]) & 1) {
        jslTokenAppendChar(HEAP8[HEAP32[35539]]);
        jslGetNextCh();
        continue;
       }
       break;
      }
     }
     break label$5;
    case 1:
     jslLexString();
     break label$5;
    case 3:
     jslSingleChar();
     if (HEAP8[HEAP32[35539]] == 61) {
      HEAP16[HEAP32[35539] + 2 >> 1] = 140;
      jslGetNextCh();
      if (HEAP8[HEAP32[35539]] == 61) {
       HEAP16[HEAP32[35539] + 2 >> 1] = 141;
       jslGetNextCh();
      }
     }
     break label$5;
    case 4:
     jslSingleChar();
     label$123 : {
      if (HEAP8[HEAP32[35539]] == 61) {
       HEAP16[HEAP32[35539] + 2 >> 1] = 150;
       jslGetNextCh();
       break label$123;
      }
      if (HEAP8[HEAP32[35539]] == 43) {
       HEAP16[HEAP32[35539] + 2 >> 1] = 152;
       jslGetNextCh();
      }
     }
     break label$5;
    case 5:
     jslSingleChar();
     label$126 : {
      if (HEAP8[HEAP32[35539]] == 61) {
       HEAP16[HEAP32[35539] + 2 >> 1] = 151;
       jslGetNextCh();
       break label$126;
      }
      if (HEAP8[HEAP32[35539]] == 45) {
       HEAP16[HEAP32[35539] + 2 >> 1] = 153;
       jslGetNextCh();
      }
     }
     break label$5;
    case 6:
     jslSingleChar();
     label$129 : {
      if (HEAP8[HEAP32[35539]] == 61) {
       HEAP16[HEAP32[35539] + 2 >> 1] = 157;
       jslGetNextCh();
       break label$129;
      }
      if (HEAP8[HEAP32[35539]] == 38) {
       HEAP16[HEAP32[35539] + 2 >> 1] = 158;
       jslGetNextCh();
      }
     }
     break label$5;
    case 7:
     jslSingleChar();
     label$132 : {
      if (HEAP8[HEAP32[35539]] == 61) {
       HEAP16[HEAP32[35539] + 2 >> 1] = 159;
       jslGetNextCh();
       break label$132;
      }
      if (HEAP8[HEAP32[35539]] == 124) {
       HEAP16[HEAP32[35539] + 2 >> 1] = 160;
       jslGetNextCh();
      }
     }
     break label$5;
    case 10:
     jslSingleChar();
     if (HEAP8[HEAP32[35539]] == 61) {
      HEAP16[HEAP32[35539] + 2 >> 1] = 161;
      jslGetNextCh();
     }
     break label$5;
    case 9:
     jslSingleChar();
     if (HEAP8[HEAP32[35539]] == 61) {
      HEAP16[HEAP32[35539] + 2 >> 1] = 154;
      jslGetNextCh();
     }
     break label$5;
    case 11:
     label$137 : {
      label$138 : {
       label$139 : {
        if (!HEAP32[$0 + 12 >> 2] | HEAP32[$0 + 12 >> 2] == 33 | (HEAP32[$0 + 12 >> 2] == 37 | HEAP32[$0 + 12 >> 2] == 38)) {
         break label$139;
        }
        if (HEAP32[$0 + 12 >> 2] == 42 | HEAP32[$0 + 12 >> 2] == 43 | (HEAP32[$0 + 12 >> 2] == 45 | HEAP32[$0 + 12 >> 2] == 47)) {
         break label$139;
        }
        if (HEAP32[$0 + 12 >> 2] == 60 | HEAP32[$0 + 12 >> 2] == 61 | (HEAP32[$0 + 12 >> 2] == 62 | HEAP32[$0 + 12 >> 2] == 63)) {
         break label$139;
        }
        if ((HEAP32[$0 + 12 >> 2] <= 161 ? HEAP32[$0 + 12 >> 2] >= 138 : 0) | (HEAP32[$0 + 12 >> 2] <= 198 ? HEAP32[$0 + 12 >> 2] >= 163 : 0) | (HEAP32[$0 + 12 >> 2] == 188 | HEAP32[$0 + 12 >> 2] == 184)) {
         break label$139;
        }
        if (HEAP32[$0 + 12 >> 2] == 91 | HEAP32[$0 + 12 >> 2] == 123 | (HEAP32[$0 + 12 >> 2] == 125 | HEAP32[$0 + 12 >> 2] == 40)) {
         break label$139;
        }
        if (HEAP32[$0 + 12 >> 2] == 44 | HEAP32[$0 + 12 >> 2] == 59 | HEAP32[$0 + 12 >> 2] == 58) {
         break label$139;
        }
        if (HEAP32[$0 + 12 >> 2] != 162) {
         break label$138;
        }
       }
       jslLexRegex();
       break label$137;
      }
      jslSingleChar();
      if (HEAP8[HEAP32[35539]] == 61) {
       HEAP16[HEAP32[35539] + 2 >> 1] = 155;
       jslGetNextCh();
      }
     }
     break label$5;
    case 8:
     jslSingleChar();
     if (HEAP8[HEAP32[35539]] == 61) {
      HEAP16[HEAP32[35539] + 2 >> 1] = 156;
      jslGetNextCh();
     }
     break label$5;
    case 13:
     jslSingleChar();
     label$144 : {
      if (HEAP8[HEAP32[35539]] == 61) {
       HEAP16[HEAP32[35539] + 2 >> 1] = 138;
       jslGetNextCh();
       if (HEAP8[HEAP32[35539]] == 61) {
        HEAP16[HEAP32[35539] + 2 >> 1] = 139;
        jslGetNextCh();
       }
       break label$144;
      }
      if (HEAP8[HEAP32[35539]] == 62) {
       HEAP16[HEAP32[35539] + 2 >> 1] = 162;
       jslGetNextCh();
      }
     }
     break label$5;
    case 12:
     jslSingleChar();
     label$148 : {
      if (HEAP8[HEAP32[35539]] == 61) {
       HEAP16[HEAP32[35539] + 2 >> 1] = 142;
       jslGetNextCh();
       break label$148;
      }
      if (HEAP8[HEAP32[35539]] == 60) {
       HEAP16[HEAP32[35539] + 2 >> 1] = 143;
       jslGetNextCh();
       if (HEAP8[HEAP32[35539]] == 61) {
        HEAP16[HEAP32[35539] + 2 >> 1] = 144;
        jslGetNextCh();
       }
      }
     }
     break label$5;
    case 14:
     jslSingleChar();
     label$152 : {
      if (HEAP8[HEAP32[35539]] == 61) {
       HEAP16[HEAP32[35539] + 2 >> 1] = 145;
       jslGetNextCh();
       break label$152;
      }
      if (HEAP8[HEAP32[35539]] == 62) {
       HEAP16[HEAP32[35539] + 2 >> 1] = 146;
       jslGetNextCh();
       label$155 : {
        if (HEAP8[HEAP32[35539]] == 61) {
         HEAP16[HEAP32[35539] + 2 >> 1] = 148;
         jslGetNextCh();
         break label$155;
        }
        if (HEAP8[HEAP32[35539]] == 62) {
         jslGetNextCh();
         label$158 : {
          if (HEAP8[HEAP32[35539]] == 61) {
           HEAP16[HEAP32[35539] + 2 >> 1] = 149;
           jslGetNextCh();
           break label$158;
          }
          HEAP16[HEAP32[35539] + 2 >> 1] = 147;
         }
        }
       }
      }
     }
     break label$5;
    case 2:
     break label$6;
    }
   }
   jslSingleChar();
  }
 }
 global$0 = $0 + 16 | 0;
}
function jswrap_graphics_drawString($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0;
 $5 = global$0 - 416 | 0;
 global$0 = $5;
 HEAP32[$5 + 408 >> 2] = $0;
 HEAP32[$5 + 404 >> 2] = $1;
 HEAP32[$5 + 400 >> 2] = $2;
 HEAP32[$5 + 396 >> 2] = $3;
 HEAP8[$5 + 395 | 0] = $4;
 label$1 : {
  if (!(graphicsGetFromVar($5 + 320 | 0, HEAP32[$5 + 408 >> 2]) & 1)) {
   HEAP32[$5 + 412 >> 2] = 0;
   break label$1;
  }
  $0 = $5 + 320 | 0;
  $1 = $5 + 304 | 0;
  _jswrap_graphics_getFontInfo($0, $1);
  HEAP32[$5 + 300 >> 2] = _jswrap_graphics_getFontHeightInternal($0, $1);
  HEAP32[$5 + 296 >> 2] = 0;
  HEAP32[$5 + 292 >> 2] = 0;
  HEAP32[$5 + 288 >> 2] = 1;
  if (HEAP32[$5 + 304 >> 2] & 32768) {
   if (HEAP32[$5 + 304 >> 2] == 40960) {
    HEAP32[$5 + 288 >> 2] = 2;
   }
   if (HEAP32[$5 + 304 >> 2] == 49152) {
    HEAP32[$5 + 288 >> 2] = 4;
   }
   HEAP32[$5 + 296 >> 2] = jsvObjectGetChild(HEAP32[$5 + 408 >> 2], 127547, 0);
   HEAP32[$5 + 292 >> 2] = jsvObjectGetChild(HEAP32[$5 + 408 >> 2], 127552, 0);
  }
  HEAP32[$5 + 284 >> 2] = HEAPU8[$5 + 328 | 0] | HEAPU8[$5 + 329 | 0] << 8 | (HEAPU8[$5 + 330 | 0] << 16 | HEAPU8[$5 + 331 | 0] << 24);
  label$6 : {
   if ((HEAPU8[$5 + 351 | 0] >>> 4 & 3) == 1) {
    $0 = (HEAPU8[$5 + 328 | 0] | HEAPU8[$5 + 329 | 0] << 8 | (HEAPU8[$5 + 330 | 0] << 16 | HEAPU8[$5 + 331 | 0] << 24)) ^ 48;
    HEAP8[$5 + 328 | 0] = $0;
    HEAP8[$5 + 329 | 0] = $0 >>> 8;
    HEAP8[$5 + 330 | 0] = $0 >>> 16;
    HEAP8[$5 + 331 | 0] = $0 >>> 24;
    HEAP32[$5 + 280 >> 2] = (HEAPU8[$5 + 332 | 0] | HEAPU8[$5 + 333 | 0] << 8) - (HEAP32[$5 + 400 >> 2] + 1 | 0);
    HEAP32[$5 + 400 >> 2] = HEAP32[$5 + 396 >> 2];
    HEAP32[$5 + 396 >> 2] = HEAP32[$5 + 280 >> 2];
    break label$6;
   }
   label$8 : {
    if ((HEAPU8[$5 + 351 | 0] >>> 4 & 3) == 2) {
     $0 = (HEAPU8[$5 + 328 | 0] | HEAPU8[$5 + 329 | 0] << 8 | (HEAPU8[$5 + 330 | 0] << 16 | HEAPU8[$5 + 331 | 0] << 24)) ^ 96;
     HEAP8[$5 + 328 | 0] = $0;
     HEAP8[$5 + 329 | 0] = $0 >>> 8;
     HEAP8[$5 + 330 | 0] = $0 >>> 16;
     HEAP8[$5 + 331 | 0] = $0 >>> 24;
     HEAP32[$5 + 400 >> 2] = (HEAPU8[$5 + 332 | 0] | HEAPU8[$5 + 333 | 0] << 8) - (HEAP32[$5 + 400 >> 2] + 1 | 0);
     HEAP32[$5 + 396 >> 2] = (HEAPU8[$5 + 334 | 0] | HEAPU8[$5 + 335 | 0] << 8) - (HEAP32[$5 + 396 >> 2] + 1 | 0);
     break label$8;
    }
    if ((HEAPU8[$5 + 351 | 0] >>> 4 & 3) == 3) {
     $0 = (HEAPU8[$5 + 328 | 0] | HEAPU8[$5 + 329 | 0] << 8 | (HEAPU8[$5 + 330 | 0] << 16 | HEAPU8[$5 + 331 | 0] << 24)) ^ 80;
     HEAP8[$5 + 328 | 0] = $0;
     HEAP8[$5 + 329 | 0] = $0 >>> 8;
     HEAP8[$5 + 330 | 0] = $0 >>> 16;
     HEAP8[$5 + 331 | 0] = $0 >>> 24;
     HEAP32[$5 + 276 >> 2] = (HEAPU8[$5 + 334 | 0] | HEAPU8[$5 + 335 | 0] << 8) - (HEAP32[$5 + 396 >> 2] + 1 | 0);
     HEAP32[$5 + 396 >> 2] = HEAP32[$5 + 400 >> 2];
     HEAP32[$5 + 400 >> 2] = HEAP32[$5 + 276 >> 2];
    }
   }
  }
  HEAP32[$5 + 272 >> 2] = jsvAsString(HEAP32[$5 + 404 >> 2]);
  HEAP32[$5 + 268 >> 2] = HEAP32[$5 + 400 >> 2];
  if ((HEAPU8[$5 + 351 | 0] & 3) < 2) {
   HEAP32[$5 + 400 >> 2] = HEAP32[$5 + 268 >> 2] - ((Math_imul(_jswrap_graphics_stringWidth($5 + 320 | 0, HEAP32[$5 + 272 >> 2], 0), (HEAPU8[$5 + 351 | 0] & 3) + 1 | 0) | 0) / 2 | 0);
  }
  if ((HEAPU8[$5 + 351 | 0] >>> 2 & 3) < 2) {
   HEAP32[$5 + 264 >> 2] = 0;
   HEAP32[$5 + 260 >> 2] = 0;
   _jswrap_graphics_stringMetrics($5 + 320 | 0, HEAP32[$5 + 272 >> 2], -1, $5 + 264 | 0, $5 + 260 | 0);
   HEAP32[$5 + 396 >> 2] = HEAP32[$5 + 396 >> 2] - ((Math_imul(HEAP32[$5 + 260 >> 2], (HEAPU8[$5 + 351 | 0] >>> 2 & 3) + 1 | 0) | 0) / 2 | 0);
  }
  $0 = $5;
  if ((HEAPU8[$5 + 328 | 0] | HEAPU8[$5 + 329 | 0] << 8 | (HEAPU8[$5 + 330 | 0] << 16 | HEAPU8[$5 + 331 | 0] << 24)) & 16) {
   $1 = HEAPU8[$5 + 354 | 0] | HEAPU8[$5 + 355 | 0] << 8;
  } else {
   $1 = HEAPU8[$5 + 352 | 0] | HEAPU8[$5 + 353 | 0] << 8;
  }
  HEAP32[$0 + 256 >> 2] = $1;
  $0 = $5;
  if ((HEAPU8[$5 + 328 | 0] | HEAPU8[$5 + 329 | 0] << 8 | (HEAPU8[$5 + 330 | 0] << 16 | HEAPU8[$5 + 331 | 0] << 24)) & 16) {
   $1 = HEAPU8[$5 + 352 | 0] | HEAPU8[$5 + 353 | 0] << 8;
  } else {
   $1 = HEAPU8[$5 + 354 | 0] | HEAPU8[$5 + 355 | 0] << 8;
  }
  HEAP32[$0 + 252 >> 2] = $1;
  $0 = $5;
  if ((HEAPU8[$5 + 328 | 0] | HEAPU8[$5 + 329 | 0] << 8 | (HEAPU8[$5 + 330 | 0] << 16 | HEAPU8[$5 + 331 | 0] << 24)) & 16) {
   $1 = HEAPU8[$5 + 358 | 0] | HEAPU8[$5 + 359 | 0] << 8;
  } else {
   $1 = HEAPU8[$5 + 356 | 0] | HEAPU8[$5 + 357 | 0] << 8;
  }
  HEAP32[$0 + 248 >> 2] = $1;
  $0 = $5;
  if ((HEAPU8[$5 + 328 | 0] | HEAPU8[$5 + 329 | 0] << 8 | (HEAPU8[$5 + 330 | 0] << 16 | HEAPU8[$5 + 331 | 0] << 24)) & 16) {
   $1 = HEAPU8[$5 + 356 | 0] | HEAPU8[$5 + 357 | 0] << 8;
  } else {
   $1 = HEAPU8[$5 + 358 | 0] | HEAPU8[$5 + 359 | 0] << 8;
  }
  HEAP32[$0 + 244 >> 2] = $1;
  jsvStringIteratorNew($5 + 208 | 0, HEAP32[$5 + 272 >> 2], 0);
  while (1) {
   if (jsvStringIteratorHasChar($5 + 208 | 0) & 1) {
    HEAP8[$5 + 207 | 0] = jsvStringIteratorGetCharAndNext($5 + 208 | 0);
    if (HEAP8[$5 + 207 | 0] == 10) {
     HEAP32[$5 + 400 >> 2] = HEAP32[$5 + 268 >> 2];
     if ((HEAPU8[$5 + 351 | 0] & 3) < 2) {
      HEAP32[$5 + 400 >> 2] = HEAP32[$5 + 268 >> 2] - ((Math_imul(_jswrap_graphics_stringWidth($5 + 320 | 0, HEAP32[$5 + 272 >> 2], jsvStringIteratorGetIndex($5 + 208 | 0)), (HEAPU8[$5 + 351 | 0] & 3) + 1 | 0) | 0) / 2 | 0);
     }
     HEAP32[$5 + 396 >> 2] = HEAP32[$5 + 300 >> 2] + HEAP32[$5 + 396 >> 2];
     continue;
    }
    if (!HEAP8[$5 + 207 | 0]) {
     $0 = $5 + 320 | 0;
     $1 = $5 + 120 | 0;
     HEAP32[$5 + 116 >> 2] = jsvStringIteratorGetIndex($5 + 208 | 0);
     if (_jswrap_graphics_parseImage($0, HEAP32[$5 + 272 >> 2], HEAP32[$5 + 116 >> 2], $1) & 1) {
      $0 = $5 + 120 | 0;
      $1 = $5 + 320 | 0;
      $2 = $5 + 208 | 0;
      jsvStringIteratorGoto($2, HEAP32[$5 + 272 >> 2], HEAP32[$5 + 116 >> 2] + HEAPU16[$5 + 168 >> 1] | 0);
      _jswrap_drawImageSimple($1, HEAP32[$5 + 400 >> 2], HEAP32[$5 + 396 >> 2] + ((HEAP32[$5 + 300 >> 2] - HEAP32[$5 + 124 >> 2] | 0) / 2 | 0) | 0, $0, $2);
      _jswrap_graphics_freeImageInfo($0);
      HEAP32[$5 + 400 >> 2] = HEAP32[$5 + 120 >> 2] + HEAP32[$5 + 400 >> 2];
     }
     continue;
    }
    label$27 : {
     if (!HEAP32[$5 + 304 >> 2]) {
      HEAP32[$5 + 112 >> 2] = graphicsVectorCharWidth($5 + 320 | 0, HEAPU16[$5 + 310 >> 1], HEAP8[$5 + 207 | 0]);
      if (!(HEAP32[$5 + 400 >> 2] <= (HEAP32[$5 + 256 >> 2] - HEAP32[$5 + 112 >> 2] | 0) | HEAP32[$5 + 400 >> 2] >= HEAP32[$5 + 248 >> 2] | (HEAP32[$5 + 396 >> 2] <= (HEAP32[$5 + 252 >> 2] - HEAPU16[$5 + 312 >> 1] | 0) | HEAP32[$5 + 396 >> 2] >= HEAP32[$5 + 244 >> 2]))) {
       if (HEAP8[$5 + 395 | 0] & 1) {
        graphicsFillRect($5 + 320 | 0, HEAP32[$5 + 400 >> 2], HEAP32[$5 + 396 >> 2], (HEAP32[$5 + 400 >> 2] + HEAP32[$5 + 112 >> 2] | 0) - 1 | 0, (HEAP32[$5 + 396 >> 2] + HEAP32[$5 + 300 >> 2] | 0) - 1 | 0, HEAPU8[$5 + 341 | 0] | HEAPU8[$5 + 342 | 0] << 8 | (HEAPU8[$5 + 343 | 0] << 16 | HEAPU8[$5 + 344 | 0] << 24));
       }
       graphicsFillVectorChar($5 + 320 | 0, HEAP32[$5 + 400 >> 2], HEAP32[$5 + 396 >> 2], HEAPU16[$5 + 310 >> 1], HEAPU16[$5 + 312 >> 1], HEAP8[$5 + 207 | 0]);
      }
      HEAP32[$5 + 400 >> 2] = HEAP32[$5 + 112 >> 2] + HEAP32[$5 + 400 >> 2];
      break label$27;
     }
     label$31 : {
      if (HEAP32[$5 + 304 >> 2] == 8192) {
       if (!(HEAP32[$5 + 400 >> 2] <= (HEAP32[$5 + 256 >> 2] - 4 | 0) | HEAP32[$5 + 400 >> 2] >= HEAP32[$5 + 248 >> 2] | (HEAP32[$5 + 396 >> 2] <= (HEAP32[$5 + 252 >> 2] - 6 | 0) | HEAP32[$5 + 396 >> 2] >= HEAP32[$5 + 244 >> 2]))) {
        graphicsDrawChar4x6($5 + 320 | 0, HEAP32[$5 + 400 >> 2], HEAP32[$5 + 396 >> 2], HEAP8[$5 + 207 | 0], HEAPU16[$5 + 310 >> 1], HEAPU16[$5 + 312 >> 1], HEAP8[$5 + 395 | 0] & 1);
       }
       HEAP32[$5 + 400 >> 2] = HEAP32[$5 + 400 >> 2] + (HEAPU16[$5 + 310 >> 1] << 2);
       break label$31;
      }
      label$34 : {
       if (HEAP32[$5 + 304 >> 2] == 16384) {
        if (!(HEAP32[$5 + 400 >> 2] <= (HEAP32[$5 + 256 >> 2] - 6 | 0) | HEAP32[$5 + 400 >> 2] >= HEAP32[$5 + 248 >> 2] | (HEAP32[$5 + 396 >> 2] <= (HEAP32[$5 + 252 >> 2] - 8 | 0) | HEAP32[$5 + 396 >> 2] >= HEAP32[$5 + 244 >> 2]))) {
         graphicsDrawChar6x8($5 + 320 | 0, HEAP32[$5 + 400 >> 2], HEAP32[$5 + 396 >> 2], HEAP8[$5 + 207 | 0], HEAPU16[$5 + 310 >> 1], HEAPU16[$5 + 312 >> 1], HEAP8[$5 + 395 | 0] & 1);
        }
        HEAP32[$5 + 400 >> 2] = HEAP32[$5 + 400 >> 2] + Math_imul(HEAPU16[$5 + 310 >> 1], 6);
        break label$34;
       }
       if (HEAP32[$5 + 304 >> 2] & 32768) {
        HEAP32[$5 + 108 >> 2] = (1 << HEAP32[$5 + 288 >> 2]) - 1;
        HEAP32[$5 + 104 >> 2] = 0;
        HEAP32[$5 + 100 >> 2] = 0;
        label$38 : {
         if (jsvIsString(HEAP32[$5 + 292 >> 2]) & 1) {
          if (HEAP8[$5 + 207 | 0] >= HEAPU8[$5 + 314 | 0]) {
           jsvStringIteratorNew($5 - -64 | 0, HEAP32[$5 + 292 >> 2], 0);
           while (1) {
            if (jsvStringIteratorHasChar($5 - -64 | 0) & 1) {
             $0 = (jsvStringIteratorGetIndex($5 - -64 | 0) | 0) < (HEAP8[$5 + 207 | 0] - HEAPU8[$5 + 314 | 0] | 0);
            } else {
             $0 = 0;
            }
            if ($0) {
             HEAP32[$5 + 100 >> 2] = (jsvStringIteratorGetCharAndNext($5 - -64 | 0) & 255) + HEAP32[$5 + 100 >> 2];
             continue;
            }
            break;
           }
           $0 = $5 - -64 | 0;
           HEAP32[$5 + 104 >> 2] = jsvStringIteratorGetChar($0) & 255;
           jsvStringIteratorFree($0);
          }
          break label$38;
         }
         HEAP32[$5 + 104 >> 2] = jsvGetInteger(HEAP32[$5 + 292 >> 2]);
         HEAP32[$5 + 100 >> 2] = Math_imul(HEAP32[$5 + 104 >> 2], HEAP8[$5 + 207 | 0] - HEAPU8[$5 + 314 | 0] | 0);
        }
        label$45 : {
         if (HEAP8[$5 + 207 | 0] < HEAPU8[$5 + 314 | 0] | HEAP32[$5 + 400 >> 2] <= (HEAP32[$5 + 256 >> 2] - HEAP32[$5 + 104 >> 2] | 0) | (HEAP32[$5 + 396 >> 2] <= (HEAP32[$5 + 252 >> 2] - HEAP32[$5 + 300 >> 2] | 0) | HEAP32[$5 + 400 >> 2] >= HEAP32[$5 + 248 >> 2])) {
          break label$45;
         }
         if (HEAP32[$5 + 396 >> 2] >= HEAP32[$5 + 244 >> 2]) {
          break label$45;
         }
         HEAP32[$5 + 60 >> 2] = HEAP32[$5 + 300 >> 2] / HEAPU16[$5 + 312 >> 1];
         HEAP32[$5 + 100 >> 2] = Math_imul(HEAP32[$5 + 100 >> 2], Math_imul(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 288 >> 2]));
         $0 = $5 + 24 | 0;
         jsvStringIteratorNew($0, HEAP32[$5 + 296 >> 2], HEAP32[$5 + 100 >> 2] >> 3);
         HEAP32[$5 + 100 >> 2] = HEAP32[$5 + 100 >> 2] & 7;
         HEAP32[$5 + 12 >> 2] = jsvStringIteratorGetChar($0) << 24 >> 24;
         HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 12 >> 2] << Math_imul(HEAP32[$5 + 288 >> 2], HEAP32[$5 + 100 >> 2]);
         HEAP32[$5 + 20 >> 2] = 0;
         while (1) {
          if (HEAP32[$5 + 20 >> 2] < HEAP32[$5 + 104 >> 2]) {
           HEAP32[$5 + 16 >> 2] = 0;
           while (1) {
            if (HEAP32[$5 + 16 >> 2] < HEAP32[$5 + 60 >> 2]) {
             HEAP32[$5 + 8 >> 2] = (HEAP32[$5 + 12 >> 2] & 255) >> 8 - HEAP32[$5 + 288 >> 2];
             if (!(HEAP32[$5 + 8 >> 2] ? 0 : !(HEAP8[$5 + 395 | 0] & 1))) {
              $0 = $5 + 320 | 0;
              graphicsFillRect($0, HEAP32[$5 + 400 >> 2] + Math_imul(HEAP32[$5 + 20 >> 2], HEAPU16[$5 + 310 >> 1]) | 0, HEAP32[$5 + 396 >> 2] + Math_imul(HEAP32[$5 + 16 >> 2], HEAPU16[$5 + 312 >> 1]) | 0, (HEAPU16[$5 + 310 >> 1] + (HEAP32[$5 + 400 >> 2] + Math_imul(HEAP32[$5 + 20 >> 2], HEAPU16[$5 + 310 >> 1]) | 0) | 0) - 1 | 0, (HEAPU16[$5 + 312 >> 1] + (HEAP32[$5 + 396 >> 2] + Math_imul(HEAP32[$5 + 16 >> 2], HEAPU16[$5 + 312 >> 1]) | 0) | 0) - 1 | 0, graphicsBlendGfxColor($0, (HEAP32[$5 + 8 >> 2] << 8) / HEAP32[$5 + 108 >> 2] | 0));
             }
             HEAP32[$5 + 100 >> 2] = HEAP32[$5 + 288 >> 2] + HEAP32[$5 + 100 >> 2];
             HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 12 >> 2] << HEAP32[$5 + 288 >> 2];
             if (HEAP32[$5 + 100 >> 2] >= 8) {
              HEAP32[$5 + 100 >> 2] = 0;
              $0 = $5 + 24 | 0;
              jsvStringIteratorNext($0);
              HEAP32[$5 + 12 >> 2] = jsvStringIteratorGetChar($0) << 24 >> 24;
             }
             HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 16 >> 2] + 1;
             continue;
            }
            break;
           }
           HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 20 >> 2] + 1;
           continue;
          }
          break;
         }
         jsvStringIteratorFree($5 + 24 | 0);
        }
        HEAP32[$5 + 400 >> 2] = HEAP32[$5 + 400 >> 2] + Math_imul(HEAP32[$5 + 104 >> 2], HEAPU16[$5 + 310 >> 1]);
       }
      }
     }
    }
    if (!(jspIsInterrupted() & 1)) {
     continue;
    }
   }
   break;
  }
  $1 = $5 + 320 | 0;
  jsvStringIteratorFree($5 + 208 | 0);
  jsvUnLock(HEAP32[$5 + 272 >> 2]);
  jsvUnLock2(HEAP32[$5 + 296 >> 2], HEAP32[$5 + 292 >> 2]);
  $0 = HEAP32[$5 + 284 >> 2];
  HEAP8[$5 + 328 | 0] = $0;
  HEAP8[$5 + 329 | 0] = $0 >>> 8;
  HEAP8[$5 + 330 | 0] = $0 >>> 16;
  HEAP8[$5 + 331 | 0] = $0 >>> 24;
  graphicsSetVar($1);
  HEAP32[$5 + 412 >> 2] = jsvLockAgain(HEAP32[$5 + 408 >> 2]);
 }
 global$0 = $5 + 416 | 0;
 return HEAP32[$5 + 412 >> 2];
}
function fmt_fp($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = +$1;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0, wasm2js_i32$3 = 0, wasm2js_i32$4 = 0, wasm2js_i32$5 = 0;
 $11 = global$0 - 560 | 0;
 global$0 = $11;
 HEAP32[$11 + 44 >> 2] = 0;
 wasm2js_scratch_store_f64(+$1);
 $6 = wasm2js_scratch_load_i32(1) | 0;
 label$1 : {
  if (wasm2js_i32$0 = 1, wasm2js_i32$1 = (wasm2js_i32$3 = wasm2js_scratch_load_i32(0) >>> 0 > 4294967295 ? 0 : 1, wasm2js_i32$4 = 0, wasm2js_i32$5 = ($6 | 0) <= -1, wasm2js_i32$5 ? wasm2js_i32$3 : wasm2js_i32$4), wasm2js_i32$2 = ($6 | 0) < -1, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1) {
   $1 = -$1;
   wasm2js_scratch_store_f64(+$1);
   $6 = wasm2js_scratch_load_i32(1) | 0;
   wasm2js_scratch_load_i32(0) | 0;
   $21 = 1;
   $22 = 138576;
   break label$1;
  }
  if ($4 & 2048) {
   $21 = 1;
   $22 = 138579;
   break label$1;
  }
  $21 = $4 & 1;
  $22 = $21 ? 138582 : 138577;
 }
 label$4 : {
  if (($6 & 2146435072) == 2146435072) {
   $10 = $21 + 3 | 0;
   pad($0, 32, $2, $10, $4 & -65537);
   out($0, $22, $21);
   $3 = $5 >>> 5 & 1;
   out($0, $1 != $1 ? $3 ? 138603 : 138607 : $3 ? 138595 : 138599, 3);
   break label$4;
  }
  $1 = frexp($1, $11 + 44 | 0);
  $1 = $1 + $1;
  if ($1 != 0) {
   HEAP32[$11 + 44 >> 2] = HEAP32[$11 + 44 >> 2] + -1;
  }
  $17 = $11 + 16 | 0;
  $23 = $5 | 32;
  if (($23 | 0) == 97) {
   $16 = $5 & 32;
   $15 = $16 ? $22 + 9 | 0 : $22;
   label$8 : {
    if ($3 >>> 0 > 11) {
     break label$8;
    }
    $6 = 12 - $3 | 0;
    if (!$6) {
     break label$8;
    }
    $18 = 8;
    while (1) {
     $18 = $18 * 16;
     $6 = $6 + -1 | 0;
     if ($6) {
      continue;
     }
     break;
    }
    if (HEAPU8[$15 | 0] == 45) {
     $1 = -($18 + (-$1 - $18));
     break label$8;
    }
    $1 = $1 + $18 - $18;
   }
   $6 = HEAP32[$11 + 44 >> 2];
   $8 = $6 >> 31;
   $6 = fmt_u($8 ^ $6 + $8, 0, $17);
   if (($17 | 0) == ($6 | 0)) {
    HEAP8[$11 + 15 | 0] = 48;
    $6 = $11 + 15 | 0;
   }
   $12 = $21 | 2;
   $8 = HEAP32[$11 + 44 >> 2];
   $14 = $6 + -2 | 0;
   HEAP8[$14 | 0] = $5 + 15;
   HEAP8[$6 + -1 | 0] = ($8 | 0) < 0 ? 45 : 43;
   $6 = $4 & 8;
   $7 = $11 + 16 | 0;
   while (1) {
    $5 = $7;
    $10 = $16;
    if (Math_abs($1) < 2147483648) {
     $8 = ~~$1;
    } else {
     $8 = -2147483648;
    }
    HEAP8[$7 | 0] = $10 | HEAPU8[$8 + 138560 | 0];
    $7 = $5 + 1 | 0;
    $1 = ($1 - +($8 | 0)) * 16;
    if (!(($7 - ($11 + 16 | 0) | 0) != 1 | ($1 == 0 ? !($6 | ($3 | 0) > 0) : 0))) {
     HEAP8[$5 + 1 | 0] = 46;
     $7 = $5 + 2 | 0;
    }
    if ($1 != 0) {
     continue;
    }
    break;
   }
   $5 = !$3 | (($7 - $11 | 0) + -18 | 0) >= ($3 | 0) ? (($17 - ($11 + 16 | 0) | 0) - $14 | 0) + $7 | 0 : (($3 + $17 | 0) - $14 | 0) + 2 | 0;
   $10 = $5 + $12 | 0;
   pad($0, 32, $2, $10, $4);
   out($0, $15, $12);
   pad($0, 48, $2, $10, $4 ^ 65536);
   $3 = $7 - ($11 + 16 | 0) | 0;
   out($0, $11 + 16 | 0, $3);
   $6 = $3;
   $3 = $17 - $14 | 0;
   pad($0, 48, $5 - ($6 + $3 | 0) | 0, 0, 0);
   out($0, $14, $3);
   break label$4;
  }
  $6 = ($3 | 0) < 0;
  label$16 : {
   if ($1 == 0) {
    $9 = HEAP32[$11 + 44 >> 2];
    break label$16;
   }
   $9 = HEAP32[$11 + 44 >> 2] + -28 | 0;
   HEAP32[$11 + 44 >> 2] = $9;
   $1 = $1 * 268435456;
  }
  $13 = $6 ? 6 : $3;
  $16 = ($9 | 0) < 0 ? $11 + 48 | 0 : $11 + 336 | 0;
  $8 = $16;
  while (1) {
   $3 = $8;
   if ($1 < 4294967296 & $1 >= 0) {
    $6 = ~~$1 >>> 0;
   } else {
    $6 = 0;
   }
   HEAP32[$3 >> 2] = $6;
   $8 = $8 + 4 | 0;
   $1 = ($1 - +($6 >>> 0)) * 1e9;
   if ($1 != 0) {
    continue;
   }
   break;
  }
  label$21 : {
   if (($9 | 0) < 1) {
    $6 = $8;
    $7 = $16;
    break label$21;
   }
   $7 = $16;
   while (1) {
    $19 = ($9 | 0) < 29 ? $9 : 29;
    $6 = $8 + -4 | 0;
    label$24 : {
     if ($6 >>> 0 < $7 >>> 0) {
      break label$24;
     }
     $3 = $19;
     $10 = 0;
     while (1) {
      $15 = 0;
      $14 = $10;
      $10 = HEAP32[$6 >> 2];
      $12 = $3 & 31;
      if (32 <= ($3 & 63) >>> 0) {
       $9 = $10 << $12;
       $12 = 0;
      } else {
       $9 = (1 << $12) - 1 & $10 >>> 32 - $12;
       $12 = $10 << $12;
      }
      $10 = $14 + $12 | 0;
      $9 = $9 + $15 | 0;
      $9 = $10 >>> 0 < $12 >>> 0 ? $9 + 1 | 0 : $9;
      $15 = $10;
      $10 = __wasm_i64_udiv($10, $9, 1e9, 0);
      $12 = __wasm_i64_mul($10, i64toi32_i32$HIGH_BITS, 1e9, 0);
      HEAP32[$6 >> 2] = $15 - $12;
      $6 = $6 + -4 | 0;
      if ($6 >>> 0 >= $7 >>> 0) {
       continue;
      }
      break;
     }
     $3 = $10;
     if (!$3) {
      break label$24;
     }
     $7 = $7 + -4 | 0;
     HEAP32[$7 >> 2] = $3;
    }
    while (1) {
     $6 = $8;
     if ($6 >>> 0 > $7 >>> 0) {
      $8 = $6 + -4 | 0;
      if (!HEAP32[$8 >> 2]) {
       continue;
      }
     }
     break;
    }
    $9 = HEAP32[$11 + 44 >> 2] - $19 | 0;
    HEAP32[$11 + 44 >> 2] = $9;
    $8 = $6;
    if (($9 | 0) > 0) {
     continue;
    }
    break;
   }
  }
  if (($9 | 0) <= -1) {
   $20 = (($13 + 25 | 0) / 9 | 0) + 1 | 0;
   $14 = ($23 | 0) == 102;
   while (1) {
    $19 = ($9 | 0) < -9 ? 9 : 0 - $9 | 0;
    label$30 : {
     if ($7 >>> 0 >= $6 >>> 0) {
      $7 = HEAP32[$7 >> 2] ? $7 : $7 + 4 | 0;
      break label$30;
     }
     $15 = 1e9 >>> $19;
     $12 = -1 << $19 ^ -1;
     $9 = 0;
     $8 = $7;
     while (1) {
      $3 = HEAP32[$8 >> 2];
      HEAP32[$8 >> 2] = ($3 >>> $19) + $9;
      $9 = Math_imul($15, $3 & $12);
      $8 = $8 + 4 | 0;
      if ($8 >>> 0 < $6 >>> 0) {
       continue;
      }
      break;
     }
     $7 = HEAP32[$7 >> 2] ? $7 : $7 + 4 | 0;
     if (!$9) {
      break label$30;
     }
     HEAP32[$6 >> 2] = $9;
     $6 = $6 + 4 | 0;
    }
    $9 = $19 + HEAP32[$11 + 44 >> 2] | 0;
    HEAP32[$11 + 44 >> 2] = $9;
    $3 = $14 ? $16 : $7;
    $6 = $6 - $3 >> 2 > ($20 | 0) ? $3 + ($20 << 2) | 0 : $6;
    if (($9 | 0) < 0) {
     continue;
    }
    break;
   }
  }
  $8 = 0;
  label$33 : {
   if ($7 >>> 0 >= $6 >>> 0) {
    break label$33;
   }
   $8 = Math_imul($16 - $7 >> 2, 9);
   $9 = 10;
   $3 = HEAP32[$7 >> 2];
   if ($3 >>> 0 < 10) {
    break label$33;
   }
   while (1) {
    $8 = $8 + 1 | 0;
    $9 = Math_imul($9, 10);
    if ($3 >>> 0 >= $9 >>> 0) {
     continue;
    }
    break;
   }
  }
  $3 = ($13 - (($23 | 0) == 102 ? 0 : $8) | 0) - (($23 | 0) == 103 & ($13 | 0) != 0) | 0;
  if (($3 | 0) < (Math_imul($6 - $16 >> 2, 9) + -9 | 0)) {
   $12 = $3 + 9216 | 0;
   $3 = ($12 | 0) / 9 | 0;
   $10 = ($16 + ($3 << 2) | 0) + -4092 | 0;
   $9 = 10;
   $3 = ($12 - Math_imul($3, 9) | 0) + 1 | 0;
   if (($3 | 0) <= 8) {
    while (1) {
     $9 = Math_imul($9, 10);
     $3 = $3 + 1 | 0;
     if (($3 | 0) != 9) {
      continue;
     }
     break;
    }
   }
   $15 = HEAP32[$10 >> 2];
   $12 = ($15 >>> 0) / ($9 >>> 0) | 0;
   $20 = $10 + 4 | 0;
   $14 = $15 - Math_imul($9, $12) | 0;
   label$38 : {
    if ($14 ? 0 : ($20 | 0) == ($6 | 0)) {
     break label$38;
    }
    $3 = $9 >>> 1;
    $18 = $14 >>> 0 < $3 >>> 0 ? .5 : ($6 | 0) == ($20 | 0) ? ($3 | 0) == ($14 | 0) ? 1 : 1.5 : 1.5;
    $1 = $12 & 1 ? 9007199254740994 : 9007199254740992;
    if (!(!$21 | HEAPU8[$22 | 0] != 45)) {
     $18 = -$18;
     $1 = -$1;
    }
    $3 = $15 - $14 | 0;
    HEAP32[$10 >> 2] = $3;
    if ($1 + $18 == $1) {
     break label$38;
    }
    $3 = $3 + $9 | 0;
    HEAP32[$10 >> 2] = $3;
    if ($3 >>> 0 >= 1e9) {
     while (1) {
      HEAP32[$10 >> 2] = 0;
      $10 = $10 + -4 | 0;
      if ($10 >>> 0 < $7 >>> 0) {
       $7 = $7 + -4 | 0;
       HEAP32[$7 >> 2] = 0;
      }
      $3 = HEAP32[$10 >> 2] + 1 | 0;
      HEAP32[$10 >> 2] = $3;
      if ($3 >>> 0 > 999999999) {
       continue;
      }
      break;
     }
    }
    $8 = Math_imul($16 - $7 >> 2, 9);
    $9 = 10;
    $3 = HEAP32[$7 >> 2];
    if ($3 >>> 0 < 10) {
     break label$38;
    }
    while (1) {
     $8 = $8 + 1 | 0;
     $9 = Math_imul($9, 10);
     if ($3 >>> 0 >= $9 >>> 0) {
      continue;
     }
     break;
    }
   }
   $3 = $10 + 4 | 0;
   $6 = $6 >>> 0 > $3 >>> 0 ? $3 : $6;
  }
  label$44 : {
   while (1) {
    $14 = $6;
    $15 = 0;
    if ($6 >>> 0 <= $7 >>> 0) {
     break label$44;
    }
    $6 = $14 + -4 | 0;
    if (!HEAP32[$6 >> 2]) {
     continue;
    }
    break;
   }
   $15 = 1;
  }
  label$46 : {
   if (($23 | 0) != 103) {
    $12 = $4 & 8;
    break label$46;
   }
   $6 = $13 ? $13 : 1;
   $3 = ($6 | 0) > ($8 | 0) & ($8 | 0) > -5;
   $13 = ($3 ? $8 ^ -1 : -1) + $6 | 0;
   $5 = ($3 ? -1 : -2) + $5 | 0;
   $12 = $4 & 8;
   if ($12) {
    break label$46;
   }
   $6 = 9;
   label$48 : {
    if (!$15) {
     break label$48;
    }
    $12 = HEAP32[$14 + -4 >> 2];
    if (!$12) {
     break label$48;
    }
    $3 = 10;
    $6 = 0;
    if (($12 >>> 0) % 10) {
     break label$48;
    }
    while (1) {
     $6 = $6 + 1 | 0;
     $3 = Math_imul($3, 10);
     if (!(($12 >>> 0) % ($3 >>> 0))) {
      continue;
     }
     break;
    }
   }
   $3 = Math_imul($14 - $16 >> 2, 9) + -9 | 0;
   if (($5 | 32) == 102) {
    $12 = 0;
    $3 = $3 - $6 | 0;
    $3 = ($3 | 0) > 0 ? $3 : 0;
    $13 = ($13 | 0) < ($3 | 0) ? $13 : $3;
    break label$46;
   }
   $12 = 0;
   $3 = ($3 + $8 | 0) - $6 | 0;
   $3 = ($3 | 0) > 0 ? $3 : 0;
   $13 = ($13 | 0) < ($3 | 0) ? $13 : $3;
  }
  $9 = $12 | $13;
  $10 = ($9 | 0) != 0;
  $3 = $0;
  $23 = $2;
  $19 = $5 | 32;
  $6 = ($8 | 0) > 0 ? $8 : 0;
  label$51 : {
   if (($19 | 0) == 102) {
    break label$51;
   }
   $6 = $8 >> 31;
   $6 = fmt_u($6 + $8 ^ $6, 0, $17);
   if (($17 - $6 | 0) <= 1) {
    while (1) {
     $6 = $6 + -1 | 0;
     HEAP8[$6 | 0] = 48;
     if (($17 - $6 | 0) < 2) {
      continue;
     }
     break;
    }
   }
   $20 = $6 + -2 | 0;
   HEAP8[$20 | 0] = $5;
   HEAP8[$6 + -1 | 0] = ($8 | 0) < 0 ? 45 : 43;
   $6 = $17 - $20 | 0;
  }
  $10 = ($6 + ($10 + ($13 + $21 | 0) | 0) | 0) + 1 | 0;
  pad($3, 32, $23, $10, $4);
  out($0, $22, $21);
  pad($0, 48, $2, $10, $4 ^ 65536);
  label$54 : {
   if (($19 | 0) == 102) {
    $3 = $11 + 16 | 8;
    $8 = $11 + 16 | 9;
    $5 = $7 >>> 0 > $16 >>> 0 ? $16 : $7;
    $7 = $5;
    while (1) {
     $6 = fmt_u(HEAP32[$7 >> 2], 0, $8);
     label$57 : {
      if (($5 | 0) != ($7 | 0)) {
       if ($6 >>> 0 <= $11 + 16 >>> 0) {
        break label$57;
       }
       while (1) {
        $6 = $6 + -1 | 0;
        HEAP8[$6 | 0] = 48;
        if ($6 >>> 0 > $11 + 16 >>> 0) {
         continue;
        }
        break;
       }
       break label$57;
      }
      if (($6 | 0) != ($8 | 0)) {
       break label$57;
      }
      HEAP8[$11 + 24 | 0] = 48;
      $6 = $3;
     }
     out($0, $6, $8 - $6 | 0);
     $7 = $7 + 4 | 0;
     if ($7 >>> 0 <= $16 >>> 0) {
      continue;
     }
     break;
    }
    if ($9) {
     out($0, 138611, 1);
    }
    label$61 : {
     if (($13 | 0) < 1 | $7 >>> 0 >= $14 >>> 0) {
      break label$61;
     }
     while (1) {
      $6 = fmt_u(HEAP32[$7 >> 2], 0, $8);
      if ($6 >>> 0 > $11 + 16 >>> 0) {
       while (1) {
        $6 = $6 + -1 | 0;
        HEAP8[$6 | 0] = 48;
        if ($6 >>> 0 > $11 + 16 >>> 0) {
         continue;
        }
        break;
       }
      }
      out($0, $6, ($13 | 0) < 9 ? $13 : 9);
      $13 = $13 + -9 | 0;
      $7 = $7 + 4 | 0;
      if ($7 >>> 0 >= $14 >>> 0) {
       break label$61;
      }
      if (($13 | 0) > 0) {
       continue;
      }
      break;
     }
    }
    pad($0, 48, $13 + 9 | 0, 9, 0);
    break label$54;
   }
   label$65 : {
    if (($13 | 0) < 0) {
     break label$65;
    }
    $5 = $15 ? $14 : $7 + 4 | 0;
    $3 = $11 + 16 | 8;
    $16 = $11 + 16 | 9;
    $8 = $7;
    while (1) {
     $6 = fmt_u(HEAP32[$8 >> 2], 0, $16);
     if (($16 | 0) == ($6 | 0)) {
      HEAP8[$11 + 24 | 0] = 48;
      $6 = $3;
     }
     label$68 : {
      if (($7 | 0) != ($8 | 0)) {
       if ($6 >>> 0 <= $11 + 16 >>> 0) {
        break label$68;
       }
       while (1) {
        $6 = $6 + -1 | 0;
        HEAP8[$6 | 0] = 48;
        if ($6 >>> 0 > $11 + 16 >>> 0) {
         continue;
        }
        break;
       }
       break label$68;
      }
      out($0, $6, 1);
      $6 = $6 + 1 | 0;
      if (($13 | 0) < 1 ? !$12 : 0) {
       break label$68;
      }
      out($0, 138611, 1);
     }
     $15 = $6;
     $6 = $16 - $6 | 0;
     out($0, $15, ($13 | 0) > ($6 | 0) ? $6 : $13);
     $13 = $13 - $6 | 0;
     $8 = $8 + 4 | 0;
     if ($8 >>> 0 >= $5 >>> 0) {
      break label$65;
     }
     if (($13 | 0) > -1) {
      continue;
     }
     break;
    }
   }
   pad($0, 48, $13 + 18 | 0, 18, 0);
   out($0, $20, $17 - $20 | 0);
  }
 }
 pad($0, 32, $2, $10, $4 ^ 8192);
 global$0 = $11 + 560 | 0;
 return (($10 | 0) < ($2 | 0) ? $2 : $10) | 0;
}
function jswrap_banglejs_idle() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $2 = global$0 - 416 | 0;
 $0 = $2;
 global$0 = $0;
 HEAP32[$0 + 412 >> 2] = jsvObjectGetChild(HEAP32[80545], 110020, 0);
 label$1 : {
  if (jsiObjectHasCallbacks(HEAP32[$0 + 412 >> 2], 110616) & 1) {
   HEAP32[84152] = HEAP32[84152] | 512;
   break label$1;
  }
  HEAP32[84152] = HEAP32[84152] & -513;
 }
 if (!HEAP32[$0 + 412 >> 2]) {
  HEAP32[84158] = 0;
 }
 if (HEAP32[84158]) {
  if (HEAP32[84158] & 4) {
   jswrap_banglejs_setLCDPower(0);
  }
  if (HEAP32[84158] & 2) {
   jswrap_banglejs_setLCDPower(1);
  }
  if (HEAP32[84158] & 16) {
   jswrap_banglejs_setLCDPowerBacklight(0);
  }
  if (HEAP32[84158] & 8) {
   jswrap_banglejs_setLCDPowerBacklight(1);
  }
  if (HEAP32[84158] & 32) {
   jswrap_banglejs_setLocked(1);
  }
  if (HEAP32[84158] & 64) {
   jswrap_banglejs_setLocked(0);
  }
  if (HEAP32[84158] & 1) {
   HEAP16[161112] = HEAPU16[161112] | 64;
  }
  if (HEAP32[84158] & 67108864) {
   jswrap_banglejs_setPollInterval_internal(80);
  }
  if (HEAP32[84158] & 134217728) {
   jswrap_banglejs_setPollInterval_internal(800);
  }
  if (HEAP32[84158] & 128) {
   HEAP32[$0 + 408 >> 2] = jswrap_banglejs_getAccel();
   if (HEAP32[$0 + 408 >> 2]) {
    jsiQueueObjectCallbacks(HEAP32[$0 + 412 >> 2], 110616, $0 + 408 | 0, 1);
    jsvUnLock(HEAP32[$0 + 408 >> 2]);
   }
  }
  if (HEAP32[84158] & 256) {
   HEAP32[$0 + 404 >> 2] = jsvNewWithFlags(5);
   if (HEAP32[$0 + 404 >> 2]) {
    HEAP32[$0 + 400 >> 2] = 110625;
    if (HEAPU8[336768] & 2) {
     HEAP32[$0 + 400 >> 2] = 110626;
    }
    if (HEAP8[336768] & 1) {
     HEAP32[$0 + 400 >> 2] = 110632;
    }
    if (HEAPU8[336768] & 8) {
     HEAP32[$0 + 400 >> 2] = 110637;
    }
    if (HEAPU8[336768] & 4) {
     HEAP32[$0 + 400 >> 2] = 110644;
    }
    if (HEAPU8[336768] & 16) {
     HEAP32[$0 + 400 >> 2] = 110648;
    }
    if (HEAPU8[336768] & 32) {
     HEAP32[$0 + 400 >> 2] = 110654;
    }
    HEAP32[$0 + 396 >> 2] = HEAPU8[336768] & 128 ? 2 : 1;
    jsvObjectSetChildAndUnLock(HEAP32[$0 + 404 >> 2], 110659, jsvNewFromString(HEAP32[$0 + 400 >> 2]));
    jsvObjectSetChildAndUnLock(HEAP32[$0 + 404 >> 2], 110663, jsvNewFromBool((HEAPU8[336768] & 128) != 0));
    $3 = HEAP32[$0 + 404 >> 2];
    if (HEAPU8[336768] & 16) {
     $1 = 0 - HEAP32[$0 + 396 >> 2] | 0;
    } else {
     if (HEAPU8[336768] & 32) {
      $1 = HEAP32[$0 + 396 >> 2];
     } else {
      $1 = 0;
     }
    }
    jsvObjectSetChildAndUnLock($3, 110430, jsvNewFromInteger($1));
    $3 = HEAP32[$0 + 404 >> 2];
    if (HEAPU8[336768] & 4) {
     $1 = 0 - HEAP32[$0 + 396 >> 2] | 0;
    } else {
     if (HEAPU8[336768] & 8) {
      $1 = HEAP32[$0 + 396 >> 2];
     } else {
      $1 = 0;
     }
    }
    jsvObjectSetChildAndUnLock($3, 110432, jsvNewFromInteger($1));
    $3 = $0 + 404 | 0;
    $4 = HEAP32[$0 + 404 >> 2];
    if (HEAP8[336768] & 1) {
     $1 = 0 - HEAP32[$0 + 396 >> 2] | 0;
    } else {
     if (HEAPU8[336768] & 2) {
      $1 = HEAP32[$0 + 396 >> 2];
     } else {
      $1 = 0;
     }
    }
    jsvObjectSetChildAndUnLock($4, 110434, jsvNewFromInteger($1));
    jsiQueueObjectCallbacks(HEAP32[$0 + 412 >> 2], 110670, $3, 1);
    jsvUnLock(HEAP32[$0 + 404 >> 2]);
   }
  }
  if (HEAP32[84158] & 16384) {
   label$37 : {
    if (!HEAP32[$0 + 412 >> 2]) {
     break label$37;
    }
    if (!(jsiObjectHasCallbacks(HEAP32[$0 + 412 >> 2], 110677) & 1)) {
     break label$37;
    }
    HEAP32[$0 + 392 >> 2] = 0;
    if (HEAP32[$0 + 392 >> 2]) {
     jsiQueueObjectCallbacks(HEAP32[$0 + 412 >> 2], 110677, $0 + 392 | 0, 1);
     jsvUnLock(HEAP32[$0 + 392 >> 2]);
    }
   }
  }
  if (HEAP32[84158] & 536870912) {
   HEAP32[$0 + 388 >> 2] = _jswrap_banglejs_getHealthStatusObject(336708);
   if (HEAP32[$0 + 388 >> 2]) {
    jsiQueueObjectCallbacks(HEAP32[$0 + 412 >> 2], 110684, $0 + 388 | 0, 1);
    jsvUnLock(HEAP32[$0 + 388 >> 2]);
   }
  }
  if (HEAP32[84158] & 32768) {
   if (jsiObjectHasCallbacks(HEAP32[$0 + 412 >> 2], 110694) & 1) {
    HEAP32[$0 + 384 >> 2] = jsvNewTypedArray(17, Math_imul(HEAPU8[336769], 3));
    if (HEAP32[$0 + 384 >> 2]) {
     HEAP32[$0 + 380 >> 2] = HEAPU8[336770] - Math_imul(HEAPU8[336769], 3);
     while (1) {
      if (HEAP32[$0 + 380 >> 2] < 0) {
       HEAP32[$0 + 380 >> 2] = HEAP32[$0 + 380 >> 2] + 150;
       continue;
      }
      break;
     }
     jsvArrayBufferIteratorNew($0 + 320 | 0, HEAP32[$0 + 384 >> 2], 0);
     HEAP32[$0 + 316 >> 2] = 0;
     while (1) {
      if (HEAP32[$0 + 316 >> 2] < (Math_imul(HEAPU8[336769], 3) | 0)) {
       $1 = HEAP32[$0 + 380 >> 2];
       HEAP32[$0 + 380 >> 2] = $1 + 1;
       $3 = $0 + 320 | 0;
       jsvArrayBufferIteratorSetByteValue($3, HEAP8[$1 + 336784 | 0]);
       jsvArrayBufferIteratorNext($3);
       if (HEAP32[$0 + 380 >> 2] >= 150) {
        HEAP32[$0 + 380 >> 2] = HEAP32[$0 + 380 >> 2] - 150;
       }
       HEAP32[$0 + 316 >> 2] = HEAP32[$0 + 316 >> 2] + 1;
       continue;
      }
      break;
     }
     $1 = $0 + 384 | 0;
     jsvArrayBufferIteratorFree($0 + 320 | 0);
     jsiQueueObjectCallbacks(HEAP32[$0 + 412 >> 2], 110694, $1, 1);
     jsvUnLock(HEAP32[$0 + 384 >> 2]);
    }
   }
   if (jsiObjectHasCallbacks(HEAP32[$0 + 412 >> 2], 110705) & 1) {
    jsfNameFromString($0 + 248 | 0, 110718);
    HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 272 >> 2];
    $1 = HEAP32[$0 + 268 >> 2];
    HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 264 >> 2];
    HEAP32[$0 + 20 >> 2] = $1;
    $1 = HEAP32[$0 + 260 >> 2];
    HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 256 >> 2];
    HEAP32[$0 + 12 >> 2] = $1;
    $1 = HEAP32[$0 + 252 >> 2];
    HEAP32[$0 >> 2] = HEAP32[$0 + 248 >> 2];
    HEAP32[$0 + 4 >> 2] = $1;
    HEAP32[$0 + 276 >> 2] = jsfFindFile($0, $0 + 280 | 0);
    label$50 : {
     if (!HEAP32[$0 + 276 >> 2]) {
      jsiConsolePrintf(110727, 0);
      break label$50;
     }
     HEAP32[$0 + 244 >> 2] = jsfGetFileSize($0 + 280 | 0);
     $1 = $2 - (HEAP32[$0 + 244 >> 2] + 15 & -16) | 0;
     global$0 = $1;
     HEAP32[$0 + 240 >> 2] = $1;
     jshFlashRead(HEAP32[$0 + 240 >> 2], HEAP32[$0 + 276 >> 2], HEAP32[$0 + 244 >> 2]);
     HEAP32[$0 + 236 >> 2] = jsvNewNativeString(HEAP32[$0 + 240 >> 2], HEAP32[$0 + 244 >> 2]);
     while (1) {
      if (jsiFreeMoreMemory() & 1) {
       continue;
      }
      break;
     }
     jsvGarbageCollect();
     HEAP32[$0 + 232 >> 2] = jswrap_tensorflow_create(4e3, HEAP32[$0 + 236 >> 2]);
     jsvUnLock(HEAP32[$0 + 236 >> 2]);
     if (HEAP32[$0 + 232 >> 2]) {
      $1 = $0 + 168 | 0;
      HEAP32[$0 + 228 >> 2] = jswrap_tfmicrointerpreter_getInput(HEAP32[$0 + 232 >> 2]);
      jsvArrayBufferIteratorNew($1, HEAP32[$0 + 228 >> 2], 0);
      HEAP32[$0 + 164 >> 2] = HEAPU8[336770] - Math_imul(HEAPU8[336769], 3);
      while (1) {
       if (HEAP32[$0 + 164 >> 2] < 0) {
        HEAP32[$0 + 164 >> 2] = HEAP32[$0 + 164 >> 2] + 150;
        continue;
       }
       break;
      }
      HEAP32[$0 + 160 >> 2] = 0;
      while (1) {
       if (HEAP32[$0 + 160 >> 2] < (Math_imul(HEAPU8[336769], 3) | 0)) {
        $1 = HEAP32[$0 + 164 >> 2];
        HEAP32[$0 + 164 >> 2] = $1 + 1;
        $2 = $0 + 168 | 0;
        jsvArrayBufferIteratorSetIntegerValue($2, HEAP8[$1 + 336784 | 0]);
        jsvArrayBufferIteratorNext($2);
        if (HEAP32[$0 + 164 >> 2] >= 150) {
         HEAP32[$0 + 164 >> 2] = HEAP32[$0 + 164 >> 2] - 150;
        }
        HEAP32[$0 + 160 >> 2] = HEAP32[$0 + 160 >> 2] + 1;
        continue;
       }
       break;
      }
      $1 = $0 + 144 | 0;
      $2 = $0 + 156 | 0;
      jsvArrayBufferIteratorFree($0 + 168 | 0);
      jsvUnLock(HEAP32[$0 + 228 >> 2]);
      jswrap_tfmicrointerpreter_invoke(HEAP32[$0 + 232 >> 2]);
      HEAP32[$0 + 228 >> 2] = jswrap_tfmicrointerpreter_getOutput(HEAP32[$0 + 232 >> 2]);
      HEAP32[$0 + 156 >> 2] = jswrap_array_slice(HEAP32[$0 + 228 >> 2], 0, 0);
      jsvUnLock2(HEAP32[$0 + 228 >> 2], HEAP32[$0 + 232 >> 2]);
      HEAP32[$0 + 152 >> 2] = jspExecuteJSFunction(110748, 1, $2);
      HEAP32[$0 + 144 >> 2] = HEAP32[$0 + 152 >> 2];
      HEAP32[$0 + 148 >> 2] = HEAP32[$0 + 156 >> 2];
      jsiQueueObjectCallbacks(HEAP32[$0 + 412 >> 2], 110705, $1, 2);
      jsvUnLock2(HEAP32[$0 + 152 >> 2], HEAP32[$0 + 156 >> 2]);
     }
    }
   }
  }
  if (HEAP32[84158] & 131072) {
   $1 = $0 + 140 | 0;
   HEAP32[$0 + 140 >> 2] = jsvNewFromBool(HEAP8[336934] & 1);
   jsiQueueObjectCallbacks(HEAP32[$0 + 412 >> 2], 110916, $1, 1);
   jsvUnLock(HEAP32[$0 + 140 >> 2]);
  }
  if (HEAP32[84158] & 262144) {
   $1 = $0 + 136 | 0;
   HEAP32[$0 + 136 >> 2] = jsvNewFromInteger(HEAP32[84168]);
   jsiQueueObjectCallbacks(HEAP32[$0 + 412 >> 2], 110928, $1, 1);
   jsvUnLock(HEAP32[$0 + 136 >> 2]);
  }
  if (HEAP32[84158] & 16777216) {
   jsiQueueObjectCallbacks(HEAP32[$0 + 412 >> 2], 110936, 0, 0);
  }
  if (HEAP32[84158] & 33554432) {
   $1 = $0 + 132 | 0;
   HEAP32[$0 + 132 >> 2] = jsvNewFromBool(HEAP8[336935] & 1);
   jsiQueueObjectCallbacks(HEAP32[$0 + 412 >> 2], 110945, $1, 1);
   jsvUnLock(HEAP32[$0 + 132 >> 2]);
   if (!(!(HEAP8[336935] & 1) | !(HEAP32[84152] & 1))) {
    if (!(!HEAP32[84154] | HEAP32[84152] & 32768)) {
     jswrap_banglejs_setLCDPower(1);
    }
    if (!(!HEAP32[84155] | HEAP32[84152] & 65536)) {
     jswrap_banglejs_setLCDPowerBacklight(1);
    }
    if (!(!HEAP32[84156] | !(HEAP32[84152] & 131072))) {
     jswrap_banglejs_setLocked(0);
    }
    HEAP16[168314] = 0;
   }
  }
  if (HEAP32[84158] & 524288) {
   $2 = $0;
   if (HEAP32[84165] == 1) {
    $1 = -1;
   } else {
    $1 = HEAP32[84165] == 2 ? 1 : 0;
   }
   HEAP32[$2 + 124 >> 2] = jsvNewFromInteger($1);
   $2 = $0 + 124 | 0;
   $1 = $0;
   if (HEAP32[84165] == 3) {
    $3 = -1;
   } else {
    $3 = HEAP32[84165] == 4 ? 1 : 0;
   }
   HEAP32[$1 + 128 >> 2] = jsvNewFromInteger($3);
   HEAP32[84165] = 0;
   jsiQueueObjectCallbacks(HEAP32[$0 + 412 >> 2], 110955, $2, 2);
   jsvUnLockMany(2, $2);
  }
  if (HEAP32[84158] & 3145728) {
   $1 = $0 + 116 | 0;
   HEAP32[$0 + 116 >> 2] = jsvNewFromInteger((HEAP32[84158] & 1048576 ? 1 : 0) | (HEAP32[84158] & 2097152 ? 2 : 0));
   HEAP32[$0 + 120 >> 2] = jsvNewWithFlags(5);
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 120 >> 2], 110430, jsvNewFromInteger(HEAPU8[336666]));
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 120 >> 2], 110432, jsvNewFromInteger(HEAPU8[336667]));
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 120 >> 2], 110964, jsvNewFromInteger(HEAPU8[336664]));
   jsiQueueObjectCallbacks(HEAP32[$0 + 412 >> 2], 110969, $1, 2);
   jsvUnLockMany(2, $1);
  }
 }
 if (HEAP32[84158] & 4194304) {
  HEAP32[$0 + 112 >> 2] = jsvNewWithFlags(5);
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 112 >> 2], 110430, jsvNewFromInteger(HEAPU8[336650]));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 112 >> 2], 110432, jsvNewFromInteger(HEAPU8[336651]));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 112 >> 2], 110978, jsvNewFromInteger(HEAP8[336652] & 1));
  $2 = HEAP32[$0 + 112 >> 2];
  if (HEAP8[336665] & 1) {
   $1 = HEAPU8[336650] - HEAPU8[336666] | 0;
  } else {
   $1 = 0;
  }
  jsvObjectSetChildAndUnLock($2, 110980, jsvNewFromInteger($1));
  $2 = $0 + 112 | 0;
  $1 = HEAP32[$0 + 112 >> 2];
  if (HEAP8[336665] & 1) {
   $3 = HEAPU8[336651] - HEAPU8[336667] | 0;
  } else {
   $3 = 0;
  }
  jsvObjectSetChildAndUnLock($1, 110983, jsvNewFromInteger($3));
  jsiQueueObjectCallbacks(HEAP32[$0 + 412 >> 2], 110986, $2, 1);
  jsvUnLock(HEAP32[$0 + 112 >> 2]);
  HEAP8[336666] = HEAPU8[336650];
  HEAP8[336667] = HEAPU8[336651];
  HEAP8[336665] = HEAP8[336652] & 1;
 }
 $1 = $0 + 32 | 0;
 jsvUnLock(HEAP32[$0 + 412 >> 2]);
 HEAP32[84158] = 0;
 HEAP32[$0 + 108 >> 2] = jsvObjectGetChild(HEAP32[80546], 110016, 0);
 if (graphicsGetFromVar($1, HEAP32[$0 + 108 >> 2]) & 1) {
  if ((HEAPU8[$0 + 76 | 0] | HEAPU8[$0 + 77 | 0] << 8) << 16 >> 16 >= (HEAPU8[$0 + 72 | 0] | HEAPU8[$0 + 73 | 0] << 8) << 16 >> 16) {
   $1 = $0 + 32 | 0;
   lcdMemLCD_flip($1);
   graphicsSetVar($1);
  }
 }
 jsvUnLock(HEAP32[$0 + 108 >> 2]);
 if (!(HEAPU8[336740] | !HEAP32[84191])) {
  jspromise_resolve(HEAP32[84191], 0);
  jsvUnLock(HEAP32[84191]);
  HEAP32[84191] = 0;
 }
 if (!(HEAPU16[168371] | !HEAP32[84190])) {
  jspromise_resolve(HEAP32[84190], 0);
  jsvUnLock(HEAP32[84190]);
  HEAP32[84190] = 0;
 }
 global$0 = $0 + 416 | 0;
 return 0;
}
function _jswrap_graphics_parseImage($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 144 | 0;
 global$0 = $4;
 HEAP32[$4 + 136 >> 2] = $0;
 HEAP32[$4 + 132 >> 2] = $1;
 HEAP32[$4 + 128 >> 2] = $2;
 HEAP32[$4 + 124 >> 2] = $3;
 memset(HEAP32[$4 + 124 >> 2], 0, 84);
 label$1 : {
  label$2 : {
   label$3 : {
    if (!(jsvIsObject(HEAP32[$4 + 132 >> 2]) & 1)) {
     break label$3;
    }
    if (!(jsvIsInstanceOf(HEAP32[$4 + 132 >> 2], 127133) & 1)) {
     break label$3;
    }
    if (!(graphicsGetFromVar($4 + 48 | 0, HEAP32[$4 + 132 >> 2]) & 1)) {
     HEAP8[$4 + 143 | 0] = 0;
     break label$1;
    }
    if (HEAPU8[$4 + 52 | 0] | HEAPU8[$4 + 53 | 0] << 8 | (HEAPU8[$4 + 54 | 0] << 16 | HEAPU8[$4 + 55 | 0] << 24)) {
     HEAP8[$4 + 143 | 0] = 0;
     break label$1;
    }
    HEAP32[HEAP32[$4 + 124 >> 2] >> 2] = HEAPU8[$4 + 60 | 0] | HEAPU8[$4 + 61 | 0] << 8;
    HEAP32[HEAP32[$4 + 124 >> 2] + 4 >> 2] = HEAPU8[$4 + 62 | 0] | HEAPU8[$4 + 63 | 0] << 8;
    HEAP32[HEAP32[$4 + 124 >> 2] + 8 >> 2] = HEAPU8[$4 + 64 | 0];
    HEAP32[$4 + 44 >> 2] = jsvObjectGetChild(HEAP32[$4 + 132 >> 2], 127455, 0);
    $0 = jsvGetArrayBufferBackingString(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 124 >> 2] + 24 | 0);
    HEAP32[HEAP32[$4 + 124 >> 2] + 20 >> 2] = $0;
    jsvUnLock(HEAP32[$4 + 44 >> 2]);
    break label$2;
   }
   label$6 : {
    if (jsvIsObject(HEAP32[$4 + 132 >> 2]) & 1) {
     $0 = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$4 + 132 >> 2], 127442, 0));
     HEAP32[HEAP32[$4 + 124 >> 2] >> 2] = $0;
     $0 = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$4 + 132 >> 2], 127448, 0));
     HEAP32[HEAP32[$4 + 124 >> 2] + 4 >> 2] = $0;
     $0 = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$4 + 132 >> 2], 127863, 0));
     HEAP32[HEAP32[$4 + 124 >> 2] + 8 >> 2] = $0;
     if (HEAP32[HEAP32[$4 + 124 >> 2] + 8 >> 2] <= 0) {
      HEAP32[HEAP32[$4 + 124 >> 2] + 8 >> 2] = 1;
     }
     HEAP32[$4 + 40 >> 2] = jsvObjectGetChild(HEAP32[$4 + 132 >> 2], 127867, 0);
     HEAP8[HEAP32[$4 + 124 >> 2] + 12 | 0] = HEAP32[$4 + 40 >> 2] != 0;
     $0 = jsvGetIntegerAndUnLock(HEAP32[$4 + 40 >> 2]);
     HEAP32[HEAP32[$4 + 124 >> 2] + 16 >> 2] = $0;
     HEAP32[$4 + 40 >> 2] = jsvObjectGetChild(HEAP32[$4 + 132 >> 2], 128183, 0);
     if (HEAP32[$4 + 40 >> 2]) {
      label$10 : {
       label$11 : {
        if (!(jsvIsArrayBuffer(HEAP32[$4 + 40 >> 2]) & 1)) {
         break label$11;
        }
        $0 = HEAP32[$4 + 40 >> 2];
        if ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8) != 2) {
         break label$11;
        }
        HEAP32[$4 + 36 >> 2] = 0;
        $0 = jsvGetDataPointer(HEAP32[$4 + 40 >> 2], $4 + 36 | 0);
        HEAP32[HEAP32[$4 + 124 >> 2] + 28 >> 2] = $0;
        jsvUnLock(HEAP32[$4 + 40 >> 2]);
        label$12 : {
         label$13 : {
          if (!(HEAP32[$4 + 36 >> 2] == 2 | HEAP32[$4 + 36 >> 2] == 4 | (HEAP32[$4 + 36 >> 2] == 8 | HEAP32[$4 + 36 >> 2] == 16))) {
           if (HEAP32[$4 + 36 >> 2] != 256) {
            break label$13;
           }
          }
          HEAP32[HEAP32[$4 + 124 >> 2] + 32 >> 2] = HEAP32[$4 + 36 >> 2] - 1;
          break label$12;
         }
         HEAP32[HEAP32[$4 + 124 >> 2] + 28 >> 2] = 0;
        }
        break label$10;
       }
       jsvUnLock(HEAP32[$4 + 40 >> 2]);
      }
      if (!HEAP32[HEAP32[$4 + 124 >> 2] + 28 >> 2]) {
       jsExceptionHere(1, 128191, 0);
       HEAP8[$4 + 143 | 0] = 0;
       break label$1;
      }
     }
     HEAP32[$4 + 32 >> 2] = jsvObjectGetChild(HEAP32[$4 + 132 >> 2], 127455, 0);
     $0 = jsvGetArrayBufferBackingString(HEAP32[$4 + 32 >> 2], HEAP32[$4 + 124 >> 2] + 24 | 0);
     HEAP32[HEAP32[$4 + 124 >> 2] + 20 >> 2] = $0;
     jsvUnLock(HEAP32[$4 + 32 >> 2]);
     $0 = HEAP32[$4 + 124 >> 2];
     HEAP32[$0 + 24 >> 2] = HEAP32[$4 + 128 >> 2] + HEAP32[$0 + 24 >> 2];
     break label$6;
    }
    label$16 : {
     label$17 : {
      if (!(jsvIsString(HEAP32[$4 + 132 >> 2]) & 1)) {
       if (!(jsvIsArrayBuffer(HEAP32[$4 + 132 >> 2]) & 1)) {
        break label$17;
       }
      }
      label$19 : {
       if (jsvIsArrayBuffer(HEAP32[$4 + 132 >> 2]) & 1) {
        $0 = jsvGetArrayBufferBackingString(HEAP32[$4 + 132 >> 2], HEAP32[$4 + 124 >> 2] + 24 | 0);
        break label$19;
       }
       $0 = jsvLockAgain(HEAP32[$4 + 132 >> 2]);
      }
      HEAP32[HEAP32[$4 + 124 >> 2] + 20 >> 2] = $0;
      $0 = jsvGetCharInString(HEAP32[HEAP32[$4 + 124 >> 2] + 20 >> 2], HEAP32[$4 + 128 >> 2]);
      HEAP32[HEAP32[$4 + 124 >> 2] >> 2] = $0 & 255;
      $0 = jsvGetCharInString(HEAP32[HEAP32[$4 + 124 >> 2] + 20 >> 2], HEAP32[$4 + 128 >> 2] + 1 | 0);
      HEAP32[HEAP32[$4 + 124 >> 2] + 4 >> 2] = $0 & 255;
      $0 = jsvGetCharInString(HEAP32[HEAP32[$4 + 124 >> 2] + 20 >> 2], HEAP32[$4 + 128 >> 2] + 2 | 0);
      HEAP32[HEAP32[$4 + 124 >> 2] + 8 >> 2] = $0 & 255;
      $0 = HEAP32[$4 + 124 >> 2];
      HEAP32[$0 + 24 >> 2] = HEAP32[$4 + 128 >> 2] + HEAP32[$0 + 24 >> 2];
      label$21 : {
       if (HEAP32[HEAP32[$4 + 124 >> 2] + 8 >> 2] & 128) {
        HEAP32[HEAP32[$4 + 124 >> 2] + 8 >> 2] = HEAP32[HEAP32[$4 + 124 >> 2] + 8 >> 2] & 127;
        HEAP8[HEAP32[$4 + 124 >> 2] + 12 | 0] = 1;
        $0 = jsvGetCharInString(HEAP32[HEAP32[$4 + 124 >> 2] + 20 >> 2], HEAP32[$4 + 128 >> 2] + 3 | 0);
        HEAP32[HEAP32[$4 + 124 >> 2] + 16 >> 2] = $0 & 255;
        HEAP16[HEAP32[$4 + 124 >> 2] + 48 >> 1] = 4;
        break label$21;
       }
       HEAP16[HEAP32[$4 + 124 >> 2] + 48 >> 1] = 3;
      }
      $0 = HEAP32[$4 + 124 >> 2];
      HEAP32[$0 + 24 >> 2] = HEAPU16[HEAP32[$4 + 124 >> 2] + 48 >> 1] + HEAP32[$0 + 24 >> 2];
      if (HEAP32[HEAP32[$4 + 124 >> 2] + 8 >> 2] & 64) {
       HEAP32[HEAP32[$4 + 124 >> 2] + 8 >> 2] = HEAP32[HEAP32[$4 + 124 >> 2] + 8 >> 2] & 63;
       HEAP32[$4 + 28 >> 2] = 1 << HEAP32[HEAP32[$4 + 124 >> 2] + 8 >> 2];
       HEAP32[HEAP32[$4 + 124 >> 2] + 32 >> 2] = HEAP32[$4 + 28 >> 2] - 1;
       label$24 : {
        if (HEAP32[$4 + 28 >> 2] << 1 >>> 0 <= 32) {
         HEAP32[$4 + 24 >> 2] = HEAP32[HEAP32[$4 + 124 >> 2] + 24 >> 2];
         HEAP32[$4 + 20 >> 2] = 0;
         while (1) {
          if (HEAP32[$4 + 20 >> 2] < HEAP32[$4 + 28 >> 2]) {
           $0 = jsvGetCharInString(HEAP32[HEAP32[$4 + 124 >> 2] + 20 >> 2], HEAP32[$4 + 24 >> 2]) & 255;
           $1 = jsvGetCharInString(HEAP32[HEAP32[$4 + 124 >> 2] + 20 >> 2], HEAP32[$4 + 24 >> 2] + 1 | 0);
           HEAP16[(HEAP32[$4 + 124 >> 2] + 52 | 0) + (HEAP32[$4 + 20 >> 2] << 1) >> 1] = $0 | ($1 & 255) << 8;
           HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 24 >> 2] + 2;
           HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 20 >> 2] + 1;
           continue;
          }
          break;
         }
         HEAP32[HEAP32[$4 + 124 >> 2] + 28 >> 2] = HEAP32[$4 + 124 >> 2] + 52;
         break label$24;
        }
        if (HEAP32[HEAP32[$4 + 124 >> 2] + 8 >> 2] <= 8) {
         HEAP32[$4 + 16 >> 2] = HEAP32[HEAP32[$4 + 124 >> 2] + 24 >> 2] + (HEAP32[$4 + 28 >> 2] << 1);
         HEAP32[$4 + 12 >> 2] = 0;
         HEAP32[$4 + 8 >> 2] = jsvGetDataPointer(HEAP32[HEAP32[$4 + 124 >> 2] + 20 >> 2], $4 + 12 | 0);
         if (!(!HEAP32[$4 + 8 >> 2] | HEAP32[HEAP32[$4 + 124 >> 2] + 8 >> 2] > 8 | HEAPU32[$4 + 16 >> 2] >= HEAPU32[$4 + 12 >> 2])) {
          HEAP32[HEAP32[$4 + 124 >> 2] + 32 >> 2] = HEAP32[$4 + 28 >> 2] - 1;
          HEAP32[HEAP32[$4 + 124 >> 2] + 28 >> 2] = HEAP32[$4 + 8 >> 2] + (HEAP32[HEAP32[$4 + 124 >> 2] + 24 >> 2] + HEAPU16[HEAP32[$4 + 124 >> 2] + 48 >> 1] | 0);
         }
        }
       }
       if (!HEAP32[HEAP32[$4 + 124 >> 2] + 28 >> 2]) {
        jsExceptionHere(1, 128266, 0);
        _jswrap_graphics_freeImageInfo(HEAP32[$4 + 124 >> 2]);
        HEAP8[$4 + 143 | 0] = 0;
        break label$1;
       }
       $0 = HEAP32[$4 + 124 >> 2];
       HEAP16[$0 + 48 >> 1] = HEAPU16[$0 + 48 >> 1] + (HEAP32[$4 + 28 >> 2] << 1 & 65535);
       $0 = HEAP32[$4 + 124 >> 2];
       HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 24 >> 2] + (HEAP32[$4 + 28 >> 2] << 1 & 65535);
      }
      break label$16;
     }
     jsExceptionHere(1, 128316, 0);
     HEAP8[$4 + 143 | 0] = 0;
     break label$1;
    }
   }
  }
  if (!(HEAP8[HEAP32[$4 + 124 >> 2] + 12 | 0] & 1)) {
   HEAP32[HEAP32[$4 + 124 >> 2] + 16 >> 2] = -1;
  }
  if (!HEAP32[HEAP32[$4 + 124 >> 2] + 28 >> 2]) {
   label$33 : {
    if (HEAP32[HEAP32[$4 + 124 >> 2] + 8 >> 2] == 1) {
     $0 = HEAP32[$4 + 136 >> 2];
     HEAP16[HEAP32[$4 + 124 >> 2] + 52 >> 1] = HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24);
     $0 = HEAP32[$4 + 136 >> 2];
     HEAP16[HEAP32[$4 + 124 >> 2] + 54 >> 1] = HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24);
     HEAP32[HEAP32[$4 + 124 >> 2] + 28 >> 2] = HEAP32[$4 + 124 >> 2] + 52;
     HEAP32[HEAP32[$4 + 124 >> 2] + 32 >> 2] = 1;
     break label$33;
    }
    label$35 : {
     if (HEAP32[HEAP32[$4 + 124 >> 2] + 8 >> 2] == 2) {
      $0 = HEAP32[$4 + 136 >> 2];
      HEAP16[HEAP32[$4 + 124 >> 2] + 52 >> 1] = HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24);
      $0 = graphicsBlendGfxColor(HEAP32[$4 + 136 >> 2], 85);
      HEAP16[HEAP32[$4 + 124 >> 2] + 54 >> 1] = $0;
      $0 = graphicsBlendGfxColor(HEAP32[$4 + 136 >> 2], 171);
      HEAP16[HEAP32[$4 + 124 >> 2] + 56 >> 1] = $0;
      $0 = HEAP32[$4 + 136 >> 2];
      HEAP16[HEAP32[$4 + 124 >> 2] + 58 >> 1] = HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24);
      HEAP32[HEAP32[$4 + 124 >> 2] + 28 >> 2] = HEAP32[$4 + 124 >> 2] + 52;
      HEAP32[HEAP32[$4 + 124 >> 2] + 32 >> 2] = 3;
      break label$35;
     }
     label$37 : {
      if (!(HEAPU8[HEAP32[$4 + 136 >> 2] + 16 | 0] != 16 | HEAP32[HEAP32[$4 + 124 >> 2] + 8 >> 2] != 3)) {
       HEAP32[HEAP32[$4 + 124 >> 2] + 28 >> 2] = 126496;
       HEAP32[HEAP32[$4 + 124 >> 2] + 32 >> 2] = 7;
       break label$37;
      }
      label$39 : {
       if (!(HEAPU8[HEAP32[$4 + 136 >> 2] + 16 | 0] != 16 | HEAP32[HEAP32[$4 + 124 >> 2] + 8 >> 2] != 4)) {
        HEAP32[HEAP32[$4 + 124 >> 2] + 28 >> 2] = 126528;
        HEAP32[HEAP32[$4 + 124 >> 2] + 32 >> 2] = 15;
        break label$39;
       }
       label$41 : {
        if (!(HEAPU8[HEAP32[$4 + 136 >> 2] + 16 | 0] != 16 | HEAP32[HEAP32[$4 + 124 >> 2] + 8 >> 2] != 8)) {
         HEAP32[HEAP32[$4 + 124 >> 2] + 28 >> 2] = 126560;
         HEAP32[HEAP32[$4 + 124 >> 2] + 32 >> 2] = 255;
         break label$41;
        }
        if (!(HEAPU8[HEAP32[$4 + 136 >> 2] + 16 | 0] != 8 | HEAP32[HEAP32[$4 + 124 >> 2] + 8 >> 2] != 4)) {
         HEAP32[HEAP32[$4 + 124 >> 2] + 28 >> 2] = 127072;
         HEAP32[HEAP32[$4 + 124 >> 2] + 32 >> 2] = 15;
        }
       }
      }
     }
    }
   }
  }
  label$44 : {
   if (!(!(jsvIsString(HEAP32[HEAP32[$4 + 124 >> 2] + 20 >> 2]) & 1) | HEAP32[HEAP32[$4 + 124 >> 2] >> 2] <= 0 | HEAP32[HEAP32[$4 + 124 >> 2] + 4 >> 2] <= 0)) {
    if (HEAP32[HEAP32[$4 + 124 >> 2] + 8 >> 2] <= 32) {
     break label$44;
    }
   }
   jsExceptionHere(1, 128369, 0);
   _jswrap_graphics_freeImageInfo(HEAP32[$4 + 124 >> 2]);
   HEAP8[$4 + 143 | 0] = 0;
   break label$1;
  }
  HEAP32[HEAP32[$4 + 124 >> 2] + 36 >> 2] = (1 << HEAP32[HEAP32[$4 + 124 >> 2] + 8 >> 2]) - 1;
  $0 = HEAP32[$4 + 124 >> 2];
  if (HEAP32[HEAP32[$4 + 124 >> 2] + 8 >> 2] < 8) {
   $1 = (8 / HEAP32[HEAP32[$4 + 124 >> 2] + 8 >> 2] | 0) - 1 | 0;
  } else {
   $1 = 0;
  }
  HEAP32[$0 + 40 >> 2] = $1;
  HEAP32[HEAP32[$4 + 124 >> 2] + 44 >> 2] = Math_imul(HEAP32[HEAP32[$4 + 124 >> 2] >> 2], HEAP32[HEAP32[$4 + 124 >> 2] + 8 >> 2]) + 7 >> 3;
  HEAP16[HEAP32[$4 + 124 >> 2] + 50 >> 1] = Math_imul(HEAP32[HEAP32[$4 + 124 >> 2] + 8 >> 2], Math_imul(HEAP32[HEAP32[$4 + 124 >> 2] >> 2], HEAP32[HEAP32[$4 + 124 >> 2] + 4 >> 2])) + 7 >> 3;
  HEAP8[$4 + 143 | 0] = 1;
 }
 global$0 = $4 + 144 | 0;
 return HEAP8[$4 + 143 | 0] & 1;
}
function gemmlowp__FixedPoint_int_2c_200__20gemmlowp__exp_on_negative_values_int_2c_205__28gemmlowp__FixedPoint_int_2c_205__29($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0;
 $1 = global$0 - 496 | 0;
 global$0 = $1;
 $6 = $1 + 24 | 0;
 $2 = $1 + 488 | 0;
 $3 = $1 + 480 | 0;
 $7 = $1 + 16 | 0;
 $8 = $1 - -64 | 0;
 $9 = $1 + 32 | 0;
 $10 = $1 + 72 | 0;
 $11 = $1 + 40 | 0;
 $12 = $1 + 48 | 0;
 $13 = $1 + 112 | 0;
 $14 = $1 + 80 | 0;
 $15 = $1 + 120 | 0;
 $16 = $1 + 88 | 0;
 $17 = $1 + 96 | 0;
 $18 = $1 + 160 | 0;
 $19 = $1 + 128 | 0;
 $20 = $1 + 168 | 0;
 $21 = $1 + 136 | 0;
 $22 = $1 + 144 | 0;
 $23 = $1 + 208 | 0;
 $24 = $1 + 176 | 0;
 $25 = $1 + 216 | 0;
 $26 = $1 + 184 | 0;
 $27 = $1 + 192 | 0;
 $28 = $1 + 256 | 0;
 $29 = $1 + 224 | 0;
 $30 = $1 + 264 | 0;
 $31 = $1 + 232 | 0;
 $32 = $1 + 240 | 0;
 $33 = $1 + 304 | 0;
 $34 = $1 + 272 | 0;
 $35 = $1 + 312 | 0;
 $36 = $1 + 280 | 0;
 $37 = $1 + 288 | 0;
 $38 = $1 + 352 | 0;
 $39 = $1 + 320 | 0;
 $40 = $1 + 360 | 0;
 $41 = $1 + 328 | 0;
 $42 = $1 + 336 | 0;
 $43 = $1 + 384 | 0;
 $44 = $1 + 368 | 0;
 $4 = $1 + 440 | 0;
 $45 = $1 + 376 | 0;
 $46 = $1 + 392 | 0;
 $5 = $1 + 472 | 0;
 $47 = $1 + 408 | 0;
 $48 = $1 + 464 | 0;
 $49 = $1 + 416 | 0;
 $50 = $1 + 424 | 0;
 $51 = $1 + 456 | 0;
 HEAP32[$1 + 480 >> 2] = $0;
 HEAP32[$1 + 472 >> 2] = gemmlowp__FixedPoint_int_2c_205__20gemmlowp__FixedPoint_int_2c_205___ConstantPOT__2__28_29();
 HEAP32[$51 >> 2] = HEAP32[$5 >> 2];
 HEAP32[$1 + 448 >> 2] = gemmlowp__FixedPoint_int_2c_2012___FromScalarRaw_28int_29(1);
 HEAP32[$1 + 464 >> 2] = gemmlowp__FixedPoint_int_2c_205__20gemmlowp__operator__int_2c_205__28gemmlowp__FixedPoint_int_2c_205__2c_20gemmlowp__FixedPoint_int_2c_205__29(HEAP32[$1 + 456 >> 2], HEAP32[$1 + 448 >> 2]);
 HEAP32[$50 >> 2] = HEAP32[$3 >> 2];
 HEAP32[$49 >> 2] = HEAP32[$48 >> 2];
 HEAP32[$1 + 432 >> 2] = gemmlowp__FixedPoint_int_2c_205__20gemmlowp__operator__int_2c_205__28gemmlowp__FixedPoint_int_2c_205__2c_20gemmlowp__FixedPoint_int_2c_205__29_1(HEAP32[$1 + 424 >> 2], HEAP32[$1 + 416 >> 2]);
 HEAP32[$47 >> 2] = HEAP32[$5 >> 2];
 HEAP32[$1 + 440 >> 2] = gemmlowp__FixedPoint_int_2c_205__20gemmlowp__operator__int_2c_205__28gemmlowp__FixedPoint_int_2c_205__2c_20gemmlowp__FixedPoint_int_2c_205__29(HEAP32[$1 + 432 >> 2], HEAP32[$1 + 408 >> 2]);
 HEAP32[$46 >> 2] = HEAP32[$4 >> 2];
 HEAP32[$1 + 400 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__Rescale_0_2c_20int_2c_205__28gemmlowp__FixedPoint_int_2c_205__29(HEAP32[$1 + 392 >> 2]);
 HEAP32[$1 + 488 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__exp_on_interval_between_negative_one_quarter_and_0_excl_int__28gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 400 >> 2]);
 HEAP32[$45 >> 2] = HEAP32[$4 >> 2];
 HEAP32[$44 >> 2] = HEAP32[$3 >> 2];
 HEAP32[$1 + 384 >> 2] = gemmlowp__FixedPoint_int_2c_205__20gemmlowp__operator__int_2c_205__28gemmlowp__FixedPoint_int_2c_205__2c_20gemmlowp__FixedPoint_int_2c_205__29(HEAP32[$1 + 376 >> 2], HEAP32[$1 + 368 >> 2]);
 HEAP32[$1 + 388 >> 2] = HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($43) >> 2];
 HEAP32[$1 + 360 >> 2] = gemmlowp__FixedPoint_int_2c_2012___FromScalarRaw_28int_29(gemmlowp__FixedPoint_int_2c_200___ScalarRawType_20gemmlowp__RescaleConstantInitializer_gemmlowp__FixedPoint_int_2c_200__20__28int_29(1672461947));
 $0 = int_20gemmlowp__MaskIfNonZero_int__28int_29(int_20gemmlowp__BitAnd_int__28int_2c_20int_29(HEAP32[$1 + 388 >> 2], tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(16777216)));
 HEAP32[$42 >> 2] = HEAP32[$2 >> 2];
 HEAP32[$41 >> 2] = HEAP32[$40 >> 2];
 HEAP32[$1 + 344 >> 2] = gemmlowp__FixedPoint_int_2c_20_280_29_20__20_280_29__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 336 >> 2], HEAP32[$1 + 328 >> 2]);
 HEAP32[$39 >> 2] = HEAP32[$2 >> 2];
 HEAP32[$1 + 352 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__SelectUsingMask_int_2c_200__28int_2c_20gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29($0, HEAP32[$1 + 344 >> 2], HEAP32[$1 + 320 >> 2]);
 HEAP32[$2 >> 2] = HEAP32[$38 >> 2];
 HEAP32[$1 + 312 >> 2] = gemmlowp__FixedPoint_int_2c_2012___FromScalarRaw_28int_29(gemmlowp__FixedPoint_int_2c_200___ScalarRawType_20gemmlowp__RescaleConstantInitializer_gemmlowp__FixedPoint_int_2c_200__20__28int_29(1302514674));
 $0 = int_20gemmlowp__MaskIfNonZero_int__28int_29(int_20gemmlowp__BitAnd_int__28int_2c_20int_29(HEAP32[$1 + 388 >> 2], tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(33554432)));
 HEAP32[$37 >> 2] = HEAP32[$2 >> 2];
 HEAP32[$36 >> 2] = HEAP32[$35 >> 2];
 HEAP32[$1 + 296 >> 2] = gemmlowp__FixedPoint_int_2c_20_280_29_20__20_280_29__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 288 >> 2], HEAP32[$1 + 280 >> 2]);
 HEAP32[$34 >> 2] = HEAP32[$2 >> 2];
 HEAP32[$1 + 304 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__SelectUsingMask_int_2c_200__28int_2c_20gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29($0, HEAP32[$1 + 296 >> 2], HEAP32[$1 + 272 >> 2]);
 HEAP32[$2 >> 2] = HEAP32[$33 >> 2];
 HEAP32[$1 + 264 >> 2] = gemmlowp__FixedPoint_int_2c_2012___FromScalarRaw_28int_29(gemmlowp__FixedPoint_int_2c_200___ScalarRawType_20gemmlowp__RescaleConstantInitializer_gemmlowp__FixedPoint_int_2c_200__20__28int_29(790015084));
 $0 = int_20gemmlowp__MaskIfNonZero_int__28int_29(int_20gemmlowp__BitAnd_int__28int_2c_20int_29(HEAP32[$1 + 388 >> 2], tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(67108864)));
 HEAP32[$32 >> 2] = HEAP32[$2 >> 2];
 HEAP32[$31 >> 2] = HEAP32[$30 >> 2];
 HEAP32[$1 + 248 >> 2] = gemmlowp__FixedPoint_int_2c_20_280_29_20__20_280_29__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 240 >> 2], HEAP32[$1 + 232 >> 2]);
 HEAP32[$29 >> 2] = HEAP32[$2 >> 2];
 HEAP32[$1 + 256 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__SelectUsingMask_int_2c_200__28int_2c_20gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29($0, HEAP32[$1 + 248 >> 2], HEAP32[$1 + 224 >> 2]);
 HEAP32[$2 >> 2] = HEAP32[$28 >> 2];
 HEAP32[$1 + 216 >> 2] = gemmlowp__FixedPoint_int_2c_2012___FromScalarRaw_28int_29(gemmlowp__FixedPoint_int_2c_200___ScalarRawType_20gemmlowp__RescaleConstantInitializer_gemmlowp__FixedPoint_int_2c_200__20__28int_29(290630308));
 $0 = int_20gemmlowp__MaskIfNonZero_int__28int_29(int_20gemmlowp__BitAnd_int__28int_2c_20int_29(HEAP32[$1 + 388 >> 2], tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(134217728)));
 HEAP32[$27 >> 2] = HEAP32[$2 >> 2];
 HEAP32[$26 >> 2] = HEAP32[$25 >> 2];
 HEAP32[$1 + 200 >> 2] = gemmlowp__FixedPoint_int_2c_20_280_29_20__20_280_29__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 192 >> 2], HEAP32[$1 + 184 >> 2]);
 HEAP32[$24 >> 2] = HEAP32[$2 >> 2];
 HEAP32[$1 + 208 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__SelectUsingMask_int_2c_200__28int_2c_20gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29($0, HEAP32[$1 + 200 >> 2], HEAP32[$1 + 176 >> 2]);
 HEAP32[$2 >> 2] = HEAP32[$23 >> 2];
 HEAP32[$1 + 168 >> 2] = gemmlowp__FixedPoint_int_2c_2012___FromScalarRaw_28int_29(gemmlowp__FixedPoint_int_2c_200___ScalarRawType_20gemmlowp__RescaleConstantInitializer_gemmlowp__FixedPoint_int_2c_200__20__28int_29(39332535));
 $0 = int_20gemmlowp__MaskIfNonZero_int__28int_29(int_20gemmlowp__BitAnd_int__28int_2c_20int_29(HEAP32[$1 + 388 >> 2], tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(268435456)));
 HEAP32[$22 >> 2] = HEAP32[$2 >> 2];
 HEAP32[$21 >> 2] = HEAP32[$20 >> 2];
 HEAP32[$1 + 152 >> 2] = gemmlowp__FixedPoint_int_2c_20_280_29_20__20_280_29__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 144 >> 2], HEAP32[$1 + 136 >> 2]);
 HEAP32[$19 >> 2] = HEAP32[$2 >> 2];
 HEAP32[$1 + 160 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__SelectUsingMask_int_2c_200__28int_2c_20gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29($0, HEAP32[$1 + 152 >> 2], HEAP32[$1 + 128 >> 2]);
 HEAP32[$2 >> 2] = HEAP32[$18 >> 2];
 HEAP32[$1 + 120 >> 2] = gemmlowp__FixedPoint_int_2c_2012___FromScalarRaw_28int_29(gemmlowp__FixedPoint_int_2c_200___ScalarRawType_20gemmlowp__RescaleConstantInitializer_gemmlowp__FixedPoint_int_2c_200__20__28int_29(720401));
 $0 = int_20gemmlowp__MaskIfNonZero_int__28int_29(int_20gemmlowp__BitAnd_int__28int_2c_20int_29(HEAP32[$1 + 388 >> 2], tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(536870912)));
 HEAP32[$17 >> 2] = HEAP32[$2 >> 2];
 HEAP32[$16 >> 2] = HEAP32[$15 >> 2];
 HEAP32[$1 + 104 >> 2] = gemmlowp__FixedPoint_int_2c_20_280_29_20__20_280_29__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 96 >> 2], HEAP32[$1 + 88 >> 2]);
 HEAP32[$14 >> 2] = HEAP32[$2 >> 2];
 HEAP32[$1 + 112 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__SelectUsingMask_int_2c_200__28int_2c_20gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29($0, HEAP32[$1 + 104 >> 2], HEAP32[$1 + 80 >> 2]);
 HEAP32[$2 >> 2] = HEAP32[$13 >> 2];
 HEAP32[$1 + 72 >> 2] = gemmlowp__FixedPoint_int_2c_2012___FromScalarRaw_28int_29(gemmlowp__FixedPoint_int_2c_200___ScalarRawType_20gemmlowp__RescaleConstantInitializer_gemmlowp__FixedPoint_int_2c_200__20__28int_29(242));
 $0 = int_20gemmlowp__MaskIfNonZero_int__28int_29(int_20gemmlowp__BitAnd_int__28int_2c_20int_29(HEAP32[$1 + 388 >> 2], tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(1073741824)));
 HEAP32[$12 >> 2] = HEAP32[$2 >> 2];
 HEAP32[$11 >> 2] = HEAP32[$10 >> 2];
 HEAP32[$1 + 56 >> 2] = gemmlowp__FixedPoint_int_2c_20_280_29_20__20_280_29__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 48 >> 2], HEAP32[$1 + 40 >> 2]);
 HEAP32[$9 >> 2] = HEAP32[$2 >> 2];
 HEAP32[$1 + 64 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__SelectUsingMask_int_2c_200__28int_2c_20gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29($0, HEAP32[$1 + 56 >> 2], HEAP32[$1 + 32 >> 2]);
 HEAP32[$2 >> 2] = HEAP32[$8 >> 2];
 HEAP32[$7 >> 2] = HEAP32[$3 >> 2];
 $0 = int_20gemmlowp__MaskIfZero_int_2c_205__28gemmlowp__FixedPoint_int_2c_205__29(HEAP32[$1 + 16 >> 2]);
 HEAP32[$1 + 8 >> 2] = gemmlowp__FixedPoint_int_2c_200___One_28_29();
 HEAP32[$1 >> 2] = HEAP32[$2 >> 2];
 HEAP32[$1 + 24 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__SelectUsingMask_int_2c_200__28int_2c_20gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29($0, HEAP32[$1 + 8 >> 2], HEAP32[$1 >> 2]);
 HEAP32[$2 >> 2] = HEAP32[$6 >> 2];
 global$0 = $1 + 496 | 0;
 return HEAP32[$1 + 488 >> 2];
}
function jsiHandleChar($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP8[$1 + 31 | 0] = $0;
 label$1 : {
  if (jsiPasswordProtected() & 1) {
   if (!(HEAP8[$1 + 31 | 0] != 10 ? HEAP8[$1 + 31 | 0] != 13 : 0)) {
    HEAP32[$1 + 24 >> 2] = jsvObjectGetChild(HEAP32[80546], 81366, 0);
    label$5 : {
     if (!HEAP32[$1 + 24 >> 2]) {
      break label$5;
     }
     if (jsvCompareString(HEAP32[80557], HEAP32[$1 + 24 >> 2], 0, 0)) {
      break label$5;
     }
     HEAP16[161112] = HEAPU16[161112] & -1025;
    }
    jsvUnLock(HEAP32[$1 + 24 >> 2]);
    jsiClearInputLine(0);
    label$6 : {
     if (jsiPasswordProtected() & 1) {
      jsiConsolePrintString(81743);
      break label$6;
     }
     jsiConsolePrintString(81773);
     HEAP8[322232] = 1;
     jsiConsoleReturnInputLine();
    }
    break label$1;
   }
   HEAP8[$1 + 22 | 0] = HEAPU8[$1 + 31 | 0];
   HEAP8[$1 + 23 | 0] = 0;
   if (jsvGetStringLength(HEAP32[80557]) >>> 0 < 20) {
    jsiAppendToInputLine($1 + 22 | 0);
   }
   break label$1;
  }
  if (!HEAP8[$1 + 31 | 0]) {
   HEAP8[322240] = 0;
   break label$1;
  }
  label$10 : {
   if (HEAP8[$1 + 31 | 0] == 1) {
    jsiHandleHome();
    break label$10;
   }
   label$12 : {
    if (HEAP8[$1 + 31 | 0] == 4) {
     jsiHandleDelete(0);
     break label$12;
    }
    label$14 : {
     if (HEAP8[$1 + 31 | 0] == 5) {
      jsiHandleEnd();
      break label$14;
     }
     label$16 : {
      if (!(HEAP8[$1 + 31 | 0] != 23 ? HEAP8[$1 + 31 | 0] != 21 : 0)) {
       jsiClearInputLine(1);
       break label$16;
      }
      label$19 : {
       if (HEAP8[$1 + 31 | 0] == 27) {
        HEAP8[322240] = 2;
        break label$19;
       }
       label$21 : {
        if (HEAPU8[322240] == 2) {
         HEAP8[322240] = 0;
         label$23 : {
          if (HEAP8[$1 + 31 | 0] == 79) {
           HEAP8[322240] = 3;
           break label$23;
          }
          label$25 : {
           if (HEAP8[$1 + 31 | 0] == 91) {
            HEAP8[322240] = 4;
            break label$25;
           }
           if (HEAP8[$1 + 31 | 0] == 10) {
            jsiHandleNewLine(0);
           }
          }
         }
         break label$21;
        }
        label$28 : {
         if (HEAPU8[322240] == 3) {
          HEAP8[322240] = 0;
          label$30 : {
           if (HEAP8[$1 + 31 | 0] == 70) {
            jsiHandleEnd();
            break label$30;
           }
           label$32 : {
            if (HEAP8[$1 + 31 | 0] == 72) {
             jsiHandleHome();
             break label$32;
            }
            label$34 : {
             if (HEAP8[$1 + 31 | 0] == 111) {
              jsiHandleChar(47);
              break label$34;
             }
             label$36 : {
              if (HEAP8[$1 + 31 | 0] == 106) {
               jsiHandleChar(42);
               break label$36;
              }
              label$38 : {
               if (HEAP8[$1 + 31 | 0] == 109) {
                jsiHandleChar(45);
                break label$38;
               }
               label$40 : {
                if (HEAP8[$1 + 31 | 0] == 107) {
                 jsiHandleChar(43);
                 break label$40;
                }
                if (HEAP8[$1 + 31 | 0] == 77) {
                 jsiHandleChar(13);
                }
               }
              }
             }
            }
           }
          }
          break label$28;
         }
         label$43 : {
          if (HEAPU8[322240] == 4) {
           HEAP8[322240] = 0;
           label$45 : {
            if (!(HEAP8[$1 + 31 | 0] < 48 | HEAP8[$1 + 31 | 0] > 57)) {
             HEAP16[161151] = HEAP8[$1 + 31 | 0] - 48;
             HEAP8[322240] = 5;
             break label$45;
            }
            label$47 : {
             if (HEAP8[$1 + 31 | 0] == 68) {
              if (HEAPU32[80559] <= 0) {
               break label$47;
              }
              if ((jsvGetCharInString(HEAP32[80557], HEAP32[80559] - 1 | 0) & 255) == 10) {
               break label$47;
              }
              HEAP32[80559] = HEAP32[80559] + -1;
              if (jsiShowInputLine() & 1) {
               jsiConsolePrintString(81047);
              }
              break label$47;
             }
             label$50 : {
              if (HEAP8[$1 + 31 | 0] == 67) {
               if (HEAPU32[80559] >= jsvGetStringLength(HEAP32[80557]) >>> 0) {
                break label$50;
               }
               if ((jsvGetCharInString(HEAP32[80557], HEAP32[80559]) & 255) == 10) {
                break label$50;
               }
               HEAP32[80559] = HEAP32[80559] + 1;
               if (jsiShowInputLine() & 1) {
                jsiConsolePrintString(81043);
               }
               break label$50;
              }
              label$53 : {
               if (HEAP8[$1 + 31 | 0] == 65) {
                HEAP32[$1 + 16 >> 2] = jsvGetStringLength(HEAP32[80557]);
                label$55 : {
                 label$56 : {
                  if (HEAP32[$1 + 16 >> 2]) {
                   if (!(jsiIsInHistory(HEAP32[80557]) & 1)) {
                    break label$56;
                   }
                  }
                  if (HEAP32[80559] != HEAP32[$1 + 16 >> 2]) {
                   break label$56;
                  }
                  jsiChangeToHistory(1);
                  break label$55;
                 }
                 jsiHandleMoveUpDown(-1);
                }
                break label$53;
               }
               label$58 : {
                if (HEAP8[$1 + 31 | 0] == 66) {
                 HEAP32[$1 + 12 >> 2] = jsvGetStringLength(HEAP32[80557]);
                 label$60 : {
                  label$61 : {
                   if (HEAP32[$1 + 12 >> 2]) {
                    if (!(jsiIsInHistory(HEAP32[80557]) & 1)) {
                     break label$61;
                    }
                   }
                   if (HEAP32[80559] != HEAP32[$1 + 12 >> 2]) {
                    break label$61;
                   }
                   jsiChangeToHistory(0);
                   break label$60;
                  }
                  jsiHandleMoveUpDown(1);
                 }
                 break label$58;
                }
                label$63 : {
                 if (HEAP8[$1 + 31 | 0] == 70) {
                  jsiHandleEnd();
                  break label$63;
                 }
                 if (HEAP8[$1 + 31 | 0] == 72) {
                  jsiHandleHome();
                 }
                }
               }
              }
             }
            }
           }
           break label$43;
          }
          label$66 : {
           if (HEAPU8[322240] == 5) {
            if (!(HEAP8[$1 + 31 | 0] < 48 | HEAP8[$1 + 31 | 0] > 57)) {
             HEAP16[161151] = (HEAP8[$1 + 31 | 0] + Math_imul(HEAPU16[161151], 10) | 0) - 48;
             break label$66;
            }
            label$69 : {
             if (HEAP8[$1 + 31 | 0] == 100) {
              HEAP16[161124] = HEAPU16[161151];
              break label$69;
             }
             label$71 : {
              if (HEAP8[$1 + 31 | 0] == 72) {
               if (HEAPU16[161151] == 2) {
                jsiClearInputLine(1);
               }
               break label$71;
              }
              if (HEAP8[$1 + 31 | 0] == 126) {
               label$75 : {
                if (HEAPU16[161151] == 1) {
                 jsiHandleHome();
                 break label$75;
                }
                label$77 : {
                 if (HEAPU16[161151] == 3) {
                  jsiHandleDelete(0);
                  break label$77;
                 }
                 label$79 : {
                  if (HEAPU16[161151] == 4) {
                   jsiHandleEnd();
                   break label$79;
                  }
                  label$81 : {
                   if (HEAPU16[161151] == 5) {
                    jsiHandlePageUpDown(0);
                    break label$81;
                   }
                   if (HEAPU16[161151] == 6) {
                    jsiHandlePageUpDown(1);
                   }
                  }
                 }
                }
               }
              }
             }
            }
            HEAP8[322240] = 0;
            break label$66;
           }
           label$84 : {
            label$85 : {
             if (HEAP8[$1 + 31 | 0] != 16) {
              break label$85;
             }
             if (jsvGetStringLength(HEAP32[80557])) {
              break label$85;
             }
             HEAP16[161112] = HEAPU16[161112] | 2;
             break label$84;
            }
            HEAP8[322240] = 0;
            label$86 : {
             if (!(HEAP8[$1 + 31 | 0] != 127 ? HEAP8[$1 + 31 | 0] != 8 : 0)) {
              jsiHandleDelete(1);
              break label$86;
             }
             label$89 : {
              if (!(HEAP8[$1 + 31 | 0] != 10 | HEAPU8[322240] != 1)) {
               HEAP8[322240] = 0;
               break label$89;
              }
              label$91 : {
               if (!(HEAP8[$1 + 31 | 0] != 10 ? HEAP8[$1 + 31 | 0] != 13 : 0)) {
                if (HEAP8[$1 + 31 | 0] == 13) {
                 HEAP8[322240] = 1;
                }
                jsiHandleNewLine(1);
                break label$91;
               }
               label$95 : {
                label$96 : {
                 if (HEAP8[$1 + 31 | 0] != 9) {
                  break label$96;
                 }
                 if (!(jsiEcho() & 1)) {
                  break label$96;
                 }
                 jsiTabComplete();
                 break label$95;
                }
                if (!(HEAP8[$1 + 31 | 0] != 9 ? HEAPU8[$1 + 31 | 0] < 32 : 0)) {
                 HEAP8[$1 + 10 | 0] = HEAPU8[$1 + 31 | 0];
                 HEAP8[$1 + 11 | 0] = 0;
                 $0 = $1;
                 if (HEAP8[$1 + 31 | 0] == 9) {
                  $2 = 81788;
                 } else {
                  $2 = $1 + 10 | 0;
                 }
                 HEAP32[$0 + 4 >> 2] = $2;
                 jsiAppendStringToInputLine(HEAP32[$1 + 4 >> 2]);
                }
               }
              }
             }
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
 global$0 = $1 + 32 | 0;
}
function dlfree($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 label$1 : {
  label$2 : {
   if (!$0) {
    break label$2;
   }
   $3 = $0 + -8 | 0;
   $8 = HEAP32[84263];
   if ($3 >>> 0 < $8 >>> 0) {
    break label$1;
   }
   $2 = HEAP32[$0 + -4 >> 2];
   $1 = $2 & 3;
   if (($1 | 0) == 1) {
    break label$1;
   }
   $0 = $2 & -8;
   $6 = $3 + $0 | 0;
   label$3 : {
    if ($2 & 1) {
     break label$3;
    }
    if (!$1) {
     break label$2;
    }
    $1 = HEAP32[$3 >> 2];
    $3 = $3 - $1 | 0;
    if ($3 >>> 0 < $8 >>> 0) {
     break label$1;
    }
    $0 = $0 + $1 | 0;
    if (HEAP32[84264] != ($3 | 0)) {
     if ($1 >>> 0 <= 255) {
      $5 = HEAP32[$3 + 12 >> 2];
      $4 = HEAP32[$3 + 8 >> 2];
      $2 = $1 >>> 3;
      $1 = ($2 << 3) + 337076 | 0;
      if (HEAP32[$4 + 12 >> 2] != ($3 | 0) | $8 >>> 0 > $4 >>> 0 ? ($4 | 0) != ($1 | 0) : 0) {
       break label$1;
      }
      if (($4 | 0) == ($5 | 0)) {
       HEAP32[84259] = HEAP32[84259] & __wasm_rotl_i32($2);
       break label$3;
      }
      if (HEAP32[$5 + 8 >> 2] != ($3 | 0) | $8 >>> 0 > $5 >>> 0 ? ($1 | 0) != ($5 | 0) : 0) {
       break label$1;
      }
      HEAP32[$4 + 12 >> 2] = $5;
      HEAP32[$5 + 8 >> 2] = $4;
      break label$3;
     }
     $7 = HEAP32[$3 + 24 >> 2];
     $2 = HEAP32[$3 + 12 >> 2];
     label$9 : {
      if (($3 | 0) != ($2 | 0)) {
       $1 = HEAP32[$3 + 8 >> 2];
       if ($8 >>> 0 > $1 >>> 0 | HEAP32[$1 + 12 >> 2] != ($3 | 0) | HEAP32[$2 + 8 >> 2] != ($3 | 0)) {
        break label$1;
       }
       HEAP32[$1 + 12 >> 2] = $2;
       HEAP32[$2 + 8 >> 2] = $1;
       break label$9;
      }
      label$11 : {
       $1 = $3 + 20 | 0;
       $4 = HEAP32[$1 >> 2];
       if ($4) {
        break label$11;
       }
       $1 = $3 + 16 | 0;
       $4 = HEAP32[$1 >> 2];
       if ($4) {
        break label$11;
       }
       $2 = 0;
       break label$9;
      }
      while (1) {
       $5 = $1;
       $2 = $4;
       $1 = $2 + 20 | 0;
       $4 = HEAP32[$1 >> 2];
       if ($4) {
        continue;
       }
       $1 = $2 + 16 | 0;
       $4 = HEAP32[$2 + 16 >> 2];
       if ($4) {
        continue;
       }
       break;
      }
      if ($8 >>> 0 > $5 >>> 0) {
       break label$1;
      }
      HEAP32[$5 >> 2] = 0;
     }
     if (!$7) {
      break label$3;
     }
     $4 = HEAP32[$3 + 28 >> 2];
     $1 = ($4 << 2) + 337340 | 0;
     label$13 : {
      if (HEAP32[$1 >> 2] == ($3 | 0)) {
       HEAP32[$1 >> 2] = $2;
       if ($2) {
        break label$13;
       }
       HEAP32[84260] = HEAP32[84260] & __wasm_rotl_i32($4);
       break label$3;
      }
      if (HEAPU32[84263] > $7 >>> 0) {
       break label$1;
      }
      HEAP32[$7 + (HEAP32[$7 + 16 >> 2] == ($3 | 0) ? 16 : 20) >> 2] = $2;
      if (!$2) {
       break label$3;
      }
     }
     $1 = HEAP32[84263];
     if ($1 >>> 0 > $2 >>> 0) {
      break label$1;
     }
     HEAP32[$2 + 24 >> 2] = $7;
     $4 = HEAP32[$3 + 16 >> 2];
     if ($4) {
      if ($1 >>> 0 > $4 >>> 0) {
       break label$1;
      }
      HEAP32[$2 + 16 >> 2] = $4;
      HEAP32[$4 + 24 >> 2] = $2;
     }
     $1 = HEAP32[$3 + 20 >> 2];
     if (!$1) {
      break label$3;
     }
     if (HEAPU32[84263] > $1 >>> 0) {
      break label$1;
     }
     HEAP32[$2 + 20 >> 2] = $1;
     HEAP32[$1 + 24 >> 2] = $2;
     break label$3;
    }
    $1 = HEAP32[$6 + 4 >> 2];
    if (($1 & 3) != 3) {
     break label$3;
    }
    HEAP32[84261] = $0;
    HEAP32[$6 + 4 >> 2] = $1 & -2;
    HEAP32[$3 + 4 >> 2] = $0 | 1;
    HEAP32[$0 + $3 >> 2] = $0;
    return;
   }
   if ($6 >>> 0 <= $3 >>> 0) {
    break label$1;
   }
   $8 = HEAP32[$6 + 4 >> 2];
   if (!($8 & 1)) {
    break label$1;
   }
   label$16 : {
    if (!($8 & 2)) {
     if (HEAP32[84265] == ($6 | 0)) {
      HEAP32[84265] = $3;
      $0 = HEAP32[84262] + $0 | 0;
      HEAP32[84262] = $0;
      HEAP32[$3 + 4 >> 2] = $0 | 1;
      if (HEAP32[84264] != ($3 | 0)) {
       break label$2;
      }
      HEAP32[84261] = 0;
      HEAP32[84264] = 0;
      return;
     }
     if (HEAP32[84264] == ($6 | 0)) {
      HEAP32[84264] = $3;
      $0 = HEAP32[84261] + $0 | 0;
      HEAP32[84261] = $0;
      HEAP32[$3 + 4 >> 2] = $0 | 1;
      HEAP32[$0 + $3 >> 2] = $0;
      return;
     }
     label$20 : {
      if ($8 >>> 0 <= 255) {
       $5 = HEAP32[$6 + 12 >> 2];
       $4 = HEAP32[$6 + 8 >> 2];
       $2 = $8 >>> 3;
       $1 = ($2 << 3) + 337076 | 0;
       if (HEAP32[$4 + 12 >> 2] != ($6 | 0) | HEAPU32[84263] > $4 >>> 0 ? ($4 | 0) != ($1 | 0) : 0) {
        break label$1;
       }
       if (($4 | 0) == ($5 | 0)) {
        HEAP32[84259] = HEAP32[84259] & __wasm_rotl_i32($2);
        break label$20;
       }
       if (HEAP32[$5 + 8 >> 2] != ($6 | 0) | HEAPU32[84263] > $5 >>> 0 ? ($1 | 0) != ($5 | 0) : 0) {
        break label$1;
       }
       HEAP32[$4 + 12 >> 2] = $5;
       HEAP32[$5 + 8 >> 2] = $4;
       break label$20;
      }
      $7 = HEAP32[$6 + 24 >> 2];
      $2 = HEAP32[$6 + 12 >> 2];
      label$25 : {
       if (($6 | 0) != ($2 | 0)) {
        $1 = HEAP32[$6 + 8 >> 2];
        if (HEAPU32[84263] > $1 >>> 0 | HEAP32[$1 + 12 >> 2] != ($6 | 0) | HEAP32[$2 + 8 >> 2] != ($6 | 0)) {
         break label$1;
        }
        HEAP32[$1 + 12 >> 2] = $2;
        HEAP32[$2 + 8 >> 2] = $1;
        break label$25;
       }
       label$27 : {
        $1 = $6 + 20 | 0;
        $4 = HEAP32[$1 >> 2];
        if ($4) {
         break label$27;
        }
        $1 = $6 + 16 | 0;
        $4 = HEAP32[$1 >> 2];
        if ($4) {
         break label$27;
        }
        $2 = 0;
        break label$25;
       }
       while (1) {
        $5 = $1;
        $2 = $4;
        $1 = $2 + 20 | 0;
        $4 = HEAP32[$1 >> 2];
        if ($4) {
         continue;
        }
        $1 = $2 + 16 | 0;
        $4 = HEAP32[$2 + 16 >> 2];
        if ($4) {
         continue;
        }
        break;
       }
       if (HEAPU32[84263] > $5 >>> 0) {
        break label$1;
       }
       HEAP32[$5 >> 2] = 0;
      }
      if (!$7) {
       break label$20;
      }
      $4 = HEAP32[$6 + 28 >> 2];
      $1 = ($4 << 2) + 337340 | 0;
      label$29 : {
       if (HEAP32[$1 >> 2] == ($6 | 0)) {
        HEAP32[$1 >> 2] = $2;
        if ($2) {
         break label$29;
        }
        HEAP32[84260] = HEAP32[84260] & __wasm_rotl_i32($4);
        break label$20;
       }
       if (HEAPU32[84263] > $7 >>> 0) {
        break label$1;
       }
       HEAP32[$7 + (HEAP32[$7 + 16 >> 2] == ($6 | 0) ? 16 : 20) >> 2] = $2;
       if (!$2) {
        break label$20;
       }
      }
      $1 = HEAP32[84263];
      if ($1 >>> 0 > $2 >>> 0) {
       break label$1;
      }
      HEAP32[$2 + 24 >> 2] = $7;
      $4 = HEAP32[$6 + 16 >> 2];
      if ($4) {
       if ($1 >>> 0 > $4 >>> 0) {
        break label$1;
       }
       HEAP32[$2 + 16 >> 2] = $4;
       HEAP32[$4 + 24 >> 2] = $2;
      }
      $1 = HEAP32[$6 + 20 >> 2];
      if (!$1) {
       break label$20;
      }
      if (HEAPU32[84263] > $1 >>> 0) {
       break label$1;
      }
      HEAP32[$2 + 20 >> 2] = $1;
      HEAP32[$1 + 24 >> 2] = $2;
     }
     $0 = ($8 & -8) + $0 | 0;
     HEAP32[$3 + 4 >> 2] = $0 | 1;
     HEAP32[$0 + $3 >> 2] = $0;
     if (HEAP32[84264] != ($3 | 0)) {
      break label$16;
     }
     HEAP32[84261] = $0;
     return;
    }
    HEAP32[$6 + 4 >> 2] = $8 & -2;
    HEAP32[$3 + 4 >> 2] = $0 | 1;
    HEAP32[$0 + $3 >> 2] = $0;
   }
   if ($0 >>> 0 <= 255) {
    $1 = $0 >>> 3;
    $0 = ($1 << 3) + 337076 | 0;
    $2 = HEAP32[84259];
    $1 = 1 << $1;
    label$33 : {
     if (!($2 & $1)) {
      HEAP32[84259] = $1 | $2;
      $1 = $0;
      break label$33;
     }
     $1 = HEAP32[$0 + 8 >> 2];
     if (HEAPU32[84263] > $1 >>> 0) {
      break label$1;
     }
    }
    HEAP32[$0 + 8 >> 2] = $3;
    HEAP32[$1 + 12 >> 2] = $3;
    HEAP32[$3 + 12 >> 2] = $0;
    HEAP32[$3 + 8 >> 2] = $1;
    return;
   }
   HEAP32[$3 + 16 >> 2] = 0;
   HEAP32[$3 + 20 >> 2] = 0;
   $1 = $3;
   $4 = $0 >>> 8;
   $2 = 0;
   label$35 : {
    if (!$4) {
     break label$35;
    }
    $2 = 31;
    if ($0 >>> 0 > 16777215) {
     break label$35;
    }
    $2 = $4;
    $4 = $4 + 1048320 >>> 16 & 8;
    $2 = $2 << $4;
    $7 = $2 + 520192 >>> 16 & 4;
    $2 = $2 << $7;
    $5 = $2 + 245760 >>> 16 & 2;
    $2 = ($2 << $5 >>> 15) - ($5 | ($4 | $7)) | 0;
    $2 = ($2 << 1 | $0 >>> $2 + 21 & 1) + 28 | 0;
   }
   HEAP32[$1 + 28 >> 2] = $2;
   $5 = ($2 << 2) + 337340 | 0;
   $4 = HEAP32[84260];
   $1 = 1 << $2;
   label$36 : {
    if (!($4 & $1)) {
     HEAP32[84260] = $1 | $4;
     HEAP32[$5 >> 2] = $3;
     HEAP32[$3 + 12 >> 2] = $3;
     HEAP32[$3 + 24 >> 2] = $5;
     HEAP32[$3 + 8 >> 2] = $3;
     break label$36;
    }
    $1 = $0 << (($2 | 0) == 31 ? 0 : 25 - ($2 >>> 1) | 0);
    $2 = HEAP32[$5 >> 2];
    label$38 : {
     while (1) {
      $4 = $2;
      if ((HEAP32[$2 + 4 >> 2] & -8) == ($0 | 0)) {
       break label$38;
      }
      $2 = $1 >>> 29;
      $1 = $1 << 1;
      $5 = ($4 + ($2 & 4) | 0) + 16 | 0;
      $2 = HEAP32[$5 >> 2];
      if ($2) {
       continue;
      }
      break;
     }
     if (HEAPU32[84263] > $5 >>> 0) {
      break label$1;
     }
     HEAP32[$5 >> 2] = $3;
     HEAP32[$3 + 12 >> 2] = $3;
     HEAP32[$3 + 24 >> 2] = $4;
     HEAP32[$3 + 8 >> 2] = $3;
     break label$36;
    }
    $0 = HEAP32[84263];
    $1 = HEAP32[$4 + 8 >> 2];
    if ($0 >>> 0 > $1 >>> 0 | $0 >>> 0 > $4 >>> 0) {
     break label$1;
    }
    HEAP32[$1 + 12 >> 2] = $3;
    HEAP32[$4 + 8 >> 2] = $3;
    HEAP32[$3 + 24 >> 2] = 0;
    HEAP32[$3 + 12 >> 2] = $4;
    HEAP32[$3 + 8 >> 2] = $1;
   }
   $0 = HEAP32[84267] + -1 | 0;
   HEAP32[84267] = $0;
   if ($0) {
    break label$2;
   }
   $3 = 337492;
   while (1) {
    $0 = HEAP32[$3 >> 2];
    $3 = $0 + 8 | 0;
    if ($0) {
     continue;
    }
    break;
   }
   HEAP32[84267] = -1;
  }
  return;
 }
 abort();
 abort();
}
function mbedtls_sha512_finish($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP32[$2 + 44 >> 2] = $0;
 HEAP32[$2 + 40 >> 2] = $1;
 $1 = HEAP32[$2 + 44 >> 2];
 $3 = HEAP32[$1 + 12 >> 2];
 $0 = HEAP32[$1 + 8 >> 2];
 $1 = $3 << 3 | $0 >>> 29;
 $3 = $0 << 3;
 $0 = $1;
 $1 = $3;
 $3 = HEAP32[HEAP32[$2 + 44 >> 2] + 4 >> 2];
 HEAP32[$2 + 24 >> 2] = $1 | $3 >>> 29;
 HEAP32[$2 + 28 >> 2] = $0;
 $1 = HEAP32[$2 + 44 >> 2];
 $0 = HEAP32[$1 + 4 >> 2];
 $1 = HEAP32[$1 >> 2];
 HEAP32[$2 + 16 >> 2] = $1 << 3;
 HEAP32[$2 + 20 >> 2] = $0 << 3 | $1 >>> 29;
 HEAP8[$2 | 0] = HEAP32[$2 + 28 >> 2] >>> 24;
 HEAP8[$2 + 1 | 0] = HEAP32[$2 + 28 >> 2] >>> 16;
 HEAP8[$2 + 2 | 0] = HEAP32[$2 + 28 >> 2] >>> 8;
 HEAP8[$2 + 3 | 0] = HEAP32[$2 + 28 >> 2];
 HEAP8[$2 + 4 | 0] = (HEAP32[$2 + 28 >> 2] & 16777215) << 8 | HEAP32[$2 + 24 >> 2] >>> 24;
 HEAP8[$2 + 5 | 0] = (HEAP32[$2 + 28 >> 2] & 65535) << 16 | HEAP32[$2 + 24 >> 2] >>> 16;
 HEAP8[$2 + 6 | 0] = (HEAP32[$2 + 28 >> 2] & 255) << 24 | HEAP32[$2 + 24 >> 2] >>> 8;
 HEAP8[$2 + 7 | 0] = HEAP32[$2 + 24 >> 2];
 HEAP8[$2 + 8 | 0] = HEAP32[$2 + 20 >> 2] >>> 24;
 HEAP8[$2 + 9 | 0] = HEAP32[$2 + 20 >> 2] >>> 16;
 HEAP8[$2 + 10 | 0] = HEAP32[$2 + 20 >> 2] >>> 8;
 HEAP8[$2 + 11 | 0] = HEAP32[$2 + 20 >> 2];
 HEAP8[$2 + 12 | 0] = (HEAP32[$2 + 20 >> 2] & 16777215) << 8 | HEAP32[$2 + 16 >> 2] >>> 24;
 HEAP8[$2 + 13 | 0] = (HEAP32[$2 + 20 >> 2] & 65535) << 16 | HEAP32[$2 + 16 >> 2] >>> 16;
 HEAP8[$2 + 14 | 0] = (HEAP32[$2 + 20 >> 2] & 255) << 24 | HEAP32[$2 + 16 >> 2] >>> 8;
 HEAP8[$2 + 15 | 0] = HEAP32[$2 + 16 >> 2];
 $0 = HEAP32[$2 + 44 >> 2];
 $0;
 HEAP32[$2 + 36 >> 2] = HEAP32[$0 >> 2] & 127;
 $0 = $2;
 if (HEAPU32[$2 + 36 >> 2] < 112) {
  $1 = 112 - HEAP32[$2 + 36 >> 2] | 0;
 } else {
  $1 = 240 - HEAP32[$2 + 36 >> 2] | 0;
 }
 HEAP32[$0 + 32 >> 2] = $1;
 mbedtls_sha512_update(HEAP32[$2 + 44 >> 2], 109440, HEAP32[$2 + 32 >> 2]);
 mbedtls_sha512_update(HEAP32[$2 + 44 >> 2], $2, 16);
 $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 20 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2]] = $1 >>> 24;
 $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 20 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 1 | 0] = $1 >>> 16;
 $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 20 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 2 | 0] = $1 >>> 8;
 $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 20 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 3 | 0] = $1;
 $0 = HEAP32[$2 + 44 >> 2];
 $1 = HEAP32[$0 + 20 >> 2];
 $0 = HEAP32[$0 + 16 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 4 | 0] = ($1 & 16777215) << 8 | $0 >>> 24;
 $0 = HEAP32[$2 + 44 >> 2];
 $1 = HEAP32[$0 + 20 >> 2];
 $0 = HEAP32[$0 + 16 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 5 | 0] = ($1 & 65535) << 16 | $0 >>> 16;
 $0 = HEAP32[$2 + 44 >> 2];
 $1 = HEAP32[$0 + 20 >> 2];
 $0 = HEAP32[$0 + 16 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 6 | 0] = ($1 & 255) << 24 | $0 >>> 8;
 $0 = HEAP32[$2 + 44 >> 2];
 $0;
 HEAP8[HEAP32[$2 + 40 >> 2] + 7 | 0] = HEAP32[$0 + 16 >> 2];
 $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 28 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 8 | 0] = $1 >>> 24;
 $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 28 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 9 | 0] = $1 >>> 16;
 $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 28 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 10 | 0] = $1 >>> 8;
 $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 28 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 11 | 0] = $1;
 $0 = HEAP32[$2 + 44 >> 2];
 $1 = HEAP32[$0 + 28 >> 2];
 $0 = HEAP32[$0 + 24 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 12 | 0] = ($1 & 16777215) << 8 | $0 >>> 24;
 $0 = HEAP32[$2 + 44 >> 2];
 $1 = HEAP32[$0 + 28 >> 2];
 $0 = HEAP32[$0 + 24 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 13 | 0] = ($1 & 65535) << 16 | $0 >>> 16;
 $0 = HEAP32[$2 + 44 >> 2];
 $1 = HEAP32[$0 + 28 >> 2];
 $0 = HEAP32[$0 + 24 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 14 | 0] = ($1 & 255) << 24 | $0 >>> 8;
 $0 = HEAP32[$2 + 44 >> 2];
 $0;
 HEAP8[HEAP32[$2 + 40 >> 2] + 15 | 0] = HEAP32[$0 + 24 >> 2];
 $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 36 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 16 | 0] = $1 >>> 24;
 $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 36 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 17 | 0] = $1 >>> 16;
 $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 36 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 18 | 0] = $1 >>> 8;
 $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 36 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 19 | 0] = $1;
 $0 = HEAP32[$2 + 44 >> 2];
 $1 = HEAP32[$0 + 36 >> 2];
 $0 = HEAP32[$0 + 32 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 20 | 0] = ($1 & 16777215) << 8 | $0 >>> 24;
 $0 = HEAP32[$2 + 44 >> 2];
 $1 = HEAP32[$0 + 36 >> 2];
 $0 = HEAP32[$0 + 32 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 21 | 0] = ($1 & 65535) << 16 | $0 >>> 16;
 $0 = HEAP32[$2 + 44 >> 2];
 $1 = HEAP32[$0 + 36 >> 2];
 $0 = HEAP32[$0 + 32 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 22 | 0] = ($1 & 255) << 24 | $0 >>> 8;
 $0 = HEAP32[$2 + 44 >> 2];
 $0;
 HEAP8[HEAP32[$2 + 40 >> 2] + 23 | 0] = HEAP32[$0 + 32 >> 2];
 $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 44 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 24 | 0] = $1 >>> 24;
 $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 44 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 25 | 0] = $1 >>> 16;
 $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 44 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 26 | 0] = $1 >>> 8;
 $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 44 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 27 | 0] = $1;
 $0 = HEAP32[$2 + 44 >> 2];
 $1 = HEAP32[$0 + 44 >> 2];
 $0 = HEAP32[$0 + 40 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 28 | 0] = ($1 & 16777215) << 8 | $0 >>> 24;
 $0 = HEAP32[$2 + 44 >> 2];
 $1 = HEAP32[$0 + 44 >> 2];
 $0 = HEAP32[$0 + 40 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 29 | 0] = ($1 & 65535) << 16 | $0 >>> 16;
 $0 = HEAP32[$2 + 44 >> 2];
 $1 = HEAP32[$0 + 44 >> 2];
 $0 = HEAP32[$0 + 40 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 30 | 0] = ($1 & 255) << 24 | $0 >>> 8;
 $0 = HEAP32[$2 + 44 >> 2];
 $0;
 HEAP8[HEAP32[$2 + 40 >> 2] + 31 | 0] = HEAP32[$0 + 40 >> 2];
 $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 52 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 32 | 0] = $1 >>> 24;
 $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 52 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 33 | 0] = $1 >>> 16;
 $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 52 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 34 | 0] = $1 >>> 8;
 $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 52 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 35 | 0] = $1;
 $0 = HEAP32[$2 + 44 >> 2];
 $1 = HEAP32[$0 + 52 >> 2];
 $0 = HEAP32[$0 + 48 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 36 | 0] = ($1 & 16777215) << 8 | $0 >>> 24;
 $0 = HEAP32[$2 + 44 >> 2];
 $1 = HEAP32[$0 + 52 >> 2];
 $0 = HEAP32[$0 + 48 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 37 | 0] = ($1 & 65535) << 16 | $0 >>> 16;
 $0 = HEAP32[$2 + 44 >> 2];
 $1 = HEAP32[$0 + 52 >> 2];
 $0 = HEAP32[$0 + 48 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 38 | 0] = ($1 & 255) << 24 | $0 >>> 8;
 $0 = HEAP32[$2 + 44 >> 2];
 $0;
 HEAP8[HEAP32[$2 + 40 >> 2] + 39 | 0] = HEAP32[$0 + 48 >> 2];
 $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 60 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 40 | 0] = $1 >>> 24;
 $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 60 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 41 | 0] = $1 >>> 16;
 $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 60 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 42 | 0] = $1 >>> 8;
 $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 60 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 43 | 0] = $1;
 $0 = HEAP32[$2 + 44 >> 2];
 $1 = HEAP32[$0 + 60 >> 2];
 $0 = HEAP32[$0 + 56 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 44 | 0] = ($1 & 16777215) << 8 | $0 >>> 24;
 $0 = HEAP32[$2 + 44 >> 2];
 $1 = HEAP32[$0 + 60 >> 2];
 $0 = HEAP32[$0 + 56 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 45 | 0] = ($1 & 65535) << 16 | $0 >>> 16;
 $0 = HEAP32[$2 + 44 >> 2];
 $1 = HEAP32[$0 + 60 >> 2];
 $0 = HEAP32[$0 + 56 >> 2];
 HEAP8[HEAP32[$2 + 40 >> 2] + 46 | 0] = ($1 & 255) << 24 | $0 >>> 8;
 $0 = HEAP32[$2 + 44 >> 2];
 $0;
 HEAP8[HEAP32[$2 + 40 >> 2] + 47 | 0] = HEAP32[$0 + 56 >> 2];
 if (!HEAP32[HEAP32[$2 + 44 >> 2] + 208 >> 2]) {
  $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 68 >> 2];
  HEAP8[HEAP32[$2 + 40 >> 2] + 48 | 0] = $1 >>> 24;
  $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 68 >> 2];
  HEAP8[HEAP32[$2 + 40 >> 2] + 49 | 0] = $1 >>> 16;
  $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 68 >> 2];
  HEAP8[HEAP32[$2 + 40 >> 2] + 50 | 0] = $1 >>> 8;
  $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 68 >> 2];
  HEAP8[HEAP32[$2 + 40 >> 2] + 51 | 0] = $1;
  $0 = HEAP32[$2 + 44 >> 2];
  $1 = HEAP32[$0 + 68 >> 2];
  $0 = HEAP32[$0 + 64 >> 2];
  HEAP8[HEAP32[$2 + 40 >> 2] + 52 | 0] = ($1 & 16777215) << 8 | $0 >>> 24;
  $0 = HEAP32[$2 + 44 >> 2];
  $1 = HEAP32[$0 + 68 >> 2];
  $0 = HEAP32[$0 + 64 >> 2];
  HEAP8[HEAP32[$2 + 40 >> 2] + 53 | 0] = ($1 & 65535) << 16 | $0 >>> 16;
  $0 = HEAP32[$2 + 44 >> 2];
  $1 = HEAP32[$0 + 68 >> 2];
  $0 = HEAP32[$0 + 64 >> 2];
  HEAP8[HEAP32[$2 + 40 >> 2] + 54 | 0] = ($1 & 255) << 24 | $0 >>> 8;
  $0 = HEAP32[$2 + 44 >> 2];
  $0;
  HEAP8[HEAP32[$2 + 40 >> 2] + 55 | 0] = HEAP32[$0 + 64 >> 2];
  $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 76 >> 2];
  HEAP8[HEAP32[$2 + 40 >> 2] + 56 | 0] = $1 >>> 24;
  $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 76 >> 2];
  HEAP8[HEAP32[$2 + 40 >> 2] + 57 | 0] = $1 >>> 16;
  $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 76 >> 2];
  HEAP8[HEAP32[$2 + 40 >> 2] + 58 | 0] = $1 >>> 8;
  $1 = HEAP32[HEAP32[$2 + 44 >> 2] + 76 >> 2];
  HEAP8[HEAP32[$2 + 40 >> 2] + 59 | 0] = $1;
  $0 = HEAP32[$2 + 44 >> 2];
  $1 = HEAP32[$0 + 76 >> 2];
  $0 = HEAP32[$0 + 72 >> 2];
  HEAP8[HEAP32[$2 + 40 >> 2] + 60 | 0] = ($1 & 16777215) << 8 | $0 >>> 24;
  $0 = HEAP32[$2 + 44 >> 2];
  $1 = HEAP32[$0 + 76 >> 2];
  $0 = HEAP32[$0 + 72 >> 2];
  HEAP8[HEAP32[$2 + 40 >> 2] + 61 | 0] = ($1 & 65535) << 16 | $0 >>> 16;
  $0 = HEAP32[$2 + 44 >> 2];
  $1 = HEAP32[$0 + 76 >> 2];
  $0 = HEAP32[$0 + 72 >> 2];
  HEAP8[HEAP32[$2 + 40 >> 2] + 62 | 0] = ($1 & 255) << 24 | $0 >>> 8;
  $0 = HEAP32[$2 + 44 >> 2];
  $0;
  HEAP8[HEAP32[$2 + 40 >> 2] + 63 | 0] = HEAP32[$0 + 72 >> 2];
 }
 global$0 = $2 + 48 | 0;
}
function jswrap_graphics_drawImage($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $5 = global$0 - 560 | 0;
 global$0 = $5;
 HEAP32[$5 + 552 >> 2] = $0;
 HEAP32[$5 + 548 >> 2] = $1;
 HEAP32[$5 + 544 >> 2] = $2;
 HEAP32[$5 + 540 >> 2] = $3;
 HEAP32[$5 + 536 >> 2] = $4;
 label$1 : {
  if (!(graphicsGetFromVar($5 + 464 | 0, HEAP32[$5 + 552 >> 2]) & 1)) {
   HEAP32[$5 + 556 >> 2] = 0;
   break label$1;
  }
  if (!(_jswrap_graphics_parseImage($5 + 464 | 0, HEAP32[$5 + 548 >> 2], 0, $5 + 376 | 0) & 1)) {
   HEAP32[$5 + 556 >> 2] = 0;
   break label$1;
  }
  HEAPF64[$5 + 368 >> 3] = 1;
  HEAPF64[$5 + 360 >> 3] = 0;
  HEAP8[$5 + 359 | 0] = 0;
  if (jsvIsObject(HEAP32[$5 + 536 >> 2]) & 1) {
   HEAP32[$5 + 352 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$5 + 536 >> 2], 127886, 0));
   if (HEAP32[$5 + 352 >> 2] > 0) {
    HEAP32[$5 + 400 >> 2] = HEAP32[$5 + 400 >> 2] + Math_imul(HEAPU16[$5 + 426 >> 1], HEAP32[$5 + 352 >> 2]);
   }
   HEAPF64[$5 + 368 >> 3] = jsvGetFloatAndUnLock(jsvObjectGetChild(HEAP32[$5 + 536 >> 2], 127892, 0));
   $0 = __DOUBLE_BITS(HEAPF64[$5 + 368 >> 3]);
   $1 = i64toi32_i32$HIGH_BITS & 2147483647;
   if (!(HEAPF64[$5 + 368 >> 3] <= 0 ? 0 : !(($1 | 0) == 2146435072 & $0 >>> 0 >= 0 | $1 >>> 0 > 2146435072))) {
    HEAPF64[$5 + 368 >> 3] = 1;
   }
   HEAPF64[$5 + 360 >> 3] = jsvGetFloatAndUnLock(jsvObjectGetChild(HEAP32[$5 + 536 >> 2], 127898, 0));
   $0 = __DOUBLE_BITS(HEAPF64[$5 + 360 >> 3]);
   $1 = i64toi32_i32$HIGH_BITS & 2147483647;
   HEAP8[$5 + 359 | 0] = ($1 | 0) == 2146435072 & $0 >>> 0 < 0 | $1 >>> 0 < 2146435072;
   if (!(HEAP8[$5 + 359 | 0] & 1)) {
    HEAPF64[$5 + 360 >> 3] = 0;
   }
  }
  HEAP32[$5 + 348 >> 2] = 0;
  HEAP32[$5 + 344 >> 2] = 0;
  HEAP32[$5 + 340 >> 2] = 0;
  HEAP32[$5 + 336 >> 2] = 0;
  jsvStringIteratorNew($5 + 296 | 0, HEAP32[$5 + 396 >> 2], HEAP32[$5 + 400 >> 2]);
  label$10 : {
   if (!(HEAP8[$5 + 359 | 0] & 1 | (HEAPF64[$5 + 368 >> 3] != 1 | HEAPF64[$5 + 360 >> 3] != 0))) {
    _jswrap_drawImageSimple($5 + 464 | 0, HEAP32[$5 + 544 >> 2], HEAP32[$5 + 540 >> 2], $5 + 376 | 0, $5 + 296 | 0);
    break label$10;
   }
   $0 = $5;
   $1 = 0;
   label$12 : {
    if (HEAP8[$5 + 359 | 0] & 1) {
     break label$12;
    }
    $1 = 0;
    if (HEAPF64[$5 + 368 >> 3] - Math_floor(HEAPF64[$5 + 368 >> 3]) != 0) {
     break label$12;
    }
    $1 = !((HEAPU8[$5 + 472 | 0] | HEAPU8[$5 + 473 | 0] << 8 | (HEAPU8[$5 + 474 | 0] << 16 | HEAPU8[$5 + 475 | 0] << 24)) & 112);
   }
   HEAP8[$0 + 295 | 0] = $1;
   label$13 : {
    if (HEAP8[$5 + 295 | 0] & 1) {
     $0 = $5;
     $7 = HEAPF64[$5 + 368 >> 3];
     label$15 : {
      if (Math_abs($7) < 2147483648) {
       $1 = ~~$7;
       break label$15;
      }
      $1 = -2147483648;
     }
     HEAP32[$0 + 288 >> 2] = $1;
     HEAP32[$5 + 284 >> 2] = HEAP32[$5 + 540 >> 2];
     HEAP32[$5 + 344 >> 2] = 0;
     while (1) {
      if (HEAP32[$5 + 344 >> 2] < HEAP32[$5 + 380 >> 2]) {
       HEAP32[$5 + 280 >> 2] = jsvStringIteratorGetIndex($5 + 296 | 0);
       HEAP32[$5 + 276 >> 2] = HEAP32[$5 + 340 >> 2];
       HEAP32[$5 + 272 >> 2] = HEAP32[$5 + 336 >> 2];
       HEAP32[$5 + 268 >> 2] = 0;
       while (1) {
        if (HEAP32[$5 + 268 >> 2] < HEAP32[$5 + 288 >> 2]) {
         if (HEAP32[$5 + 268 >> 2]) {
          jsvStringIteratorGoto($5 + 296 | 0, HEAP32[$5 + 396 >> 2], HEAP32[$5 + 280 >> 2]);
          HEAP32[$5 + 340 >> 2] = HEAP32[$5 + 276 >> 2];
          HEAP32[$5 + 336 >> 2] = HEAP32[$5 + 272 >> 2];
         }
         HEAP32[$5 + 264 >> 2] = HEAP32[$5 + 544 >> 2];
         HEAP32[$5 + 348 >> 2] = 0;
         while (1) {
          if (HEAP32[$5 + 348 >> 2] < HEAP32[$5 + 376 >> 2]) {
           while (1) {
            if (HEAP32[$5 + 340 >> 2] < HEAP32[$5 + 384 >> 2]) {
             HEAP32[$5 + 336 >> 2] = HEAP32[$5 + 336 >> 2] << 8 | jsvStringIteratorGetCharAndNext($5 + 296 | 0) & 255;
             HEAP32[$5 + 340 >> 2] = HEAP32[$5 + 340 >> 2] + 8;
             continue;
            }
            break;
           }
           HEAP32[$5 + 260 >> 2] = HEAP32[$5 + 412 >> 2] & HEAP32[$5 + 336 >> 2] >>> HEAP32[$5 + 340 >> 2] - HEAP32[$5 + 384 >> 2];
           HEAP32[$5 + 340 >> 2] = HEAP32[$5 + 340 >> 2] - HEAP32[$5 + 384 >> 2];
           label$26 : {
            if (!(HEAP32[$5 + 392 >> 2] == HEAP32[$5 + 260 >> 2] | HEAP32[$5 + 284 >> 2] < (HEAPU8[$5 + 498 | 0] | HEAPU8[$5 + 499 | 0] << 8) | HEAP32[$5 + 284 >> 2] > (HEAPU8[$5 + 502 | 0] | HEAPU8[$5 + 503 | 0] << 8))) {
             if (HEAP32[$5 + 404 >> 2]) {
              HEAP32[$5 + 260 >> 2] = HEAPU16[HEAP32[$5 + 404 >> 2] + ((HEAP32[$5 + 260 >> 2] & HEAP32[$5 + 408 >> 2]) << 1) >> 1];
             }
             HEAP32[$5 + 256 >> 2] = 0;
             while (1) {
              if (HEAP32[$5 + 256 >> 2] < HEAP32[$5 + 288 >> 2]) {
               if (!(HEAP32[$5 + 264 >> 2] < (HEAPU8[$5 + 496 | 0] | HEAPU8[$5 + 497 | 0] << 8) | HEAP32[$5 + 264 >> 2] > (HEAPU8[$5 + 500 | 0] | HEAPU8[$5 + 501 | 0] << 8))) {
                FUNCTION_TABLE[HEAPU8[$5 + 516 | 0] | HEAPU8[$5 + 517 | 0] << 8 | (HEAPU8[$5 + 518 | 0] << 16 | HEAPU8[$5 + 519 | 0] << 24)]($5 + 464 | 0, HEAP32[$5 + 264 >> 2], HEAP32[$5 + 284 >> 2], HEAP32[$5 + 260 >> 2]);
               }
               HEAP32[$5 + 264 >> 2] = HEAP32[$5 + 264 >> 2] + 1;
               HEAP32[$5 + 256 >> 2] = HEAP32[$5 + 256 >> 2] + 1;
               continue;
              }
              break;
             }
             break label$26;
            }
            HEAP32[$5 + 264 >> 2] = HEAP32[$5 + 288 >> 2] + HEAP32[$5 + 264 >> 2];
           }
           HEAP32[$5 + 348 >> 2] = HEAP32[$5 + 348 >> 2] + 1;
           continue;
          }
          break;
         }
         HEAP32[$5 + 284 >> 2] = HEAP32[$5 + 284 >> 2] + 1;
         HEAP32[$5 + 268 >> 2] = HEAP32[$5 + 268 >> 2] + 1;
         continue;
        }
        break;
       }
       HEAP32[$5 + 344 >> 2] = HEAP32[$5 + 344 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$5 + 252 >> 2] = HEAP32[$5 + 544 >> 2];
     HEAP32[$5 + 248 >> 2] = HEAP32[$5 + 540 >> 2];
     HEAP32[$5 + 244 >> 2] = HEAP32[$5 + 544 >> 2] + Math_imul(HEAP32[$5 + 288 >> 2], HEAP32[$5 + 376 >> 2]);
     HEAP32[$5 + 240 >> 2] = HEAP32[$5 + 540 >> 2] + Math_imul(HEAP32[$5 + 288 >> 2], HEAP32[$5 + 380 >> 2]);
     graphicsSetModifiedAndClip($5 + 464 | 0, $5 + 252 | 0, $5 + 248 | 0, $5 + 244 | 0, $5 + 240 | 0);
     break label$13;
    }
    $2 = $5 + 464 | 0;
    $3 = $5 + 44 | 0;
    $4 = $5 + 40 | 0;
    $8 = $5 + 36 | 0;
    $9 = $5 + 32 | 0;
    $0 = $5 + 296 | 0;
    HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 544 >> 2];
    HEAP32[$5 + 52 >> 2] = HEAP32[$5 + 540 >> 2];
    $1 = $5 + 48 | 0;
    memcpy($1 + 36 | 0, $5 + 376 | 0, 84);
    $6 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 120 >> 2] = HEAP32[$0 >> 2];
    HEAP32[$1 + 124 >> 2] = $6;
    HEAP32[$1 + 152 >> 2] = HEAP32[$0 + 32 >> 2];
    $6 = HEAP32[$0 + 28 >> 2];
    HEAP32[$1 + 144 >> 2] = HEAP32[$0 + 24 >> 2];
    HEAP32[$1 + 148 >> 2] = $6;
    $6 = HEAP32[$0 + 20 >> 2];
    HEAP32[$1 + 136 >> 2] = HEAP32[$0 + 16 >> 2];
    HEAP32[$1 + 140 >> 2] = $6;
    $6 = HEAP32[$0 + 12 >> 2];
    HEAP32[$1 + 128 >> 2] = HEAP32[$0 + 8 >> 2];
    HEAP32[$1 + 132 >> 2] = $6;
    HEAPF64[$5 + 64 >> 3] = HEAPF64[$5 + 360 >> 3];
    HEAPF64[$5 + 72 >> 3] = HEAPF64[$5 + 368 >> 3];
    HEAP8[$5 + 80 | 0] = HEAP8[$5 + 359 | 0] & 1;
    HEAP8[$5 + 81 | 0] = 0;
    _jswrap_drawImageLayerInit($1);
    HEAP32[$5 + 44 >> 2] = HEAP32[$5 + 48 >> 2];
    HEAP32[$5 + 40 >> 2] = HEAP32[$5 + 52 >> 2];
    HEAP32[$5 + 36 >> 2] = HEAP32[$5 + 56 >> 2] - 1;
    HEAP32[$5 + 32 >> 2] = HEAP32[$5 + 60 >> 2] - 1;
    graphicsSetModifiedAndClip($2, $3, $4, $8, $9);
    _jswrap_drawImageLayerSetStart($1, HEAP32[$5 + 44 >> 2], HEAP32[$5 + 40 >> 2]);
    HEAP32[$5 + 28 >> 2] = graphicsGetSetPixelFn($2);
    HEAP32[$5 + 344 >> 2] = HEAP32[$5 + 40 >> 2];
    while (1) {
     if (HEAP32[$5 + 344 >> 2] <= HEAP32[$5 + 32 >> 2]) {
      _jswrap_drawImageLayerStartX($5 + 48 | 0);
      HEAP32[$5 + 348 >> 2] = HEAP32[$5 + 44 >> 2];
      while (1) {
       if (HEAP32[$5 + 348 >> 2] <= HEAP32[$5 + 36 >> 2]) {
        if (_jswrap_drawImageLayerGetPixel($5 + 48 | 0, $5 + 336 | 0) & 1) {
         FUNCTION_TABLE[HEAP32[$5 + 28 >> 2]]($5 + 464 | 0, HEAP32[$5 + 348 >> 2], HEAP32[$5 + 344 >> 2], HEAP32[$5 + 336 >> 2]);
        }
        _jswrap_drawImageLayerNextX($5 + 48 | 0);
        HEAP32[$5 + 348 >> 2] = HEAP32[$5 + 348 >> 2] + 1;
        continue;
       }
       break;
      }
      _jswrap_drawImageLayerNextY($5 + 48 | 0);
      HEAP32[$5 + 344 >> 2] = HEAP32[$5 + 344 >> 2] + 1;
      continue;
     }
     break;
    }
    $0 = $5 + 48 | 0;
    $3 = HEAP32[$0 + 124 >> 2];
    $1 = $5 + 296 | 0;
    HEAP32[$1 >> 2] = HEAP32[$0 + 120 >> 2];
    HEAP32[$1 + 4 >> 2] = $3;
    HEAP32[$1 + 32 >> 2] = HEAP32[$0 + 152 >> 2];
    $2 = HEAP32[$0 + 148 >> 2];
    HEAP32[$1 + 24 >> 2] = HEAP32[$0 + 144 >> 2];
    HEAP32[$1 + 28 >> 2] = $2;
    $2 = HEAP32[$0 + 140 >> 2];
    HEAP32[$1 + 16 >> 2] = HEAP32[$0 + 136 >> 2];
    HEAP32[$1 + 20 >> 2] = $2;
    $2 = HEAP32[$0 + 132 >> 2];
    HEAP32[$1 + 8 >> 2] = HEAP32[$0 + 128 >> 2];
    HEAP32[$1 + 12 >> 2] = $2;
   }
  }
  $0 = $5 + 464 | 0;
  $1 = $5 + 376 | 0;
  jsvStringIteratorFree($5 + 296 | 0);
  _jswrap_graphics_freeImageInfo($1);
  graphicsSetVar($0);
  HEAP32[$5 + 556 >> 2] = jsvLockAgain(HEAP32[$5 + 552 >> 2]);
 }
 global$0 = $5 + 560 | 0;
 return HEAP32[$5 + 556 >> 2];
}
function jswrap_graphics_toColor($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0, $5 = 0;
 $4 = global$0 - 304 | 0;
 global$0 = $4;
 HEAP32[$4 + 296 >> 2] = $0;
 HEAP32[$4 + 292 >> 2] = $1;
 HEAP32[$4 + 288 >> 2] = $2;
 HEAP32[$4 + 284 >> 2] = $3;
 label$1 : {
  if (!(graphicsGetFromVar($4 + 208 | 0, HEAP32[$4 + 296 >> 2]) & 1)) {
   HEAP32[$4 + 300 >> 2] = 0;
   break label$1;
  }
  HEAP32[$4 + 204 >> 2] = 0;
  label$3 : {
   if (jsvIsString(HEAP32[$4 + 292 >> 2]) & 1) {
    $0 = $4 + 167 | 0;
    HEAP8[$0 | 0] = 0;
    HEAP8[$0 + 1 | 0] = 0;
    HEAP8[$0 + 2 | 0] = 0;
    HEAP8[$0 + 3 | 0] = 0;
    HEAP8[$0 + 4 | 0] = 0;
    HEAP8[$0 + 5 | 0] = 0;
    HEAP8[$0 + 6 | 0] = 0;
    HEAP8[$0 + 7 | 0] = 0;
    HEAP8[$0 + 8 | 0] = 0;
    jsvGetString(HEAP32[$4 + 292 >> 2], $0, 9);
    label$5 : {
     if (!HEAP8[$4 + 171 | 0]) {
      HEAPF64[$4 + 192 >> 3] = +(chtod(HEAP8[$4 + 168 | 0]) | 0) / 15;
      HEAPF64[$4 + 184 >> 3] = +(chtod(HEAP8[$4 + 169 | 0]) | 0) / 15;
      HEAPF64[$4 + 176 >> 3] = +(chtod(HEAP8[$4 + 170 | 0]) | 0) / 15;
      break label$5;
     }
     HEAPF64[$4 + 192 >> 3] = +(hexToByte(HEAP8[$4 + 168 | 0], HEAP8[$4 + 169 | 0]) | 0) / 255;
     HEAPF64[$4 + 184 >> 3] = +(hexToByte(HEAP8[$4 + 170 | 0], HEAP8[$4 + 171 | 0]) | 0) / 255;
     HEAPF64[$4 + 176 >> 3] = +(hexToByte(HEAP8[$4 + 172 | 0], HEAP8[$4 + 173 | 0]) | 0) / 255;
    }
    label$7 : {
     if (!(HEAPF64[$4 + 192 >> 3] < 0 | HEAPF64[$4 + 184 >> 3] < 0 | HEAPF64[$4 + 176 >> 3] < 0)) {
      if (!HEAP8[$4 + 174 | 0]) {
       break label$7;
      }
     }
     jsExceptionHere(1, 127482, 0);
     HEAP32[$4 + 300 >> 2] = 0;
     break label$1;
    }
    break label$3;
   }
   HEAPF64[$4 + 192 >> 3] = jsvGetFloat(HEAP32[$4 + 292 >> 2]);
   HEAPF64[$4 + 184 >> 3] = jsvGetFloat(HEAP32[$4 + 288 >> 2]);
   HEAPF64[$4 + 176 >> 3] = jsvGetFloat(HEAP32[$4 + 284 >> 2]);
  }
  $0 = __DOUBLE_BITS(HEAPF64[$4 + 192 >> 3]);
  label$9 : {
   label$10 : {
    $1 = i64toi32_i32$HIGH_BITS & 2147483647;
    if (($1 | 0) == 2146435072 & $0 >>> 0 >= 0 | $1 >>> 0 > 2146435072) {
     break label$10;
    }
    $0 = __DOUBLE_BITS(HEAPF64[$4 + 184 >> 3]);
    $1 = i64toi32_i32$HIGH_BITS & 2147483647;
    if (($1 | 0) == 2146435072 & $0 >>> 0 >= 0 | $1 >>> 0 > 2146435072) {
     break label$10;
    }
    $0 = __DOUBLE_BITS(HEAPF64[$4 + 176 >> 3]);
    $1 = i64toi32_i32$HIGH_BITS & 2147483647;
    if (($1 | 0) == 2146435072 & $0 >>> 0 >= 0 | $1 >>> 0 > 2146435072) {
     break label$10;
    }
    $0 = $4;
    $5 = HEAPF64[$4 + 192 >> 3] * 256;
    label$14 : {
     if (Math_abs($5) < 2147483648) {
      $1 = ~~$5;
      break label$14;
     }
     $1 = -2147483648;
    }
    HEAP32[$0 + 160 >> 2] = $1;
    $0 = $4;
    $5 = HEAPF64[$4 + 184 >> 3] * 256;
    label$16 : {
     if (Math_abs($5) < 2147483648) {
      $1 = ~~$5;
      break label$16;
     }
     $1 = -2147483648;
    }
    HEAP32[$0 + 156 >> 2] = $1;
    $0 = $4;
    $5 = HEAPF64[$4 + 176 >> 3] * 256;
    label$18 : {
     if (Math_abs($5) < 2147483648) {
      $1 = ~~$5;
      break label$18;
     }
     $1 = -2147483648;
    }
    HEAP32[$0 + 152 >> 2] = $1;
    if (HEAP32[$4 + 160 >> 2] > 255) {
     HEAP32[$4 + 160 >> 2] = 255;
    }
    if (HEAP32[$4 + 156 >> 2] > 255) {
     HEAP32[$4 + 156 >> 2] = 255;
    }
    if (HEAP32[$4 + 152 >> 2] > 255) {
     HEAP32[$4 + 152 >> 2] = 255;
    }
    if (HEAP32[$4 + 160 >> 2] < 0) {
     HEAP32[$4 + 160 >> 2] = 0;
    }
    if (HEAP32[$4 + 156 >> 2] < 0) {
     HEAP32[$4 + 156 >> 2] = 0;
    }
    if (HEAP32[$4 + 152 >> 2] < 0) {
     HEAP32[$4 + 152 >> 2] = 0;
    }
    HEAP32[$4 + 148 >> 2] = (HEAPU8[$4 + 216 | 0] | HEAPU8[$4 + 217 | 0] << 8 | (HEAPU8[$4 + 218 | 0] << 16 | HEAPU8[$4 + 219 | 0] << 24)) & 896;
    if (HEAP32[$4 + 148 >> 2]) {
     HEAP32[$4 + 144 >> 2] = HEAP32[$4 + 160 >> 2];
     HEAP32[$4 + 140 >> 2] = HEAP32[$4 + 156 >> 2];
     HEAP32[$4 + 136 >> 2] = HEAP32[$4 + 152 >> 2];
     label$27 : {
      label$28 : {
       label$29 : {
        label$30 : {
         label$31 : {
          $0 = HEAP32[$4 + 148 >> 2];
          if (($0 | 0) != 128) {
           if (($0 | 0) == 256) {
            break label$31;
           }
           if (($0 | 0) == 384) {
            break label$30;
           }
           if (($0 | 0) == 512) {
            break label$29;
           }
           if (($0 | 0) == 640) {
            break label$28;
           }
           break label$27;
          }
          HEAP32[$4 + 160 >> 2] = HEAP32[$4 + 136 >> 2];
          HEAP32[$4 + 156 >> 2] = HEAP32[$4 + 144 >> 2];
          HEAP32[$4 + 152 >> 2] = HEAP32[$4 + 140 >> 2];
          break label$27;
         }
         HEAP32[$4 + 160 >> 2] = HEAP32[$4 + 136 >> 2];
         HEAP32[$4 + 152 >> 2] = HEAP32[$4 + 144 >> 2];
         break label$27;
        }
        HEAP32[$4 + 160 >> 2] = HEAP32[$4 + 140 >> 2];
        HEAP32[$4 + 156 >> 2] = HEAP32[$4 + 136 >> 2];
        HEAP32[$4 + 152 >> 2] = HEAP32[$4 + 144 >> 2];
        break label$27;
       }
       HEAP32[$4 + 160 >> 2] = HEAP32[$4 + 140 >> 2];
       HEAP32[$4 + 156 >> 2] = HEAP32[$4 + 144 >> 2];
       break label$27;
      }
      HEAP32[$4 + 156 >> 2] = HEAP32[$4 + 136 >> 2];
      HEAP32[$4 + 152 >> 2] = HEAP32[$4 + 140 >> 2];
     }
    }
    label$33 : {
     if (HEAPU8[$4 + 224 | 0] == 16) {
      HEAP32[$4 + 204 >> 2] = HEAP32[$4 + 156 >> 2] >> 2 << 5 | HEAP32[$4 + 152 >> 2] >> 3 | HEAP32[$4 + 160 >> 2] >> 3 << 11;
      break label$33;
     }
     label$35 : {
      if (HEAPU8[$4 + 224 | 0] == 32) {
       HEAP32[$4 + 204 >> 2] = HEAP32[$4 + 152 >> 2] | HEAP32[$4 + 156 >> 2] << 8 | HEAP32[$4 + 160 >> 2] << 16 | -16777216;
       break label$35;
      }
      label$37 : {
       if (HEAPU8[$4 + 224 | 0] == 24) {
        HEAP32[$4 + 204 >> 2] = HEAP32[$4 + 152 >> 2] | HEAP32[$4 + 156 >> 2] << 8 | HEAP32[$4 + 160 >> 2] << 16;
        break label$37;
       }
       label$39 : {
        if (HEAPU8[$4 + 224 | 0] == 4) {
         HEAP32[$4 + 132 >> 2] = 2147483647;
         HEAP32[$4 + 204 >> 2] = 0;
         HEAP32[$4 + 128 >> 2] = 0;
         while (1) {
          if (HEAPU32[$4 + 128 >> 2] < 16) {
           HEAP32[$4 + 124 >> 2] = HEAPU16[(HEAP32[$4 + 128 >> 2] << 1) + 126528 >> 1];
           HEAP32[$4 + 120 >> 2] = HEAP32[$4 + 124 >> 2] >> 8 & 248;
           HEAP32[$4 + 116 >> 2] = HEAP32[$4 + 124 >> 2] >> 3 & 252;
           HEAP32[$4 + 112 >> 2] = HEAP32[$4 + 124 >> 2] << 3 & 248;
           HEAP32[$4 + 120 >> 2] = HEAP32[$4 + 120 >> 2] | HEAP32[$4 + 120 >> 2] >> 5;
           HEAP32[$4 + 116 >> 2] = HEAP32[$4 + 116 >> 2] | HEAP32[$4 + 112 >> 2] >> 6;
           HEAP32[$4 + 112 >> 2] = HEAP32[$4 + 112 >> 2] | HEAP32[$4 + 112 >> 2] >> 5;
           HEAP32[$4 + 108 >> 2] = HEAP32[$4 + 120 >> 2] - HEAP32[$4 + 160 >> 2];
           HEAP32[$4 + 104 >> 2] = HEAP32[$4 + 116 >> 2] - HEAP32[$4 + 156 >> 2];
           HEAP32[$4 + 100 >> 2] = HEAP32[$4 + 112 >> 2] - HEAP32[$4 + 152 >> 2];
           HEAP32[$4 + 96 >> 2] = (Math_imul(HEAP32[$4 + 108 >> 2], HEAP32[$4 + 108 >> 2]) + Math_imul(HEAP32[$4 + 104 >> 2], HEAP32[$4 + 104 >> 2]) | 0) + Math_imul(HEAP32[$4 + 100 >> 2], HEAP32[$4 + 100 >> 2]);
           if (HEAP32[$4 + 96 >> 2] < HEAP32[$4 + 132 >> 2]) {
            HEAP32[$4 + 132 >> 2] = HEAP32[$4 + 96 >> 2];
            HEAP32[$4 + 204 >> 2] = HEAP32[$4 + 128 >> 2];
           }
           HEAP32[$4 + 128 >> 2] = HEAP32[$4 + 128 >> 2] + 1;
           continue;
          }
          break;
         }
         break label$39;
        }
        label$44 : {
         if (HEAPU8[$4 + 224 | 0] == 8) {
          HEAP32[$4 + 92 >> 2] = 2147483647;
          HEAP32[$4 + 204 >> 2] = 0;
          HEAP32[$4 + 88 >> 2] = 0;
          while (1) {
           if (HEAP32[$4 + 88 >> 2] < 255) {
            HEAP32[$4 + 84 >> 2] = HEAPU16[(HEAP32[$4 + 88 >> 2] << 1) + 126560 >> 1];
            HEAP32[$4 + 80 >> 2] = HEAP32[$4 + 84 >> 2] >> 8 & 248;
            HEAP32[$4 + 76 >> 2] = HEAP32[$4 + 84 >> 2] >> 3 & 252;
            HEAP32[$4 + 72 >> 2] = HEAP32[$4 + 84 >> 2] << 3 & 248;
            HEAP32[$4 + 80 >> 2] = HEAP32[$4 + 80 >> 2] | HEAP32[$4 + 80 >> 2] >> 5;
            HEAP32[$4 + 76 >> 2] = HEAP32[$4 + 76 >> 2] | HEAP32[$4 + 72 >> 2] >> 6;
            HEAP32[$4 + 72 >> 2] = HEAP32[$4 + 72 >> 2] | HEAP32[$4 + 72 >> 2] >> 5;
            HEAP32[$4 + 68 >> 2] = HEAP32[$4 + 80 >> 2] - HEAP32[$4 + 160 >> 2];
            HEAP32[$4 + 64 >> 2] = HEAP32[$4 + 76 >> 2] - HEAP32[$4 + 156 >> 2];
            HEAP32[$4 + 60 >> 2] = HEAP32[$4 + 72 >> 2] - HEAP32[$4 + 152 >> 2];
            HEAP32[$4 + 56 >> 2] = (Math_imul(HEAP32[$4 + 68 >> 2], HEAP32[$4 + 68 >> 2]) + Math_imul(HEAP32[$4 + 64 >> 2], HEAP32[$4 + 64 >> 2]) | 0) + Math_imul(HEAP32[$4 + 60 >> 2], HEAP32[$4 + 60 >> 2]);
            if (HEAP32[$4 + 56 >> 2] < HEAP32[$4 + 92 >> 2]) {
             HEAP32[$4 + 92 >> 2] = HEAP32[$4 + 56 >> 2];
             HEAP32[$4 + 204 >> 2] = HEAP32[$4 + 88 >> 2];
            }
            HEAP32[$4 + 88 >> 2] = HEAP32[$4 + 88 >> 2] + 1;
            continue;
           }
           break;
          }
          break label$44;
         }
         HEAP32[$4 + 204 >> 2] = (HEAP32[$4 + 152 >> 2] + (HEAP32[$4 + 160 >> 2] + HEAP32[$4 + 156 >> 2] | 0) | 0) >= 384 ? -1 : 0;
        }
       }
      }
     }
    }
    break label$9;
   }
   HEAP32[$4 + 204 >> 2] = jsvGetInteger(HEAP32[$4 + 292 >> 2]);
  }
  HEAP32[$4 + 300 >> 2] = HEAP32[$4 + 204 >> 2];
 }
 global$0 = $4 + 304 | 0;
 return HEAP32[$4 + 300 >> 2];
}
function dispose_chunk($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $5 = $0 + $1 | 0;
 label$1 : {
  label$2 : {
   label$3 : {
    $2 = HEAP32[$0 + 4 >> 2];
    if ($2 & 1) {
     break label$3;
    }
    if (!($2 & 3)) {
     break label$2;
    }
    $4 = HEAP32[$0 >> 2];
    $0 = $0 - $4 | 0;
    $7 = HEAP32[84263];
    if ($0 >>> 0 < $7 >>> 0) {
     break label$1;
    }
    $1 = $1 + $4 | 0;
    if (HEAP32[84264] != ($0 | 0)) {
     if ($4 >>> 0 <= 255) {
      $2 = HEAP32[$0 + 12 >> 2];
      $3 = HEAP32[$0 + 8 >> 2];
      $4 = $4 >>> 3;
      $6 = ($4 << 3) + 337076 | 0;
      if (HEAP32[$3 + 12 >> 2] != ($0 | 0) | $7 >>> 0 > $3 >>> 0 ? ($3 | 0) != ($6 | 0) : 0) {
       break label$1;
      }
      if (($2 | 0) == ($3 | 0)) {
       HEAP32[84259] = HEAP32[84259] & __wasm_rotl_i32($4);
       break label$3;
      }
      if (HEAP32[$2 + 8 >> 2] != ($0 | 0) | $7 >>> 0 > $2 >>> 0 ? ($2 | 0) != ($6 | 0) : 0) {
       break label$1;
      }
      HEAP32[$3 + 12 >> 2] = $2;
      HEAP32[$2 + 8 >> 2] = $3;
      break label$3;
     }
     $8 = HEAP32[$0 + 24 >> 2];
     $2 = HEAP32[$0 + 12 >> 2];
     label$9 : {
      if (($2 | 0) != ($0 | 0)) {
       $3 = HEAP32[$0 + 8 >> 2];
       if ($7 >>> 0 > $3 >>> 0 | HEAP32[$3 + 12 >> 2] != ($0 | 0) | HEAP32[$2 + 8 >> 2] != ($0 | 0)) {
        break label$1;
       }
       HEAP32[$3 + 12 >> 2] = $2;
       HEAP32[$2 + 8 >> 2] = $3;
       break label$9;
      }
      label$11 : {
       $3 = $0 + 20 | 0;
       $4 = HEAP32[$3 >> 2];
       if ($4) {
        break label$11;
       }
       $3 = $0 + 16 | 0;
       $4 = HEAP32[$3 >> 2];
       if ($4) {
        break label$11;
       }
       $2 = 0;
       break label$9;
      }
      while (1) {
       $6 = $3;
       $2 = $4;
       $3 = $2 + 20 | 0;
       $4 = HEAP32[$3 >> 2];
       if ($4) {
        continue;
       }
       $3 = $2 + 16 | 0;
       $4 = HEAP32[$2 + 16 >> 2];
       if ($4) {
        continue;
       }
       break;
      }
      if ($7 >>> 0 > $6 >>> 0) {
       break label$1;
      }
      HEAP32[$6 >> 2] = 0;
     }
     if (!$8) {
      break label$3;
     }
     $3 = HEAP32[$0 + 28 >> 2];
     $4 = ($3 << 2) + 337340 | 0;
     label$13 : {
      if (HEAP32[$4 >> 2] == ($0 | 0)) {
       HEAP32[$4 >> 2] = $2;
       if ($2) {
        break label$13;
       }
       HEAP32[84260] = HEAP32[84260] & __wasm_rotl_i32($3);
       break label$3;
      }
      if (HEAPU32[84263] > $8 >>> 0) {
       break label$1;
      }
      HEAP32[$8 + (HEAP32[$8 + 16 >> 2] == ($0 | 0) ? 16 : 20) >> 2] = $2;
      if (!$2) {
       break label$3;
      }
     }
     $4 = HEAP32[84263];
     if ($4 >>> 0 > $2 >>> 0) {
      break label$1;
     }
     HEAP32[$2 + 24 >> 2] = $8;
     $3 = HEAP32[$0 + 16 >> 2];
     if ($3) {
      if ($4 >>> 0 > $3 >>> 0) {
       break label$1;
      }
      HEAP32[$2 + 16 >> 2] = $3;
      HEAP32[$3 + 24 >> 2] = $2;
     }
     $3 = HEAP32[$0 + 20 >> 2];
     if (!$3) {
      break label$3;
     }
     if (HEAPU32[84263] > $3 >>> 0) {
      break label$1;
     }
     HEAP32[$2 + 20 >> 2] = $3;
     HEAP32[$3 + 24 >> 2] = $2;
     break label$3;
    }
    $2 = HEAP32[$5 + 4 >> 2];
    if (($2 & 3) != 3) {
     break label$3;
    }
    HEAP32[84261] = $1;
    HEAP32[$5 + 4 >> 2] = $2 & -2;
    HEAP32[$0 + 4 >> 2] = $1 | 1;
    HEAP32[$5 >> 2] = $1;
    return;
   }
   $7 = HEAP32[84263];
   if ($5 >>> 0 < $7 >>> 0) {
    break label$1;
   }
   $9 = HEAP32[$5 + 4 >> 2];
   label$16 : {
    if (!($9 & 2)) {
     if (HEAP32[84265] == ($5 | 0)) {
      HEAP32[84265] = $0;
      $1 = HEAP32[84262] + $1 | 0;
      HEAP32[84262] = $1;
      HEAP32[$0 + 4 >> 2] = $1 | 1;
      if (HEAP32[84264] != ($0 | 0)) {
       break label$2;
      }
      HEAP32[84261] = 0;
      HEAP32[84264] = 0;
      return;
     }
     if (HEAP32[84264] == ($5 | 0)) {
      HEAP32[84264] = $0;
      $1 = HEAP32[84261] + $1 | 0;
      HEAP32[84261] = $1;
      HEAP32[$0 + 4 >> 2] = $1 | 1;
      HEAP32[$0 + $1 >> 2] = $1;
      return;
     }
     label$20 : {
      if ($9 >>> 0 <= 255) {
       $2 = HEAP32[$5 + 12 >> 2];
       $3 = HEAP32[$5 + 8 >> 2];
       $4 = $9 >>> 3;
       $6 = ($4 << 3) + 337076 | 0;
       if (HEAP32[$3 + 12 >> 2] != ($5 | 0) | $7 >>> 0 > $3 >>> 0 ? ($3 | 0) != ($6 | 0) : 0) {
        break label$1;
       }
       if (($2 | 0) == ($3 | 0)) {
        HEAP32[84259] = HEAP32[84259] & __wasm_rotl_i32($4);
        break label$20;
       }
       if (HEAP32[$2 + 8 >> 2] != ($5 | 0) | $7 >>> 0 > $2 >>> 0 ? ($2 | 0) != ($6 | 0) : 0) {
        break label$1;
       }
       HEAP32[$3 + 12 >> 2] = $2;
       HEAP32[$2 + 8 >> 2] = $3;
       break label$20;
      }
      $8 = HEAP32[$5 + 24 >> 2];
      $2 = HEAP32[$5 + 12 >> 2];
      label$25 : {
       if (($5 | 0) != ($2 | 0)) {
        $3 = HEAP32[$5 + 8 >> 2];
        if ($7 >>> 0 > $3 >>> 0 | HEAP32[$3 + 12 >> 2] != ($5 | 0) | HEAP32[$2 + 8 >> 2] != ($5 | 0)) {
         break label$1;
        }
        HEAP32[$3 + 12 >> 2] = $2;
        HEAP32[$2 + 8 >> 2] = $3;
        break label$25;
       }
       label$27 : {
        $3 = $5 + 20 | 0;
        $4 = HEAP32[$3 >> 2];
        if ($4) {
         break label$27;
        }
        $3 = $5 + 16 | 0;
        $4 = HEAP32[$3 >> 2];
        if ($4) {
         break label$27;
        }
        $2 = 0;
        break label$25;
       }
       while (1) {
        $6 = $3;
        $2 = $4;
        $3 = $2 + 20 | 0;
        $4 = HEAP32[$3 >> 2];
        if ($4) {
         continue;
        }
        $3 = $2 + 16 | 0;
        $4 = HEAP32[$2 + 16 >> 2];
        if ($4) {
         continue;
        }
        break;
       }
       if ($7 >>> 0 > $6 >>> 0) {
        break label$1;
       }
       HEAP32[$6 >> 2] = 0;
      }
      if (!$8) {
       break label$20;
      }
      $3 = HEAP32[$5 + 28 >> 2];
      $4 = ($3 << 2) + 337340 | 0;
      label$29 : {
       if (HEAP32[$4 >> 2] == ($5 | 0)) {
        HEAP32[$4 >> 2] = $2;
        if ($2) {
         break label$29;
        }
        HEAP32[84260] = HEAP32[84260] & __wasm_rotl_i32($3);
        break label$20;
       }
       if (HEAPU32[84263] > $8 >>> 0) {
        break label$1;
       }
       HEAP32[$8 + (HEAP32[$8 + 16 >> 2] == ($5 | 0) ? 16 : 20) >> 2] = $2;
       if (!$2) {
        break label$20;
       }
      }
      $4 = HEAP32[84263];
      if ($4 >>> 0 > $2 >>> 0) {
       break label$1;
      }
      HEAP32[$2 + 24 >> 2] = $8;
      $3 = HEAP32[$5 + 16 >> 2];
      if ($3) {
       if ($4 >>> 0 > $3 >>> 0) {
        break label$1;
       }
       HEAP32[$2 + 16 >> 2] = $3;
       HEAP32[$3 + 24 >> 2] = $2;
      }
      $3 = HEAP32[$5 + 20 >> 2];
      if (!$3) {
       break label$20;
      }
      if (HEAPU32[84263] > $3 >>> 0) {
       break label$1;
      }
      HEAP32[$2 + 20 >> 2] = $3;
      HEAP32[$3 + 24 >> 2] = $2;
     }
     $1 = ($9 & -8) + $1 | 0;
     HEAP32[$0 + 4 >> 2] = $1 | 1;
     HEAP32[$0 + $1 >> 2] = $1;
     if (HEAP32[84264] != ($0 | 0)) {
      break label$16;
     }
     HEAP32[84261] = $1;
     return;
    }
    HEAP32[$5 + 4 >> 2] = $9 & -2;
    HEAP32[$0 + 4 >> 2] = $1 | 1;
    HEAP32[$0 + $1 >> 2] = $1;
   }
   if ($1 >>> 0 <= 255) {
    $2 = $1 >>> 3;
    $1 = ($2 << 3) + 337076 | 0;
    $3 = HEAP32[84259];
    $2 = 1 << $2;
    label$33 : {
     if (!($3 & $2)) {
      HEAP32[84259] = $2 | $3;
      $3 = $1;
      break label$33;
     }
     $3 = HEAP32[$1 + 8 >> 2];
     if (HEAPU32[84263] > $3 >>> 0) {
      break label$1;
     }
    }
    HEAP32[$1 + 8 >> 2] = $0;
    HEAP32[$3 + 12 >> 2] = $0;
    HEAP32[$0 + 12 >> 2] = $1;
    HEAP32[$0 + 8 >> 2] = $3;
    return;
   }
   HEAP32[$0 + 16 >> 2] = 0;
   HEAP32[$0 + 20 >> 2] = 0;
   $3 = $0;
   $4 = $1 >>> 8;
   $2 = 0;
   label$35 : {
    if (!$4) {
     break label$35;
    }
    $2 = 31;
    if ($1 >>> 0 > 16777215) {
     break label$35;
    }
    $6 = $4 + 1048320 >>> 16 & 8;
    $4 = $4 << $6;
    $2 = $4 + 520192 >>> 16 & 4;
    $5 = $4 << $2;
    $4 = $5 + 245760 >>> 16 & 2;
    $2 = ($5 << $4 >>> 15) - ($4 | ($2 | $6)) | 0;
    $2 = ($2 << 1 | $1 >>> $2 + 21 & 1) + 28 | 0;
   }
   HEAP32[$3 + 28 >> 2] = $2;
   $4 = ($2 << 2) + 337340 | 0;
   label$36 : {
    $3 = HEAP32[84260];
    $6 = 1 << $2;
    label$37 : {
     if (!($3 & $6)) {
      HEAP32[84260] = $3 | $6;
      HEAP32[$4 >> 2] = $0;
      break label$37;
     }
     $3 = $1 << (($2 | 0) == 31 ? 0 : 25 - ($2 >>> 1) | 0);
     $2 = HEAP32[$4 >> 2];
     while (1) {
      $4 = $2;
      if ((HEAP32[$2 + 4 >> 2] & -8) == ($1 | 0)) {
       break label$36;
      }
      $2 = $3 >>> 29;
      $3 = $3 << 1;
      $6 = ($4 + ($2 & 4) | 0) + 16 | 0;
      $2 = HEAP32[$6 >> 2];
      if ($2) {
       continue;
      }
      break;
     }
     if (HEAPU32[84263] > $6 >>> 0) {
      break label$1;
     }
     HEAP32[$6 >> 2] = $0;
    }
    HEAP32[$0 + 24 >> 2] = $4;
    HEAP32[$0 + 12 >> 2] = $0;
    HEAP32[$0 + 8 >> 2] = $0;
    return;
   }
   $2 = HEAP32[84263];
   $1 = HEAP32[$4 + 8 >> 2];
   if ($2 >>> 0 > $1 >>> 0 | $2 >>> 0 > $4 >>> 0) {
    break label$1;
   }
   HEAP32[$1 + 12 >> 2] = $0;
   HEAP32[$4 + 8 >> 2] = $0;
   HEAP32[$0 + 24 >> 2] = 0;
   HEAP32[$0 + 12 >> 2] = $4;
   HEAP32[$0 + 8 >> 2] = $1;
  }
  return;
 }
 abort();
 abort();
}
function jspeStatementFor() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $0 = global$0 - 432 | 0;
 global$0 = $0;
 jslGetNextToken();
 label$1 : {
  if (!(jslMatch(40) & 1)) {
   break label$1;
  }
  HEAP8[$0 + 427 | 0] = (HEAP32[80549] & 512) != 0;
  HEAP32[80549] = HEAP32[80549] | 256;
  HEAP32[$0 + 420 >> 2] = 0;
  if (HEAP16[HEAP32[35539] + 2 >> 1] != 59) {
   HEAP32[$0 + 420 >> 2] = jspeStatement();
  }
  if (jspIsInterrupted() & 1) {
   jsvUnLock(HEAP32[$0 + 420 >> 2]);
   break label$1;
  }
  HEAP32[80549] = HEAP32[80549] & -257;
  label$5 : {
   if (!(HEAP16[HEAP32[35539] + 2 >> 1] != 198 ? HEAP16[HEAP32[35539] + 2 >> 1] != 185 : 0)) {
    HEAP8[$0 + 419 | 0] = HEAP16[HEAP32[35539] + 2 >> 1] == 198;
    label$8 : {
     if ((HEAP32[80549] & 63) != 1) {
      break label$8;
     }
     if (jsvIsName(HEAP32[$0 + 420 >> 2]) & 1) {
      break label$8;
     }
     jsvUnLock(HEAP32[$0 + 420 >> 2]);
     $1 = HEAP8[$0 + 419 | 0] & 1 ? 80665 : 80668;
     HEAP32[$0 + 20 >> 2] = HEAP32[$0 + 420 >> 2];
     HEAP32[$0 + 16 >> 2] = $1;
     jsExceptionHere(1, 80615, $0 + 16 | 0);
     break label$1;
    }
    $1 = $0 + 368 | 0;
    jslGetNextToken();
    HEAP32[$0 + 412 >> 2] = jsvSkipNameAndUnLock(jspeExpression());
    jslCharPosFromLex($1);
    if (!(jslMatch(41) & 1)) {
     $1 = $0 + 368 | 0;
     jsvUnLock2(HEAP32[$0 + 420 >> 2], HEAP32[$0 + 412 >> 2]);
     jslCharPosFree($1);
     break label$1;
    }
    $1 = $0 + 320 | 0;
    HEAP32[$0 + 364 >> 2] = HEAP32[80549];
    jspSetNoExecute();
    HEAP32[80549] = HEAP32[80549] | 512;
    jsvUnLock(jspeBlockOrStatement());
    jslCharPosNew($1, HEAP32[HEAP32[35539] + 84 >> 2], HEAP32[HEAP32[35539] + 4 >> 2]);
    if (!(HEAP8[$0 + 427 | 0] & 1)) {
     HEAP32[80549] = HEAP32[80549] & -513;
    }
    HEAP32[80549] = HEAP32[80549] & -1664 | HEAP32[$0 + 364 >> 2] & 1663;
    if ((HEAP32[80549] & 63) == 1) {
     label$12 : {
      if (jsvIsIterable(HEAP32[$0 + 412 >> 2]) & 1) {
       HEAP32[$0 + 316 >> 2] = jsvGetInternalFunctionCheckerFor(HEAP32[$0 + 412 >> 2]);
       HEAP32[$0 + 312 >> 2] = 0;
       if (!(HEAP8[$0 + 419 | 0] & 1)) {
        HEAP32[$0 + 312 >> 2] = jspGetBuiltinPrototype(HEAP32[$0 + 412 >> 2]);
       }
       jsvIteratorNew($0 + 248 | 0, HEAP32[$0 + 412 >> 2], HEAP8[$0 + 419 | 0] & 1 ? 1 : 0);
       HEAP8[$0 + 247 | 0] = 0;
       while (1) {
        $1 = 0;
        label$16 : {
         if ((HEAP32[80549] & 63) != 1) {
          break label$16;
         }
         $2 = !(jsvIteratorHasElement($0 + 248 | 0) & 1);
         $1 = 0;
         if ($2) {
          break label$16;
         }
         $1 = HEAPU8[$0 + 247 | 0] ^ -1;
        }
        if ($1 & 1) {
         HEAP32[$0 + 240 >> 2] = jsvIteratorGetKey($0 + 248 | 0);
         HEAP8[$0 + 239 | 0] = 0;
         label$18 : {
          if (!HEAP32[$0 + 316 >> 2]) {
           break label$18;
          }
          if (!(FUNCTION_TABLE[HEAP32[$0 + 316 >> 2]](HEAP32[$0 + 240 >> 2]) & 1)) {
           break label$18;
          }
          HEAP8[$0 + 239 | 0] = 1;
          label$19 : {
           if (!(jsvIsString(HEAP32[$0 + 240 >> 2]) & 1)) {
            break label$19;
           }
           if (!(jsvIsStringEqual(HEAP32[$0 + 240 >> 2], 79526) & 1)) {
            break label$19;
           }
           HEAP32[$0 + 312 >> 2] = jsvSkipName(HEAP32[$0 + 240 >> 2]);
          }
         }
         if (!(HEAP8[$0 + 239 | 0] & 1)) {
          label$21 : {
           if (HEAP8[$0 + 419 | 0] & 1) {
            HEAP32[$0 + 232 >> 2] = jsvIteratorGetValue($0 + 248 | 0);
            break label$21;
           }
           $1 = $0;
           label$23 : {
            if (jsvIsName(HEAP32[$0 + 240 >> 2]) & 1) {
             $2 = jsvCopyNameOnly(HEAP32[$0 + 240 >> 2], 0, 0);
             break label$23;
            }
            $2 = HEAP32[$0 + 240 >> 2];
           }
           HEAP32[$1 + 232 >> 2] = $2;
          }
          if (!(HEAP32[$0 + 232 >> 2] ? 0 : !(HEAP8[$0 + 419 | 0] & 1))) {
           jsvReplaceWithOrAddToRoot(HEAP32[$0 + 420 >> 2], HEAP32[$0 + 232 >> 2]);
           if (HEAP32[$0 + 232 >> 2] != HEAP32[$0 + 240 >> 2]) {
            jsvUnLock(HEAP32[$0 + 232 >> 2]);
           }
           jslSeekToP($0 + 368 | 0);
           HEAP32[80549] = HEAP32[80549] | 512;
           jspDebuggerLoopIfCtrlC();
           jsvUnLock(jspeBlockOrStatement());
           if (!(HEAP8[$0 + 427 | 0] & 1)) {
            HEAP32[80549] = HEAP32[80549] & -513;
           }
           HEAP8[$0 + 247 | 0] = (jspeCheckBreakContinue() & 1 | HEAP8[$0 + 247 | 0] & 1) != 0;
          }
         }
         $1 = $0 + 248 | 0;
         jsvIteratorNext($1);
         jsvUnLock(HEAP32[$0 + 240 >> 2]);
         if (!(jsvIteratorHasElement($1) & 1 | HEAP8[$0 + 419 | 0] & 1 | !HEAP32[$0 + 312 >> 2])) {
          $1 = $0 + 248 | 0;
          jsvIteratorFree($1);
          HEAP32[$0 + 228 >> 2] = HEAP32[$0 + 312 >> 2];
          jsvIteratorNew($1, HEAP32[$0 + 228 >> 2], 0);
          HEAP32[$0 + 316 >> 2] = jsvGetInternalFunctionCheckerFor(HEAP32[$0 + 228 >> 2]);
          HEAP32[$0 + 312 >> 2] = jspGetBuiltinPrototype(HEAP32[$0 + 228 >> 2]);
          jsvUnLock(HEAP32[$0 + 228 >> 2]);
         }
         continue;
        }
        break;
       }
       jsvIteratorFree($0 + 248 | 0);
       break label$12;
      }
      if (!(jsvIsUndefined(HEAP32[$0 + 412 >> 2]) & 1)) {
       HEAP32[$0 >> 2] = HEAP32[$0 + 412 >> 2];
       jsExceptionHere(1, 80671, $0);
      }
     }
    }
    $1 = $0 + 368 | 0;
    $2 = $0 + 320 | 0;
    jslSeekToP($2);
    jslCharPosFree($1);
    jslCharPosFree($2);
    jsvUnLock2(HEAP32[$0 + 420 >> 2], HEAP32[$0 + 412 >> 2]);
    break label$5;
   }
   $1 = $0 + 184 | 0;
   HEAP8[$0 + 227 | 0] = 1;
   HEAP8[$0 + 226 | 0] = 0;
   jsvUnLock(HEAP32[$0 + 420 >> 2]);
   jslCharPosFromLex($1);
   if (!(jslMatch(59) & 1)) {
    jslCharPosFree($0 + 184 | 0);
    break label$1;
   }
   if (HEAP16[HEAP32[35539] + 2 >> 1] != 59) {
    HEAP32[$0 + 180 >> 2] = jspeExpression();
    $1 = $0;
    if ((HEAP32[80549] & 63) == 1) {
     $2 = jsvGetBoolAndUnLock(jsvSkipName(HEAP32[$0 + 180 >> 2]));
    } else {
     $2 = 0;
    }
    HEAP8[$1 + 227 | 0] = $2 & 1;
    jsvUnLock(HEAP32[$0 + 180 >> 2]);
   }
   jslCharPosFromLex($0 + 136 | 0);
   if (!(jslMatch(59) & 1)) {
    $1 = $0 + 136 | 0;
    jslCharPosFree($0 + 184 | 0);
    jslCharPosFree($1);
    break label$1;
   }
   if (HEAP16[HEAP32[35539] + 2 >> 1] != 41) {
    HEAP32[$0 + 132 >> 2] = HEAP32[80549];
    jspSetNoExecute();
    jsvUnLock(jspeExpression());
    HEAP32[80549] = HEAP32[80549] & -1664 | HEAP32[$0 + 132 >> 2] & 1663;
   }
   $1 = $0 + 88 | 0;
   jslSkipWhiteSpace();
   jslCharPosFromLex($1);
   if (!(jslMatch(41) & 1)) {
    $1 = $0 + 88 | 0;
    $2 = $0 + 136 | 0;
    jslCharPosFree($0 + 184 | 0);
    jslCharPosFree($2);
    jslCharPosFree($1);
    break label$1;
   }
   HEAP32[$0 + 84 >> 2] = HEAP32[80549];
   if (!(HEAP8[$0 + 227 | 0] & 1)) {
    jspSetNoExecute();
   }
   $1 = $0 + 40 | 0;
   HEAP32[80549] = HEAP32[80549] | 512;
   jsvUnLock(jspeBlockOrStatement());
   jslSkipWhiteSpace();
   jslCharPosNew($1, HEAP32[HEAP32[35539] + 84 >> 2], HEAP32[HEAP32[35539] + 4 >> 2]);
   if (!(HEAP8[$0 + 427 | 0] & 1)) {
    HEAP32[80549] = HEAP32[80549] & -513;
   }
   if (!((HEAP32[80549] & 63) == 1 ? !(HEAP8[$0 + 227 | 0] & 1) : 0)) {
    HEAP8[$0 + 226 | 0] = (jspeCheckBreakContinue() & 1 | HEAP8[$0 + 226 | 0] & 1) != 0;
   }
   if (!(HEAP8[$0 + 227 | 0] & 1)) {
    HEAP32[80549] = HEAP32[80549] & -1664 | HEAP32[$0 + 84 >> 2] & 1663;
   }
   if (HEAP8[$0 + 227 | 0] & 1) {
    jslSeekToP($0 + 136 | 0);
    if (HEAP16[HEAP32[35539] + 2 >> 1] != 41) {
     jsvUnLock(jspeExpression());
    }
   }
   while (1) {
    $1 = 0;
    label$46 : {
     if (HEAP8[$0 + 226 | 0] & 1) {
      break label$46;
     }
     $1 = 0;
     if ((HEAP32[80549] & 63) != 1) {
      break label$46;
     }
     $1 = HEAPU8[$0 + 227 | 0];
    }
    if ($1 & 1) {
     jslSeekToP($0 + 184 | 0);
     label$48 : {
      if (HEAP16[HEAP32[35539] + 2 >> 1] == 59) {
       HEAP8[$0 + 227 | 0] = 1;
       break label$48;
      }
      HEAP32[$0 + 36 >> 2] = jspeExpression();
      HEAP8[$0 + 227 | 0] = jsvGetBoolAndUnLock(jsvSkipName(HEAP32[$0 + 36 >> 2])) & 1;
      jsvUnLock(HEAP32[$0 + 36 >> 2]);
     }
     if (!(!(HEAP8[$0 + 227 | 0] & 1) | (HEAP32[80549] & 63) != 1)) {
      jslSeekToP($0 + 88 | 0);
      HEAP32[80549] = HEAP32[80549] | 512;
      jspDebuggerLoopIfCtrlC();
      jsvUnLock(jspeBlockOrStatement());
      if (!(HEAP8[$0 + 427 | 0] & 1)) {
       HEAP32[80549] = HEAP32[80549] & -513;
      }
      HEAP8[$0 + 226 | 0] = (jspeCheckBreakContinue() & 1 | HEAP8[$0 + 226 | 0] & 1) != 0;
     }
     if (!(HEAP8[$0 + 226 | 0] & 1 | (!(HEAP8[$0 + 227 | 0] & 1) | (HEAP32[80549] & 63) != 1))) {
      jslSeekToP($0 + 136 | 0);
      if (HEAP16[HEAP32[35539] + 2 >> 1] != 41) {
       jsvUnLock(jspeExpression());
      }
     }
     continue;
    }
    break;
   }
   $1 = $0 + 88 | 0;
   $2 = $0 + 136 | 0;
   $4 = $0 + 184 | 0;
   $3 = $0 + 40 | 0;
   jslSeekToP($3);
   jslCharPosFree($4);
   jslCharPosFree($2);
   jslCharPosFree($1);
   jslCharPosFree($3);
  }
 }
 HEAP32[$0 + 428 >> 2] = 0;
 global$0 = $0 + 432 | 0;
 return HEAP32[$0 + 428 >> 2];
}
function jswrap_graphics_drawImages($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $3 = global$0 - 1024 | 0;
 global$0 = $3;
 HEAP32[$3 + 1016 >> 2] = $0;
 HEAP32[$3 + 1012 >> 2] = $1;
 HEAP32[$3 + 1008 >> 2] = $2;
 HEAP32[$3 + 1004 >> 2] = 4;
 label$1 : {
  if (!(graphicsGetFromVar($3 + 928 | 0, HEAP32[$3 + 1016 >> 2]) & 1)) {
   HEAP32[$3 + 1020 >> 2] = 0;
   break label$1;
  }
  label$3 : {
   if (jsvIsArray(HEAP32[$3 + 1012 >> 2]) & 1) {
    $0 = jsvGetArrayLength(HEAP32[$3 + 1012 >> 2]);
    HEAP32[$3 + 152 >> 2] = $0;
    if (($0 | 0) <= 4) {
     break label$3;
    }
   }
   HEAP32[$3 + 32 >> 2] = 4;
   jsExceptionHere(3, 127905, $3 + 32 | 0);
   HEAP32[$3 + 1020 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 148 >> 2] = 1e4;
  HEAP32[$3 + 144 >> 2] = 1e4;
  HEAP32[$3 + 140 >> 2] = 1e4;
  HEAP32[$3 + 136 >> 2] = 1e4;
  HEAP8[$3 + 135 | 0] = 1;
  HEAP32[$3 + 156 >> 2] = 0;
  while (1) {
   if (HEAP32[$3 + 156 >> 2] < HEAP32[$3 + 152 >> 2]) {
    HEAP32[$3 + 128 >> 2] = jsvGetArrayItem(HEAP32[$3 + 1012 >> 2], HEAP32[$3 + 156 >> 2]);
    label$7 : {
     if (jsvIsObject(HEAP32[$3 + 128 >> 2]) & 1) {
      $0 = $3 + 928 | 0;
      $1 = $3 + 160 | 0;
      HEAP32[$3 + 124 >> 2] = jsvObjectGetChild(HEAP32[$3 + 128 >> 2], 127957, 0);
      label$9 : {
       if (_jswrap_graphics_parseImage($0, HEAP32[$3 + 124 >> 2], 0, ($1 + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0) + 36 | 0) & 1) {
        $0 = $3 + 160 | 0;
        $1 = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$3 + 128 >> 2], 127462, 0));
        HEAP32[$0 + Math_imul(HEAP32[$3 + 156 >> 2], 192) >> 2] = $1;
        $1 = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$3 + 128 >> 2], 127464, 0));
        HEAP32[($0 + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0) + 4 >> 2] = $1;
        $4 = jsvGetFloatAndUnLock(jsvObjectGetChild(HEAP32[$3 + 128 >> 2], 127892, 0));
        HEAPF64[($0 + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0) + 24 >> 3] = $4;
        $0 = __DOUBLE_BITS(HEAPF64[(($3 + 160 | 0) + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0) + 24 >> 3]);
        $1 = i64toi32_i32$HIGH_BITS & 2147483647;
        if (!(HEAPF64[(($3 + 160 | 0) + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0) + 24 >> 3] <= 0 ? 0 : !(($1 | 0) == 2146435072 & $0 >>> 0 >= 0 | $1 >>> 0 > 2146435072))) {
         HEAPF64[(($3 + 160 | 0) + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0) + 24 >> 3] = 1;
        }
        $0 = $3 + 160 | 0;
        $4 = jsvGetFloatAndUnLock(jsvObjectGetChild(HEAP32[$3 + 128 >> 2], 127898, 0));
        HEAPF64[($0 + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0) + 16 >> 3] = $4;
        $0 = __DOUBLE_BITS(HEAPF64[(($3 + 160 | 0) + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0) + 16 >> 3]);
        $1 = i64toi32_i32$HIGH_BITS & 2147483647;
        if (($1 | 0) == 2146435072 & $0 >>> 0 >= 0 | $1 >>> 0 > 2146435072) {
         HEAPF64[(($3 + 160 | 0) + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0) + 16 >> 3] = 0;
        }
        $0 = $3 + 160 | 0;
        $1 = jsvGetBoolAndUnLock(jsvObjectGetChild(HEAP32[$3 + 128 >> 2], 127963, 0));
        HEAP8[($0 + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0) + 32 | 0] = $1 & 1;
        $1 = jsvGetBoolAndUnLock(jsvObjectGetChild(HEAP32[$3 + 128 >> 2], 127970, 0));
        HEAP8[($0 + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0) + 33 | 0] = $1 & 1;
        _jswrap_drawImageLayerInit($0 + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0);
        if (!(jsvGetBoolAndUnLock(jsvObjectGetChild(HEAP32[$3 + 128 >> 2], 127977, 0)) & 1)) {
         if (HEAP32[($3 + 160 | 0) + Math_imul(HEAP32[$3 + 156 >> 2], 192) >> 2] < HEAP32[$3 + 148 >> 2]) {
          HEAP32[$3 + 148 >> 2] = HEAP32[($3 + 160 | 0) + Math_imul(HEAP32[$3 + 156 >> 2], 192) >> 2];
         }
         if (HEAP32[(($3 + 160 | 0) + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0) + 4 >> 2] < HEAP32[$3 + 144 >> 2]) {
          HEAP32[$3 + 144 >> 2] = HEAP32[(($3 + 160 | 0) + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0) + 4 >> 2];
         }
         if (HEAP32[(($3 + 160 | 0) + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0) + 8 >> 2] > (HEAP32[$3 + 148 >> 2] + HEAP32[$3 + 140 >> 2] | 0)) {
          HEAP32[$3 + 140 >> 2] = HEAP32[(($3 + 160 | 0) + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0) + 8 >> 2] - HEAP32[$3 + 148 >> 2];
         }
         if (HEAP32[(($3 + 160 | 0) + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0) + 12 >> 2] > (HEAP32[$3 + 144 >> 2] + HEAP32[$3 + 136 >> 2] | 0)) {
          HEAP32[$3 + 136 >> 2] = HEAP32[(($3 + 160 | 0) + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0) + 12 >> 2] - HEAP32[$3 + 144 >> 2];
         }
        }
        break label$9;
       }
       HEAP8[$3 + 135 | 0] = 0;
      }
      jsvUnLock(HEAP32[$3 + 124 >> 2]);
      break label$7;
     }
     HEAP8[$3 + 135 | 0] = 0;
    }
    jsvUnLock(HEAP32[$3 + 128 >> 2]);
    HEAP32[$3 + 156 >> 2] = HEAP32[$3 + 156 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$3 + 64 >> 2] = 127462;
  HEAP16[$3 + 68 >> 1] = 9;
  HEAP32[$3 + 72 >> 2] = $3 + 148;
  HEAP32[$3 + 76 >> 2] = 127464;
  HEAP16[$3 + 80 >> 1] = 9;
  HEAP32[$3 + 84 >> 2] = $3 + 144;
  HEAP32[$3 + 88 >> 2] = 127442;
  HEAP16[$3 + 92 >> 1] = 9;
  HEAP32[$3 + 96 >> 2] = $3 + 140;
  HEAP32[$3 + 100 >> 2] = 127448;
  HEAP16[$3 + 104 >> 1] = 9;
  HEAP32[$3 + 108 >> 2] = $3 + 136;
  if (!(jsvReadConfigObject(HEAP32[$3 + 1008 >> 2], $3 - -64 | 0, 4) & 1)) {
   HEAP8[$3 + 135 | 0] = 0;
  }
  HEAP32[$3 + 60 >> 2] = (HEAP32[$3 + 148 >> 2] + HEAP32[$3 + 140 >> 2] | 0) - 1;
  HEAP32[$3 + 56 >> 2] = (HEAP32[$3 + 144 >> 2] + HEAP32[$3 + 136 >> 2] | 0) - 1;
  $0 = $3 + 928 | 0;
  graphicsSetModifiedAndClip($0, $3 + 148 | 0, $3 + 144 | 0, $3 + 60 | 0, $3 + 56 | 0);
  HEAP32[$3 + 52 >> 2] = graphicsGetSetPixelFn($0);
  if (HEAP8[$3 + 135 | 0] & 1) {
   HEAP32[$3 + 156 >> 2] = 0;
   while (1) {
    if (HEAP32[$3 + 156 >> 2] < HEAP32[$3 + 152 >> 2]) {
     $0 = $3 + 160 | 0;
     jsvStringIteratorNew(($0 + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0) + 120 | 0, HEAP32[($0 + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0) + 56 >> 2], HEAP32[($0 + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0) + 60 >> 2]);
     _jswrap_drawImageLayerSetStart($0 + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0, HEAP32[$3 + 148 >> 2], HEAP32[$3 + 144 >> 2]);
     HEAP32[$3 + 156 >> 2] = HEAP32[$3 + 156 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$3 + 48 >> 2] = HEAP32[$3 + 144 >> 2];
   while (1) {
    if (HEAP32[$3 + 48 >> 2] <= HEAP32[$3 + 56 >> 2]) {
     HEAP32[$3 + 156 >> 2] = 0;
     while (1) {
      if (HEAP32[$3 + 156 >> 2] < HEAP32[$3 + 152 >> 2]) {
       _jswrap_drawImageLayerStartX(($3 + 160 | 0) + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0);
       HEAP32[$3 + 156 >> 2] = HEAP32[$3 + 156 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 148 >> 2];
     while (1) {
      if (HEAP32[$3 + 44 >> 2] <= HEAP32[$3 + 60 >> 2]) {
       HEAP8[$3 + 43 | 0] = 0;
       HEAP32[$3 + 36 >> 2] = 0;
       HEAP32[$3 + 156 >> 2] = HEAP32[$3 + 152 >> 2] - 1;
       while (1) {
        if (HEAP32[$3 + 156 >> 2] >= 0) {
         if (_jswrap_drawImageLayerGetPixel(($3 + 160 | 0) + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0, $3 + 36 | 0) & 1) {
          HEAP8[$3 + 43 | 0] = 1;
         } else {
          HEAP32[$3 + 156 >> 2] = HEAP32[$3 + 156 >> 2] + -1;
          continue;
         }
        }
        break;
       }
       if (HEAP8[$3 + 43 | 0] & 1) {
        FUNCTION_TABLE[HEAP32[$3 + 52 >> 2]]($3 + 928 | 0, HEAP32[$3 + 44 >> 2], HEAP32[$3 + 48 >> 2], HEAP32[$3 + 36 >> 2]);
       }
       HEAP32[$3 + 156 >> 2] = 0;
       while (1) {
        if (HEAP32[$3 + 156 >> 2] < HEAP32[$3 + 152 >> 2]) {
         $0 = $3 + 160 | 0;
         _jswrap_drawImageLayerNextX($0 + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0);
         _jswrap_drawImageLayerNextXRepeat($0 + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0);
         HEAP32[$3 + 156 >> 2] = HEAP32[$3 + 156 >> 2] + 1;
         continue;
        }
        break;
       }
       HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 44 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$3 + 156 >> 2] = 0;
     while (1) {
      if (HEAP32[$3 + 156 >> 2] < HEAP32[$3 + 152 >> 2]) {
       _jswrap_drawImageLayerNextY(($3 + 160 | 0) + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0);
       HEAP32[$3 + 156 >> 2] = HEAP32[$3 + 156 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$3 + 48 >> 2] = HEAP32[$3 + 48 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$3 + 156 >> 2] = 0;
   while (1) {
    if (HEAP32[$3 + 156 >> 2] < HEAP32[$3 + 152 >> 2]) {
     jsvStringIteratorFree((Math_imul(HEAP32[$3 + 156 >> 2], 192) + $3 | 0) + 280 | 0);
     HEAP32[$3 + 156 >> 2] = HEAP32[$3 + 156 >> 2] + 1;
     continue;
    }
    break;
   }
  }
  HEAP32[$3 + 156 >> 2] = 0;
  while (1) {
   if (HEAP32[$3 + 156 >> 2] < HEAP32[$3 + 152 >> 2]) {
    jsvUnLock(HEAP32[(($3 + 160 | 0) + Math_imul(HEAP32[$3 + 156 >> 2], 192) | 0) + 56 >> 2]);
    HEAP32[$3 + 156 >> 2] = HEAP32[$3 + 156 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$3 + 1020 >> 2] = jsvLockAgain(HEAP32[$3 + 1016 >> 2]);
 }
 global$0 = $3 + 1024 | 0;
 return HEAP32[$3 + 1020 >> 2];
}
function _jsvTrace($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 336 | 0;
 global$0 = $4;
 HEAP32[$4 + 332 >> 2] = $0;
 HEAP32[$4 + 328 >> 2] = $1;
 HEAP32[$4 + 324 >> 2] = $2;
 HEAP32[$4 + 320 >> 2] = $3;
 HEAP32[$4 + 316 >> 2] = 0;
 while (1) {
  if (HEAP32[$4 + 316 >> 2] < HEAP32[$4 + 328 >> 2]) {
   jsiConsolePrintString(78839);
   HEAP32[$4 + 316 >> 2] = HEAP32[$4 + 316 >> 2] + 1;
   continue;
  }
  break;
 }
 label$3 : {
  if (!HEAP32[$4 + 332 >> 2]) {
   jsiConsolePrintString(78366);
   break label$3;
  }
  if (!(HEAP32[$4 + 332 >> 2] != HEAP32[80545] | HEAP32[$4 + 320 >> 2] <= 0)) {
   jsiConsolePrintString(78841);
   break label$3;
  }
  jsvTraceLockInfo(HEAP32[$4 + 332 >> 2]);
  HEAP32[$4 + 312 >> 2] = _jsvTraceGetLowestLevel(HEAP32[$4 + 324 >> 2], HEAP32[$4 + 332 >> 2]);
  if (!(HEAP32[$4 + 312 >> 2] < 0 | HEAP32[$4 + 312 >> 2] >= HEAP32[$4 + 320 >> 2] ? HEAP32[$4 + 320 >> 2] <= 16 : 0)) {
   jsiConsolePrintString(78846);
   break label$3;
  }
  label$8 : {
   if (jsvIsNewChild(HEAP32[$4 + 332 >> 2]) & 1) {
    jsiConsolePrintString(78851);
    HEAP32[$4 + 308 >> 2] = jsvGetAddressOf(jsvGetNextSibling(HEAP32[$4 + 332 >> 2]) & 65535);
    _jsvTrace(HEAP32[$4 + 308 >> 2], HEAP32[$4 + 328 >> 2] + 2 | 0, HEAP32[$4 + 324 >> 2], HEAP32[$4 + 320 >> 2] + 1 | 0);
    jsiConsolePrintString(78868);
    break label$8;
   }
   if (jsvIsName(HEAP32[$4 + 332 >> 2]) & 1) {
    jsiConsolePrintString(78876);
   }
  }
  HEAP8[$4 + 307 | 0] = 32;
  label$11 : {
   if (jsvIsObject(HEAP32[$4 + 332 >> 2]) & 1) {
    jsiConsolePrintString(78882);
    HEAP8[$4 + 307 | 0] = 125;
    break label$11;
   }
   label$13 : {
    if (jsvIsGetterOrSetter(HEAP32[$4 + 332 >> 2]) & 1) {
     jsiConsolePrintString(78892);
     HEAP8[$4 + 307 | 0] = 125;
     break label$13;
    }
    label$15 : {
     if (jsvIsArray(HEAP32[$4 + 332 >> 2]) & 1) {
      $0 = HEAP32[$4 + 332 >> 2];
      HEAP32[$4 + 48 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
      jsiConsolePrintf(78909, $4 + 48 | 0);
      HEAP8[$4 + 307 | 0] = 93;
      break label$15;
     }
     label$17 : {
      if (jsvIsNativeFunction(HEAP32[$4 + 332 >> 2]) & 1) {
       $0 = HEAP32[$4 + 332 >> 2];
       $0 = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
       $1 = HEAP32[$4 + 332 >> 2];
       HEAP32[$4 + 68 >> 2] = HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8;
       HEAP32[$4 + 64 >> 2] = $0;
       jsiConsolePrintf(78922, $4 - -64 | 0);
       HEAP8[$4 + 307 | 0] = 125;
       break label$17;
      }
      label$19 : {
       if (jsvIsFunction(HEAP32[$4 + 332 >> 2]) & 1) {
        jsiConsolePrintString(78950);
        if (jsvIsFunctionReturn(HEAP32[$4 + 332 >> 2]) & 1) {
         jsiConsolePrintString(78962);
        }
        HEAP8[$4 + 307 | 0] = 125;
        break label$19;
       }
       label$22 : {
        if (jsvIsPin(HEAP32[$4 + 332 >> 2]) & 1) {
         HEAP32[$4 + 80 >> 2] = jsvGetInteger(HEAP32[$4 + 332 >> 2]);
         jsiConsolePrintf(78970, $4 + 80 | 0);
         break label$22;
        }
        label$24 : {
         if (jsvIsInt(HEAP32[$4 + 332 >> 2]) & 1) {
          HEAP32[$4 + 96 >> 2] = jsvGetInteger(HEAP32[$4 + 332 >> 2]);
          jsiConsolePrintf(78977, $4 + 96 | 0);
          break label$24;
         }
         label$26 : {
          if (jsvIsBoolean(HEAP32[$4 + 332 >> 2]) & 1) {
           HEAP32[$4 + 112 >> 2] = jsvGetBool(HEAP32[$4 + 332 >> 2]) & 1 ? 78381 : 78386;
           jsiConsolePrintf(78988, $4 + 112 | 0);
           break label$26;
          }
          label$28 : {
           if (jsvIsFloat(HEAP32[$4 + 332 >> 2]) & 1) {
            HEAPF64[$4 + 128 >> 3] = jsvGetFloat(HEAP32[$4 + 332 >> 2]);
            jsiConsolePrintf(78996, $4 + 128 | 0);
            break label$28;
           }
           label$30 : {
            if (jsvIsFunctionParameter(HEAP32[$4 + 332 >> 2]) & 1) {
             HEAP32[$4 + 144 >> 2] = HEAP32[$4 + 332 >> 2];
             jsiConsolePrintf(79006, $4 + 144 | 0);
             break label$30;
            }
            label$32 : {
             if (jsvIsArrayBufferName(HEAP32[$4 + 332 >> 2]) & 1) {
              HEAP32[$4 + 160 >> 2] = jsvGetInteger(HEAP32[$4 + 332 >> 2]);
              jsiConsolePrintf(79016, $4 + 160 | 0);
              break label$32;
             }
             label$34 : {
              if (jsvIsArrayBuffer(HEAP32[$4 + 332 >> 2]) & 1) {
               label$36 : {
                if (jswGetBasicObjectName(HEAP32[$4 + 332 >> 2])) {
                 $0 = jswGetBasicObjectName(HEAP32[$4 + 332 >> 2]);
                 break label$36;
                }
                $0 = 79058;
               }
               $1 = HEAP32[$4 + 332 >> 2];
               $1 = HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8;
               $2 = HEAP32[$4 + 332 >> 2];
               HEAP32[$4 + 184 >> 2] = HEAPU8[$2 + 2 | 0] | HEAPU8[$2 + 3 | 0] << 8;
               HEAP32[$4 + 180 >> 2] = $1;
               HEAP32[$4 + 176 >> 2] = $0;
               jsiConsolePrintf(79037, $4 + 176 | 0);
               break label$34;
              }
              label$38 : {
               if (jsvIsString(HEAP32[$4 + 332 >> 2]) & 1) {
                HEAP32[$4 + 300 >> 2] = 1;
                if (jsvGetLastChild(HEAP32[$4 + 332 >> 2]) & 65535) {
                 HEAP32[$4 + 296 >> 2] = jsvGetAddressOf(jsvGetLastChild(HEAP32[$4 + 332 >> 2]) & 65535);
                 HEAP32[$4 + 300 >> 2] = jsvCountJsVarsUsed(HEAP32[$4 + 296 >> 2]) + HEAP32[$4 + 300 >> 2];
                }
                if (jsvIsFlatString(HEAP32[$4 + 332 >> 2]) & 1) {
                 HEAP32[$4 + 300 >> 2] = jsvGetFlatStringBlocks(HEAP32[$4 + 332 >> 2]) + HEAP32[$4 + 300 >> 2];
                }
                HEAP32[$4 + 292 >> 2] = 79078;
                if (jsvIsFlatString(HEAP32[$4 + 332 >> 2]) & 1) {
                 HEAP32[$4 + 292 >> 2] = 79079;
                }
                if (jsvIsNativeString(HEAP32[$4 + 332 >> 2]) & 1) {
                 HEAP32[$4 + 292 >> 2] = 79084;
                }
                if (jsvIsFlashString(HEAP32[$4 + 332 >> 2]) & 1) {
                 HEAP32[$4 + 292 >> 2] = 79091;
                }
                $0 = HEAP32[$4 + 292 >> 2];
                $1 = HEAP32[$4 + 300 >> 2];
                HEAP32[$4 + 200 >> 2] = HEAP32[$4 + 332 >> 2];
                HEAP32[$4 + 196 >> 2] = $1;
                HEAP32[$4 + 192 >> 2] = $0;
                jsiConsolePrintf(79097, $4 + 192 | 0);
                break label$38;
               }
               $0 = HEAP32[$4 + 332 >> 2];
               HEAP32[$4 + 208 >> 2] = (HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 57855;
               jsiConsolePrintf(79121, $4 + 208 | 0);
              }
             }
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
  if (jsvIsNameInt(HEAP32[$4 + 332 >> 2]) & 1) {
   HEAP32[$4 >> 2] = jsvGetFirstChildSigned(HEAP32[$4 + 332 >> 2]) << 16 >> 16;
   jsiConsolePrintf(79132, $4);
   break label$3;
  }
  if (jsvIsNameIntBool(HEAP32[$4 + 332 >> 2]) & 1) {
   HEAP32[$4 + 16 >> 2] = jsvGetFirstChild(HEAP32[$4 + 332 >> 2]) & 65535 ? 78381 : 78386;
   jsiConsolePrintf(79142, $4 + 16 | 0);
   break label$3;
  }
  label$47 : {
   if (jsvHasSingleChild(HEAP32[$4 + 332 >> 2]) & 1) {
    $0 = $4;
    label$49 : {
     if (jsvGetFirstChild(HEAP32[$4 + 332 >> 2]) & 65535) {
      $1 = jsvGetAddressOf(jsvGetFirstChild(HEAP32[$4 + 332 >> 2]) & 65535);
      break label$49;
     }
     $1 = 0;
    }
    HEAP32[$0 + 288 >> 2] = $1;
    _jsvTrace(HEAP32[$4 + 288 >> 2], HEAP32[$4 + 328 >> 2] + 2 | 0, HEAP32[$4 + 324 >> 2], HEAP32[$4 + 320 >> 2] + 1 | 0);
    break label$47;
   }
   if (jsvHasChildren(HEAP32[$4 + 332 >> 2]) & 1) {
    jsvIteratorNew($4 + 224 | 0, HEAP32[$4 + 332 >> 2], 0);
    HEAP8[$4 + 223 | 0] = 1;
    while (1) {
     if (jsvIteratorHasElement($4 + 224 | 0) & 1) {
      $0 = jspIsInterrupted() ^ -1;
     } else {
      $0 = 0;
     }
     if ($0 & 1) {
      if (HEAP8[$4 + 223 | 0] & 1) {
       jsiConsolePrintf(79153, 0);
      }
      HEAP8[$4 + 223 | 0] = 0;
      HEAP32[$4 + 216 >> 2] = jsvIteratorGetKey($4 + 224 | 0);
      _jsvTrace(HEAP32[$4 + 216 >> 2], HEAP32[$4 + 328 >> 2] + 2 | 0, HEAP32[$4 + 324 >> 2], HEAP32[$4 + 320 >> 2] + 1 | 0);
      jsvUnLock(HEAP32[$4 + 216 >> 2]);
      jsiConsolePrintf(79153, 0);
      jsvIteratorNext($4 + 224 | 0);
      continue;
     }
     break;
    }
    jsvIteratorFree($4 + 224 | 0);
    if (!(HEAP8[$4 + 223 | 0] & 1)) {
     HEAP32[$4 + 316 >> 2] = 0;
     while (1) {
      if (HEAP32[$4 + 316 >> 2] < HEAP32[$4 + 328 >> 2]) {
       jsiConsolePrintString(78839);
       HEAP32[$4 + 316 >> 2] = HEAP32[$4 + 316 >> 2] + 1;
       continue;
      }
      break;
     }
    }
   }
  }
  HEAP32[$4 + 32 >> 2] = HEAP8[$4 + 307 | 0];
  jsiConsolePrintf(79155, $4 + 32 | 0);
 }
 global$0 = $4 + 336 | 0;
}
function jswrap_banglejs_init() {
 var $0 = 0, $1 = 0, $2 = 0;
 $0 = global$0 - 240 | 0;
 global$0 = $0;
 HEAP8[$0 + 238 | 0] = (HEAPU16[161112] & 4096) != 0;
 label$1 : {
  if (!(HEAP8[$0 + 238 | 0] & 1)) {
   break label$1;
  }
 }
 if (HEAP8[$0 + 238 | 0] & 1) {
  HEAP32[84152] = 98350;
  HEAP8[336668] = 255;
  HEAP32[84172] = 0;
  healthStateClear(336692);
  healthStateClear(336708);
  healthStateClear(336724);
 }
 HEAP32[84152] = HEAP32[84152] | 1024;
 HEAP16[168314] = 0;
 HEAP32[84154] = 0;
 HEAP32[84155] = 3e3;
 HEAP32[84156] = 5e3;
 HEAP8[336636] = 0;
 if (jshPinGetValue(17) & 1) {
  HEAP8[336636] = 1;
 }
 HEAP8[336740] = 0;
 HEAP16[168371] = 0;
 HEAP32[$0 + 232 >> 2] = jsvNewFromString(110482);
 HEAP32[$0 + 228 >> 2] = jswrap_storage_readJSON(HEAP32[$0 + 232 >> 2], 1);
 jsvUnLock(HEAP32[$0 + 232 >> 2]);
 $1 = $0;
 label$4 : {
  if (jsvIsObject(HEAP32[$0 + 228 >> 2]) & 1) {
   $2 = jsvObjectGetChild(HEAP32[$0 + 228 >> 2], 110495, 0);
   break label$4;
  }
  $2 = 0;
 }
 HEAP32[$1 + 224 >> 2] = $2;
 label$6 : {
  label$7 : {
   if (!HEAP32[$0 + 224 >> 2]) {
    break label$7;
   }
   if (jsvGetBool(HEAP32[$0 + 224 >> 2]) & 1) {
    break label$7;
   }
   HEAP32[84152] = HEAP32[84152] & -129;
   break label$6;
  }
  HEAP32[84152] = HEAP32[84152] | 128;
  HEAP32[84152] = HEAP32[84152] | 64;
 }
 jsvUnLock(HEAP32[$0 + 224 >> 2]);
 $1 = $0;
 label$8 : {
  if (jsvIsObject(HEAP32[$0 + 228 >> 2]) & 1) {
   $2 = jsvObjectGetChild(HEAP32[$0 + 228 >> 2], 110500, 0);
   break label$8;
  }
  $2 = 0;
 }
 HEAP32[$1 + 224 >> 2] = $2;
 label$10 : {
  label$11 : {
   if (!HEAP32[$0 + 224 >> 2]) {
    break label$11;
   }
   if (jsvGetBool(HEAP32[$0 + 224 >> 2]) & 1) {
    break label$11;
   }
   HEAP32[84152] = HEAP32[84152] & -257;
   break label$10;
  }
  HEAP32[84152] = HEAP32[84152] | 256;
 }
 jsvUnLock(HEAP32[$0 + 224 >> 2]);
 HEAP8[324592] = 0;
 HEAP8[324593] = 0;
 HEAP8[324594] = 65535;
 HEAP8[324595] = 255;
 HEAP8[324596] = 0;
 HEAP8[324597] = 0;
 HEAP8[324598] = 49151;
 HEAP8[324599] = 191;
 HEAP8[324600] = 0;
 HEAP8[324601] = 0;
 HEAP8[324602] = 2047;
 HEAP8[324603] = 7;
 HEAP8[324604] = 0;
 $1 = $0;
 label$12 : {
  if (jsvIsObject(HEAP32[$0 + 228 >> 2]) & 1) {
   $2 = jsvObjectGetChild(HEAP32[$0 + 228 >> 2], 110508, 0);
   break label$12;
  }
  $2 = 0;
 }
 HEAP32[$1 + 224 >> 2] = $2;
 if (jsvIsObject(HEAP32[$0 + 224 >> 2]) & 1) {
  $1 = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$0 + 224 >> 2], 110514, 0));
  HEAP8[324592] = $1;
  HEAP8[324593] = $1 >>> 8;
  $1 = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$0 + 224 >> 2], 110517, 0));
  HEAP8[324594] = $1;
  HEAP8[324595] = $1 >>> 8;
  $1 = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$0 + 224 >> 2], 110520, 0));
  HEAP8[324596] = $1;
  HEAP8[324597] = $1 >>> 8;
  $1 = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$0 + 224 >> 2], 110524, 0));
  HEAP8[324598] = $1;
  HEAP8[324599] = $1 >>> 8;
  $1 = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$0 + 224 >> 2], 110528, 0));
  HEAP8[324600] = $1;
  HEAP8[324601] = $1 >>> 8;
  $1 = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$0 + 224 >> 2], 110532, 0));
  HEAP8[324602] = $1;
  HEAP8[324603] = $1 >>> 8;
  HEAP8[324604] = jsvGetBoolAndUnLock(jsvObjectGetChild(HEAP32[$0 + 224 >> 2], 110536, 0)) & 1;
 }
 jsvUnLock2(HEAP32[$0 + 224 >> 2], HEAP32[$0 + 228 >> 2]);
 HEAP32[$0 + 220 >> 2] = jspNewObject(0, 110541);
 label$15 : {
  if (!HEAP32[$0 + 220 >> 2]) {
   break label$15;
  }
  graphicsStructInit($0 + 144 | 0, 176, 176, 3);
  HEAP8[$0 + 148 | 0] = 6;
  HEAP8[$0 + 149 | 0] = 0;
  HEAP8[$0 + 150 | 0] = 0;
  HEAP8[$0 + 151 | 0] = 0;
  HEAP8[$0 + 160 | 0] = 16;
  HEAP8[$0 + 152 | 0] = 0;
  HEAP8[$0 + 153 | 0] = 0;
  HEAP8[$0 + 154 | 0] = 0;
  HEAP8[$0 + 155 | 0] = 0;
  HEAP8[$0 + 169 | 0] = 16385;
  HEAP8[$0 + 170 | 0] = 64;
  $1 = HEAP32[$0 + 220 >> 2];
  HEAP8[$0 + 144 | 0] = $1;
  HEAP8[$0 + 145 | 0] = $1 >>> 8;
  HEAP8[$0 + 146 | 0] = $1 >>> 16;
  HEAP8[$0 + 147 | 0] = $1 >>> 24;
  label$16 : {
   if (HEAP8[$0 + 238 | 0] & 1) {
    lcdMemLCD_init($0 + 144 | 0);
    jswrap_banglejs_pwrBacklight();
    break label$16;
   }
   do_indexing(0);
  }
  $1 = $0 + 144 | 0;
  graphicsSetVar($1);
  jsvObjectSetChild(HEAP32[80545], 110550, HEAP32[$0 + 220 >> 2]);
  jsvObjectSetChild(HEAP32[80546], 110016, HEAP32[$0 + 220 >> 2]);
  graphicsGetFromVar($1, HEAP32[$0 + 220 >> 2]);
  HEAP32[$0 + 140 >> 2] = jsvNewNativeFunction(552, 32792);
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 220 >> 2], 110552, HEAP32[$0 + 140 >> 2]);
  label$18 : {
   if (HEAP8[$0 + 238 | 0] & 1) {
    break label$18;
   }
  }
  HEAP8[$0 + 139 | 0] = 1;
  if (HEAPU16[161112] & 64) {
   HEAP8[$0 + 139 | 0] = 0;
   if (!(HEAP8[$0 + 238 | 0] & 1)) {
    HEAP32[$0 + 132 >> 2] = 88;
    HEAP32[$0 + 128 >> 2] = 88;
    $2 = $0 + 144 | 0;
    graphicsFillRect($2, HEAP32[$0 + 132 >> 2] - 49 | 0, HEAP32[$0 + 128 >> 2] - 19 | 0, HEAP32[$0 + 132 >> 2] + 49 | 0, HEAP32[$0 + 128 >> 2] + 19 | 0, HEAPU8[324594] | HEAPU8[324595] << 8);
    $1 = HEAPU8[324592] | HEAPU8[324593] << 8;
    HEAP8[$0 + 161 | 0] = $1;
    HEAP8[$0 + 162 | 0] = $1 >>> 8;
    HEAP8[$0 + 163 | 0] = $1 >>> 16;
    HEAP8[$0 + 164 | 0] = $1 >>> 24;
    graphicsDrawRect($2, HEAP32[$0 + 132 >> 2] - 50 | 0, HEAP32[$0 + 128 >> 2] - 20 | 0, HEAP32[$0 + 132 >> 2] + 50 | 0, HEAP32[$0 + 128 >> 2] + 20 | 0);
    HEAP32[$0 + 128 >> 2] = HEAP32[$0 + 128 >> 2] - 4;
    HEAP32[$0 + 132 >> 2] = HEAP32[$0 + 132 >> 2] - 24;
    HEAP32[$0 + 124 >> 2] = 110557;
    while (1) {
     if (HEAPU8[HEAP32[$0 + 124 >> 2]]) {
      graphicsDrawChar6x8($0 + 144 | 0, HEAP32[$0 + 132 >> 2], HEAP32[$0 + 128 >> 2], HEAP8[HEAP32[$0 + 124 >> 2]], 1, 1, 0);
      HEAP32[$0 + 132 >> 2] = HEAP32[$0 + 132 >> 2] + 6;
      HEAP32[$0 + 124 >> 2] = HEAP32[$0 + 124 >> 2] + 1;
      continue;
     }
     break;
    }
    lcdMemLCD_flip($0 + 144 | 0);
   }
  }
  if (HEAP8[$0 + 139 | 0] & 1) {
   $1 = $0 + 88 | 0;
   graphicsClear($0 + 144 | 0);
   HEAP8[$0 + 123 | 0] = 0;
   jsfNameFromString($1, 110568);
   HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 112 >> 2];
   $1 = HEAP32[$0 + 108 >> 2];
   HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 104 >> 2];
   HEAP32[$0 + 28 >> 2] = $1;
   $1 = HEAP32[$0 + 100 >> 2];
   HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 96 >> 2];
   HEAP32[$0 + 20 >> 2] = $1;
   $1 = HEAP32[$0 + 92 >> 2];
   HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 88 >> 2];
   HEAP32[$0 + 12 >> 2] = $1;
   HEAP32[$0 + 116 >> 2] = jsfReadFile($0 + 8 | 0, 0, 0);
   label$24 : {
    if (jsvIsString(HEAP32[$0 + 116 >> 2]) & 1) {
     if (jsvGetStringLength(HEAP32[$0 + 116 >> 2])) {
      break label$24;
     }
    }
    jsvUnLock(HEAP32[$0 + 116 >> 2]);
    HEAP8[$0 + 123 | 0] = 1;
    HEAP32[$0 + 116 >> 2] = jswrap_banglejs_getLogo();
   }
   $1 = $0 + 144 | 0;
   HEAP32[$0 + 84 >> 2] = jsvGetCharInString(HEAP32[$0 + 116 >> 2], 0) & 255;
   HEAP32[$0 + 80 >> 2] = jsvGetCharInString(HEAP32[$0 + 116 >> 2], 1) & 255;
   graphicsSetVar($1);
   HEAP32[$0 + 76 >> 2] = (176 - HEAP32[$0 + 80 >> 2] | 0) / 2;
   jsvUnLock2(jswrap_graphics_drawImage(HEAP32[$0 + 220 >> 2], HEAP32[$0 + 116 >> 2], (176 - HEAP32[$0 + 84 >> 2] | 0) / 2 | 0, HEAP32[$0 + 76 >> 2], 0), HEAP32[$0 + 116 >> 2]);
   if (HEAP8[$0 + 123 | 0] & 1) {
    label$27 : {
     if (HEAP32[$0 + 80 >> 2] > 56) {
      HEAP32[$0 + 76 >> 2] = HEAP32[$0 + 76 >> 2] + (HEAP32[$0 + 80 >> 2] - 28 | 0);
      break label$27;
     }
     HEAP32[$0 + 76 >> 2] = HEAP32[$0 + 76 >> 2] + (HEAP32[$0 + 80 >> 2] - 15 | 0);
    }
    $1 = $0 + 144 | 0;
    $2 = $0 + 48 | 0;
    HEAP32[$0 + 44 >> 2] = jsvNewFromString(110576);
    jsvGetString(HEAP32[$0 + 44 >> 2], $2, 20);
    jsvUnLock(HEAP32[$0 + 44 >> 2]);
    jswrap_graphics_drawCString($1, HEAP32[$0 + 76 >> 2], 110585);
    jswrap_graphics_drawCString($1, HEAP32[$0 + 76 >> 2] + 10 | 0, $2);
    jswrap_graphics_drawCString($1, HEAP32[$0 + 76 >> 2] + 20 | 0, 110590);
   }
  }
  $1 = $0 + 144 | 0;
  lcdMemLCD_flip($1);
  graphicsStructResetState($1);
  graphicsSetVar($1);
  jsvUnLock(HEAP32[$0 + 220 >> 2]);
  if (HEAP8[$0 + 238 | 0] & 1) {
   stepcount_init();
   HEAP32[84168] = 0;
  }
  HEAP8[336744] = 0;
  jshPinSetState(23, 5);
  HEAP32[84187] = 0;
  HEAP32[84188] = 0;
  HEAP32[84189] = 0;
  jshSetPinShouldStayWatched(1);
  HEAP8[$0 + 239 | 0] = jshPinWatch(17, 1);
  if (HEAPU8[$0 + 239 | 0]) {
   jshSetEventCallback(HEAPU8[$0 + 239 | 0], 553);
  }
  if (HEAP8[$0 + 238 | 0] & 1) {
   break label$15;
  }
  jsvUnLock(jsiSetTimeout());
 }
 global$0 = $0 + 240 | 0;
}
function mbedtls_sha1_process($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 160 | 0;
 global$0 = $2;
 HEAP32[$2 + 156 >> 2] = $0;
 HEAP32[$2 + 152 >> 2] = $1;
 HEAP32[$2 + 64 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 3 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2]] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 1 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 2 | 0] << 8);
 HEAP32[$2 + 68 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 7 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 4 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 5 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 6 | 0] << 8);
 HEAP32[$2 + 72 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 11 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 8 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 9 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 10 | 0] << 8);
 HEAP32[$2 + 76 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 15 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 12 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 13 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 14 | 0] << 8);
 HEAP32[$2 + 80 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 19 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 16 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 17 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 18 | 0] << 8);
 HEAP32[$2 + 84 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 23 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 20 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 21 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 22 | 0] << 8);
 HEAP32[$2 + 88 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 27 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 24 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 25 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 26 | 0] << 8);
 HEAP32[$2 + 92 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 31 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 28 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 29 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 30 | 0] << 8);
 HEAP32[$2 + 96 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 35 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 32 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 33 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 34 | 0] << 8);
 HEAP32[$2 + 100 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 39 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 36 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 37 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 38 | 0] << 8);
 HEAP32[$2 + 104 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 43 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 40 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 41 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 42 | 0] << 8);
 HEAP32[$2 + 108 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 47 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 44 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 45 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 46 | 0] << 8);
 HEAP32[$2 + 112 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 51 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 48 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 49 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 50 | 0] << 8);
 HEAP32[$2 + 116 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 55 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 52 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 53 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 54 | 0] << 8);
 HEAP32[$2 + 120 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 59 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 56 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 57 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 58 | 0] << 8);
 HEAP32[$2 + 124 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 63 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 60 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 61 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 62 | 0] << 8);
 HEAP32[$2 + 148 >> 2] = 0;
 while (1) {
  if (HEAPU32[$2 + 148 >> 2] < 5) {
   HEAP32[($2 + 32 | 0) + (HEAP32[$2 + 148 >> 2] << 2) >> 2] = HEAP32[(HEAP32[$2 + 156 >> 2] + 8 | 0) + (HEAP32[$2 + 148 >> 2] << 2) >> 2];
   HEAP32[$2 + 148 >> 2] = HEAP32[$2 + 148 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[$2 + 148 >> 2] = 0;
 while (1) {
  if (HEAPU32[$2 + 148 >> 2] < 20) {
   HEAP32[$2 + 28 >> 2] = HEAPU32[$2 + 148 >> 2] % 5;
   label$5 : {
    if (HEAPU32[$2 + 148 >> 2] < 16) {
     HEAP32[$2 + 24 >> 2] = HEAP32[($2 - -64 | 0) + (HEAP32[$2 + 148 >> 2] << 2) >> 2];
     break label$5;
    }
    HEAP32[$2 + 24 >> 2] = mbedtls_sha1_processR($2 - -64 | 0, HEAP32[$2 + 148 >> 2]);
   }
   $0 = $2 + 32 | 0;
   $1 = $0 + (4 - HEAP32[$2 + 28 >> 2] << 2) | 0;
   HEAP32[$1 >> 2] = HEAP32[$1 >> 2] + (HEAP32[$2 + 24 >> 2] + (((HEAP32[$0 + ((5 - HEAP32[$2 + 28 >> 2] >>> 0) % 5 << 2) >> 2] << 5 | HEAP32[$0 + ((5 - HEAP32[$2 + 28 >> 2] >>> 0) % 5 << 2) >> 2] >>> 27) + (HEAP32[$0 + ((8 - HEAP32[$2 + 28 >> 2] >>> 0) % 5 << 2) >> 2] ^ HEAP32[$0 + ((6 - HEAP32[$2 + 28 >> 2] >>> 0) % 5 << 2) >> 2] & (HEAP32[$0 + ((7 - HEAP32[$2 + 28 >> 2] >>> 0) % 5 << 2) >> 2] ^ HEAP32[$0 + ((8 - HEAP32[$2 + 28 >> 2] >>> 0) % 5 << 2) >> 2])) | 0) + 1518500249 | 0) | 0);
   HEAP32[$0 + ((6 - HEAP32[$2 + 28 >> 2] >>> 0) % 5 << 2) >> 2] = HEAP32[$0 + ((6 - HEAP32[$2 + 28 >> 2] >>> 0) % 5 << 2) >> 2] << 30 | HEAP32[$0 + ((6 - HEAP32[$2 + 28 >> 2] >>> 0) % 5 << 2) >> 2] >>> 2;
   HEAP32[$2 + 148 >> 2] = HEAP32[$2 + 148 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[$2 + 148 >> 2] = 20;
 while (1) {
  if (HEAPU32[$2 + 148 >> 2] < 40) {
   HEAP32[$2 + 20 >> 2] = HEAPU32[$2 + 148 >> 2] % 5;
   $0 = $2 + 32 | 0;
   $1 = (((HEAP32[$0 + ((5 - HEAP32[$2 + 20 >> 2] >>> 0) % 5 << 2) >> 2] << 5 | HEAP32[$0 + ((5 - HEAP32[$2 + 20 >> 2] >>> 0) % 5 << 2) >> 2] >>> 27) + (HEAP32[$0 + ((8 - HEAP32[$2 + 20 >> 2] >>> 0) % 5 << 2) >> 2] ^ (HEAP32[$0 + ((6 - HEAP32[$2 + 20 >> 2] >>> 0) % 5 << 2) >> 2] ^ HEAP32[$0 + ((7 - HEAP32[$2 + 20 >> 2] >>> 0) % 5 << 2) >> 2])) | 0) + 1859775393 | 0) + mbedtls_sha1_processR($2 - -64 | 0, HEAP32[$2 + 148 >> 2]) | 0;
   $3 = $0 + (4 - HEAP32[$2 + 20 >> 2] << 2) | 0;
   HEAP32[$3 >> 2] = $1 + HEAP32[$3 >> 2];
   HEAP32[$0 + ((6 - HEAP32[$2 + 20 >> 2] >>> 0) % 5 << 2) >> 2] = HEAP32[$0 + ((6 - HEAP32[$2 + 20 >> 2] >>> 0) % 5 << 2) >> 2] << 30 | HEAP32[$0 + ((6 - HEAP32[$2 + 20 >> 2] >>> 0) % 5 << 2) >> 2] >>> 2;
   HEAP32[$2 + 148 >> 2] = HEAP32[$2 + 148 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[$2 + 148 >> 2] = 40;
 while (1) {
  if (HEAPU32[$2 + 148 >> 2] < 60) {
   HEAP32[$2 + 16 >> 2] = HEAPU32[$2 + 148 >> 2] % 5;
   $0 = $2 + 32 | 0;
   $1 = (((HEAP32[$0 + ((5 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2] << 5 | HEAP32[$0 + ((5 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2] >>> 27) + (HEAP32[$0 + ((6 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2] & HEAP32[$0 + ((7 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2] | HEAP32[$0 + ((8 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2] & (HEAP32[$0 + ((6 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2] | HEAP32[$0 + ((7 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2])) | 0) + -1894007588 | 0) + mbedtls_sha1_processR($2 - -64 | 0, HEAP32[$2 + 148 >> 2]) | 0;
   $3 = $0 + (4 - HEAP32[$2 + 16 >> 2] << 2) | 0;
   HEAP32[$3 >> 2] = $1 + HEAP32[$3 >> 2];
   HEAP32[$0 + ((6 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2] = HEAP32[$0 + ((6 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2] << 30 | HEAP32[$0 + ((6 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2] >>> 2;
   HEAP32[$2 + 148 >> 2] = HEAP32[$2 + 148 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[$2 + 148 >> 2] = 60;
 while (1) {
  if (HEAPU32[$2 + 148 >> 2] < 80) {
   HEAP32[$2 + 12 >> 2] = HEAPU32[$2 + 148 >> 2] % 5;
   $0 = $2 + 32 | 0;
   $1 = (((HEAP32[$0 + ((5 - HEAP32[$2 + 12 >> 2] >>> 0) % 5 << 2) >> 2] << 5 | HEAP32[$0 + ((5 - HEAP32[$2 + 12 >> 2] >>> 0) % 5 << 2) >> 2] >>> 27) + (HEAP32[$0 + ((8 - HEAP32[$2 + 12 >> 2] >>> 0) % 5 << 2) >> 2] ^ (HEAP32[$0 + ((6 - HEAP32[$2 + 12 >> 2] >>> 0) % 5 << 2) >> 2] ^ HEAP32[$0 + ((7 - HEAP32[$2 + 12 >> 2] >>> 0) % 5 << 2) >> 2])) | 0) + -899497514 | 0) + mbedtls_sha1_processR($2 - -64 | 0, HEAP32[$2 + 148 >> 2]) | 0;
   $3 = $0 + (4 - HEAP32[$2 + 12 >> 2] << 2) | 0;
   HEAP32[$3 >> 2] = $1 + HEAP32[$3 >> 2];
   HEAP32[$0 + ((6 - HEAP32[$2 + 12 >> 2] >>> 0) % 5 << 2) >> 2] = HEAP32[$0 + ((6 - HEAP32[$2 + 12 >> 2] >>> 0) % 5 << 2) >> 2] << 30 | HEAP32[$0 + ((6 - HEAP32[$2 + 12 >> 2] >>> 0) % 5 << 2) >> 2] >>> 2;
   HEAP32[$2 + 148 >> 2] = HEAP32[$2 + 148 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[$2 + 148 >> 2] = 0;
 while (1) {
  if (HEAPU32[$2 + 148 >> 2] < 5) {
   $0 = (HEAP32[$2 + 156 >> 2] + 8 | 0) + (HEAP32[$2 + 148 >> 2] << 2) | 0;
   HEAP32[$0 >> 2] = HEAP32[($2 + 32 | 0) + (HEAP32[$2 + 148 >> 2] << 2) >> 2] + HEAP32[$0 >> 2];
   HEAP32[$2 + 148 >> 2] = HEAP32[$2 + 148 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $2 + 160 | 0;
}
function jswrap_graphics_asBMP($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = global$0 - 208 | 0;
 global$0 = $1;
 HEAP32[$1 + 200 >> 2] = $0;
 label$1 : {
  if (!(graphicsGetFromVar($1 + 128 | 0, HEAP32[$1 + 200 >> 2]) & 1)) {
   HEAP32[$1 + 204 >> 2] = 0;
   break label$1;
  }
  $0 = $1 + 128 | 0;
  HEAP32[$1 + 124 >> 2] = graphicsGetWidth($0) & 65535;
  HEAP32[$1 + 120 >> 2] = graphicsGetHeight($0) & 65535;
  HEAP32[$1 + 116 >> 2] = HEAPU8[$1 + 144 | 0];
  if ((HEAPU8[$1 + 132 | 0] | HEAPU8[$1 + 133 | 0] << 8 | (HEAPU8[$1 + 134 | 0] << 16 | HEAPU8[$1 + 135 | 0] << 24)) == 6) {
   HEAP32[$1 + 116 >> 2] = 3;
  }
  HEAP32[$1 + 112 >> 2] = HEAP32[$1 + 116 >> 2];
  label$4 : {
   if (!(HEAP32[$1 + 112 >> 2] <= 1 | HEAP32[$1 + 112 >> 2] >= 4)) {
    HEAP32[$1 + 112 >> 2] = 4;
    break label$4;
   }
   if (!(HEAP32[$1 + 112 >> 2] <= 4 | HEAP32[$1 + 112 >> 2] >= 8)) {
    HEAP32[$1 + 112 >> 2] = 8;
   }
  }
  HEAP8[$1 + 111 | 0] = HEAP32[$1 + 112 >> 2] <= 8;
  HEAP32[$1 + 104 >> 2] = Math_imul(HEAP32[$1 + 124 >> 2], HEAP32[$1 + 112 >> 2]) + 31 >> 5 << 2;
  $0 = $1;
  if (HEAP8[$1 + 111 | 0] & 1) {
   $2 = 1 << HEAP32[$1 + 112 >> 2];
  } else {
   $2 = 0;
  }
  HEAP32[$0 + 100 >> 2] = $2;
  HEAP32[$1 + 96 >> 2] = Math_imul(HEAP32[$1 + 100 >> 2], 3) + 26;
  HEAP32[$1 + 92 >> 2] = HEAP32[$1 + 96 >> 2] + Math_imul(HEAP32[$1 + 120 >> 2], HEAP32[$1 + 104 >> 2]);
  HEAP32[$1 + 88 >> 2] = jsvNewFlatStringOfLength(HEAP32[$1 + 92 >> 2]);
  if (!HEAP32[$1 + 88 >> 2]) {
   HEAP32[$1 + 204 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 84 >> 2] = jsvGetFlatStringPointer(HEAP32[$1 + 88 >> 2]);
  HEAP8[HEAP32[$1 + 84 >> 2]] = 66;
  HEAP8[HEAP32[$1 + 84 >> 2] + 1 | 0] = 77;
  HEAP8[HEAP32[$1 + 84 >> 2] + 2 | 0] = HEAP32[$1 + 92 >> 2];
  HEAP8[HEAP32[$1 + 84 >> 2] + 3 | 0] = HEAP32[$1 + 92 >> 2] >> 8;
  HEAP8[HEAP32[$1 + 84 >> 2] + 10 | 0] = HEAP32[$1 + 96 >> 2];
  HEAP8[HEAP32[$1 + 84 >> 2] + 14 | 0] = 12;
  HEAP8[HEAP32[$1 + 84 >> 2] + 18 | 0] = HEAP32[$1 + 124 >> 2];
  HEAP8[HEAP32[$1 + 84 >> 2] + 19 | 0] = HEAP32[$1 + 124 >> 2] >> 8;
  HEAP8[HEAP32[$1 + 84 >> 2] + 20 | 0] = HEAP32[$1 + 120 >> 2];
  HEAP8[HEAP32[$1 + 84 >> 2] + 21 | 0] = HEAP32[$1 + 120 >> 2] >> 8;
  HEAP8[HEAP32[$1 + 84 >> 2] + 22 | 0] = 1;
  HEAP8[HEAP32[$1 + 84 >> 2] + 24 | 0] = HEAP32[$1 + 112 >> 2];
  if (HEAP8[$1 + 111 | 0] & 1) {
   label$11 : {
    if (HEAP32[$1 + 112 >> 2] == 1) {
     HEAP8[HEAP32[$1 + 84 >> 2] + 26 | 0] = 255;
     HEAP8[HEAP32[$1 + 84 >> 2] + 27 | 0] = 255;
     HEAP8[HEAP32[$1 + 84 >> 2] + 28 | 0] = 255;
     break label$11;
    }
    label$13 : {
     if (HEAP32[$1 + 116 >> 2] == 3) {
      HEAP32[$1 + 80 >> 2] = 0;
      while (1) {
       if (HEAP32[$1 + 80 >> 2] < HEAP32[$1 + 100 >> 2]) {
        HEAP8[HEAP32[$1 + 84 >> 2] + (Math_imul(HEAP32[$1 + 80 >> 2], 3) + 26 | 0) | 0] = HEAP32[$1 + 80 >> 2] & 1 ? 255 : 0;
        HEAP8[HEAP32[$1 + 84 >> 2] + (Math_imul(HEAP32[$1 + 80 >> 2], 3) + 27 | 0) | 0] = HEAP32[$1 + 80 >> 2] & 2 ? 255 : 0;
        HEAP8[HEAP32[$1 + 84 >> 2] + (Math_imul(HEAP32[$1 + 80 >> 2], 3) + 28 | 0) | 0] = HEAP32[$1 + 80 >> 2] & 4 ? 255 : 0;
        HEAP32[$1 + 80 >> 2] = HEAP32[$1 + 80 >> 2] + 1;
        continue;
       }
       break;
      }
      break label$13;
     }
     label$17 : {
      if (HEAP32[$1 + 116 >> 2] == 4) {
       HEAP32[$1 + 76 >> 2] = 0;
       while (1) {
        if (HEAP32[$1 + 76 >> 2] < 16) {
         HEAP32[$1 + 72 >> 2] = HEAPU16[(HEAP32[$1 + 76 >> 2] << 1) + 126528 >> 1];
         HEAP8[HEAP32[$1 + 84 >> 2] + (Math_imul(HEAP32[$1 + 76 >> 2], 3) + 26 | 0) | 0] = HEAP32[$1 + 72 >> 2] << 3 & 248;
         HEAP8[HEAP32[$1 + 84 >> 2] + (Math_imul(HEAP32[$1 + 76 >> 2], 3) + 27 | 0) | 0] = HEAP32[$1 + 72 >> 2] >> 3 & 252;
         HEAP8[HEAP32[$1 + 84 >> 2] + (Math_imul(HEAP32[$1 + 76 >> 2], 3) + 28 | 0) | 0] = HEAP32[$1 + 72 >> 2] >> 8 & 248;
         HEAP32[$1 + 76 >> 2] = HEAP32[$1 + 76 >> 2] + 1;
         continue;
        }
        break;
       }
       break label$17;
      }
      label$21 : {
       if (HEAP32[$1 + 116 >> 2] == 8) {
        HEAP32[$1 + 68 >> 2] = 0;
        while (1) {
         if (HEAP32[$1 + 68 >> 2] < 255) {
          HEAP32[$1 + 64 >> 2] = HEAPU16[(HEAP32[$1 + 68 >> 2] << 1) + 126560 >> 1];
          HEAP8[HEAP32[$1 + 84 >> 2] + (Math_imul(HEAP32[$1 + 68 >> 2], 3) + 26 | 0) | 0] = HEAP32[$1 + 64 >> 2] << 3 & 248;
          HEAP8[HEAP32[$1 + 84 >> 2] + (Math_imul(HEAP32[$1 + 68 >> 2], 3) + 27 | 0) | 0] = HEAP32[$1 + 64 >> 2] >> 3 & 252;
          HEAP8[HEAP32[$1 + 84 >> 2] + (Math_imul(HEAP32[$1 + 68 >> 2], 3) + 28 | 0) | 0] = HEAP32[$1 + 64 >> 2] >> 8 & 248;
          HEAP32[$1 + 68 >> 2] = HEAP32[$1 + 68 >> 2] + 1;
          continue;
         }
         break;
        }
        break label$21;
       }
       HEAP32[$1 + 60 >> 2] = 0;
       while (1) {
        if (HEAP32[$1 + 60 >> 2] < 1 << HEAP32[$1 + 116 >> 2]) {
         HEAP32[$1 + 56 >> 2] = (Math_imul(HEAP32[$1 + 60 >> 2], 255) | 0) / (1 << HEAP32[$1 + 116 >> 2]);
         HEAP8[HEAP32[$1 + 84 >> 2] + (Math_imul(HEAP32[$1 + 60 >> 2], 3) + 26 | 0) | 0] = HEAP32[$1 + 56 >> 2];
         HEAP8[HEAP32[$1 + 84 >> 2] + (Math_imul(HEAP32[$1 + 60 >> 2], 3) + 27 | 0) | 0] = HEAP32[$1 + 56 >> 2];
         HEAP8[HEAP32[$1 + 84 >> 2] + (Math_imul(HEAP32[$1 + 60 >> 2], 3) + 28 | 0) | 0] = HEAP32[$1 + 56 >> 2];
         HEAP32[$1 + 60 >> 2] = HEAP32[$1 + 60 >> 2] + 1;
         continue;
        }
        break;
       }
      }
     }
    }
   }
  }
  HEAP32[$1 + 52 >> 2] = (1 << HEAP32[$1 + 112 >> 2]) - 1;
  HEAP32[$1 + 48 >> 2] = 8 / HEAP32[$1 + 112 >> 2];
  HEAP32[$1 + 44 >> 2] = 0;
  while (1) {
   if (HEAP32[$1 + 44 >> 2] < HEAP32[$1 + 120 >> 2]) {
    HEAP32[$1 + 40 >> 2] = HEAP32[$1 + 120 >> 2] - (HEAP32[$1 + 44 >> 2] + 1 | 0);
    label$29 : {
     if (HEAP32[$1 + 112 >> 2] < 8) {
      HEAP32[$1 + 36 >> 2] = HEAP32[$1 + 96 >> 2] + Math_imul(HEAP32[$1 + 40 >> 2], HEAP32[$1 + 104 >> 2]);
      HEAP32[$1 + 32 >> 2] = 0;
      while (1) {
       if (HEAP32[$1 + 32 >> 2] < HEAP32[$1 + 124 >> 2]) {
        HEAP32[$1 + 28 >> 2] = 0;
        HEAP32[$1 + 24 >> 2] = 0;
        while (1) {
         if (HEAP32[$1 + 24 >> 2] < HEAP32[$1 + 48 >> 2]) {
          $0 = HEAP32[$1 + 32 >> 2];
          HEAP32[$1 + 32 >> 2] = $0 + 1;
          HEAP32[$1 + 20 >> 2] = graphicsGetPixel($1 + 128 | 0, $0, HEAP32[$1 + 44 >> 2]);
          if ((HEAPU8[$1 + 132 | 0] | HEAPU8[$1 + 133 | 0] << 8 | (HEAPU8[$1 + 134 | 0] << 16 | HEAPU8[$1 + 135 | 0] << 24)) == 6) {
           HEAP32[$1 + 20 >> 2] = (HEAP32[$1 + 20 >> 2] & 32768 ? 4 : 0) | (HEAP32[$1 + 20 >> 2] & 1024 ? 2 : 0) | (HEAP32[$1 + 20 >> 2] & 16 ? 1 : 0);
          }
          HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2] & HEAP32[$1 + 52 >> 2] | HEAP32[$1 + 28 >> 2] << HEAP32[$1 + 112 >> 2];
          HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 24 >> 2] + 1;
          continue;
         }
         break;
        }
        $0 = HEAP32[$1 + 28 >> 2];
        $2 = HEAP32[$1 + 84 >> 2];
        $3 = HEAP32[$1 + 36 >> 2];
        HEAP32[$1 + 36 >> 2] = $3 + 1;
        HEAP8[$2 + $3 | 0] = $0;
        continue;
       }
       break;
      }
      break label$29;
     }
     HEAP32[$1 + 16 >> 2] = 0;
     while (1) {
      if (HEAP32[$1 + 16 >> 2] < HEAP32[$1 + 124 >> 2]) {
       HEAP32[$1 + 12 >> 2] = graphicsGetPixel($1 + 128 | 0, HEAP32[$1 + 16 >> 2], HEAP32[$1 + 44 >> 2]);
       HEAP32[$1 + 8 >> 2] = (HEAP32[$1 + 96 >> 2] + Math_imul(HEAP32[$1 + 40 >> 2], HEAP32[$1 + 104 >> 2]) | 0) + Math_imul(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 112 >> 2] >> 3);
       HEAP32[$1 + 4 >> 2] = 0;
       while (1) {
        if (HEAP32[$1 + 4 >> 2] < HEAP32[$1 + 112 >> 2]) {
         $0 = HEAP32[$1 + 12 >> 2];
         $2 = HEAP32[$1 + 84 >> 2];
         $3 = HEAP32[$1 + 8 >> 2];
         HEAP32[$1 + 8 >> 2] = $3 + 1;
         HEAP8[$2 + $3 | 0] = $0;
         HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 12 >> 2] >>> 8;
         HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + 8;
         continue;
        }
        break;
       }
       HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 16 >> 2] + 1;
       continue;
      }
      break;
     }
    }
    HEAP32[$1 + 44 >> 2] = HEAP32[$1 + 44 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$1 + 204 >> 2] = HEAP32[$1 + 88 >> 2];
 }
 global$0 = $1 + 208 | 0;
 return HEAP32[$1 + 204 >> 2];
}
function tflite__reference_integer_ops__DepthwiseConvPerChannel_28tflite__DepthwiseParams_20const__2c_20int_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10) {
 var $11 = 0;
 $11 = global$0 - 192 | 0;
 global$0 = $11;
 HEAP32[$11 + 188 >> 2] = $0;
 HEAP32[$11 + 184 >> 2] = $1;
 HEAP32[$11 + 180 >> 2] = $2;
 HEAP32[$11 + 176 >> 2] = $3;
 HEAP32[$11 + 172 >> 2] = $4;
 HEAP32[$11 + 168 >> 2] = $5;
 HEAP32[$11 + 164 >> 2] = $6;
 HEAP32[$11 + 160 >> 2] = $7;
 HEAP32[$11 + 156 >> 2] = $8;
 HEAP32[$11 + 152 >> 2] = $9;
 HEAP32[$11 + 148 >> 2] = $10;
 HEAP32[$11 + 144 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 10 >> 1];
 HEAP32[$11 + 140 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 12 >> 1];
 HEAP32[$11 + 136 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 14 >> 1];
 HEAP32[$11 + 132 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 16 >> 1];
 HEAP32[$11 + 128 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 2 >> 1];
 HEAP32[$11 + 124 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 4 >> 1];
 HEAP32[$11 + 120 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 18 >> 1];
 HEAP32[$11 + 116 >> 2] = HEAP32[HEAP32[$11 + 188 >> 2] + 20 >> 2];
 HEAP32[$11 + 112 >> 2] = HEAP32[HEAP32[$11 + 188 >> 2] + 28 >> 2];
 HEAP32[$11 + 108 >> 2] = HEAP32[HEAP32[$11 + 188 >> 2] + 40 >> 2];
 HEAP32[$11 + 104 >> 2] = HEAP32[HEAP32[$11 + 188 >> 2] + 44 >> 2];
 label$1 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$11 + 176 >> 2]) | 0) != 4) {
   break label$1;
  }
 }
 label$2 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$11 + 168 >> 2]) | 0) != 4) {
   break label$2;
  }
 }
 label$3 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$11 + 152 >> 2]) | 0) != 4) {
   break label$3;
  }
 }
 label$4 : {
  if (HEAP32[$11 + 108 >> 2] > HEAP32[$11 + 104 >> 2]) {
   break label$4;
  }
 }
 HEAP32[$11 + 100 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$11 + 176 >> 2], 0, HEAP32[$11 + 152 >> 2], 0);
 HEAP32[$11 + 96 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$11 + 168 >> 2], 3, HEAP32[$11 + 152 >> 2], 3);
 HEAP32[$11 + 92 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 176 >> 2], 1);
 HEAP32[$11 + 88 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 176 >> 2], 2);
 HEAP32[$11 + 84 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 176 >> 2], 3);
 HEAP32[$11 + 80 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 168 >> 2], 1);
 HEAP32[$11 + 76 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 168 >> 2], 2);
 HEAP32[$11 + 72 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 152 >> 2], 1);
 HEAP32[$11 + 68 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 152 >> 2], 2);
 label$5 : {
  if (HEAP32[$11 + 96 >> 2] != (Math_imul(HEAP32[$11 + 84 >> 2], HEAP32[$11 + 120 >> 2]) | 0)) {
   break label$5;
  }
 }
 label$6 : {
  if ((tflite__RuntimeShape__FlatSize_28_29_20const(HEAP32[$11 + 160 >> 2]) | 0) != HEAP32[$11 + 96 >> 2]) {
   break label$6;
  }
 }
 HEAP32[$11 + 64 >> 2] = 0;
 while (1) {
  if (HEAP32[$11 + 64 >> 2] < HEAP32[$11 + 100 >> 2]) {
   HEAP32[$11 + 60 >> 2] = 0;
   while (1) {
    if (HEAP32[$11 + 60 >> 2] < HEAP32[$11 + 72 >> 2]) {
     HEAP32[$11 + 56 >> 2] = 0;
     while (1) {
      if (HEAP32[$11 + 56 >> 2] < HEAP32[$11 + 68 >> 2]) {
       HEAP32[$11 + 52 >> 2] = 0;
       while (1) {
        if (HEAP32[$11 + 52 >> 2] < HEAP32[$11 + 84 >> 2]) {
         HEAP32[$11 + 48 >> 2] = 0;
         while (1) {
          if (HEAP32[$11 + 48 >> 2] < HEAP32[$11 + 120 >> 2]) {
           HEAP32[$11 + 44 >> 2] = HEAP32[$11 + 48 >> 2] + Math_imul(HEAP32[$11 + 52 >> 2], HEAP32[$11 + 120 >> 2]);
           HEAP32[$11 + 40 >> 2] = Math_imul(HEAP32[$11 + 56 >> 2], HEAP32[$11 + 144 >> 2]) - HEAP32[$11 + 128 >> 2];
           HEAP32[$11 + 36 >> 2] = Math_imul(HEAP32[$11 + 60 >> 2], HEAP32[$11 + 140 >> 2]) - HEAP32[$11 + 124 >> 2];
           HEAP32[$11 + 32 >> 2] = 0;
           HEAP32[$11 + 28 >> 2] = 0;
           while (1) {
            if (HEAP32[$11 + 28 >> 2] < HEAP32[$11 + 80 >> 2]) {
             HEAP32[$11 + 24 >> 2] = 0;
             while (1) {
              if (HEAP32[$11 + 24 >> 2] < HEAP32[$11 + 76 >> 2]) {
               HEAP32[$11 + 20 >> 2] = HEAP32[$11 + 40 >> 2] + Math_imul(HEAP32[$11 + 136 >> 2], HEAP32[$11 + 24 >> 2]);
               HEAP32[$11 + 16 >> 2] = HEAP32[$11 + 36 >> 2] + Math_imul(HEAP32[$11 + 132 >> 2], HEAP32[$11 + 28 >> 2]);
               $0 = $11;
               $1 = 0;
               label$21 : {
                if (HEAP32[$11 + 20 >> 2] < 0) {
                 break label$21;
                }
                $1 = 0;
                if (HEAP32[$11 + 20 >> 2] >= HEAP32[$11 + 88 >> 2]) {
                 break label$21;
                }
                $1 = 0;
                if (HEAP32[$11 + 16 >> 2] < 0) {
                 break label$21;
                }
                $1 = HEAP32[$11 + 16 >> 2] < HEAP32[$11 + 92 >> 2];
               }
               HEAP8[$0 + 15 | 0] = $1;
               if (HEAP8[$11 + 15 | 0] & 1) {
                HEAP32[$11 + 8 >> 2] = HEAP8[HEAP32[$11 + 172 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$11 + 176 >> 2], HEAP32[$11 + 64 >> 2], HEAP32[$11 + 16 >> 2], HEAP32[$11 + 20 >> 2], HEAP32[$11 + 52 >> 2]) | 0];
                HEAP32[$11 + 4 >> 2] = HEAP8[HEAP32[$11 + 164 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$11 + 168 >> 2], 0, HEAP32[$11 + 28 >> 2], HEAP32[$11 + 24 >> 2], HEAP32[$11 + 44 >> 2]) | 0];
                HEAP32[$11 + 32 >> 2] = HEAP32[$11 + 32 >> 2] + Math_imul(HEAP32[$11 + 4 >> 2], HEAP32[$11 + 8 >> 2] + HEAP32[$11 + 116 >> 2] | 0);
               }
               HEAP32[$11 + 24 >> 2] = HEAP32[$11 + 24 >> 2] + 1;
               continue;
              }
              break;
             }
             HEAP32[$11 + 28 >> 2] = HEAP32[$11 + 28 >> 2] + 1;
             continue;
            }
            break;
           }
           if (HEAP32[$11 + 156 >> 2]) {
            HEAP32[$11 + 32 >> 2] = HEAP32[HEAP32[$11 + 156 >> 2] + (HEAP32[$11 + 44 >> 2] << 2) >> 2] + HEAP32[$11 + 32 >> 2];
           }
           $0 = $11 + 32 | 0;
           $1 = $11 + 104 | 0;
           $2 = $11 + 108 | 0;
           HEAP32[$11 + 32 >> 2] = tflite__MultiplyByQuantizedMultiplier_28int_2c_20int_2c_20int_29(HEAP32[$11 + 32 >> 2], HEAP32[HEAP32[$11 + 184 >> 2] + (HEAP32[$11 + 44 >> 2] << 2) >> 2], HEAP32[HEAP32[$11 + 180 >> 2] + (HEAP32[$11 + 44 >> 2] << 2) >> 2]);
           HEAP32[$11 + 32 >> 2] = HEAP32[$11 + 112 >> 2] + HEAP32[$11 + 32 >> 2];
           HEAP32[$11 + 32 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($0, $2) >> 2];
           HEAP32[$11 + 32 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($0, $1) >> 2];
           $0 = HEAP32[$11 + 32 >> 2];
           HEAP8[HEAP32[$11 + 148 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$11 + 152 >> 2], HEAP32[$11 + 64 >> 2], HEAP32[$11 + 60 >> 2], HEAP32[$11 + 56 >> 2], HEAP32[$11 + 44 >> 2]) | 0] = $0;
           HEAP32[$11 + 48 >> 2] = HEAP32[$11 + 48 >> 2] + 1;
           continue;
          }
          break;
         }
         HEAP32[$11 + 52 >> 2] = HEAP32[$11 + 52 >> 2] + 1;
         continue;
        }
        break;
       }
       HEAP32[$11 + 56 >> 2] = HEAP32[$11 + 56 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$11 + 60 >> 2] = HEAP32[$11 + 60 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$11 + 64 >> 2] = HEAP32[$11 + 64 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $11 + 192 | 0;
}
function tflite__ops__micro__quantize__Eval_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = global$0 - 240 | 0;
 global$0 = $2;
 HEAP32[$2 + 232 >> 2] = $0;
 HEAP32[$2 + 228 >> 2] = $1;
 label$1 : {
  if (!HEAP32[HEAP32[$2 + 228 >> 2] + 8 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$2 + 224 >> 2] = HEAP32[HEAP32[$2 + 228 >> 2] + 8 >> 2];
 HEAP32[$2 + 220 >> 2] = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 232 >> 2], HEAP32[$2 + 228 >> 2], 0);
 HEAP32[$2 + 216 >> 2] = tflite__micro__GetEvalOutput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 232 >> 2], HEAP32[$2 + 228 >> 2]);
 label$2 : {
  label$3 : {
   if (HEAP32[HEAP32[$2 + 220 >> 2] + 8 >> 2] == 1) {
    label$5 : {
     $0 = HEAP32[HEAP32[$2 + 216 >> 2] + 8 >> 2] + -3 | 0;
     if ($0 >>> 0 > 6) {
      break label$5;
     }
     label$6 : {
      switch ($0 - 1 | 0) {
      case 5:
       $0 = HEAP32[$2 + 224 >> 2];
       tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($2 + 192 | 0, HEAP32[$2 + 220 >> 2]);
       $1 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$2 + 220 >> 2]);
       tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($2 + 160 | 0, HEAP32[$2 + 216 >> 2]);
       void_20tflite__reference_ops__AffineQuantize_float_2c_20signed_20char__28tflite__QuantizationParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($0, $2 + 192 | 0, $1, $2 + 160 | 0, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$2 + 216 >> 2]));
       $0 = $2 + 192 | 0;
       tflite__RuntimeShape___RuntimeShape_28_29($2 + 160 | 0);
       tflite__RuntimeShape___RuntimeShape_28_29($0);
       break label$3;
      default:
       $0 = HEAP32[$2 + 224 >> 2];
       tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($2 + 136 | 0, HEAP32[$2 + 220 >> 2]);
       $1 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$2 + 220 >> 2]);
       tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($2 + 112 | 0, HEAP32[$2 + 216 >> 2]);
       void_20tflite__reference_ops__AffineQuantize_float_2c_20unsigned_20char__28tflite__QuantizationParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29($0, $2 + 136 | 0, $1, $2 + 112 | 0, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$2 + 216 >> 2]));
       $0 = $2 + 136 | 0;
       tflite__RuntimeShape___RuntimeShape_28_29($2 + 112 | 0);
       tflite__RuntimeShape___RuntimeShape_28_29($0);
       break label$3;
      case 0:
      case 1:
      case 2:
      case 4:
       break label$5;
      case 3:
       break label$6;
      }
     }
     $0 = HEAP32[$2 + 224 >> 2];
     tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($2 + 88 | 0, HEAP32[$2 + 220 >> 2]);
     $1 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$2 + 220 >> 2]);
     tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($2 - -64 | 0, HEAP32[$2 + 216 >> 2]);
     void_20tflite__reference_ops__AffineQuantize_float_2c_20short__28tflite__QuantizationParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20short__29($0, $2 + 88 | 0, $1, $2 - -64 | 0, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$2 + 216 >> 2]));
     $0 = $2 + 88 | 0;
     tflite__RuntimeShape___RuntimeShape_28_29($2 - -64 | 0);
     tflite__RuntimeShape___RuntimeShape_28_29($0);
     HEAP32[$2 + 236 >> 2] = 0;
     break label$2;
    }
    $0 = HEAP32[HEAP32[$2 + 232 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 232 >> 2];
    $3 = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 220 >> 2] + 8 >> 2]);
    HEAP32[$2 + 4 >> 2] = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 216 >> 2] + 8 >> 2]);
    HEAP32[$2 >> 2] = $3;
    FUNCTION_TABLE[$0]($1, 135619, $2);
    HEAP32[$2 + 236 >> 2] = 1;
    break label$2;
   }
   label$9 : {
    if (HEAP32[HEAP32[$2 + 220 >> 2] + 8 >> 2] == 7) {
     HEAP32[$2 + 60 >> 2] = tflite__ElementCount_28TfLiteIntArray_20const__29(HEAP32[HEAP32[$2 + 220 >> 2] + 4 >> 2]);
     label$11 : {
      label$12 : {
       $0 = HEAP32[HEAP32[$2 + 216 >> 2] + 8 >> 2] + -7 | 0;
       if ($0 >>> 0 > 2) {
        break label$12;
       }
       label$13 : {
        switch ($0 - 1 | 0) {
        case 1:
         void_20tflite__reference_ops__Requantize_short_2c_20signed_20char__28short_20const__2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20signed_20char__29(float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$2 + 220 >> 2]), HEAP32[$2 + 60 >> 2], HEAP32[HEAP32[$2 + 224 >> 2] + 16 >> 2], HEAP32[HEAP32[$2 + 224 >> 2] + 20 >> 2], HEAP32[HEAP32[$2 + 224 >> 2] + 24 >> 2], HEAP32[HEAP32[$2 + 224 >> 2] >> 2], float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$2 + 216 >> 2]));
         break label$11;
        case 0:
         break label$12;
        default:
         break label$13;
        }
       }
       void_20tflite__reference_ops__Requantize_short_2c_20short__28short_20const__2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20short__29(float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$2 + 220 >> 2]), HEAP32[$2 + 60 >> 2], HEAP32[HEAP32[$2 + 224 >> 2] + 16 >> 2], HEAP32[HEAP32[$2 + 224 >> 2] + 20 >> 2], HEAP32[HEAP32[$2 + 224 >> 2] + 24 >> 2], HEAP32[HEAP32[$2 + 224 >> 2] >> 2], float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$2 + 216 >> 2]));
       HEAP32[$2 + 236 >> 2] = 0;
       break label$2;
      }
      $0 = HEAP32[HEAP32[$2 + 232 >> 2] + 20 >> 2];
      $1 = HEAP32[$2 + 232 >> 2];
      $3 = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 220 >> 2] + 8 >> 2]);
      HEAP32[$2 + 20 >> 2] = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 216 >> 2] + 8 >> 2]);
      HEAP32[$2 + 16 >> 2] = $3;
      FUNCTION_TABLE[$0]($1, 135619, $2 + 16 | 0);
      HEAP32[$2 + 236 >> 2] = 1;
      break label$2;
     }
     break label$9;
    }
    label$15 : {
     if (HEAP32[HEAP32[$2 + 220 >> 2] + 8 >> 2] == 9) {
      HEAP32[$2 + 56 >> 2] = tflite__ElementCount_28TfLiteIntArray_20const__29(HEAP32[HEAP32[$2 + 220 >> 2] + 4 >> 2]);
      label$17 : {
       if (HEAP32[HEAP32[$2 + 216 >> 2] + 8 >> 2] == 9) {
        void_20tflite__reference_ops__Requantize_signed_20char_2c_20signed_20char__28signed_20char_20const__2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20signed_20char__29(float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$2 + 220 >> 2]), HEAP32[$2 + 56 >> 2], HEAP32[HEAP32[$2 + 224 >> 2] + 16 >> 2], HEAP32[HEAP32[$2 + 224 >> 2] + 20 >> 2], HEAP32[HEAP32[$2 + 224 >> 2] + 24 >> 2], HEAP32[HEAP32[$2 + 224 >> 2] >> 2], float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$2 + 216 >> 2]));
        break label$17;
       }
       $0 = HEAP32[HEAP32[$2 + 232 >> 2] + 20 >> 2];
       $1 = HEAP32[$2 + 232 >> 2];
       $3 = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 220 >> 2] + 8 >> 2]);
       HEAP32[$2 + 36 >> 2] = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 216 >> 2] + 8 >> 2]);
       HEAP32[$2 + 32 >> 2] = $3;
       FUNCTION_TABLE[$0]($1, 135619, $2 + 32 | 0);
       HEAP32[$2 + 236 >> 2] = 1;
       break label$2;
      }
      break label$15;
     }
     $0 = HEAP32[HEAP32[$2 + 232 >> 2] + 20 >> 2];
     $1 = HEAP32[$2 + 232 >> 2];
     $3 = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 220 >> 2] + 8 >> 2]);
     HEAP32[$2 + 52 >> 2] = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 216 >> 2] + 8 >> 2]);
     HEAP32[$2 + 48 >> 2] = $3;
     FUNCTION_TABLE[$0]($1, 135619, $2 + 48 | 0);
     HEAP32[$2 + 236 >> 2] = 1;
     break label$2;
    }
   }
  }
  HEAP32[$2 + 236 >> 2] = 0;
 }
 global$0 = $2 + 240 | 0;
 return HEAP32[$2 + 236 >> 2];
}
function jspeFactor() {
 var $0 = 0, $1 = 0, $2 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 $0 = global$0 - 112 | 0;
 global$0 = $0;
 label$1 : {
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 128) {
   HEAP32[$0 + 104 >> 2] = jspGetNamedVariable(jslGetTokenValueAsString());
   jslGetNextToken();
   label$3 : {
    if (HEAP16[HEAP32[35539] + 2 >> 1] == 133) {
     jsExceptionHere(2, 80368, 0);
     break label$3;
    }
    label$5 : {
     if (HEAP16[HEAP32[35539] + 2 >> 1] != 162) {
      break label$5;
     }
     if (wasm2js_i32$0 = !(jsvIsName(HEAP32[$0 + 104 >> 2]) & 1), wasm2js_i32$1 = 0, wasm2js_i32$2 = HEAP32[$0 + 104 >> 2] | (HEAP32[80549] & 63) == 1, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1) {
      break label$5;
     }
     HEAP32[$0 + 100 >> 2] = jspeArrowFunction(0, HEAP32[$0 + 104 >> 2]);
     jsvUnLock(HEAP32[$0 + 104 >> 2]);
     HEAP32[$0 + 104 >> 2] = HEAP32[$0 + 100 >> 2];
    }
   }
   HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 104 >> 2];
   break label$1;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 129) {
   HEAP32[$0 + 96 >> 2] = 0;
   if ((HEAP32[80549] & 63) == 1) {
    HEAP32[$0 + 96 >> 2] = jsvNewFromLongInteger(stringToInt(jslGetTokenValueAsString()), i64toi32_i32$HIGH_BITS);
   }
   jslGetNextToken();
   HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 96 >> 2];
   break label$1;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 130) {
   HEAP32[$0 + 92 >> 2] = 0;
   if ((HEAP32[80549] & 63) == 1) {
    HEAP32[$0 + 92 >> 2] = jsvNewFromFloat(stringToFloat(jslGetTokenValueAsString()));
   }
   jslGetNextToken();
   HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 92 >> 2];
   break label$1;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 40) {
   jslGetNextToken();
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$0 + 108 >> 2] = 0;
    break label$1;
   }
   HEAP32[$0 + 108 >> 2] = jspeExpressionOrArrowFunction();
   break label$1;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 180) {
   jslGetNextToken();
   $2 = $0;
   label$14 : {
    if ((HEAP32[80549] & 63) == 1) {
     $1 = jsvNewFromBool(1);
     break label$14;
    }
    $1 = 0;
   }
   HEAP32[$2 + 108 >> 2] = $1;
   break label$1;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 181) {
   jslGetNextToken();
   $2 = $0;
   label$17 : {
    if ((HEAP32[80549] & 63) == 1) {
     $1 = jsvNewFromBool(0);
     break label$17;
    }
    $1 = 0;
   }
   HEAP32[$2 + 108 >> 2] = $1;
   break label$1;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 182) {
   jslGetNextToken();
   $2 = $0;
   label$20 : {
    if ((HEAP32[80549] & 63) == 1) {
     $1 = jsvNewWithFlags(2);
     break label$20;
    }
    $1 = 0;
   }
   HEAP32[$2 + 108 >> 2] = $1;
   break label$1;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 183) {
   jslGetNextToken();
   HEAP32[$0 + 108 >> 2] = 0;
   break label$1;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 131) {
   HEAP32[$0 + 88 >> 2] = 0;
   if ((HEAP32[80549] & 63) == 1) {
    HEAP32[$0 + 88 >> 2] = jslGetTokenValueAsVar();
   }
   jslGetNextToken();
   HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 88 >> 2];
   break label$1;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 133) {
   HEAP32[$0 + 108 >> 2] = jspeTemplateLiteral();
   break label$1;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 135) {
   $2 = $0 + 32 | 0;
   HEAP32[$0 + 84 >> 2] = 0;
   HEAP32[$0 + 80 >> 2] = jslGetTokenValueAsVar();
   HEAP32[$0 + 76 >> 2] = 0;
   HEAP32[$0 + 72 >> 2] = 0;
   jsvStringIteratorNew($2, HEAP32[$0 + 80 >> 2], 0);
   while (1) {
    if (jsvStringIteratorHasChar($0 + 32 | 0) & 1) {
     HEAP32[$0 + 72 >> 2] = HEAP32[$0 + 72 >> 2] + 1;
     if ((jsvStringIteratorGetCharAndNext($0 + 32 | 0) & 255) == 47) {
      HEAP32[$0 + 76 >> 2] = HEAP32[$0 + 72 >> 2];
     }
     continue;
    }
    break;
   }
   jsvStringIteratorFree($0 + 32 | 0);
   HEAP32[$0 + 28 >> 2] = 0;
   if (HEAPU32[$0 + 76 >> 2] < HEAPU32[$0 + 72 >> 2]) {
    HEAP32[$0 + 28 >> 2] = jsvNewFromStringVar(HEAP32[$0 + 80 >> 2], HEAP32[$0 + 76 >> 2], 2147483647);
   }
   HEAP32[$0 + 24 >> 2] = jsvNewFromStringVar(HEAP32[$0 + 80 >> 2], 1, HEAP32[$0 + 76 >> 2] - 2 | 0);
   HEAP32[$0 + 84 >> 2] = jswrap_regexp_constructor(HEAP32[$0 + 24 >> 2], HEAP32[$0 + 28 >> 2]);
   jsvUnLock3(HEAP32[$0 + 80 >> 2], HEAP32[$0 + 28 >> 2], HEAP32[$0 + 24 >> 2]);
   jslGetNextToken();
   HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 84 >> 2];
   break label$1;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 123) {
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$0 + 108 >> 2] = 0;
    break label$1;
   }
   HEAP32[$0 + 108 >> 2] = jspeFactorObject();
   break label$1;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 91) {
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$0 + 108 >> 2] = 0;
    break label$1;
   }
   HEAP32[$0 + 108 >> 2] = jspeFactorArray();
   break label$1;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 170) {
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$0 + 108 >> 2] = 0;
    break label$1;
   }
   jslGetNextToken();
   HEAP32[$0 + 108 >> 2] = jspeFunctionDefinition(1);
   break label$1;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 194) {
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$0 + 108 >> 2] = 0;
    break label$1;
   }
   jslGetNextToken();
   HEAP32[$0 + 108 >> 2] = jspeClassDefinition(1);
   break label$1;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 196) {
   jslGetNextToken();
   if (jsvIsObject(HEAP32[80548]) & 1) {
    HEAP32[$0 + 20 >> 2] = jsvObjectGetChild(HEAP32[80548], 79526, 0);
    $2 = $0;
    label$41 : {
     if (jsvIsObject(HEAP32[$0 + 20 >> 2]) & 1) {
      $1 = jsvObjectGetChild(HEAP32[$0 + 20 >> 2], 79526, 0);
      break label$41;
     }
     $1 = 0;
    }
    HEAP32[$2 + 16 >> 2] = $1;
    jsvUnLock(HEAP32[$0 + 20 >> 2]);
    if (!HEAP32[$0 + 16 >> 2]) {
     jsExceptionHere(2, 80407, 0);
     HEAP32[$0 + 108 >> 2] = 0;
     break label$1;
    }
    if (HEAP16[HEAP32[35539] + 2 >> 1] == 40) {
     HEAP32[$0 + 12 >> 2] = jsvObjectGetChild(HEAP32[$0 + 16 >> 2], 80199, 0);
     jsvUnLock(HEAP32[$0 + 16 >> 2]);
     HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 12 >> 2];
     break label$1;
    }
    HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 16 >> 2];
    break label$1;
   }
   if (jsvIsFunction(HEAP32[80548]) & 1) {
    HEAP32[$0 + 8 >> 2] = jsvObjectGetChild(HEAP32[80548], 79516, 0);
    $2 = $0;
    label$46 : {
     if (jsvIsObject(HEAP32[$0 + 8 >> 2]) & 1) {
      $1 = jsvObjectGetChild(HEAP32[$0 + 8 >> 2], 79526, 0);
      break label$46;
     }
     $1 = 0;
    }
    HEAP32[$2 + 4 >> 2] = $1;
    jsvUnLock(HEAP32[$0 + 8 >> 2]);
    if (!HEAP32[$0 + 4 >> 2]) {
     jsExceptionHere(2, 80407, 0);
     HEAP32[$0 + 108 >> 2] = 0;
     break label$1;
    }
    HEAP32[$0 >> 2] = jsvObjectGetChild(HEAP32[$0 + 4 >> 2], 80199, 0);
    jsvUnLock(HEAP32[$0 + 4 >> 2]);
    HEAP32[$0 + 108 >> 2] = HEAP32[$0 >> 2];
    break label$1;
   }
   jsExceptionHere(2, 80407, 0);
   HEAP32[$0 + 108 >> 2] = 0;
   break label$1;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 175) {
   jslGetNextToken();
   $2 = $0;
   if (HEAP32[80548]) {
    $1 = HEAP32[80548];
   } else {
    $1 = HEAP32[80545];
   }
   HEAP32[$2 + 108 >> 2] = jsvLockAgain($1);
   break label$1;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 190) {
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$0 + 108 >> 2] = 0;
    break label$1;
   }
   HEAP32[$0 + 108 >> 2] = jspeFactorDelete();
   break label$1;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 191) {
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$0 + 108 >> 2] = 0;
    break label$1;
   }
   HEAP32[$0 + 108 >> 2] = jspeFactorTypeOf();
   break label$1;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 192) {
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$0 + 108 >> 2] = 0;
    break label$1;
   }
   jslGetNextToken();
   jsvUnLock(jspeUnaryExpression());
   HEAP32[$0 + 108 >> 2] = 0;
   break label$1;
  }
  if (!(jslMatch(0) & 1)) {
   HEAP32[$0 + 108 >> 2] = 0;
   break label$1;
  }
  jsExceptionHere(2, 80440, 0);
  HEAP32[$0 + 108 >> 2] = 0;
 }
 global$0 = $0 + 112 | 0;
 return HEAP32[$0 + 108 >> 2];
}
function tflite__reference_integer_ops__ConvPerChannel_28tflite__ConvParams_20const__2c_20int_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10) {
 var $11 = 0;
 $11 = global$0 - 192 | 0;
 global$0 = $11;
 HEAP32[$11 + 188 >> 2] = $0;
 HEAP32[$11 + 184 >> 2] = $1;
 HEAP32[$11 + 180 >> 2] = $2;
 HEAP32[$11 + 176 >> 2] = $3;
 HEAP32[$11 + 172 >> 2] = $4;
 HEAP32[$11 + 168 >> 2] = $5;
 HEAP32[$11 + 164 >> 2] = $6;
 HEAP32[$11 + 160 >> 2] = $7;
 HEAP32[$11 + 156 >> 2] = $8;
 HEAP32[$11 + 152 >> 2] = $9;
 HEAP32[$11 + 148 >> 2] = $10;
 HEAP32[$11 + 144 >> 2] = HEAP32[HEAP32[$11 + 188 >> 2] + 20 >> 2];
 HEAP32[$11 + 140 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 10 >> 1];
 HEAP32[$11 + 136 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 12 >> 1];
 HEAP32[$11 + 132 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 14 >> 1];
 HEAP32[$11 + 128 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 16 >> 1];
 HEAP32[$11 + 124 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 2 >> 1];
 HEAP32[$11 + 120 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 4 >> 1];
 HEAP32[$11 + 116 >> 2] = HEAP32[HEAP32[$11 + 188 >> 2] + 28 >> 2];
 HEAP32[$11 + 112 >> 2] = HEAP32[HEAP32[$11 + 188 >> 2] + 40 >> 2];
 HEAP32[$11 + 108 >> 2] = HEAP32[HEAP32[$11 + 188 >> 2] + 44 >> 2];
 label$1 : {
  if (HEAP32[$11 + 112 >> 2] > HEAP32[$11 + 108 >> 2]) {
   break label$1;
  }
 }
 label$2 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$11 + 176 >> 2]) | 0) != 4) {
   break label$2;
  }
 }
 label$3 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$11 + 168 >> 2]) | 0) != 4) {
   break label$3;
  }
 }
 label$4 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$11 + 152 >> 2]) | 0) != 4) {
   break label$4;
  }
 }
 HEAP32[$11 + 104 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$11 + 176 >> 2], 0, HEAP32[$11 + 152 >> 2], 0);
 HEAP32[$11 + 100 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$11 + 176 >> 2], 3, HEAP32[$11 + 168 >> 2], 3);
 HEAP32[$11 + 96 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$11 + 168 >> 2], 0, HEAP32[$11 + 152 >> 2], 3);
 if (HEAP32[$11 + 156 >> 2]) {
  label$6 : {
   if ((tflite__RuntimeShape__FlatSize_28_29_20const(HEAP32[$11 + 160 >> 2]) | 0) != HEAP32[$11 + 96 >> 2]) {
    break label$6;
   }
  }
 }
 HEAP32[$11 + 92 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 176 >> 2], 1);
 HEAP32[$11 + 88 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 176 >> 2], 2);
 HEAP32[$11 + 84 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 168 >> 2], 1);
 HEAP32[$11 + 80 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 168 >> 2], 2);
 HEAP32[$11 + 76 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 152 >> 2], 1);
 HEAP32[$11 + 72 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 152 >> 2], 2);
 HEAP32[$11 + 68 >> 2] = 0;
 while (1) {
  if (HEAP32[$11 + 68 >> 2] < HEAP32[$11 + 104 >> 2]) {
   HEAP32[$11 + 64 >> 2] = 0;
   while (1) {
    if (HEAP32[$11 + 64 >> 2] < HEAP32[$11 + 76 >> 2]) {
     HEAP32[$11 + 60 >> 2] = 0;
     while (1) {
      if (HEAP32[$11 + 60 >> 2] < HEAP32[$11 + 72 >> 2]) {
       HEAP32[$11 + 56 >> 2] = 0;
       while (1) {
        if (HEAP32[$11 + 56 >> 2] < HEAP32[$11 + 96 >> 2]) {
         HEAP32[$11 + 52 >> 2] = Math_imul(HEAP32[$11 + 60 >> 2], HEAP32[$11 + 140 >> 2]) - HEAP32[$11 + 124 >> 2];
         HEAP32[$11 + 48 >> 2] = Math_imul(HEAP32[$11 + 64 >> 2], HEAP32[$11 + 136 >> 2]) - HEAP32[$11 + 120 >> 2];
         HEAP32[$11 + 44 >> 2] = 0;
         HEAP32[$11 + 40 >> 2] = 0;
         while (1) {
          if (HEAP32[$11 + 40 >> 2] < HEAP32[$11 + 84 >> 2]) {
           HEAP32[$11 + 36 >> 2] = 0;
           while (1) {
            if (HEAP32[$11 + 36 >> 2] < HEAP32[$11 + 80 >> 2]) {
             HEAP32[$11 + 32 >> 2] = 0;
             while (1) {
              if (HEAP32[$11 + 32 >> 2] < HEAP32[$11 + 100 >> 2]) {
               HEAP32[$11 + 28 >> 2] = HEAP32[$11 + 52 >> 2] + Math_imul(HEAP32[$11 + 132 >> 2], HEAP32[$11 + 36 >> 2]);
               HEAP32[$11 + 24 >> 2] = HEAP32[$11 + 48 >> 2] + Math_imul(HEAP32[$11 + 128 >> 2], HEAP32[$11 + 40 >> 2]);
               $0 = $11;
               $1 = 0;
               label$21 : {
                if (HEAP32[$11 + 28 >> 2] < 0) {
                 break label$21;
                }
                $1 = 0;
                if (HEAP32[$11 + 28 >> 2] >= HEAP32[$11 + 88 >> 2]) {
                 break label$21;
                }
                $1 = 0;
                if (HEAP32[$11 + 24 >> 2] < 0) {
                 break label$21;
                }
                $1 = HEAP32[$11 + 24 >> 2] < HEAP32[$11 + 92 >> 2];
               }
               HEAP8[$0 + 23 | 0] = $1;
               if (HEAP8[$11 + 23 | 0] & 1) {
                HEAP32[$11 + 16 >> 2] = HEAP8[HEAP32[$11 + 172 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$11 + 176 >> 2], HEAP32[$11 + 68 >> 2], HEAP32[$11 + 24 >> 2], HEAP32[$11 + 28 >> 2], HEAP32[$11 + 32 >> 2]) | 0];
                HEAP32[$11 + 12 >> 2] = HEAP8[HEAP32[$11 + 164 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$11 + 168 >> 2], HEAP32[$11 + 56 >> 2], HEAP32[$11 + 40 >> 2], HEAP32[$11 + 36 >> 2], HEAP32[$11 + 32 >> 2]) | 0];
                HEAP32[$11 + 44 >> 2] = HEAP32[$11 + 44 >> 2] + Math_imul(HEAP32[$11 + 12 >> 2], HEAP32[$11 + 16 >> 2] + HEAP32[$11 + 144 >> 2] | 0);
               }
               HEAP32[$11 + 32 >> 2] = HEAP32[$11 + 32 >> 2] + 1;
               continue;
              }
              break;
             }
             HEAP32[$11 + 36 >> 2] = HEAP32[$11 + 36 >> 2] + 1;
             continue;
            }
            break;
           }
           HEAP32[$11 + 40 >> 2] = HEAP32[$11 + 40 >> 2] + 1;
           continue;
          }
          break;
         }
         if (HEAP32[$11 + 156 >> 2]) {
          HEAP32[$11 + 44 >> 2] = HEAP32[HEAP32[$11 + 156 >> 2] + (HEAP32[$11 + 56 >> 2] << 2) >> 2] + HEAP32[$11 + 44 >> 2];
         }
         $0 = $11 + 44 | 0;
         $1 = $11 + 108 | 0;
         $2 = $11 + 112 | 0;
         HEAP32[$11 + 44 >> 2] = tflite__MultiplyByQuantizedMultiplier_28int_2c_20int_2c_20int_29(HEAP32[$11 + 44 >> 2], HEAP32[HEAP32[$11 + 184 >> 2] + (HEAP32[$11 + 56 >> 2] << 2) >> 2], HEAP32[HEAP32[$11 + 180 >> 2] + (HEAP32[$11 + 56 >> 2] << 2) >> 2]);
         HEAP32[$11 + 44 >> 2] = HEAP32[$11 + 116 >> 2] + HEAP32[$11 + 44 >> 2];
         HEAP32[$11 + 44 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($0, $2) >> 2];
         HEAP32[$11 + 44 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($0, $1) >> 2];
         $0 = HEAP32[$11 + 44 >> 2];
         HEAP8[HEAP32[$11 + 148 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$11 + 152 >> 2], HEAP32[$11 + 68 >> 2], HEAP32[$11 + 64 >> 2], HEAP32[$11 + 60 >> 2], HEAP32[$11 + 56 >> 2]) | 0] = $0;
         HEAP32[$11 + 56 >> 2] = HEAP32[$11 + 56 >> 2] + 1;
         continue;
        }
        break;
       }
       HEAP32[$11 + 60 >> 2] = HEAP32[$11 + 60 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$11 + 64 >> 2] = HEAP32[$11 + 64 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$11 + 68 >> 2] = HEAP32[$11 + 68 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $11 + 192 | 0;
}
function vcbprintf($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = global$0 - 144 | 0;
 global$0 = $4;
 HEAP32[$4 + 140 >> 2] = $0;
 HEAP32[$4 + 136 >> 2] = $1;
 HEAP32[$4 + 132 >> 2] = $2;
 HEAP32[$4 + 128 >> 2] = $3;
 while (1) {
  label$2 : {
   if (!HEAPU8[HEAP32[$4 + 132 >> 2]]) {
    break label$2;
   }
   label$3 : {
    if (HEAP8[HEAP32[$4 + 132 >> 2]] == 37) {
     HEAP32[$4 + 132 >> 2] = HEAP32[$4 + 132 >> 2] + 1;
     $0 = HEAP32[$4 + 132 >> 2];
     HEAP32[$4 + 132 >> 2] = $0 + 1;
     HEAP8[$4 + 95 | 0] = HEAPU8[$0 | 0];
     $0 = HEAP8[$4 + 95 | 0] + -32 | 0;
     if ($0 >>> 0 > 88) {
      break label$2;
     }
     label$5 : {
      label$6 : {
       switch ($0 - 1 | 0) {
       default:
        HEAP32[$4 + 88 >> 2] = 79481;
        if (HEAP8[$4 + 95 | 0] == 48) {
         HEAP32[$4 + 88 >> 2] = 79483;
         $0 = HEAP32[$4 + 132 >> 2];
         HEAP32[$4 + 132 >> 2] = $0 + 1;
         HEAP8[$4 + 95 | 0] = HEAPU8[$0 | 0];
        }
        HEAP32[$4 + 84 >> 2] = HEAP8[$4 + 95 | 0] - 48;
        $0 = HEAP32[$4 + 128 >> 2];
        HEAP32[$4 + 128 >> 2] = $0 + 4;
        HEAP32[$4 + 80 >> 2] = HEAP32[$0 >> 2];
        label$18 : {
         if (HEAP8[HEAP32[$4 + 132 >> 2]] == 120) {
          itostr_extra(HEAP32[$4 + 80 >> 2], $4 + 96 | 0, 0, 16);
          break label$18;
         }
         itostr(HEAP32[$4 + 80 >> 2], $4 + 96 | 0, 10);
        }
        HEAP32[$4 + 132 >> 2] = HEAP32[$4 + 132 >> 2] + 1;
        HEAP32[$4 + 76 >> 2] = strlen($4 + 96 | 0);
        while (1) {
         if (HEAP32[$4 + 76 >> 2] < HEAP32[$4 + 84 >> 2]) {
          FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]](HEAP32[$4 + 88 >> 2], HEAP32[$4 + 136 >> 2]);
          HEAP32[$4 + 76 >> 2] = HEAP32[$4 + 76 >> 2] + 1;
          continue;
         }
         break;
        }
        FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($4 + 96 | 0, HEAP32[$4 + 136 >> 2]);
        break label$5;
       case 67:
        $0 = HEAP32[$4 + 128 >> 2];
        HEAP32[$4 + 128 >> 2] = $0 + 4;
        $1 = HEAP32[$0 >> 2];
        $0 = $4 + 96 | 0;
        itostr($1, $0, 10);
        FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($0, HEAP32[$4 + 136 >> 2]);
        break label$5;
       case 87:
        $0 = HEAP32[$4 + 128 >> 2];
        HEAP32[$4 + 128 >> 2] = $0 + 4;
        $1 = HEAP32[$0 >> 2];
        $0 = $4 + 96 | 0;
        itostr_extra($1, $0, 0, 16);
        FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($0, HEAP32[$4 + 136 >> 2]);
        break label$5;
       case 43:
        HEAP32[$4 + 72 >> 2] = 10;
        HEAP8[$4 + 71 | 0] = 1;
        if (HEAP8[HEAP32[$4 + 132 >> 2]] == 120) {
         HEAP32[$4 + 72 >> 2] = 16;
         HEAP32[$4 + 132 >> 2] = HEAP32[$4 + 132 >> 2] + 1;
         HEAP8[$4 + 71 | 0] = 0;
        }
        $0 = HEAP32[$4 + 128 >> 2];
        HEAP32[$4 + 128 >> 2] = $0 + 4;
        $1 = HEAP32[$0 >> 2];
        $0 = $4 + 96 | 0;
        itostr_extra($1, $0, HEAP8[$4 + 71 | 0] & 1, HEAP32[$4 + 72 >> 2]);
        FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($0, HEAP32[$4 + 136 >> 2]);
        break label$5;
       case 69:
        $0 = HEAP32[$4 + 128 >> 2] + 7 & -8;
        HEAP32[$4 + 128 >> 2] = $0 + 8;
        $5 = HEAPF64[$0 >> 3];
        $0 = $4 + 96 | 0;
        ftoa_bounded($5, $0, 32);
        FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($0, HEAP32[$4 + 136 >> 2]);
        break label$5;
       case 82:
        $0 = HEAP32[$4 + 140 >> 2];
        $1 = HEAP32[$4 + 128 >> 2];
        HEAP32[$4 + 128 >> 2] = $1 + 4;
        FUNCTION_TABLE[$0](HEAP32[$1 >> 2], HEAP32[$4 + 136 >> 2]);
        break label$5;
       case 66:
        $0 = HEAP32[$4 + 128 >> 2];
        HEAP32[$4 + 128 >> 2] = $0 + 4;
        HEAP8[$4 + 96 | 0] = HEAP32[$0 >> 2];
        HEAP8[$4 + 97 | 0] = 0;
        FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($4 + 96 | 0, HEAP32[$4 + 136 >> 2]);
        break label$5;
       case 48:
       case 80:
       case 85:
        HEAP8[$4 + 70 | 0] = HEAP8[$4 + 95 | 0] != 118;
        HEAP8[$4 + 69 | 0] = HEAP8[$4 + 95 | 0] == 81;
        if (HEAP8[$4 + 70 | 0] & 1) {
         FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]](79485, HEAP32[$4 + 136 >> 2]);
        }
        $0 = HEAP32[$4 + 128 >> 2];
        HEAP32[$4 + 128 >> 2] = $0 + 4;
        HEAP32[$4 + 64 >> 2] = jsvAsString(HEAP32[$0 >> 2]);
        HEAP8[$4 + 97 | 0] = 0;
        if (jsvIsString(HEAP32[$4 + 64 >> 2]) & 1) {
         jsvStringIteratorNew($4 + 24 | 0, HEAP32[$4 + 64 >> 2], 0);
         while (1) {
          if (jsvStringIteratorHasChar($4 + 24 | 0) & 1) {
           HEAP8[$4 + 96 | 0] = jsvStringIteratorGetCharAndNext($4 + 24 | 0);
           label$27 : {
            if (HEAP8[$4 + 70 | 0] & 1) {
             $0 = HEAP32[$4 + 140 >> 2];
             FUNCTION_TABLE[$0](escapeCharacter(HEAP8[$4 + 96 | 0], HEAP8[$4 + 69 | 0] & 1), HEAP32[$4 + 136 >> 2]);
             break label$27;
            }
            FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($4 + 96 | 0, HEAP32[$4 + 136 >> 2]);
           }
           continue;
          }
          break;
         }
         jsvStringIteratorFree($4 + 24 | 0);
         jsvUnLock(HEAP32[$4 + 64 >> 2]);
        }
        if (HEAP8[$4 + 70 | 0] & 1) {
         FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]](79485, HEAP32[$4 + 136 >> 2]);
        }
        break label$5;
       case 73:
        $0 = HEAP32[$4 + 128 >> 2];
        HEAP32[$4 + 128 >> 2] = $0 + 4;
        HEAP32[$4 + 20 >> 2] = HEAP32[$0 >> 2];
        jsfGetJSONWithCallback(HEAP32[$4 + 20 >> 2], 0, 2085, 0, HEAP32[$4 + 140 >> 2], HEAP32[$4 + 136 >> 2]);
        break label$5;
       case 83:
        $0 = HEAP32[$4 + 128 >> 2];
        HEAP32[$4 + 128 >> 2] = $0 + 4;
        HEAP32[$4 + 16 >> 2] = HEAP32[$0 >> 2];
        $0 = $4;
        $2 = jsvIsNull(HEAP32[$4 + 16 >> 2]) & 1;
        $1 = 79487;
        label$30 : {
         if ($2) {
          break label$30;
         }
         $1 = jswGetBasicObjectName(HEAP32[$4 + 16 >> 2]);
        }
        HEAP32[$0 + 12 >> 2] = $1;
        if (!HEAP32[$4 + 12 >> 2]) {
         HEAP32[$4 + 12 >> 2] = jsvGetTypeOf(HEAP32[$4 + 16 >> 2]);
        }
        FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]](HEAP32[$4 + 12 >> 2], HEAP32[$4 + 136 >> 2]);
        break label$5;
       case 0:
       case 1:
       case 2:
       case 3:
       case 4:
       case 5:
       case 6:
       case 7:
       case 8:
       case 9:
       case 10:
       case 11:
       case 12:
       case 13:
       case 14:
       case 25:
       case 26:
       case 27:
       case 28:
       case 29:
       case 30:
       case 31:
       case 32:
       case 33:
       case 34:
       case 35:
       case 36:
       case 37:
       case 38:
       case 39:
       case 40:
       case 41:
       case 42:
       case 44:
       case 45:
       case 46:
       case 47:
       case 49:
       case 50:
       case 51:
       case 52:
       case 53:
       case 54:
       case 55:
       case 56:
       case 57:
       case 58:
       case 59:
       case 60:
       case 61:
       case 62:
       case 63:
       case 64:
       case 65:
       case 68:
       case 70:
       case 71:
       case 72:
       case 74:
       case 75:
       case 76:
       case 77:
       case 78:
       case 81:
       case 84:
       case 86:
        break label$2;
       case 79:
        break label$6;
       }
      }
      $0 = HEAP32[$4 + 128 >> 2];
      HEAP32[$4 + 128 >> 2] = $0 + 4;
      $1 = $4 + 96 | 0;
      jshGetPinString($1, HEAP32[$0 >> 2] & 255);
      FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($1, HEAP32[$4 + 136 >> 2]);
     }
     break label$3;
    }
    $0 = HEAP32[$4 + 132 >> 2];
    HEAP32[$4 + 132 >> 2] = $0 + 1;
    HEAP8[$4 + 96 | 0] = HEAPU8[$0 | 0];
    HEAP8[$4 + 97 | 0] = 0;
    FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($4 + 96 | 0, HEAP32[$4 + 136 >> 2]);
   }
   continue;
  }
  break;
 }
 global$0 = $4 + 144 | 0;
}
function tflite__reference_ops__depthwise_conv__DepthwiseConvBasicKernel__28tflite__DepthwiseConvOutputRounding_291___Run_28tflite__DepthwiseParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0;
 $9 = global$0 - 192 | 0;
 global$0 = $9;
 HEAP32[$9 + 188 >> 2] = $0;
 HEAP32[$9 + 184 >> 2] = $1;
 HEAP32[$9 + 180 >> 2] = $2;
 HEAP32[$9 + 176 >> 2] = $3;
 HEAP32[$9 + 172 >> 2] = $4;
 HEAP32[$9 + 168 >> 2] = $5;
 HEAP32[$9 + 164 >> 2] = $6;
 HEAP32[$9 + 160 >> 2] = $7;
 HEAP32[$9 + 156 >> 2] = $8;
 HEAP32[$9 + 152 >> 2] = HEAP16[HEAP32[$9 + 188 >> 2] + 10 >> 1];
 HEAP32[$9 + 148 >> 2] = HEAP16[HEAP32[$9 + 188 >> 2] + 12 >> 1];
 HEAP32[$9 + 144 >> 2] = HEAP16[HEAP32[$9 + 188 >> 2] + 14 >> 1];
 HEAP32[$9 + 140 >> 2] = HEAP16[HEAP32[$9 + 188 >> 2] + 16 >> 1];
 HEAP32[$9 + 136 >> 2] = HEAP16[HEAP32[$9 + 188 >> 2] + 2 >> 1];
 HEAP32[$9 + 132 >> 2] = HEAP16[HEAP32[$9 + 188 >> 2] + 4 >> 1];
 HEAP32[$9 + 128 >> 2] = HEAP16[HEAP32[$9 + 188 >> 2] + 18 >> 1];
 HEAP32[$9 + 124 >> 2] = HEAP32[HEAP32[$9 + 188 >> 2] + 40 >> 2];
 HEAP32[$9 + 120 >> 2] = HEAP32[HEAP32[$9 + 188 >> 2] + 44 >> 2];
 HEAP32[$9 + 116 >> 2] = HEAP32[HEAP32[$9 + 188 >> 2] + 20 >> 2];
 HEAP32[$9 + 112 >> 2] = HEAP32[HEAP32[$9 + 188 >> 2] + 24 >> 2];
 HEAP32[$9 + 108 >> 2] = HEAP32[HEAP32[$9 + 188 >> 2] + 28 >> 2];
 HEAP32[$9 + 104 >> 2] = HEAP32[HEAP32[$9 + 188 >> 2] + 32 >> 2];
 HEAP32[$9 + 100 >> 2] = HEAP32[HEAP32[$9 + 188 >> 2] + 36 >> 2];
 label$1 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 184 >> 2]) | 0) != 4) {
   break label$1;
  }
 }
 label$2 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 176 >> 2]) | 0) != 4) {
   break label$2;
  }
 }
 label$3 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 160 >> 2]) | 0) != 4) {
   break label$3;
  }
 }
 label$4 : {
  if (HEAP32[$9 + 124 >> 2] > HEAP32[$9 + 120 >> 2]) {
   break label$4;
  }
 }
 HEAP32[$9 + 96 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$9 + 184 >> 2], 0, HEAP32[$9 + 160 >> 2], 0);
 HEAP32[$9 + 92 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$9 + 176 >> 2], 3, HEAP32[$9 + 160 >> 2], 3);
 HEAP32[$9 + 88 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 184 >> 2], 1);
 HEAP32[$9 + 84 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 184 >> 2], 2);
 HEAP32[$9 + 80 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 184 >> 2], 3);
 HEAP32[$9 + 76 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 176 >> 2], 1);
 HEAP32[$9 + 72 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 176 >> 2], 2);
 HEAP32[$9 + 68 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 160 >> 2], 1);
 HEAP32[$9 + 64 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 160 >> 2], 2);
 label$5 : {
  if (HEAP32[$9 + 92 >> 2] != (Math_imul(HEAP32[$9 + 80 >> 2], HEAP32[$9 + 128 >> 2]) | 0)) {
   break label$5;
  }
 }
 label$6 : {
  if ((tflite__RuntimeShape__FlatSize_28_29_20const(HEAP32[$9 + 168 >> 2]) | 0) != HEAP32[$9 + 92 >> 2]) {
   break label$6;
  }
 }
 HEAP32[$9 + 60 >> 2] = 0;
 while (1) {
  if (HEAP32[$9 + 60 >> 2] < HEAP32[$9 + 96 >> 2]) {
   HEAP32[$9 + 56 >> 2] = 0;
   while (1) {
    if (HEAP32[$9 + 56 >> 2] < HEAP32[$9 + 68 >> 2]) {
     HEAP32[$9 + 52 >> 2] = 0;
     while (1) {
      if (HEAP32[$9 + 52 >> 2] < HEAP32[$9 + 64 >> 2]) {
       HEAP32[$9 + 48 >> 2] = 0;
       while (1) {
        if (HEAP32[$9 + 48 >> 2] < HEAP32[$9 + 80 >> 2]) {
         HEAP32[$9 + 44 >> 2] = 0;
         while (1) {
          if (HEAP32[$9 + 44 >> 2] < HEAP32[$9 + 128 >> 2]) {
           HEAP32[$9 + 40 >> 2] = HEAP32[$9 + 44 >> 2] + Math_imul(HEAP32[$9 + 48 >> 2], HEAP32[$9 + 128 >> 2]);
           HEAP32[$9 + 36 >> 2] = Math_imul(HEAP32[$9 + 52 >> 2], HEAP32[$9 + 152 >> 2]) - HEAP32[$9 + 136 >> 2];
           HEAP32[$9 + 32 >> 2] = Math_imul(HEAP32[$9 + 56 >> 2], HEAP32[$9 + 148 >> 2]) - HEAP32[$9 + 132 >> 2];
           HEAP32[$9 + 28 >> 2] = 0;
           HEAP32[$9 + 24 >> 2] = 0;
           while (1) {
            if (HEAP32[$9 + 24 >> 2] < HEAP32[$9 + 76 >> 2]) {
             HEAP32[$9 + 20 >> 2] = 0;
             while (1) {
              if (HEAP32[$9 + 20 >> 2] < HEAP32[$9 + 72 >> 2]) {
               HEAP32[$9 + 16 >> 2] = HEAP32[$9 + 36 >> 2] + Math_imul(HEAP32[$9 + 144 >> 2], HEAP32[$9 + 20 >> 2]);
               HEAP32[$9 + 12 >> 2] = HEAP32[$9 + 32 >> 2] + Math_imul(HEAP32[$9 + 140 >> 2], HEAP32[$9 + 24 >> 2]);
               if (!(HEAP32[$9 + 16 >> 2] < 0 | HEAP32[$9 + 16 >> 2] >= HEAP32[$9 + 84 >> 2] | (HEAP32[$9 + 12 >> 2] < 0 | HEAP32[$9 + 12 >> 2] >= HEAP32[$9 + 88 >> 2]))) {
                HEAP32[$9 + 8 >> 2] = HEAPU8[HEAP32[$9 + 180 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$9 + 184 >> 2], HEAP32[$9 + 60 >> 2], HEAP32[$9 + 12 >> 2], HEAP32[$9 + 16 >> 2], HEAP32[$9 + 48 >> 2]) | 0];
                HEAP32[$9 + 4 >> 2] = HEAPU8[HEAP32[$9 + 172 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$9 + 176 >> 2], 0, HEAP32[$9 + 24 >> 2], HEAP32[$9 + 20 >> 2], HEAP32[$9 + 40 >> 2]) | 0];
                HEAP32[$9 + 28 >> 2] = HEAP32[$9 + 28 >> 2] + Math_imul(HEAP32[$9 + 4 >> 2] + HEAP32[$9 + 112 >> 2] | 0, HEAP32[$9 + 8 >> 2] + HEAP32[$9 + 116 >> 2] | 0);
               }
               HEAP32[$9 + 20 >> 2] = HEAP32[$9 + 20 >> 2] + 1;
               continue;
              }
              break;
             }
             HEAP32[$9 + 24 >> 2] = HEAP32[$9 + 24 >> 2] + 1;
             continue;
            }
            break;
           }
           if (HEAP32[$9 + 164 >> 2]) {
            HEAP32[$9 + 28 >> 2] = HEAP32[HEAP32[$9 + 164 >> 2] + (HEAP32[$9 + 40 >> 2] << 2) >> 2] + HEAP32[$9 + 28 >> 2];
           }
           $0 = $9 + 28 | 0;
           $1 = $9 + 120 | 0;
           $2 = $9 + 124 | 0;
           HEAP32[$9 + 28 >> 2] = int_20tflite__reference_ops__depthwise_conv__DepthwiseConvRound__28tflite__DepthwiseConvOutputRounding_291__28int_2c_20int_2c_20int_29(HEAP32[$9 + 28 >> 2], HEAP32[$9 + 104 >> 2], HEAP32[$9 + 100 >> 2]);
           HEAP32[$9 + 28 >> 2] = HEAP32[$9 + 108 >> 2] + HEAP32[$9 + 28 >> 2];
           HEAP32[$9 + 28 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($0, $2) >> 2];
           HEAP32[$9 + 28 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($0, $1) >> 2];
           $0 = HEAP32[$9 + 28 >> 2];
           HEAP8[HEAP32[$9 + 156 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$9 + 160 >> 2], HEAP32[$9 + 60 >> 2], HEAP32[$9 + 56 >> 2], HEAP32[$9 + 52 >> 2], HEAP32[$9 + 40 >> 2]) | 0] = $0;
           HEAP32[$9 + 44 >> 2] = HEAP32[$9 + 44 >> 2] + 1;
           continue;
          }
          break;
         }
         HEAP32[$9 + 48 >> 2] = HEAP32[$9 + 48 >> 2] + 1;
         continue;
        }
        break;
       }
       HEAP32[$9 + 52 >> 2] = HEAP32[$9 + 52 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$9 + 56 >> 2] = HEAP32[$9 + 56 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$9 + 60 >> 2] = HEAP32[$9 + 60 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $9 + 192 | 0;
}
function tflite__reference_ops__Conv_28tflite__ConvParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__2c_20void__29($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10) {
 var $11 = 0;
 $11 = global$0 - 192 | 0;
 global$0 = $11;
 HEAP32[$11 + 188 >> 2] = $0;
 HEAP32[$11 + 184 >> 2] = $1;
 HEAP32[$11 + 180 >> 2] = $2;
 HEAP32[$11 + 176 >> 2] = $3;
 HEAP32[$11 + 172 >> 2] = $4;
 HEAP32[$11 + 168 >> 2] = $5;
 HEAP32[$11 + 164 >> 2] = $6;
 HEAP32[$11 + 160 >> 2] = $7;
 HEAP32[$11 + 156 >> 2] = $8;
 HEAP32[$11 + 152 >> 2] = $9;
 HEAP32[$11 + 148 >> 2] = $10;
 HEAP32[$11 + 144 >> 2] = 0;
 HEAP32[$11 + 140 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 10 >> 1];
 HEAP32[$11 + 136 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 12 >> 1];
 HEAP32[$11 + 132 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 14 >> 1];
 HEAP32[$11 + 128 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 16 >> 1];
 HEAP32[$11 + 124 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 2 >> 1];
 HEAP32[$11 + 120 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 4 >> 1];
 HEAP32[$11 + 116 >> 2] = HEAP32[HEAP32[$11 + 188 >> 2] + 20 >> 2];
 HEAP32[$11 + 112 >> 2] = HEAP32[HEAP32[$11 + 188 >> 2] + 24 >> 2];
 HEAP32[$11 + 108 >> 2] = HEAP32[HEAP32[$11 + 188 >> 2] + 28 >> 2];
 HEAP32[$11 + 104 >> 2] = HEAP32[HEAP32[$11 + 188 >> 2] + 32 >> 2];
 HEAP32[$11 + 100 >> 2] = HEAP32[HEAP32[$11 + 188 >> 2] + 36 >> 2];
 HEAP32[$11 + 96 >> 2] = HEAP32[HEAP32[$11 + 188 >> 2] + 40 >> 2];
 HEAP32[$11 + 92 >> 2] = HEAP32[HEAP32[$11 + 188 >> 2] + 44 >> 2];
 label$1 : {
  if (HEAP32[$11 + 96 >> 2] > HEAP32[$11 + 92 >> 2]) {
   break label$1;
  }
 }
 label$2 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$11 + 184 >> 2]) | 0) != 4) {
   break label$2;
  }
 }
 label$3 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$11 + 176 >> 2]) | 0) != 4) {
   break label$3;
  }
 }
 label$4 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$11 + 160 >> 2]) | 0) != 4) {
   break label$4;
  }
 }
 HEAP32[$11 + 88 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$11 + 184 >> 2], 0, HEAP32[$11 + 160 >> 2], 0);
 HEAP32[$11 + 84 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$11 + 184 >> 2], 3, HEAP32[$11 + 176 >> 2], 3);
 HEAP32[$11 + 80 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$11 + 176 >> 2], 0, HEAP32[$11 + 160 >> 2], 3);
 if (HEAP32[$11 + 164 >> 2]) {
  label$6 : {
   if ((tflite__RuntimeShape__FlatSize_28_29_20const(HEAP32[$11 + 168 >> 2]) | 0) != HEAP32[$11 + 80 >> 2]) {
    break label$6;
   }
  }
 }
 HEAP32[$11 + 76 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 184 >> 2], 1);
 HEAP32[$11 + 72 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 184 >> 2], 2);
 HEAP32[$11 + 68 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 176 >> 2], 1);
 HEAP32[$11 + 64 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 176 >> 2], 2);
 HEAP32[$11 + 60 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 160 >> 2], 1);
 HEAP32[$11 + 56 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 160 >> 2], 2);
 HEAP32[$11 + 52 >> 2] = 0;
 while (1) {
  if (HEAP32[$11 + 52 >> 2] < HEAP32[$11 + 88 >> 2]) {
   HEAP32[$11 + 48 >> 2] = 0;
   while (1) {
    if (HEAP32[$11 + 48 >> 2] < HEAP32[$11 + 60 >> 2]) {
     HEAP32[$11 + 44 >> 2] = 0;
     while (1) {
      if (HEAP32[$11 + 44 >> 2] < HEAP32[$11 + 56 >> 2]) {
       HEAP32[$11 + 40 >> 2] = 0;
       while (1) {
        if (HEAP32[$11 + 40 >> 2] < HEAP32[$11 + 80 >> 2]) {
         HEAP32[$11 + 36 >> 2] = Math_imul(HEAP32[$11 + 44 >> 2], HEAP32[$11 + 140 >> 2]) - HEAP32[$11 + 124 >> 2];
         HEAP32[$11 + 32 >> 2] = Math_imul(HEAP32[$11 + 48 >> 2], HEAP32[$11 + 136 >> 2]) - HEAP32[$11 + 120 >> 2];
         HEAP32[$11 + 28 >> 2] = 0;
         HEAP32[$11 + 24 >> 2] = 0;
         while (1) {
          if (HEAP32[$11 + 24 >> 2] < HEAP32[$11 + 68 >> 2]) {
           HEAP32[$11 + 20 >> 2] = 0;
           while (1) {
            if (HEAP32[$11 + 20 >> 2] < HEAP32[$11 + 64 >> 2]) {
             HEAP32[$11 + 16 >> 2] = 0;
             while (1) {
              if (HEAP32[$11 + 16 >> 2] < HEAP32[$11 + 84 >> 2]) {
               HEAP32[$11 + 12 >> 2] = HEAP32[$11 + 36 >> 2] + Math_imul(HEAP32[$11 + 132 >> 2], HEAP32[$11 + 20 >> 2]);
               HEAP32[$11 + 8 >> 2] = HEAP32[$11 + 32 >> 2] + Math_imul(HEAP32[$11 + 128 >> 2], HEAP32[$11 + 24 >> 2]);
               if (!(HEAP32[$11 + 12 >> 2] < 0 | HEAP32[$11 + 12 >> 2] >= HEAP32[$11 + 72 >> 2] | (HEAP32[$11 + 8 >> 2] < 0 | HEAP32[$11 + 8 >> 2] >= HEAP32[$11 + 76 >> 2]))) {
                HEAP32[$11 + 4 >> 2] = HEAPU8[HEAP32[$11 + 180 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$11 + 184 >> 2], HEAP32[$11 + 52 >> 2], HEAP32[$11 + 8 >> 2], HEAP32[$11 + 12 >> 2], HEAP32[$11 + 16 >> 2]) | 0];
                HEAP32[$11 >> 2] = HEAPU8[HEAP32[$11 + 172 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$11 + 176 >> 2], HEAP32[$11 + 40 >> 2], HEAP32[$11 + 24 >> 2], HEAP32[$11 + 20 >> 2], HEAP32[$11 + 16 >> 2]) | 0];
                HEAP32[$11 + 28 >> 2] = HEAP32[$11 + 28 >> 2] + Math_imul(HEAP32[$11 >> 2] + HEAP32[$11 + 112 >> 2] | 0, HEAP32[$11 + 4 >> 2] + HEAP32[$11 + 116 >> 2] | 0);
               }
               HEAP32[$11 + 16 >> 2] = HEAP32[$11 + 16 >> 2] + 1;
               continue;
              }
              break;
             }
             HEAP32[$11 + 20 >> 2] = HEAP32[$11 + 20 >> 2] + 1;
             continue;
            }
            break;
           }
           HEAP32[$11 + 24 >> 2] = HEAP32[$11 + 24 >> 2] + 1;
           continue;
          }
          break;
         }
         if (HEAP32[$11 + 164 >> 2]) {
          HEAP32[$11 + 28 >> 2] = HEAP32[HEAP32[$11 + 164 >> 2] + (HEAP32[$11 + 40 >> 2] << 2) >> 2] + HEAP32[$11 + 28 >> 2];
         }
         $0 = $11 + 28 | 0;
         $1 = $11 + 92 | 0;
         $2 = $11 + 96 | 0;
         HEAP32[$11 + 28 >> 2] = tflite__MultiplyByQuantizedMultiplier_28int_2c_20int_2c_20int_29(HEAP32[$11 + 28 >> 2], HEAP32[$11 + 104 >> 2], HEAP32[$11 + 100 >> 2]);
         HEAP32[$11 + 28 >> 2] = HEAP32[$11 + 108 >> 2] + HEAP32[$11 + 28 >> 2];
         HEAP32[$11 + 28 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($0, $2) >> 2];
         HEAP32[$11 + 28 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($0, $1) >> 2];
         $0 = HEAP32[$11 + 28 >> 2];
         HEAP8[HEAP32[$11 + 156 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$11 + 160 >> 2], HEAP32[$11 + 52 >> 2], HEAP32[$11 + 48 >> 2], HEAP32[$11 + 44 >> 2], HEAP32[$11 + 40 >> 2]) | 0] = $0;
         HEAP32[$11 + 40 >> 2] = HEAP32[$11 + 40 >> 2] + 1;
         continue;
        }
        break;
       }
       HEAP32[$11 + 44 >> 2] = HEAP32[$11 + 44 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$11 + 48 >> 2] = HEAP32[$11 + 48 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$11 + 52 >> 2] = HEAP32[$11 + 52 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $11 + 192 | 0;
}
function tflite__internal__InitializeTfLiteTensorFromFlatbuffer_28tflite__SimpleMemoryAllocator__2c_20bool_2c_20tflite__Tensor_20const__2c_20flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer__20__20const__2c_20tflite__ErrorReporter__2c_20TfLiteTensor__29($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = Math_fround(0), wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0, wasm2js_i32$3 = 0;
 $6 = global$0 - 128 | 0;
 global$0 = $6;
 HEAP32[$6 + 120 >> 2] = $0;
 HEAP8[$6 + 119 | 0] = $1;
 HEAP32[$6 + 112 >> 2] = $2;
 HEAP32[$6 + 108 >> 2] = $3;
 HEAP32[$6 + 104 >> 2] = $4;
 HEAP32[$6 + 100 >> 2] = $5;
 label$1 : {
  if (!HEAP32[$6 + 100 >> 2]) {
   break label$1;
  }
 }
 $1 = $6 + 56 | 0;
 $0 = $1;
 HEAP32[$0 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 32 >> 2] = 0;
 HEAP32[$0 + 36 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
 $4 = HEAP32[$0 + 4 >> 2];
 $2 = HEAP32[$6 + 100 >> 2];
 HEAP32[$2 >> 2] = HEAP32[$0 >> 2];
 HEAP32[$2 + 4 >> 2] = $4;
 $0 = HEAP32[$0 + 36 >> 2];
 HEAP32[$2 + 32 >> 2] = HEAP32[$1 + 32 >> 2];
 HEAP32[$2 + 36 >> 2] = $0;
 $0 = HEAP32[$1 + 28 >> 2];
 HEAP32[$2 + 24 >> 2] = HEAP32[$1 + 24 >> 2];
 HEAP32[$2 + 28 >> 2] = $0;
 $0 = HEAP32[$1 + 20 >> 2];
 HEAP32[$2 + 16 >> 2] = HEAP32[$1 + 16 >> 2];
 HEAP32[$2 + 20 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$2 + 8 >> 2] = HEAP32[$1 + 8 >> 2];
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$6 + 52 >> 2] = tflite__ConvertTensorType_28tflite__TensorType_2c_20TfLiteType__2c_20tflite__ErrorReporter__29(tflite__Tensor__type_28_29_20const(HEAP32[$6 + 112 >> 2]), HEAP32[$6 + 100 >> 2] + 28 | 0, HEAP32[$6 + 104 >> 2]);
 label$2 : {
  if (HEAP32[$6 + 52 >> 2]) {
   HEAP32[$6 + 124 >> 2] = HEAP32[$6 + 52 >> 2];
   break label$2;
  }
  $0 = tflite__Tensor__is_variable_28_29_20const(HEAP32[$6 + 112 >> 2]);
  HEAP8[HEAP32[$6 + 100 >> 2] + 36 | 0] = $0 & 1;
  $0 = tflite__internal__GetFlatbufferTensorBuffer_28tflite__Tensor_20const__2c_20flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer__20__20const__29(HEAP32[$6 + 112 >> 2], HEAP32[$6 + 108 >> 2]);
  HEAP32[HEAP32[$6 + 100 >> 2] + 16 >> 2] = $0;
  label$4 : {
   if (!HEAP32[HEAP32[$6 + 100 >> 2] + 16 >> 2]) {
    HEAP32[HEAP32[$6 + 100 >> 2] + 32 >> 2] = 2;
    break label$4;
   }
   HEAP32[HEAP32[$6 + 100 >> 2] + 32 >> 2] = 1;
  }
  HEAP32[$6 + 44 >> 2] = tflite__BytesRequiredForTensor_28tflite__Tensor_20const__2c_20unsigned_20long__2c_20unsigned_20long__2c_20tflite__ErrorReporter__29(HEAP32[$6 + 112 >> 2], HEAP32[$6 + 100 >> 2] + 24 | 0, $6 + 48 | 0, HEAP32[$6 + 104 >> 2]);
  if (HEAP32[$6 + 44 >> 2]) {
   HEAP32[$6 + 124 >> 2] = HEAP32[$6 + 44 >> 2];
   break label$2;
  }
  label$7 : {
   if (!tflite__Tensor__shape_28_29_20const(HEAP32[$6 + 112 >> 2])) {
    HEAP32[HEAP32[$6 + 100 >> 2] + 20 >> 2] = 131504;
    break label$7;
   }
   HEAP32[$6 + 40 >> 2] = TfLiteStatus_20tflite__internal__FlatBufferVectorToTfLiteTypeArray_int_2c_20TfLiteIntArray__28tflite__SimpleMemoryAllocator__2c_20tflite__ErrorReporter__2c_20flatbuffers__Vector_int__20const__2c_20TfLiteIntArray___29(HEAP32[$6 + 120 >> 2], HEAP32[$6 + 104 >> 2], tflite__Tensor__shape_28_29_20const(HEAP32[$6 + 112 >> 2]), HEAP32[$6 + 100 >> 2] + 20 | 0);
   if (HEAP32[$6 + 40 >> 2]) {
    HEAP32[$6 + 124 >> 2] = HEAP32[$6 + 40 >> 2];
    break label$2;
   }
  }
  HEAP32[$6 + 36 >> 2] = tflite__Tensor__quantization_28_29_20const(HEAP32[$6 + 112 >> 2]);
  label$10 : {
   if (!HEAP32[$6 + 36 >> 2]) {
    break label$10;
   }
   if (!tflite__Model__subgraphs_28_29_20const(HEAP32[$6 + 36 >> 2])) {
    break label$10;
   }
   if (flatbuffers__Vector_int___size_28_29_20const(tflite__Model__subgraphs_28_29_20const(HEAP32[$6 + 36 >> 2])) >>> 0 <= 0) {
    break label$10;
   }
   if (!tflite__SubGraph__operators_28_29_20const(HEAP32[$6 + 36 >> 2])) {
    break label$10;
   }
   if (flatbuffers__Vector_int___size_28_29_20const(tflite__SubGraph__operators_28_29_20const(HEAP32[$6 + 36 >> 2])) >>> 0 <= 0) {
    break label$10;
   }
   $7 = flatbuffers__Vector_float___Get_28unsigned_20int_29_20const(tflite__Model__subgraphs_28_29_20const(HEAP32[$6 + 36 >> 2]));
   HEAPF32[HEAP32[$6 + 100 >> 2] + 8 >> 2] = $7;
   $0 = flatbuffers__Vector_long_20long___Get_28unsigned_20int_29_20const(tflite__SubGraph__operators_28_29_20const(HEAP32[$6 + 36 >> 2]), 0);
   HEAP32[HEAP32[$6 + 100 >> 2] + 12 >> 2] = $0;
   HEAP32[$6 + 32 >> 2] = flatbuffers__Vector_int___size_28_29_20const(tflite__Model__subgraphs_28_29_20const(HEAP32[$6 + 36 >> 2]));
   $0 = $6;
   label$11 : {
    if (HEAP8[$6 + 119 | 0] & 1) {
     $1 = HEAP32[$6 + 120 >> 2];
     $1 = FUNCTION_TABLE[HEAP32[HEAP32[$1 >> 2] + 16 >> 2]]($1, 12, 4) | 0;
     break label$11;
    }
    $1 = HEAP32[$6 + 120 >> 2];
    $1 = FUNCTION_TABLE[HEAP32[HEAP32[$1 >> 2] + 12 >> 2]]($1, 12, 4) | 0;
   }
   HEAP32[$0 + 28 >> 2] = $1;
   if (!HEAP32[$6 + 28 >> 2]) {
    tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$6 + 104 >> 2], 131508, 0);
    HEAP32[$6 + 124 >> 2] = 1;
    break label$2;
   }
   label$14 : {
    if (HEAP8[$6 + 119 | 0] & 1) {
     $0 = HEAP32[$6 + 120 >> 2];
     $0 = (wasm2js_i32$1 = $0, wasm2js_i32$2 = TfLiteIntArrayGetSizeInBytes(HEAP32[$6 + 32 >> 2]), wasm2js_i32$3 = 4, wasm2js_i32$0 = HEAP32[HEAP32[$0 >> 2] + 16 >> 2], FUNCTION_TABLE[wasm2js_i32$0](wasm2js_i32$1 | 0, wasm2js_i32$2 | 0, wasm2js_i32$3 | 0) | 0);
     break label$14;
    }
    $0 = HEAP32[$6 + 120 >> 2];
    $0 = (wasm2js_i32$3 = $0, wasm2js_i32$2 = TfLiteIntArrayGetSizeInBytes(HEAP32[$6 + 32 >> 2]), wasm2js_i32$1 = 4, wasm2js_i32$0 = HEAP32[HEAP32[$0 >> 2] + 12 >> 2], FUNCTION_TABLE[wasm2js_i32$0](wasm2js_i32$3 | 0, wasm2js_i32$2 | 0, wasm2js_i32$1 | 0) | 0);
   }
   HEAP32[HEAP32[$6 + 28 >> 2] + 4 >> 2] = $0;
   if (!HEAP32[HEAP32[$6 + 28 >> 2] + 4 >> 2]) {
    tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$6 + 104 >> 2], 131554, 0);
    HEAP32[$6 + 124 >> 2] = 1;
    break label$2;
   }
   HEAP32[$6 + 24 >> 2] = TfLiteStatus_20tflite__internal__FlatBufferVectorToTfLiteTypeArray_int_2c_20TfLiteIntArray__28tflite__SimpleMemoryAllocator__2c_20tflite__ErrorReporter__2c_20flatbuffers__Vector_int__20const__2c_20TfLiteIntArray___29(HEAP32[$6 + 120 >> 2], HEAP32[$6 + 104 >> 2], tflite__Model__subgraphs_28_29_20const(HEAP32[$6 + 36 >> 2]), HEAP32[$6 + 28 >> 2]);
   if (HEAP32[$6 + 24 >> 2]) {
    HEAP32[$6 + 124 >> 2] = HEAP32[$6 + 24 >> 2];
    break label$2;
   }
   HEAP32[HEAP32[HEAP32[$6 + 28 >> 2] + 4 >> 2] >> 2] = HEAP32[$6 + 32 >> 2];
   HEAP32[$6 + 20 >> 2] = HEAP32[HEAP32[$6 + 28 >> 2] + 4 >> 2] + 4;
   HEAP32[$6 + 16 >> 2] = 0;
   while (1) {
    if (HEAP32[$6 + 16 >> 2] < HEAP32[$6 + 32 >> 2]) {
     $0 = flatbuffers__Vector_long_20long___Get_28unsigned_20int_29_20const(tflite__SubGraph__operators_28_29_20const(HEAP32[$6 + 36 >> 2]), HEAP32[$6 + 16 >> 2]);
     HEAP32[HEAP32[$6 + 20 >> 2] + (HEAP32[$6 + 16 >> 2] << 2) >> 2] = $0;
     HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 16 >> 2] + 1;
     continue;
    }
    break;
   }
   $0 = $6 + 8 | 0;
   $1 = tflite__QuantizationParameters__quantized_dimension_28_29_20const(HEAP32[$6 + 36 >> 2]);
   HEAP32[HEAP32[$6 + 28 >> 2] + 8 >> 2] = $1;
   HEAP32[$6 + 8 >> 2] = 1;
   HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 28 >> 2];
   $2 = HEAP32[$0 + 4 >> 2];
   $1 = HEAP32[$6 + 100 >> 2];
   HEAP32[$1 >> 2] = HEAP32[$0 >> 2];
   HEAP32[$1 + 4 >> 2] = $2;
  }
  HEAP32[$6 + 124 >> 2] = 0;
 }
 global$0 = $6 + 128 | 0;
 return HEAP32[$6 + 124 >> 2];
}
function jsiDumpState($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $2 = global$0 - 272 | 0;
 global$0 = $2;
 HEAP32[$2 + 268 >> 2] = $0;
 HEAP32[$2 + 264 >> 2] = $1;
 jsvObjectIteratorNew($2 + 256 | 0, HEAP32[80545]);
 while (1) {
  if (jsvObjectIteratorHasValue($2 + 256 | 0) & 1) {
   $0 = $2 + 176 | 0;
   $1 = $2 + 256 | 0;
   HEAP32[$2 + 252 >> 2] = jsvObjectIteratorGetKey($1);
   HEAP32[$2 + 248 >> 2] = jsvObjectIteratorGetValue($1);
   jsvGetString(HEAP32[$2 + 252 >> 2], $0, 64);
   HEAP8[$2 + 175 | 0] = 0;
   HEAP32[$2 + 168 >> 2] = 82053;
   while (1) {
    if (HEAPU8[HEAP32[$2 + 168 >> 2]]) {
     if (!strcmp(HEAP32[$2 + 168 >> 2], $2 + 176 | 0)) {
      HEAP8[$2 + 175 | 0] = 1;
     }
     HEAP32[$2 + 168 >> 2] = (strlen(HEAP32[$2 + 168 >> 2]) + 1 | 0) + HEAP32[$2 + 168 >> 2];
     continue;
    }
    break;
   }
   if (!(HEAP8[$2 + 175 | 0] & 1)) {
    label$7 : {
     if (jswIsBuiltInObject($2 + 176 | 0) & 1) {
      jsiDumpObjectState(HEAP32[$2 + 268 >> 2], HEAP32[$2 + 264 >> 2], HEAP32[$2 + 252 >> 2], HEAP32[$2 + 248 >> 2]);
      break label$7;
     }
     if (!(jsvIsStringEqualOrStartsWith(HEAP32[$2 + 252 >> 2], 81166, 1) & 1)) {
      if (!(jsvIsStringEqual(HEAP32[$2 + 252 >> 2], 81074) & 1)) {
       if (!(jsvIsStringEqual(HEAP32[$2 + 252 >> 2], 81081) & 1)) {
        label$12 : {
         if (HEAP8[HEAP32[$2 + 252 >> 2]] == -1) {
          break label$12;
         }
         if (jshFromDeviceString($2 + 176 | 0) & 255) {
          break label$12;
         }
         if (!(jsvIsNative(HEAP32[$2 + 248 >> 2]) & 1)) {
          label$15 : {
           if (jsvIsFunction(HEAP32[$2 + 248 >> 2]) & 1) {
            $0 = HEAP32[$2 + 268 >> 2];
            $1 = HEAP32[$2 + 264 >> 2];
            HEAP32[$2 >> 2] = HEAP32[$2 + 252 >> 2];
            cbprintf($0, $1, 82056, $2);
            jsfGetJSONForFunctionWithCallback(HEAP32[$2 + 248 >> 2], 32, HEAP32[$2 + 268 >> 2], HEAP32[$2 + 264 >> 2]);
            FUNCTION_TABLE[HEAP32[$2 + 268 >> 2]](81553, HEAP32[$2 + 264 >> 2]);
            jsiDumpObjectState(HEAP32[$2 + 268 >> 2], HEAP32[$2 + 264 >> 2], HEAP32[$2 + 252 >> 2], HEAP32[$2 + 248 >> 2]);
            break label$15;
           }
           $0 = HEAP32[$2 + 268 >> 2];
           $1 = HEAP32[$2 + 264 >> 2];
           HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 252 >> 2];
           cbprintf($0, $1, 82068, $2 + 32 | 0);
           HEAP8[$2 + 167 | 0] = 0;
           if (jsvIsObject(HEAP32[$2 + 248 >> 2]) & 1) {
            HEAP32[$2 + 160 >> 2] = jsvObjectGetChild(HEAP32[$2 + 248 >> 2], 82078, 0);
            if (HEAP32[$2 + 160 >> 2]) {
             HEAP32[$2 + 156 >> 2] = jsvGetPathTo(HEAP32[80545], HEAP32[$2 + 160 >> 2], HEAP32[$2 + 248 >> 2]);
             if (HEAP32[$2 + 156 >> 2]) {
              $0 = HEAP32[$2 + 268 >> 2];
              $1 = HEAP32[$2 + 264 >> 2];
              HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 156 >> 2];
              cbprintf($0, $1, 82088, $2 + 16 | 0);
              jsiDumpObjectState(HEAP32[$2 + 268 >> 2], HEAP32[$2 + 264 >> 2], HEAP32[$2 + 252 >> 2], HEAP32[$2 + 248 >> 2]);
              HEAP8[$2 + 167 | 0] = 1;
             }
            }
           }
           if (!(HEAP8[$2 + 167 | 0] & 1)) {
            jsiDumpJSON(HEAP32[$2 + 268 >> 2], HEAP32[$2 + 264 >> 2], HEAP32[$2 + 248 >> 2], HEAP32[$2 + 252 >> 2]);
            FUNCTION_TABLE[HEAP32[$2 + 268 >> 2]](81179, HEAP32[$2 + 264 >> 2]);
           }
          }
         }
        }
       }
      }
     }
    }
   }
   $0 = $2 + 256 | 0;
   jsvUnLock2(HEAP32[$2 + 248 >> 2], HEAP32[$2 + 252 >> 2]);
   jsvObjectIteratorNext($0);
   continue;
  }
  break;
 }
 $0 = $2 + 256 | 0;
 jsvObjectIteratorFree($0);
 HEAP32[$2 + 152 >> 2] = jsvLock(HEAPU16[161110]);
 jsvObjectIteratorNew($0, HEAP32[$2 + 152 >> 2]);
 jsvUnLock(HEAP32[$2 + 152 >> 2]);
 while (1) {
  if (jsvObjectIteratorHasValue($2 + 256 | 0) & 1) {
   $0 = $2 + 256 | 0;
   HEAP32[$2 + 148 >> 2] = jsvObjectIteratorGetValue($0);
   HEAP32[$2 + 144 >> 2] = jsvObjectIteratorGetKey($0);
   HEAP32[$2 + 140 >> 2] = jsvSkipOneNameAndUnLock(jsvFindChildFromString(HEAP32[$2 + 148 >> 2], 81908, 0));
   HEAP32[$2 + 136 >> 2] = jsvObjectGetChild(HEAP32[$2 + 148 >> 2], 81982, 0);
   FUNCTION_TABLE[HEAP32[$2 + 268 >> 2]](HEAP32[$2 + 136 >> 2] ? 82108 : 82121, HEAP32[$2 + 264 >> 2]);
   jsiDumpJSON(HEAP32[$2 + 268 >> 2], HEAP32[$2 + 264 >> 2], HEAP32[$2 + 140 >> 2], 0);
   $3 = HEAP32[$2 + 268 >> 2];
   $4 = HEAP32[$2 + 264 >> 2];
   label$23 : {
    if (HEAP32[$2 + 136 >> 2]) {
     $0 = jsvGetLongInteger(HEAP32[$2 + 136 >> 2]);
     $1 = i64toi32_i32$HIGH_BITS;
     break label$23;
    }
    $0 = jsvGetLongIntegerAndUnLock(jsvObjectGetChild(HEAP32[$2 + 148 >> 2], 81897, 0));
    $1 = i64toi32_i32$HIGH_BITS;
   }
   $6 = jshGetMillisecondsFromTime($0, $1);
   HEAP32[$2 + 56 >> 2] = HEAP32[$2 + 144 >> 2];
   HEAPF64[$2 + 48 >> 3] = $6;
   cbprintf($3, $4, 82133, $2 + 48 | 0);
   $0 = $2 + 256 | 0;
   jsvUnLock3(HEAP32[$2 + 136 >> 2], HEAP32[$2 + 140 >> 2], HEAP32[$2 + 144 >> 2]);
   jsvUnLock(HEAP32[$2 + 148 >> 2]);
   jsvObjectIteratorNext($0);
   continue;
  }
  break;
 }
 $0 = $2 + 256 | 0;
 jsvObjectIteratorFree($0);
 HEAP32[$2 + 132 >> 2] = jsvLock(HEAPU16[161111]);
 jsvObjectIteratorNew($0, HEAP32[$2 + 132 >> 2]);
 jsvUnLock(HEAP32[$2 + 132 >> 2]);
 while (1) {
  if (jsvObjectIteratorHasValue($2 + 256 | 0) & 1) {
   HEAP32[$2 + 128 >> 2] = jsvObjectIteratorGetValue($2 + 256 | 0);
   HEAP32[$2 + 124 >> 2] = jsvSkipOneNameAndUnLock(jsvFindChildFromString(HEAP32[$2 + 128 >> 2], 81908, 0));
   HEAP8[$2 + 123 | 0] = jsvGetBoolAndUnLock(jsvObjectGetChild(HEAP32[$2 + 128 >> 2], 81926, 0)) & 1;
   HEAP32[$2 + 116 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$2 + 128 >> 2], 81848, 0));
   HEAP32[$2 + 112 >> 2] = jsvObjectGetChild(HEAP32[$2 + 128 >> 2], 81100, 0);
   HEAP32[$2 + 108 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$2 + 128 >> 2], 81874, 0));
   FUNCTION_TABLE[HEAP32[$2 + 268 >> 2]](82147, HEAP32[$2 + 264 >> 2]);
   jsiDumpJSON(HEAP32[$2 + 268 >> 2], HEAP32[$2 + 264 >> 2], HEAP32[$2 + 124 >> 2], 0);
   $3 = HEAP32[$2 + 268 >> 2];
   $4 = HEAP32[$2 + 264 >> 2];
   $0 = HEAP32[$2 + 112 >> 2];
   $1 = HEAP8[$2 + 123 | 0] & 1 ? 82186 : 82191;
   $7 = $2;
   if (HEAP32[$2 + 116 >> 2] < 0) {
    $5 = 82197;
   } else {
    $5 = HEAP32[$2 + 116 >> 2] > 0 ? 82205 : 82212;
   }
   HEAP32[$7 + 88 >> 2] = $5;
   HEAP32[$2 + 84 >> 2] = $1;
   HEAP32[$2 + 80 >> 2] = $0;
   cbprintf($3, $4, 82157, $2 + 80 | 0);
   if (HEAP32[$2 + 108 >> 2] > 0) {
    $0 = HEAP32[$2 + 268 >> 2];
    $1 = HEAP32[$2 + 264 >> 2];
    $3 = HEAP32[$2 + 108 >> 2];
    HEAPF64[$2 + 64 >> 3] = jshGetMillisecondsFromTime($3, $3 >> 31);
    cbprintf($0, $1, 82217, $2 - -64 | 0);
   }
   $0 = $2 + 256 | 0;
   FUNCTION_TABLE[HEAP32[$2 + 268 >> 2]](82233, HEAP32[$2 + 264 >> 2]);
   jsvUnLock2(HEAP32[$2 + 112 >> 2], HEAP32[$2 + 124 >> 2]);
   jsvUnLock(HEAP32[$2 + 128 >> 2]);
   jsvObjectIteratorNext($0);
   continue;
  }
  break;
 }
 jsvObjectIteratorFree($2 + 256 | 0);
 jsiDumpHardwareInitialisation(HEAP32[$2 + 268 >> 2], HEAP32[$2 + 264 >> 2], 1);
 HEAP32[$2 + 104 >> 2] = jsfGetBootCodeFromFlash(0);
 if (HEAP32[$2 + 104 >> 2]) {
  cbprintf(HEAP32[$2 + 268 >> 2], HEAP32[$2 + 264 >> 2], 82239, 0);
  jslPrintTokenisedString(HEAP32[$2 + 104 >> 2], HEAP32[$2 + 268 >> 2], HEAP32[$2 + 264 >> 2]);
  jsvUnLock(HEAP32[$2 + 104 >> 2]);
 }
 global$0 = $2 + 272 | 0;
}
function __rem_pio2_large($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0;
 $7 = global$0 - 560 | 0;
 global$0 = $7;
 $5 = $2;
 $2 = ($2 + -3 | 0) / 24 | 0;
 $16 = ($2 | 0) > 0 ? $2 : 0;
 $12 = $5 + Math_imul($16, -24) | 0;
 $11 = HEAP32[34665];
 $8 = $3 + -1 | 0;
 if (($11 + $8 | 0) >= 0) {
  $5 = $3 + $11 | 0;
  $2 = $16 - $8 | 0;
  while (1) {
   HEAPF64[($7 + 320 | 0) + ($6 << 3) >> 3] = ($2 | 0) < 0 ? 0 : +HEAP32[($2 << 2) + 138672 >> 2];
   $2 = $2 + 1 | 0;
   $6 = $6 + 1 | 0;
   if (($5 | 0) != ($6 | 0)) {
    continue;
   }
   break;
  }
 }
 $10 = $12 + -24 | 0;
 $5 = 0;
 $6 = ($3 | 0) < 1;
 while (1) {
  label$6 : {
   if ($6) {
    $4 = 0;
    break label$6;
   }
   $9 = $5 + $8 | 0;
   $2 = 0;
   $4 = 0;
   while (1) {
    $4 = $4 + HEAPF64[($2 << 3) + $0 >> 3] * HEAPF64[($7 + 320 | 0) + ($9 - $2 << 3) >> 3];
    $2 = $2 + 1 | 0;
    if (($3 | 0) != ($2 | 0)) {
     continue;
    }
    break;
   }
  }
  HEAPF64[($5 << 3) + $7 >> 3] = $4;
  $2 = ($5 | 0) < ($11 | 0);
  $5 = $5 + 1 | 0;
  if ($2) {
   continue;
  }
  break;
 }
 $20 = 23 - $10 | 0;
 $17 = 24 - $10 | 0;
 $5 = $11;
 label$9 : {
  while (1) {
   $4 = HEAPF64[($5 << 3) + $7 >> 3];
   $2 = 0;
   $6 = $5;
   $14 = ($5 | 0) < 1;
   if (!$14) {
    while (1) {
     $8 = ($7 + 480 | 0) + ($2 << 2) | 0;
     $13 = $4;
     $4 = $4 * 5.960464477539063e-8;
     label$14 : {
      if (Math_abs($4) < 2147483648) {
       $9 = ~~$4;
       break label$14;
      }
      $9 = -2147483648;
     }
     $4 = +($9 | 0);
     $13 = $13 + $4 * -16777216;
     label$13 : {
      if (Math_abs($13) < 2147483648) {
       $9 = ~~$13;
       break label$13;
      }
      $9 = -2147483648;
     }
     HEAP32[$8 >> 2] = $9;
     $6 = $6 + -1 | 0;
     $4 = HEAPF64[($6 << 3) + $7 >> 3] + $4;
     $2 = $2 + 1 | 0;
     if (($5 | 0) != ($2 | 0)) {
      continue;
     }
     break;
    }
   }
   $4 = scalbn($4, $10);
   $4 = $4 + Math_floor($4 * .125) * -8;
   label$17 : {
    if (Math_abs($4) < 2147483648) {
     $9 = ~~$4;
     break label$17;
    }
    $9 = -2147483648;
   }
   $4 = $4 - +($9 | 0);
   label$19 : {
    label$20 : {
     label$21 : {
      $18 = ($10 | 0) < 1;
      label$22 : {
       if (!$18) {
        $6 = ($5 << 2) + $7 | 0;
        $8 = HEAP32[$6 + 476 >> 2];
        $2 = $8 >> $17;
        $15 = $6;
        $6 = $8 - ($2 << $17) | 0;
        HEAP32[$15 + 476 >> 2] = $6;
        $9 = $2 + $9 | 0;
        $8 = $6 >> $20;
        break label$22;
       }
       if ($10) {
        break label$21;
       }
       $8 = HEAP32[(($5 << 2) + $7 | 0) + 476 >> 2] >> 23;
      }
      if (($8 | 0) < 1) {
       break label$19;
      }
      break label$20;
     }
     $8 = 2;
     if (!!($4 >= .5)) {
      break label$20;
     }
     $8 = 0;
     break label$19;
    }
    $2 = 0;
    $6 = 0;
    if (!$14) {
     while (1) {
      $19 = ($7 + 480 | 0) + ($2 << 2) | 0;
      $14 = HEAP32[$19 >> 2];
      $15 = 16777215;
      label$26 : {
       label$27 : {
        if (!$6) {
         if (!$14) {
          break label$27;
         }
         $15 = 16777216;
         $6 = 1;
        }
        HEAP32[$19 >> 2] = $15 - $14;
        break label$26;
       }
       $6 = 0;
      }
      $2 = $2 + 1 | 0;
      if (($5 | 0) != ($2 | 0)) {
       continue;
      }
      break;
     }
    }
    label$29 : {
     if ($18) {
      break label$29;
     }
     $2 = $10 + -1 | 0;
     if ($2 >>> 0 > 1) {
      break label$29;
     }
     if ($2 - 1) {
      $2 = ($5 << 2) + $7 | 0;
      HEAP32[$2 + 476 >> 2] = HEAP32[$2 + 476 >> 2] & 8388607;
      break label$29;
     }
     $2 = ($5 << 2) + $7 | 0;
     HEAP32[$2 + 476 >> 2] = HEAP32[$2 + 476 >> 2] & 4194303;
    }
    $9 = $9 + 1 | 0;
    if (($8 | 0) != 2) {
     break label$19;
    }
    $4 = 1 - $4;
    $8 = 2;
    if (!$6) {
     break label$19;
    }
    $4 = $4 - scalbn(1, $10);
   }
   if ($4 == 0) {
    $6 = 0;
    label$32 : {
     $2 = $5;
     if (($2 | 0) <= ($11 | 0)) {
      break label$32;
     }
     while (1) {
      $2 = $2 + -1 | 0;
      $6 = HEAP32[($7 + 480 | 0) + ($2 << 2) >> 2] | $6;
      if (($2 | 0) > ($11 | 0)) {
       continue;
      }
      break;
     }
     if (!$6) {
      break label$32;
     }
     $12 = $10;
     while (1) {
      $12 = $12 + -24 | 0;
      $5 = $5 + -1 | 0;
      if (!HEAP32[($7 + 480 | 0) + ($5 << 2) >> 2]) {
       continue;
      }
      break;
     }
     break label$9;
    }
    $2 = 1;
    while (1) {
     $6 = $2;
     $2 = $2 + 1 | 0;
     if (!HEAP32[($7 + 480 | 0) + ($11 - $6 << 2) >> 2]) {
      continue;
     }
     break;
    }
    $6 = $5 + $6 | 0;
    while (1) {
     $8 = $3 + $5 | 0;
     $5 = $5 + 1 | 0;
     HEAPF64[($7 + 320 | 0) + ($8 << 3) >> 3] = HEAP32[($16 + $5 << 2) + 138672 >> 2];
     $2 = 0;
     $4 = 0;
     if (($3 | 0) >= 1) {
      while (1) {
       $4 = $4 + HEAPF64[($2 << 3) + $0 >> 3] * HEAPF64[($7 + 320 | 0) + ($8 - $2 << 3) >> 3];
       $2 = $2 + 1 | 0;
       if (($3 | 0) != ($2 | 0)) {
        continue;
       }
       break;
      }
     }
     HEAPF64[($5 << 3) + $7 >> 3] = $4;
     if (($5 | 0) < ($6 | 0)) {
      continue;
     }
     break;
    }
    $5 = $6;
    continue;
   }
   break;
  }
  $4 = scalbn($4, 0 - $10 | 0);
  label$39 : {
   if (!!($4 >= 16777216)) {
    $0 = ($7 + 480 | 0) + ($5 << 2) | 0;
    $13 = $4;
    $4 = $4 * 5.960464477539063e-8;
    label$42 : {
     if (Math_abs($4) < 2147483648) {
      $2 = ~~$4;
      break label$42;
     }
     $2 = -2147483648;
    }
    $4 = $13 + +($2 | 0) * -16777216;
    label$41 : {
     if (Math_abs($4) < 2147483648) {
      $3 = ~~$4;
      break label$41;
     }
     $3 = -2147483648;
    }
    HEAP32[$0 >> 2] = $3;
    $5 = $5 + 1 | 0;
    break label$39;
   }
   if (Math_abs($4) < 2147483648) {
    $2 = ~~$4;
   } else {
    $2 = -2147483648;
   }
   $12 = $10;
  }
  HEAP32[($7 + 480 | 0) + ($5 << 2) >> 2] = $2;
 }
 $4 = scalbn(1, $12);
 label$47 : {
  if (($5 | 0) <= -1) {
   break label$47;
  }
  $2 = $5;
  while (1) {
   HEAPF64[($2 << 3) + $7 >> 3] = $4 * +HEAP32[($7 + 480 | 0) + ($2 << 2) >> 2];
   $4 = $4 * 5.960464477539063e-8;
   $0 = ($2 | 0) > 0;
   $2 = $2 + -1 | 0;
   if ($0) {
    continue;
   }
   break;
  }
  if (($5 | 0) <= -1) {
   break label$47;
  }
  $2 = $5;
  while (1) {
   $0 = $2;
   $3 = $5 - $2 | 0;
   $4 = 0;
   $2 = 0;
   while (1) {
    $4 = $4 + HEAPF64[($2 << 3) + 141440 >> 3] * HEAPF64[($0 + $2 << 3) + $7 >> 3];
    label$51 : {
     if (($2 | 0) >= ($11 | 0)) {
      break label$51;
     }
     $10 = $2 >>> 0 < $3 >>> 0;
     $2 = $2 + 1 | 0;
     if ($10) {
      continue;
     }
    }
    break;
   }
   HEAPF64[($7 + 160 | 0) + ($3 << 3) >> 3] = $4;
   $2 = $0 + -1 | 0;
   if (($0 | 0) > 0) {
    continue;
   }
   break;
  }
 }
 $4 = 0;
 if (($5 | 0) >= 0) {
  $2 = $5;
  while (1) {
   $4 = $4 + HEAPF64[($7 + 160 | 0) + ($2 << 3) >> 3];
   $0 = ($2 | 0) > 0;
   $2 = $2 + -1 | 0;
   if ($0) {
    continue;
   }
   break;
  }
 }
 HEAPF64[$1 >> 3] = $8 ? -$4 : $4;
 $4 = HEAPF64[$7 + 160 >> 3] - $4;
 $2 = 1;
 if (($5 | 0) >= 1) {
  while (1) {
   $4 = $4 + HEAPF64[($7 + 160 | 0) + ($2 << 3) >> 3];
   $0 = ($2 | 0) != ($5 | 0);
   $2 = $2 + 1 | 0;
   if ($0) {
    continue;
   }
   break;
  }
 }
 HEAPF64[$1 + 8 >> 3] = $8 ? -$4 : $4;
 global$0 = $7 + 560 | 0;
 return $9 & 7;
}
function tflite__PopulateConvolutionQuantizationParams_28TfLiteContext__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor__2c_20TfLiteFusedActivation_20const__2c_20int__2c_20int__2c_20int__2c_20int__2c_20int__2c_20int__2c_20int_29($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12) {
 var $13 = 0, $14 = Math_fround(0);
 $13 = global$0 - 336 | 0;
 global$0 = $13;
 HEAP32[$13 + 328 >> 2] = $0;
 HEAP32[$13 + 324 >> 2] = $1;
 HEAP32[$13 + 320 >> 2] = $2;
 HEAP32[$13 + 316 >> 2] = $3;
 HEAP32[$13 + 312 >> 2] = $4;
 HEAP32[$13 + 308 >> 2] = $5;
 HEAP32[$13 + 304 >> 2] = $6;
 HEAP32[$13 + 300 >> 2] = $7;
 HEAP32[$13 + 296 >> 2] = $8;
 HEAP32[$13 + 292 >> 2] = $9;
 HEAP32[$13 + 288 >> 2] = $10;
 HEAP32[$13 + 284 >> 2] = $11;
 HEAP32[$13 + 280 >> 2] = $12;
 label$1 : {
  if (HEAP32[HEAP32[$13 + 324 >> 2] >> 2] != 1) {
   $0 = HEAP32[HEAP32[$13 + 328 >> 2] + 20 >> 2];
   $1 = HEAP32[$13 + 328 >> 2];
   $2 = HEAP32[HEAP32[$13 + 324 >> 2] >> 2];
   HEAP32[$13 + 20 >> 2] = 1;
   HEAP32[$13 + 16 >> 2] = $2;
   HEAP32[$13 + 12 >> 2] = 137241;
   HEAP32[$13 + 8 >> 2] = 137216;
   HEAP32[$13 + 4 >> 2] = 97;
   HEAP32[$13 >> 2] = 137133;
   FUNCTION_TABLE[$0]($1, 137107, $13);
   HEAP32[$13 + 332 >> 2] = 1;
   break label$1;
  }
  if (HEAP32[HEAP32[$13 + 320 >> 2] >> 2] != 1) {
   $0 = HEAP32[HEAP32[$13 + 328 >> 2] + 20 >> 2];
   $1 = HEAP32[$13 + 328 >> 2];
   $2 = HEAP32[HEAP32[$13 + 320 >> 2] >> 2];
   HEAP32[$13 + 52 >> 2] = 1;
   HEAP32[$13 + 48 >> 2] = $2;
   HEAP32[$13 + 44 >> 2] = 137241;
   HEAP32[$13 + 40 >> 2] = 137267;
   HEAP32[$13 + 36 >> 2] = 99;
   HEAP32[$13 + 32 >> 2] = 137133;
   FUNCTION_TABLE[$0]($1, 137107, $13 + 32 | 0);
   HEAP32[$13 + 332 >> 2] = 1;
   break label$1;
  }
  HEAP32[$13 + 276 >> 2] = HEAP32[HEAP32[$13 + 320 >> 2] + 4 >> 2];
  if (!HEAP32[$13 + 276 >> 2]) {
   $0 = HEAP32[HEAP32[$13 + 328 >> 2] + 20 >> 2];
   $1 = HEAP32[$13 + 328 >> 2];
   HEAP32[$13 + 200 >> 2] = 137316;
   HEAP32[$13 + 196 >> 2] = 109;
   HEAP32[$13 + 192 >> 2] = 137133;
   FUNCTION_TABLE[$0]($1, 137293, $13 + 192 | 0);
   HEAP32[$13 + 332 >> 2] = 1;
   break label$1;
  }
  if (!HEAP32[HEAP32[$13 + 276 >> 2] >> 2]) {
   $0 = HEAP32[HEAP32[$13 + 328 >> 2] + 20 >> 2];
   $1 = HEAP32[$13 + 328 >> 2];
   HEAP32[$13 + 184 >> 2] = 137336;
   HEAP32[$13 + 180 >> 2] = 110;
   HEAP32[$13 + 176 >> 2] = 137133;
   FUNCTION_TABLE[$0]($1, 137293, $13 + 176 | 0);
   HEAP32[$13 + 332 >> 2] = 1;
   break label$1;
  }
  HEAP8[$13 + 275 | 0] = HEAP32[HEAP32[HEAP32[$13 + 276 >> 2] >> 2] >> 2] > 1;
  if (HEAP8[$13 + 275 | 0] & 1) {
   if (!(HEAP32[HEAP32[$13 + 324 >> 2] + 28 >> 2] == 9 | HEAP32[HEAP32[$13 + 324 >> 2] + 28 >> 2] == 7)) {
    $0 = HEAP32[HEAP32[$13 + 328 >> 2] + 20 >> 2];
    $1 = HEAP32[$13 + 328 >> 2];
    HEAP32[$13 + 168 >> 2] = 137363;
    HEAP32[$13 + 164 >> 2] = 115;
    HEAP32[$13 + 160 >> 2] = 137133;
    FUNCTION_TABLE[$0]($1, 137293, $13 + 160 | 0);
    HEAP32[$13 + 332 >> 2] = 1;
    break label$1;
   }
   if (HEAP32[HEAP32[$13 + 320 >> 2] + 28 >> 2] != 9) {
    $0 = HEAP32[HEAP32[$13 + 328 >> 2] + 20 >> 2];
    $1 = HEAP32[$13 + 328 >> 2];
    $2 = HEAP32[HEAP32[$13 + 320 >> 2] + 28 >> 2];
    HEAP32[$13 + 84 >> 2] = 9;
    HEAP32[$13 + 80 >> 2] = $2;
    HEAP32[$13 + 76 >> 2] = 137434;
    HEAP32[$13 + 72 >> 2] = 137421;
    HEAP32[$13 + 68 >> 2] = 116;
    HEAP32[$13 + 64 >> 2] = 137133;
    FUNCTION_TABLE[$0]($1, 137107, $13 - -64 | 0);
    HEAP32[$13 + 332 >> 2] = 1;
    break label$1;
   }
   if (HEAP32[HEAP32[HEAP32[$13 + 276 >> 2] >> 2] >> 2] != HEAP32[$13 + 280 >> 2]) {
    $0 = HEAP32[HEAP32[$13 + 328 >> 2] + 20 >> 2];
    $1 = HEAP32[$13 + 328 >> 2];
    $2 = HEAP32[HEAP32[HEAP32[$13 + 276 >> 2] >> 2] >> 2];
    HEAP32[$13 + 116 >> 2] = HEAP32[$13 + 280 >> 2];
    HEAP32[$13 + 112 >> 2] = $2;
    HEAP32[$13 + 108 >> 2] = 137479;
    HEAP32[$13 + 104 >> 2] = 137446;
    HEAP32[$13 + 100 >> 2] = 117;
    HEAP32[$13 + 96 >> 2] = 137133;
    FUNCTION_TABLE[$0]($1, 137107, $13 + 96 | 0);
    HEAP32[$13 + 332 >> 2] = 1;
    break label$1;
   }
   if (HEAP32[$13 + 280 >> 2] != HEAP32[(HEAP32[HEAP32[$13 + 320 >> 2] + 20 >> 2] + 4 | 0) + (HEAP32[HEAP32[$13 + 276 >> 2] + 8 >> 2] << 2) >> 2]) {
    $0 = HEAP32[HEAP32[$13 + 328 >> 2] + 20 >> 2];
    $1 = HEAP32[$13 + 328 >> 2];
    $2 = HEAP32[$13 + 280 >> 2];
    HEAP32[$13 + 148 >> 2] = HEAP32[(HEAP32[HEAP32[$13 + 320 >> 2] + 20 >> 2] + 4 | 0) + (HEAP32[HEAP32[$13 + 276 >> 2] + 8 >> 2] << 2) >> 2];
    HEAP32[$13 + 144 >> 2] = $2;
    HEAP32[$13 + 140 >> 2] = 137492;
    HEAP32[$13 + 136 >> 2] = 137479;
    HEAP32[$13 + 132 >> 2] = 120;
    HEAP32[$13 + 128 >> 2] = 137133;
    FUNCTION_TABLE[$0]($1, 137107, $13 + 128 | 0);
    HEAP32[$13 + 332 >> 2] = 1;
    break label$1;
   }
  }
  HEAPF32[$13 + 268 >> 2] = HEAPF32[HEAP32[$13 + 324 >> 2] + 8 >> 2];
  HEAPF32[$13 + 264 >> 2] = HEAPF32[HEAP32[$13 + 312 >> 2] + 8 >> 2];
  HEAP32[$13 + 260 >> 2] = HEAP32[HEAP32[$13 + 276 >> 2] >> 2] + 4;
  HEAP32[$13 + 256 >> 2] = 0;
  while (1) {
   if (HEAP32[$13 + 256 >> 2] < HEAP32[$13 + 280 >> 2]) {
    $0 = $13;
    if (HEAP8[$13 + 275 | 0] & 1) {
     $14 = HEAPF32[HEAP32[$13 + 260 >> 2] + (HEAP32[$13 + 256 >> 2] << 2) >> 2];
    } else {
     $14 = HEAPF32[HEAP32[$13 + 260 >> 2] >> 2];
    }
    HEAPF32[$0 + 252 >> 2] = $14;
    HEAPF64[$13 + 240 >> 3] = HEAPF32[$13 + 252 >> 2];
    HEAPF64[$13 + 232 >> 3] = +HEAPF32[$13 + 268 >> 2] * HEAPF64[$13 + 240 >> 3] / +HEAPF32[$13 + 264 >> 2];
    tflite__QuantizeMultiplier_28double_2c_20int__2c_20int__29(HEAPF64[$13 + 232 >> 3], $13 + 228 | 0, $13 + 224 | 0);
    HEAP32[HEAP32[$13 + 288 >> 2] + (HEAP32[$13 + 256 >> 2] << 2) >> 2] = HEAP32[$13 + 228 >> 2];
    HEAP32[HEAP32[$13 + 284 >> 2] + (HEAP32[$13 + 256 >> 2] << 2) >> 2] = HEAP32[$13 + 224 >> 2];
    HEAP32[$13 + 256 >> 2] = HEAP32[$13 + 256 >> 2] + 1;
    continue;
   }
   break;
  }
  if (HEAP32[HEAP32[$13 + 324 >> 2] + 28 >> 2] == 3) {
   HEAPF64[$13 + 216 >> 3] = 0;
   HEAP32[$13 + 212 >> 2] = tflite__GetQuantizedConvolutionMultipler_28TfLiteContext__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor__2c_20double__29(HEAP32[$13 + 328 >> 2], HEAP32[$13 + 324 >> 2], HEAP32[$13 + 320 >> 2], HEAP32[$13 + 316 >> 2], HEAP32[$13 + 312 >> 2], $13 + 216 | 0);
   if (HEAP32[$13 + 212 >> 2]) {
    HEAP32[$13 + 332 >> 2] = HEAP32[$13 + 212 >> 2];
    break label$1;
   }
   tflite__QuantizeMultiplier_28double_2c_20int__2c_20int__29(HEAPF64[$13 + 216 >> 3], HEAP32[$13 + 304 >> 2], $13 + 208 | 0);
   HEAP32[HEAP32[$13 + 300 >> 2] >> 2] = 0 - HEAP32[$13 + 208 >> 2];
  }
  if (!(HEAP32[HEAP32[$13 + 324 >> 2] + 28 >> 2] != 7 ? !(HEAP32[HEAP32[$13 + 324 >> 2] + 28 >> 2] == 9 | HEAP32[HEAP32[$13 + 324 >> 2] + 28 >> 2] == 3) : 0)) {
   HEAP32[$13 + 204 >> 2] = tflite__CalculateActivationRangeQuantized_28TfLiteContext__2c_20TfLiteFusedActivation_2c_20TfLiteTensor__2c_20int__2c_20int__29(HEAP32[$13 + 328 >> 2], HEAP32[HEAP32[$13 + 308 >> 2] >> 2], HEAP32[$13 + 312 >> 2], HEAP32[$13 + 296 >> 2], HEAP32[$13 + 292 >> 2]);
   if (HEAP32[$13 + 204 >> 2]) {
    HEAP32[$13 + 332 >> 2] = HEAP32[$13 + 204 >> 2];
    break label$1;
   }
  }
  HEAP32[$13 + 332 >> 2] = 0;
 }
 global$0 = $13 + 336 | 0;
 return HEAP32[$13 + 332 >> 2];
}
function tflite__MicroAllocator__PrepareNodeAndRegistrationDataFromFlatbuffer_28tflite__Model_20const__2c_20tflite__MicroOpResolver_20const__2c_20tflite__NodeAndRegistration__29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0, $5 = 0;
 $4 = global$0 - 224 | 0;
 global$0 = $4;
 HEAP32[$4 + 216 >> 2] = $0;
 HEAP32[$4 + 212 >> 2] = $1;
 HEAP32[$4 + 208 >> 2] = $2;
 HEAP32[$4 + 204 >> 2] = $3;
 $0 = HEAP32[$4 + 216 >> 2];
 label$1 : {
  if (!HEAP32[$4 + 212 >> 2]) {
   break label$1;
  }
 }
 label$2 : {
  if (!HEAP32[$4 + 204 >> 2]) {
   break label$2;
  }
 }
 HEAP32[$4 + 200 >> 2] = tflite__MicroAllocator__GetSubGraphFromModel_28tflite__Model_20const__29($0, HEAP32[$4 + 212 >> 2]);
 label$3 : {
  if (!HEAP32[$4 + 200 >> 2]) {
   break label$3;
  }
 }
 $1 = $4 + 184 | 0;
 HEAP32[$4 + 196 >> 2] = 0;
 HEAP32[$4 + 192 >> 2] = tflite__SubGraph__inputs_28_29_20const(HEAP32[$4 + 212 >> 2]);
 tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator__MicroBuiltinDataAllocator_28tflite__SimpleMemoryAllocator__29($1, HEAP32[$0 + 4 >> 2]);
 HEAP32[$4 + 180 >> 2] = 0;
 label$4 : {
  while (1) {
   if (HEAPU32[$4 + 180 >> 2] < flatbuffers__Vector_int___size_28_29_20const(tflite__SubGraph__operators_28_29_20const(HEAP32[$4 + 200 >> 2])) >>> 0) {
    HEAP32[$4 + 168 >> 2] = flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph__20___Get_28unsigned_20int_29_20const(tflite__SubGraph__operators_28_29_20const(HEAP32[$4 + 200 >> 2]), HEAP32[$4 + 180 >> 2]);
    HEAP32[$4 + 164 >> 2] = tflite__Operator__opcode_index_28_29_20const(HEAP32[$4 + 168 >> 2]);
    if (HEAPU32[$4 + 164 >> 2] >= flatbuffers__Vector_int___size_28_29_20const(HEAP32[$4 + 192 >> 2]) >>> 0) {
     $0 = HEAP32[$0 + 8 >> 2];
     HEAP32[$4 >> 2] = HEAP32[$4 + 164 >> 2];
     tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 132171, $4);
     HEAP32[$4 + 220 >> 2] = 1;
     break label$4;
    }
    HEAP32[$4 + 156 >> 2] = flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph__20___operator_5b_5d_28unsigned_20int_29_20const(HEAP32[$4 + 192 >> 2], HEAP32[$4 + 164 >> 2]);
    HEAP32[$4 + 196 >> 2] = tflite__GetRegistrationFromOpCode_28tflite__OperatorCode_20const__2c_20tflite__OpResolver_20const__2c_20tflite__ErrorReporter__2c_20TfLiteRegistration_20const___29(HEAP32[$4 + 156 >> 2], HEAP32[$4 + 208 >> 2], HEAP32[$0 + 8 >> 2], (HEAP32[$4 + 204 >> 2] + Math_imul(HEAP32[$4 + 180 >> 2], 28) | 0) + 24 | 0);
    if (HEAP32[$4 + 196 >> 2]) {
     $0 = HEAP32[$0 + 8 >> 2];
     HEAP32[$4 + 16 >> 2] = tflite__EnumNameBuiltinOperator_28tflite__BuiltinOperator_29(tflite__OperatorCode__builtin_code_28_29_20const(HEAP32[$4 + 156 >> 2]));
     tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 132213, $4 + 16 | 0);
     HEAP32[$4 + 220 >> 2] = HEAP32[$4 + 196 >> 2];
     break label$4;
    }
    HEAP32[$4 + 152 >> 2] = HEAP32[(HEAP32[$4 + 204 >> 2] + Math_imul(HEAP32[$4 + 180 >> 2], 28) | 0) + 24 >> 2];
    if (!HEAP32[$4 + 152 >> 2]) {
     $0 = HEAP32[$0 + 8 >> 2];
     HEAP32[$4 + 32 >> 2] = HEAP32[$4 + 164 >> 2];
     tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 132258, $4 + 32 | 0);
     HEAP32[$4 + 220 >> 2] = 1;
     break label$4;
    }
    HEAP32[$4 + 148 >> 2] = HEAP32[HEAP32[$4 + 152 >> 2] + 20 >> 2];
    HEAP32[$4 + 144 >> 2] = 0;
    HEAP32[$4 + 140 >> 2] = 0;
    HEAP32[$4 + 136 >> 2] = 0;
    label$10 : {
     if (HEAP32[$4 + 148 >> 2] == 32) {
      if (tflite__Operator__custom_options_28_29_20const(HEAP32[$4 + 168 >> 2])) {
       HEAP32[$4 + 144 >> 2] = flatbuffers__Vector_unsigned_20char___data_28_29_20const(tflite__Operator__custom_options_28_29_20const(HEAP32[$4 + 168 >> 2]));
       HEAP32[$4 + 140 >> 2] = flatbuffers__Vector_int___size_28_29_20const(tflite__Operator__custom_options_28_29_20const(HEAP32[$4 + 168 >> 2]));
      }
      break label$10;
     }
     if (tflite__Operator__custom_options_28_29_20const(HEAP32[$4 + 168 >> 2])) {
      $0 = HEAP32[$0 + 8 >> 2];
      HEAP32[$4 + 48 >> 2] = tflite__EnumNameBuiltinOperator_28tflite__BuiltinOperator_29(HEAP32[$4 + 148 >> 2]);
      tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 132291, $4 + 48 | 0);
      HEAP32[$4 + 220 >> 2] = 1;
      break label$4;
     }
     $1 = HEAP32[$4 + 208 >> 2];
     HEAP32[$4 + 132 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$1 >> 2] + 28 >> 2]]($1, HEAP32[$4 + 148 >> 2]);
     if (!HEAP32[$4 + 132 >> 2]) {
      $0 = HEAP32[$0 + 8 >> 2];
      HEAP32[$4 + 64 >> 2] = tflite__EnumNameBuiltinOperator_28tflite__BuiltinOperator_29(HEAP32[$4 + 148 >> 2]);
      tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 132361, $4 - -64 | 0);
      HEAP32[$4 + 220 >> 2] = 1;
      break label$4;
     }
     HEAP32[$4 + 128 >> 2] = FUNCTION_TABLE[HEAP32[$4 + 132 >> 2]](HEAP32[$4 + 168 >> 2], HEAP32[$0 + 8 >> 2], $4 + 184 | 0, $4 + 136 | 0);
     if (HEAP32[$4 + 128 >> 2]) {
      HEAP32[$4 + 220 >> 2] = HEAP32[$4 + 128 >> 2];
      break label$4;
     }
    }
    HEAP32[$4 + 120 >> 2] = TfLiteStatus_20tflite__internal__FlatBufferVectorToTfLiteTypeArray_int_2c_20TfLiteIntArray__28tflite__SimpleMemoryAllocator__2c_20tflite__ErrorReporter__2c_20flatbuffers__Vector_int__20const__2c_20TfLiteIntArray___29(HEAP32[$0 + 4 >> 2], HEAP32[$0 + 8 >> 2], tflite__SubGraph__inputs_28_29_20const(HEAP32[$4 + 168 >> 2]), $4 + 124 | 0);
    if (HEAP32[$4 + 120 >> 2]) {
     HEAP32[$4 + 220 >> 2] = HEAP32[$4 + 120 >> 2];
     break label$4;
    }
    HEAP32[$4 + 112 >> 2] = TfLiteStatus_20tflite__internal__FlatBufferVectorToTfLiteTypeArray_int_2c_20TfLiteIntArray__28tflite__SimpleMemoryAllocator__2c_20tflite__ErrorReporter__2c_20flatbuffers__Vector_int__20const__2c_20TfLiteIntArray___29(HEAP32[$0 + 4 >> 2], HEAP32[$0 + 8 >> 2], tflite__Model__subgraphs_28_29_20const(HEAP32[$4 + 168 >> 2]), $4 + 116 | 0);
    if (HEAP32[$4 + 112 >> 2]) {
     HEAP32[$4 + 220 >> 2] = HEAP32[$4 + 112 >> 2];
     break label$4;
    }
    HEAP32[$4 + 108 >> 2] = HEAP32[$4 + 204 >> 2] + Math_imul(HEAP32[$4 + 180 >> 2], 28);
    $2 = $4 + 80 | 0;
    $1 = $2;
    HEAP32[$1 >> 2] = 0;
    HEAP32[$1 + 4 >> 2] = 0;
    HEAP32[$1 + 16 >> 2] = 0;
    HEAP32[$1 + 20 >> 2] = 0;
    HEAP32[$1 + 8 >> 2] = 0;
    HEAP32[$1 + 12 >> 2] = 0;
    $5 = HEAP32[$1 + 4 >> 2];
    $3 = HEAP32[$4 + 108 >> 2];
    HEAP32[$3 >> 2] = HEAP32[$1 >> 2];
    HEAP32[$3 + 4 >> 2] = $5;
    $1 = HEAP32[$1 + 20 >> 2];
    HEAP32[$3 + 16 >> 2] = HEAP32[$2 + 16 >> 2];
    HEAP32[$3 + 20 >> 2] = $1;
    $1 = HEAP32[$2 + 12 >> 2];
    HEAP32[$3 + 8 >> 2] = HEAP32[$2 + 8 >> 2];
    HEAP32[$3 + 12 >> 2] = $1;
    HEAP32[HEAP32[$4 + 108 >> 2] >> 2] = HEAP32[$4 + 124 >> 2];
    HEAP32[HEAP32[$4 + 108 >> 2] + 4 >> 2] = HEAP32[$4 + 116 >> 2];
    HEAP32[HEAP32[$4 + 108 >> 2] + 12 >> 2] = HEAP32[$4 + 136 >> 2];
    HEAP32[HEAP32[$4 + 108 >> 2] + 16 >> 2] = HEAP32[$4 + 144 >> 2];
    HEAP32[HEAP32[$4 + 108 >> 2] + 20 >> 2] = HEAP32[$4 + 140 >> 2];
    HEAP32[$4 + 180 >> 2] = HEAP32[$4 + 180 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$4 + 220 >> 2] = 0;
 }
 HEAP32[$4 + 160 >> 2] = 1;
 tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator___MicroBuiltinDataAllocator_28_29($4 + 184 | 0);
 global$0 = $4 + 224 | 0;
 return HEAP32[$4 + 220 >> 2];
}
function tflite__ops__micro__dequantize__Eval_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = global$0 - 272 | 0;
 global$0 = $2;
 HEAP32[$2 + 264 >> 2] = $0;
 HEAP32[$2 + 260 >> 2] = $1;
 label$1 : {
  if (!HEAP32[HEAP32[$2 + 260 >> 2] + 8 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$2 + 256 >> 2] = HEAP32[HEAP32[$2 + 260 >> 2] + 8 >> 2];
 HEAP32[$2 + 252 >> 2] = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 264 >> 2], HEAP32[$2 + 260 >> 2], 0);
 HEAP32[$2 + 248 >> 2] = tflite__micro__GetEvalOutput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 264 >> 2], HEAP32[$2 + 260 >> 2]);
 label$2 : {
  label$3 : {
   if (HEAP32[HEAP32[$2 + 248 >> 2] + 8 >> 2] == 1) {
    label$5 : {
     $0 = HEAP32[HEAP32[$2 + 252 >> 2] + 8 >> 2] + -3 | 0;
     if ($0 >>> 0 > 6) {
      break label$5;
     }
     label$6 : {
      switch ($0 - 1 | 0) {
      default:
       $0 = HEAP32[$2 + 256 >> 2];
       tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($2 + 224 | 0, HEAP32[$2 + 252 >> 2]);
       $1 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$2 + 252 >> 2]);
       tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($2 + 192 | 0, HEAP32[$2 + 248 >> 2]);
       void_20tflite__reference_ops__Dequantize_unsigned_20char_2c_20float__28tflite__DequantizationParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($0, $2 + 224 | 0, $1, $2 + 192 | 0, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$2 + 248 >> 2]));
       $0 = $2 + 224 | 0;
       tflite__RuntimeShape___RuntimeShape_28_29($2 + 192 | 0);
       tflite__RuntimeShape___RuntimeShape_28_29($0);
       break label$3;
      case 5:
       $0 = HEAP32[$2 + 256 >> 2];
       tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($2 + 168 | 0, HEAP32[$2 + 252 >> 2]);
       $1 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$2 + 252 >> 2]);
       tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($2 + 144 | 0, HEAP32[$2 + 248 >> 2]);
       void_20tflite__reference_ops__Dequantize_signed_20char_2c_20float__28tflite__DequantizationParams_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($0, $2 + 168 | 0, $1, $2 + 144 | 0, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$2 + 248 >> 2]));
       $0 = $2 + 168 | 0;
       tflite__RuntimeShape___RuntimeShape_28_29($2 + 144 | 0);
       tflite__RuntimeShape___RuntimeShape_28_29($0);
       break label$3;
      case 0:
      case 1:
      case 2:
      case 4:
       break label$5;
      case 3:
       break label$6;
      }
     }
     $0 = HEAP32[$2 + 256 >> 2];
     tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($2 + 120 | 0, HEAP32[$2 + 252 >> 2]);
     $1 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$2 + 252 >> 2]);
     tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($2 + 96 | 0, HEAP32[$2 + 248 >> 2]);
     void_20tflite__reference_ops__Dequantize_short_2c_20float__28tflite__DequantizationParams_20const__2c_20tflite__RuntimeShape_20const__2c_20short_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($0, $2 + 120 | 0, $1, $2 + 96 | 0, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$2 + 248 >> 2]));
     $0 = $2 + 120 | 0;
     tflite__RuntimeShape___RuntimeShape_28_29($2 + 96 | 0);
     tflite__RuntimeShape___RuntimeShape_28_29($0);
     break label$3;
    }
    $0 = HEAP32[HEAP32[$2 + 264 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 264 >> 2];
    $3 = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 252 >> 2] + 8 >> 2]);
    HEAP32[$2 + 4 >> 2] = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 248 >> 2] + 8 >> 2]);
    HEAP32[$2 >> 2] = $3;
    FUNCTION_TABLE[$0]($1, 136040, $2);
    HEAP32[$2 + 268 >> 2] = 1;
    break label$2;
   }
   label$9 : {
    if (HEAP32[HEAP32[$2 + 248 >> 2] + 8 >> 2] == 2) {
     $0 = $2 + 40 | 0;
     tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($2 - -64 | 0, HEAP32[$2 + 252 >> 2]);
     tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($0, HEAP32[$2 + 248 >> 2]);
     $0 = tflite__MatchingFlatSize_28tflite__RuntimeShape_20const__2c_20tflite__RuntimeShape_20const__29($2 - -64 | 0, $2 + 40 | 0);
     tflite__RuntimeShape___RuntimeShape_28_29($2 + 40 | 0);
     tflite__RuntimeShape___RuntimeShape_28_29($2 - -64 | 0);
     HEAP32[$2 + 92 >> 2] = $0;
     label$11 : {
      label$12 : {
       $0 = HEAP32[HEAP32[$2 + 252 >> 2] + 8 >> 2] + -7 | 0;
       if ($0 >>> 0 > 2) {
        break label$12;
       }
       label$13 : {
        switch ($0 - 1 | 0) {
        default:
         void_20tflite__reference_ops__Requantize_short_2c_20int__28short_20const__2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int__29(float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$2 + 252 >> 2]), HEAP32[$2 + 92 >> 2], HEAP32[HEAP32[$2 + 256 >> 2] + 16 >> 2], HEAP32[HEAP32[$2 + 256 >> 2] + 20 >> 2], HEAP32[HEAP32[$2 + 256 >> 2] + 8 >> 2], HEAP32[HEAP32[$2 + 256 >> 2] + 24 >> 2], float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$2 + 248 >> 2]));
         break label$11;
        case 0:
         break label$12;
        case 1:
         break label$13;
        }
       }
       void_20tflite__reference_ops__Requantize_signed_20char_2c_20int__28signed_20char_20const__2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int__29(float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$2 + 252 >> 2]), HEAP32[$2 + 92 >> 2], HEAP32[HEAP32[$2 + 256 >> 2] + 16 >> 2], HEAP32[HEAP32[$2 + 256 >> 2] + 20 >> 2], HEAP32[HEAP32[$2 + 256 >> 2] + 8 >> 2], HEAP32[HEAP32[$2 + 256 >> 2] + 24 >> 2], float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$2 + 248 >> 2]));
       break label$11;
      }
      $0 = HEAP32[HEAP32[$2 + 264 >> 2] + 20 >> 2];
      $1 = HEAP32[$2 + 264 >> 2];
      $3 = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 252 >> 2] + 8 >> 2]);
      HEAP32[$2 + 20 >> 2] = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 248 >> 2] + 8 >> 2]);
      HEAP32[$2 + 16 >> 2] = $3;
      FUNCTION_TABLE[$0]($1, 136040, $2 + 16 | 0);
      HEAP32[$2 + 268 >> 2] = 1;
      break label$2;
     }
     break label$9;
    }
    $0 = HEAP32[HEAP32[$2 + 264 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 264 >> 2];
    $3 = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 252 >> 2] + 8 >> 2]);
    HEAP32[$2 + 36 >> 2] = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 248 >> 2] + 8 >> 2]);
    HEAP32[$2 + 32 >> 2] = $3;
    FUNCTION_TABLE[$0]($1, 136040, $2 + 32 | 0);
    HEAP32[$2 + 268 >> 2] = 1;
    break label$2;
   }
  }
  HEAP32[$2 + 268 >> 2] = 0;
 }
 global$0 = $2 + 272 | 0;
 return HEAP32[$2 + 268 >> 2];
}
function tflite__reference_ops__Conv_28tflite__ConvParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float__2c_20tflite__RuntimeShape_20const__2c_20float__29($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10) {
 var $11 = 0, $12 = Math_fround(0);
 $11 = global$0 - 176 | 0;
 global$0 = $11;
 HEAP32[$11 + 172 >> 2] = $0;
 HEAP32[$11 + 168 >> 2] = $1;
 HEAP32[$11 + 164 >> 2] = $2;
 HEAP32[$11 + 160 >> 2] = $3;
 HEAP32[$11 + 156 >> 2] = $4;
 HEAP32[$11 + 152 >> 2] = $5;
 HEAP32[$11 + 148 >> 2] = $6;
 HEAP32[$11 + 144 >> 2] = $7;
 HEAP32[$11 + 140 >> 2] = $8;
 HEAP32[$11 + 136 >> 2] = $9;
 HEAP32[$11 + 132 >> 2] = $10;
 HEAP32[$11 + 128 >> 2] = HEAP16[HEAP32[$11 + 172 >> 2] + 10 >> 1];
 HEAP32[$11 + 124 >> 2] = HEAP16[HEAP32[$11 + 172 >> 2] + 12 >> 1];
 HEAP32[$11 + 120 >> 2] = HEAP16[HEAP32[$11 + 172 >> 2] + 14 >> 1];
 HEAP32[$11 + 116 >> 2] = HEAP16[HEAP32[$11 + 172 >> 2] + 16 >> 1];
 HEAP32[$11 + 112 >> 2] = HEAP16[HEAP32[$11 + 172 >> 2] + 2 >> 1];
 HEAP32[$11 + 108 >> 2] = HEAP16[HEAP32[$11 + 172 >> 2] + 4 >> 1];
 HEAPF32[$11 + 104 >> 2] = HEAPF32[HEAP32[$11 + 172 >> 2] + 48 >> 2];
 HEAPF32[$11 + 100 >> 2] = HEAPF32[HEAP32[$11 + 172 >> 2] + 52 >> 2];
 label$1 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$11 + 168 >> 2]) | 0) != 4) {
   break label$1;
  }
 }
 label$2 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$11 + 160 >> 2]) | 0) != 4) {
   break label$2;
  }
 }
 label$3 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$11 + 144 >> 2]) | 0) != 4) {
   break label$3;
  }
 }
 HEAP32[$11 + 96 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$11 + 168 >> 2], 0, HEAP32[$11 + 144 >> 2], 0);
 HEAP32[$11 + 92 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$11 + 168 >> 2], 3, HEAP32[$11 + 160 >> 2], 3);
 HEAP32[$11 + 88 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$11 + 160 >> 2], 0, HEAP32[$11 + 144 >> 2], 3);
 if (HEAP32[$11 + 148 >> 2]) {
  label$5 : {
   if ((tflite__RuntimeShape__FlatSize_28_29_20const(HEAP32[$11 + 152 >> 2]) | 0) != HEAP32[$11 + 88 >> 2]) {
    break label$5;
   }
  }
 }
 HEAP32[$11 + 84 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 168 >> 2], 1);
 HEAP32[$11 + 80 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 168 >> 2], 2);
 HEAP32[$11 + 76 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 160 >> 2], 1);
 HEAP32[$11 + 72 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 160 >> 2], 2);
 HEAP32[$11 + 68 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 144 >> 2], 1);
 HEAP32[$11 + 64 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 144 >> 2], 2);
 HEAP32[$11 + 60 >> 2] = 0;
 while (1) {
  if (HEAP32[$11 + 60 >> 2] < HEAP32[$11 + 96 >> 2]) {
   HEAP32[$11 + 56 >> 2] = 0;
   while (1) {
    if (HEAP32[$11 + 56 >> 2] < HEAP32[$11 + 68 >> 2]) {
     HEAP32[$11 + 52 >> 2] = 0;
     while (1) {
      if (HEAP32[$11 + 52 >> 2] < HEAP32[$11 + 64 >> 2]) {
       HEAP32[$11 + 48 >> 2] = 0;
       while (1) {
        if (HEAP32[$11 + 48 >> 2] < HEAP32[$11 + 88 >> 2]) {
         HEAP32[$11 + 44 >> 2] = Math_imul(HEAP32[$11 + 52 >> 2], HEAP32[$11 + 128 >> 2]) - HEAP32[$11 + 112 >> 2];
         HEAP32[$11 + 40 >> 2] = Math_imul(HEAP32[$11 + 56 >> 2], HEAP32[$11 + 124 >> 2]) - HEAP32[$11 + 108 >> 2];
         HEAPF32[$11 + 36 >> 2] = 0;
         HEAP32[$11 + 32 >> 2] = 0;
         while (1) {
          if (HEAP32[$11 + 32 >> 2] < HEAP32[$11 + 76 >> 2]) {
           HEAP32[$11 + 28 >> 2] = 0;
           while (1) {
            if (HEAP32[$11 + 28 >> 2] < HEAP32[$11 + 72 >> 2]) {
             HEAP32[$11 + 24 >> 2] = 0;
             while (1) {
              if (HEAP32[$11 + 24 >> 2] < HEAP32[$11 + 92 >> 2]) {
               HEAP32[$11 + 20 >> 2] = HEAP32[$11 + 44 >> 2] + Math_imul(HEAP32[$11 + 120 >> 2], HEAP32[$11 + 28 >> 2]);
               HEAP32[$11 + 16 >> 2] = HEAP32[$11 + 40 >> 2] + Math_imul(HEAP32[$11 + 116 >> 2], HEAP32[$11 + 32 >> 2]);
               if (!(HEAP32[$11 + 20 >> 2] < 0 | HEAP32[$11 + 20 >> 2] >= HEAP32[$11 + 80 >> 2] | (HEAP32[$11 + 16 >> 2] < 0 | HEAP32[$11 + 16 >> 2] >= HEAP32[$11 + 84 >> 2]))) {
                HEAPF32[$11 + 12 >> 2] = HEAPF32[HEAP32[$11 + 164 >> 2] + (tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$11 + 168 >> 2], HEAP32[$11 + 60 >> 2], HEAP32[$11 + 16 >> 2], HEAP32[$11 + 20 >> 2], HEAP32[$11 + 24 >> 2]) << 2) >> 2];
                HEAPF32[$11 + 8 >> 2] = HEAPF32[HEAP32[$11 + 156 >> 2] + (tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$11 + 160 >> 2], HEAP32[$11 + 48 >> 2], HEAP32[$11 + 32 >> 2], HEAP32[$11 + 28 >> 2], HEAP32[$11 + 24 >> 2]) << 2) >> 2];
                HEAPF32[$11 + 36 >> 2] = HEAPF32[$11 + 36 >> 2] + Math_fround(HEAPF32[$11 + 12 >> 2] * HEAPF32[$11 + 8 >> 2]);
               }
               HEAP32[$11 + 24 >> 2] = HEAP32[$11 + 24 >> 2] + 1;
               continue;
              }
              break;
             }
             HEAP32[$11 + 28 >> 2] = HEAP32[$11 + 28 >> 2] + 1;
             continue;
            }
            break;
           }
           HEAP32[$11 + 32 >> 2] = HEAP32[$11 + 32 >> 2] + 1;
           continue;
          }
          break;
         }
         HEAPF32[$11 + 4 >> 2] = 0;
         if (HEAP32[$11 + 148 >> 2]) {
          HEAPF32[$11 + 4 >> 2] = HEAPF32[HEAP32[$11 + 148 >> 2] + (HEAP32[$11 + 48 >> 2] << 2) >> 2];
         }
         $12 = float_20tflite__ActivationFunctionWithMinMax_float__28float_2c_20float_2c_20float_29(Math_fround(HEAPF32[$11 + 36 >> 2] + HEAPF32[$11 + 4 >> 2]), HEAPF32[$11 + 104 >> 2], HEAPF32[$11 + 100 >> 2]);
         HEAPF32[HEAP32[$11 + 140 >> 2] + (tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$11 + 144 >> 2], HEAP32[$11 + 60 >> 2], HEAP32[$11 + 56 >> 2], HEAP32[$11 + 52 >> 2], HEAP32[$11 + 48 >> 2]) << 2) >> 2] = $12;
         HEAP32[$11 + 48 >> 2] = HEAP32[$11 + 48 >> 2] + 1;
         continue;
        }
        break;
       }
       HEAP32[$11 + 52 >> 2] = HEAP32[$11 + 52 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$11 + 56 >> 2] = HEAP32[$11 + 56 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$11 + 60 >> 2] = HEAP32[$11 + 60 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $11 + 176 | 0;
}
function tflite__reference_ops__DepthwiseConv_28tflite__DepthwiseParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0, $10 = Math_fround(0);
 $9 = global$0 - 176 | 0;
 global$0 = $9;
 HEAP32[$9 + 172 >> 2] = $0;
 HEAP32[$9 + 168 >> 2] = $1;
 HEAP32[$9 + 164 >> 2] = $2;
 HEAP32[$9 + 160 >> 2] = $3;
 HEAP32[$9 + 156 >> 2] = $4;
 HEAP32[$9 + 152 >> 2] = $5;
 HEAP32[$9 + 148 >> 2] = $6;
 HEAP32[$9 + 144 >> 2] = $7;
 HEAP32[$9 + 140 >> 2] = $8;
 HEAP32[$9 + 136 >> 2] = HEAP16[HEAP32[$9 + 172 >> 2] + 10 >> 1];
 HEAP32[$9 + 132 >> 2] = HEAP16[HEAP32[$9 + 172 >> 2] + 12 >> 1];
 HEAP32[$9 + 128 >> 2] = HEAP16[HEAP32[$9 + 172 >> 2] + 14 >> 1];
 HEAP32[$9 + 124 >> 2] = HEAP16[HEAP32[$9 + 172 >> 2] + 16 >> 1];
 HEAP32[$9 + 120 >> 2] = HEAP16[HEAP32[$9 + 172 >> 2] + 2 >> 1];
 HEAP32[$9 + 116 >> 2] = HEAP16[HEAP32[$9 + 172 >> 2] + 4 >> 1];
 HEAP32[$9 + 112 >> 2] = HEAP16[HEAP32[$9 + 172 >> 2] + 18 >> 1];
 HEAPF32[$9 + 108 >> 2] = HEAPF32[HEAP32[$9 + 172 >> 2] + 48 >> 2];
 HEAPF32[$9 + 104 >> 2] = HEAPF32[HEAP32[$9 + 172 >> 2] + 52 >> 2];
 label$1 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 168 >> 2]) | 0) != 4) {
   break label$1;
  }
 }
 label$2 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 160 >> 2]) | 0) != 4) {
   break label$2;
  }
 }
 label$3 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 144 >> 2]) | 0) != 4) {
   break label$3;
  }
 }
 HEAP32[$9 + 100 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$9 + 168 >> 2], 0, HEAP32[$9 + 144 >> 2], 0);
 HEAP32[$9 + 96 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$9 + 160 >> 2], 3, HEAP32[$9 + 144 >> 2], 3);
 HEAP32[$9 + 92 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 168 >> 2], 1);
 HEAP32[$9 + 88 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 168 >> 2], 2);
 HEAP32[$9 + 84 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 168 >> 2], 3);
 HEAP32[$9 + 80 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 160 >> 2], 1);
 HEAP32[$9 + 76 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 160 >> 2], 2);
 HEAP32[$9 + 72 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 144 >> 2], 1);
 HEAP32[$9 + 68 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 144 >> 2], 2);
 label$4 : {
  if (HEAP32[$9 + 96 >> 2] != (Math_imul(HEAP32[$9 + 84 >> 2], HEAP32[$9 + 112 >> 2]) | 0)) {
   break label$4;
  }
 }
 label$5 : {
  if ((tflite__RuntimeShape__FlatSize_28_29_20const(HEAP32[$9 + 152 >> 2]) | 0) != HEAP32[$9 + 96 >> 2]) {
   break label$5;
  }
 }
 HEAP32[$9 + 64 >> 2] = 0;
 while (1) {
  if (HEAP32[$9 + 64 >> 2] < HEAP32[$9 + 100 >> 2]) {
   HEAP32[$9 + 60 >> 2] = 0;
   while (1) {
    if (HEAP32[$9 + 60 >> 2] < HEAP32[$9 + 72 >> 2]) {
     HEAP32[$9 + 56 >> 2] = 0;
     while (1) {
      if (HEAP32[$9 + 56 >> 2] < HEAP32[$9 + 68 >> 2]) {
       HEAP32[$9 + 52 >> 2] = 0;
       while (1) {
        if (HEAP32[$9 + 52 >> 2] < HEAP32[$9 + 84 >> 2]) {
         HEAP32[$9 + 48 >> 2] = 0;
         while (1) {
          if (HEAP32[$9 + 48 >> 2] < HEAP32[$9 + 112 >> 2]) {
           HEAP32[$9 + 44 >> 2] = HEAP32[$9 + 48 >> 2] + Math_imul(HEAP32[$9 + 52 >> 2], HEAP32[$9 + 112 >> 2]);
           HEAP32[$9 + 40 >> 2] = Math_imul(HEAP32[$9 + 56 >> 2], HEAP32[$9 + 136 >> 2]) - HEAP32[$9 + 120 >> 2];
           HEAP32[$9 + 36 >> 2] = Math_imul(HEAP32[$9 + 60 >> 2], HEAP32[$9 + 132 >> 2]) - HEAP32[$9 + 116 >> 2];
           HEAPF32[$9 + 32 >> 2] = 0;
           HEAP32[$9 + 28 >> 2] = 0;
           while (1) {
            if (HEAP32[$9 + 28 >> 2] < HEAP32[$9 + 80 >> 2]) {
             HEAP32[$9 + 24 >> 2] = 0;
             while (1) {
              if (HEAP32[$9 + 24 >> 2] < HEAP32[$9 + 76 >> 2]) {
               HEAP32[$9 + 20 >> 2] = HEAP32[$9 + 40 >> 2] + Math_imul(HEAP32[$9 + 128 >> 2], HEAP32[$9 + 24 >> 2]);
               HEAP32[$9 + 16 >> 2] = HEAP32[$9 + 36 >> 2] + Math_imul(HEAP32[$9 + 124 >> 2], HEAP32[$9 + 28 >> 2]);
               if (!(HEAP32[$9 + 20 >> 2] < 0 | HEAP32[$9 + 20 >> 2] >= HEAP32[$9 + 88 >> 2] | (HEAP32[$9 + 16 >> 2] < 0 | HEAP32[$9 + 16 >> 2] >= HEAP32[$9 + 92 >> 2]))) {
                HEAPF32[$9 + 12 >> 2] = HEAPF32[HEAP32[$9 + 164 >> 2] + (tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$9 + 168 >> 2], HEAP32[$9 + 64 >> 2], HEAP32[$9 + 16 >> 2], HEAP32[$9 + 20 >> 2], HEAP32[$9 + 52 >> 2]) << 2) >> 2];
                HEAPF32[$9 + 8 >> 2] = HEAPF32[HEAP32[$9 + 156 >> 2] + (tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$9 + 160 >> 2], 0, HEAP32[$9 + 28 >> 2], HEAP32[$9 + 24 >> 2], HEAP32[$9 + 44 >> 2]) << 2) >> 2];
                HEAPF32[$9 + 32 >> 2] = HEAPF32[$9 + 32 >> 2] + Math_fround(HEAPF32[$9 + 12 >> 2] * HEAPF32[$9 + 8 >> 2]);
               }
               HEAP32[$9 + 24 >> 2] = HEAP32[$9 + 24 >> 2] + 1;
               continue;
              }
              break;
             }
             HEAP32[$9 + 28 >> 2] = HEAP32[$9 + 28 >> 2] + 1;
             continue;
            }
            break;
           }
           HEAPF32[$9 + 4 >> 2] = 0;
           if (HEAP32[$9 + 148 >> 2]) {
            HEAPF32[$9 + 4 >> 2] = HEAPF32[HEAP32[$9 + 148 >> 2] + (HEAP32[$9 + 44 >> 2] << 2) >> 2];
           }
           $10 = float_20tflite__ActivationFunctionWithMinMax_float__28float_2c_20float_2c_20float_29(Math_fround(HEAPF32[$9 + 32 >> 2] + HEAPF32[$9 + 4 >> 2]), HEAPF32[$9 + 108 >> 2], HEAPF32[$9 + 104 >> 2]);
           HEAPF32[HEAP32[$9 + 140 >> 2] + (tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$9 + 144 >> 2], HEAP32[$9 + 64 >> 2], HEAP32[$9 + 60 >> 2], HEAP32[$9 + 56 >> 2], HEAP32[$9 + 44 >> 2]) << 2) >> 2] = $10;
           HEAP32[$9 + 48 >> 2] = HEAP32[$9 + 48 >> 2] + 1;
           continue;
          }
          break;
         }
         HEAP32[$9 + 52 >> 2] = HEAP32[$9 + 52 >> 2] + 1;
         continue;
        }
        break;
       }
       HEAP32[$9 + 56 >> 2] = HEAP32[$9 + 56 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$9 + 60 >> 2] = HEAP32[$9 + 60 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$9 + 64 >> 2] = HEAP32[$9 + 64 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $9 + 176 | 0;
}
function jswrap_storagefile_write($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 352 | 0;
 global$0 = $2;
 HEAP32[$2 + 348 >> 2] = $0;
 HEAP32[$2 + 344 >> 2] = $1;
 HEAP8[$2 + 343 | 0] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$2 + 348 >> 2], 125579, 0));
 label$1 : {
  if (!(HEAP8[$2 + 343 | 0] == 119 | HEAP8[$2 + 343 | 0] == 97)) {
   jsExceptionHere(1, 125608, 0);
   break label$1;
  }
  HEAP32[$2 + 336 >> 2] = jsvAsString(HEAP32[$2 + 344 >> 2]);
  if (!HEAP32[$2 + 336 >> 2]) {
   break label$1;
  }
  HEAP32[$2 + 332 >> 2] = jsvGetStringLength(HEAP32[$2 + 336 >> 2]);
  if (!HEAP32[$2 + 332 >> 2]) {
   break label$1;
  }
  $0 = $2 + 288 | 0;
  HEAP32[$2 + 328 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$2 + 348 >> 2], 125563, 0));
  HEAP32[$2 + 324 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$2 + 348 >> 2], 125575, 0));
  HEAP32[$2 + 320 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$2 + 348 >> 2], 125557, 0));
  jsfNameFromVarAndUnLock($0, jsvObjectGetChild(HEAP32[$2 + 348 >> 2], 125552, 0));
  HEAP32[$2 + 284 >> 2] = 27;
  while (1) {
   if (HEAP32[$2 + 284 >> 2] ? !HEAP8[(HEAP32[$2 + 284 >> 2] + $2 | 0) + 287 | 0] : 0) {
    HEAP32[$2 + 284 >> 2] = HEAP32[$2 + 284 >> 2] + -1;
    continue;
   }
   break;
  }
  HEAP8[HEAP32[$2 + 284 >> 2] + ($2 + 288 | 0) | 0] = HEAP32[$2 + 320 >> 2];
  HEAP32[$2 + 280 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$2 + 348 >> 2], 125570, 0));
  HEAP32[$2 + 276 >> 2] = HEAP32[$2 + 324 >> 2] - HEAP32[$2 + 328 >> 2];
  label$7 : {
   if (HEAP32[$2 + 280 >> 2]) {
    $0 = $2 + 288 | 0;
    $1 = $2 + 240 | 0;
    jshFlashRead($1, HEAP32[$2 + 280 >> 2] - 32 | 0, 32);
    if (memcmp($1 + 4 | 0, $0, HEAP32[$2 + 284 >> 2] + 1 | 0)) {
     HEAP32[$2 + 96 >> 2] = HEAP32[$2 + 312 >> 2];
     $0 = HEAP32[$2 + 308 >> 2];
     HEAP32[$2 + 88 >> 2] = HEAP32[$2 + 304 >> 2];
     HEAP32[$2 + 92 >> 2] = $0;
     $0 = HEAP32[$2 + 300 >> 2];
     HEAP32[$2 + 80 >> 2] = HEAP32[$2 + 296 >> 2];
     HEAP32[$2 + 84 >> 2] = $0;
     $0 = HEAP32[$2 + 292 >> 2];
     HEAP32[$2 + 72 >> 2] = HEAP32[$2 + 288 >> 2];
     HEAP32[$2 + 76 >> 2] = $0;
     HEAP32[$2 + 280 >> 2] = jsfFindFile($2 + 72 | 0, $2 + 240 | 0);
     if (!HEAP32[$2 + 280 >> 2]) {
      jsExceptionHere(1, 125633, 0);
      break label$1;
     }
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 348 >> 2], 125570, jsvNewFromInteger(HEAP32[$2 + 280 >> 2]));
    }
    break label$7;
   }
   $0 = HEAP32[$2 + 336 >> 2];
   HEAP32[$2 + 160 >> 2] = HEAP32[$2 + 312 >> 2];
   $1 = HEAP32[$2 + 308 >> 2];
   HEAP32[$2 + 152 >> 2] = HEAP32[$2 + 304 >> 2];
   HEAP32[$2 + 156 >> 2] = $1;
   $1 = HEAP32[$2 + 300 >> 2];
   HEAP32[$2 + 144 >> 2] = HEAP32[$2 + 296 >> 2];
   HEAP32[$2 + 148 >> 2] = $1;
   $1 = HEAP32[$2 + 292 >> 2];
   HEAP32[$2 + 136 >> 2] = HEAP32[$2 + 288 >> 2];
   HEAP32[$2 + 140 >> 2] = $1;
   if (jsfWriteFile($2 + 136 | 0, $0, 64, 0, 40928) & 1) {
    HEAP32[$2 + 128 >> 2] = HEAP32[$2 + 312 >> 2];
    $0 = HEAP32[$2 + 308 >> 2];
    HEAP32[$2 + 120 >> 2] = HEAP32[$2 + 304 >> 2];
    HEAP32[$2 + 124 >> 2] = $0;
    $0 = HEAP32[$2 + 300 >> 2];
    HEAP32[$2 + 112 >> 2] = HEAP32[$2 + 296 >> 2];
    HEAP32[$2 + 116 >> 2] = $0;
    $0 = HEAP32[$2 + 292 >> 2];
    HEAP32[$2 + 104 >> 2] = HEAP32[$2 + 288 >> 2];
    HEAP32[$2 + 108 >> 2] = $0;
    HEAP32[$2 + 280 >> 2] = jsfFindFile($2 + 104 | 0, $2 + 208 | 0);
    HEAP32[$2 + 324 >> 2] = jsfGetFileSize($2 + 208 | 0);
    HEAP32[$2 + 328 >> 2] = HEAP32[$2 + 332 >> 2];
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 348 >> 2], 125563, jsvNewFromInteger(HEAP32[$2 + 328 >> 2]));
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 348 >> 2], 125575, jsvNewFromInteger(HEAP32[$2 + 324 >> 2]));
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 348 >> 2], 125570, jsvNewFromInteger(HEAP32[$2 + 280 >> 2]));
   }
   jsvUnLock(HEAP32[$2 + 336 >> 2]);
   break label$1;
  }
  label$12 : {
   if (HEAP32[$2 + 332 >> 2] < HEAP32[$2 + 276 >> 2]) {
    jswrap_flash_write(HEAP32[$2 + 336 >> 2], HEAP32[$2 + 280 >> 2] + HEAP32[$2 + 328 >> 2] | 0);
    HEAP32[$2 + 328 >> 2] = HEAP32[$2 + 332 >> 2] + HEAP32[$2 + 328 >> 2];
    break label$12;
   }
   HEAP32[$2 + 204 >> 2] = jsvNewFromStringVar(HEAP32[$2 + 336 >> 2], 0, HEAP32[$2 + 276 >> 2]);
   jswrap_flash_write(HEAP32[$2 + 204 >> 2], HEAP32[$2 + 280 >> 2] + HEAP32[$2 + 328 >> 2] | 0);
   jsvUnLock(HEAP32[$2 + 204 >> 2]);
   if (HEAP32[$2 + 320 >> 2] == 255) {
    jsExceptionHere(1, 125661, 0);
    jsvUnLock(HEAP32[$2 + 336 >> 2]);
    break label$1;
   }
   HEAP32[$2 + 320 >> 2] = HEAP32[$2 + 320 >> 2] + 1;
   HEAP8[HEAP32[$2 + 284 >> 2] + ($2 + 288 | 0) | 0] = HEAP32[$2 + 320 >> 2];
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 348 >> 2], 125557, jsvNewFromInteger(HEAP32[$2 + 320 >> 2]));
   HEAP32[$2 + 204 >> 2] = jsvNewFromStringVar(HEAP32[$2 + 336 >> 2], HEAP32[$2 + 276 >> 2], 2147483647);
   $0 = HEAP32[$2 + 204 >> 2];
   HEAP32[$2 + 64 >> 2] = HEAP32[$2 + 312 >> 2];
   $1 = HEAP32[$2 + 308 >> 2];
   HEAP32[$2 + 56 >> 2] = HEAP32[$2 + 304 >> 2];
   HEAP32[$2 + 60 >> 2] = $1;
   $1 = HEAP32[$2 + 300 >> 2];
   HEAP32[$2 + 48 >> 2] = HEAP32[$2 + 296 >> 2];
   HEAP32[$2 + 52 >> 2] = $1;
   $1 = HEAP32[$2 + 292 >> 2];
   HEAP32[$2 + 40 >> 2] = HEAP32[$2 + 288 >> 2];
   HEAP32[$2 + 44 >> 2] = $1;
   label$15 : {
    if (jsfWriteFile($2 + 40 | 0, $0, 64, 0, 40928) & 1) {
     HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 312 >> 2];
     $0 = HEAP32[$2 + 308 >> 2];
     HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 304 >> 2];
     HEAP32[$2 + 28 >> 2] = $0;
     $0 = HEAP32[$2 + 300 >> 2];
     HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 296 >> 2];
     HEAP32[$2 + 20 >> 2] = $0;
     $0 = HEAP32[$2 + 292 >> 2];
     HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 288 >> 2];
     HEAP32[$2 + 12 >> 2] = $0;
     HEAP32[$2 + 280 >> 2] = jsfFindFile($2 + 8 | 0, $2 + 168 | 0);
     HEAP32[$2 + 324 >> 2] = jsfGetFileSize($2 + 168 | 0);
     HEAP32[$2 + 328 >> 2] = HEAP32[$2 + 332 >> 2];
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 348 >> 2], 125563, jsvNewFromInteger(HEAP32[$2 + 328 >> 2]));
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 348 >> 2], 125575, jsvNewFromInteger(HEAP32[$2 + 324 >> 2]));
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 348 >> 2], 125570, jsvNewFromInteger(HEAP32[$2 + 280 >> 2]));
     break label$15;
    }
    jsvUnLock(HEAP32[$2 + 336 >> 2]);
    break label$1;
   }
   HEAP32[$2 + 328 >> 2] = jsvGetStringLength(HEAP32[$2 + 204 >> 2]);
   jsvUnLock(HEAP32[$2 + 204 >> 2]);
  }
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 348 >> 2], 125563, jsvNewFromInteger(HEAP32[$2 + 328 >> 2]));
  jsvUnLock(HEAP32[$2 + 336 >> 2]);
 }
 global$0 = $2 + 352 | 0;
}
function tflite__ops__micro__activations___28anonymous_20namespace_29__CalculateSoftmaxParams_28TfLiteContext__2c_20TfLiteTensor_20const__2c_20TfLiteTensor__2c_20TfLiteSoftmaxParams_20const__2c_20tflite__SoftmaxParams__29($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 $5 = global$0 - 304 | 0;
 global$0 = $5;
 HEAP32[$5 + 296 >> 2] = $0;
 HEAP32[$5 + 292 >> 2] = $1;
 HEAP32[$5 + 288 >> 2] = $2;
 HEAP32[$5 + 284 >> 2] = $3;
 HEAP32[$5 + 280 >> 2] = $4;
 label$1 : {
  label$2 : {
   if (!(HEAP32[HEAP32[$5 + 292 >> 2] + 28 >> 2] != 9 ? HEAP32[HEAP32[$5 + 292 >> 2] + 28 >> 2] != 3 : 0)) {
    label$5 : {
     if (HEAP32[HEAP32[$5 + 292 >> 2] + 28 >> 2] == 3) {
      if (HEAP32[HEAP32[$5 + 288 >> 2] + 28 >> 2] != 3) {
       $0 = HEAP32[HEAP32[$5 + 296 >> 2] + 20 >> 2];
       $1 = HEAP32[$5 + 296 >> 2];
       $2 = TfLiteTypeGetName(HEAP32[HEAP32[$5 + 288 >> 2] + 28 >> 2]);
       HEAP32[$5 + 20 >> 2] = TfLiteTypeGetName(3);
       HEAP32[$5 + 16 >> 2] = $2;
       HEAP32[$5 + 12 >> 2] = 134689;
       HEAP32[$5 + 8 >> 2] = 134676;
       HEAP32[$5 + 4 >> 2] = 40;
       HEAP32[$5 >> 2] = 134453;
       FUNCTION_TABLE[$0]($1, 134650, $5);
       HEAP32[$5 + 300 >> 2] = 1;
       break label$1;
      }
      if (HEAP32[HEAP32[$5 + 288 >> 2] + 12 >> 2]) {
       $0 = HEAP32[HEAP32[$5 + 296 >> 2] + 20 >> 2];
       $1 = HEAP32[$5 + 296 >> 2];
       $2 = HEAP32[HEAP32[$5 + 288 >> 2] + 12 >> 2];
       HEAP32[$5 + 52 >> 2] = 0;
       HEAP32[$5 + 48 >> 2] = $2;
       HEAP32[$5 + 44 >> 2] = 134728;
       HEAP32[$5 + 40 >> 2] = 134702;
       HEAP32[$5 + 36 >> 2] = 41;
       HEAP32[$5 + 32 >> 2] = 134453;
       FUNCTION_TABLE[$0]($1, 134427, $5 + 32 | 0);
       HEAP32[$5 + 300 >> 2] = 1;
       break label$1;
      }
      break label$5;
     }
     if (HEAP32[HEAP32[$5 + 292 >> 2] + 28 >> 2] != 9) {
      $0 = HEAP32[HEAP32[$5 + 296 >> 2] + 20 >> 2];
      $1 = HEAP32[$5 + 296 >> 2];
      $2 = TfLiteTypeGetName(HEAP32[HEAP32[$5 + 292 >> 2] + 28 >> 2]);
      HEAP32[$5 + 84 >> 2] = TfLiteTypeGetName(9);
      HEAP32[$5 + 80 >> 2] = $2;
      HEAP32[$5 + 76 >> 2] = 134742;
      HEAP32[$5 + 72 >> 2] = 134730;
      HEAP32[$5 + 68 >> 2] = 43;
      HEAP32[$5 + 64 >> 2] = 134453;
      FUNCTION_TABLE[$0]($1, 134650, $5 - -64 | 0);
      HEAP32[$5 + 300 >> 2] = 1;
      break label$1;
     }
     label$10 : {
      if (HEAP32[HEAP32[$5 + 288 >> 2] + 28 >> 2] == 7) {
       if (HEAP32[HEAP32[$5 + 288 >> 2] + 12 >> 2] != -32768) {
        $0 = HEAP32[HEAP32[$5 + 296 >> 2] + 20 >> 2];
        $1 = HEAP32[$5 + 296 >> 2];
        $2 = HEAP32[HEAP32[$5 + 288 >> 2] + 12 >> 2];
        HEAP32[$5 + 116 >> 2] = -32768;
        HEAP32[$5 + 112 >> 2] = $2;
        HEAP32[$5 + 108 >> 2] = 134754;
        HEAP32[$5 + 104 >> 2] = 134702;
        HEAP32[$5 + 100 >> 2] = 45;
        HEAP32[$5 + 96 >> 2] = 134453;
        FUNCTION_TABLE[$0]($1, 134427, $5 + 96 | 0);
        HEAP32[$5 + 300 >> 2] = 1;
        break label$1;
       }
       break label$10;
      }
      if (HEAP32[HEAP32[$5 + 288 >> 2] + 28 >> 2] != 9) {
       $0 = HEAP32[HEAP32[$5 + 296 >> 2] + 20 >> 2];
       $1 = HEAP32[$5 + 296 >> 2];
       $2 = TfLiteTypeGetName(HEAP32[HEAP32[$5 + 288 >> 2] + 28 >> 2]);
       HEAP32[$5 + 148 >> 2] = TfLiteTypeGetName(9);
       HEAP32[$5 + 144 >> 2] = $2;
       HEAP32[$5 + 140 >> 2] = 134742;
       HEAP32[$5 + 136 >> 2] = 134676;
       HEAP32[$5 + 132 >> 2] = 50;
       HEAP32[$5 + 128 >> 2] = 134453;
       FUNCTION_TABLE[$0]($1, 134650, $5 + 128 | 0);
       HEAP32[$5 + 300 >> 2] = 1;
       break label$1;
      }
      if (HEAP32[HEAP32[$5 + 288 >> 2] + 12 >> 2] != -128) {
       $0 = HEAP32[HEAP32[$5 + 296 >> 2] + 20 >> 2];
       $1 = HEAP32[$5 + 296 >> 2];
       $2 = HEAP32[HEAP32[$5 + 288 >> 2] + 12 >> 2];
       HEAP32[$5 + 180 >> 2] = -128;
       HEAP32[$5 + 176 >> 2] = $2;
       HEAP32[$5 + 172 >> 2] = 134761;
       HEAP32[$5 + 168 >> 2] = 134702;
       HEAP32[$5 + 164 >> 2] = 51;
       HEAP32[$5 + 160 >> 2] = 134453;
       FUNCTION_TABLE[$0]($1, 134427, $5 + 160 | 0);
       HEAP32[$5 + 300 >> 2] = 1;
       break label$1;
      }
      if (HEAPF32[HEAP32[$5 + 288 >> 2] + 8 >> 2] != Math_fround(.00390625)) {
       $0 = HEAP32[HEAP32[$5 + 296 >> 2] + 20 >> 2];
       $1 = HEAP32[$5 + 296 >> 2];
       HEAP32[$5 + 200 >> 2] = 134766;
       HEAP32[$5 + 196 >> 2] = 52;
       HEAP32[$5 + 192 >> 2] = 134453;
       FUNCTION_TABLE[$0]($1, 134573, $5 + 192 | 0);
       HEAP32[$5 + 300 >> 2] = 1;
       break label$1;
      }
     }
    }
    tflite__PreprocessSoftmaxScaling_28double_2c_20double_2c_20int_2c_20int__2c_20int__29(+HEAPF32[HEAP32[$5 + 284 >> 2] >> 2], +HEAPF32[HEAP32[$5 + 292 >> 2] + 8 >> 2], HEAP32[$5 + 280 >> 2] + 8 | 0, $5 + 276 | 0);
    HEAP32[HEAP32[$5 + 280 >> 2] + 12 >> 2] = HEAP32[$5 + 276 >> 2];
    $6 = -1 * +(tflite__CalculateInputRadius_28int_2c_20int_2c_20int_29(HEAP32[HEAP32[$5 + 280 >> 2] + 12 >> 2]) | 0);
    label$16 : {
     if (Math_abs($6) < 2147483648) {
      $0 = ~~$6;
      break label$16;
     }
     $0 = -2147483648;
    }
    HEAP32[HEAP32[$5 + 280 >> 2] + 24 >> 2] = $0;
    break label$2;
   }
   if (HEAP32[HEAP32[$5 + 292 >> 2] + 28 >> 2] != 1) {
    $0 = HEAP32[HEAP32[$5 + 296 >> 2] + 20 >> 2];
    $1 = HEAP32[$5 + 296 >> 2];
    $2 = TfLiteTypeGetName(HEAP32[HEAP32[$5 + 292 >> 2] + 28 >> 2]);
    HEAP32[$5 + 228 >> 2] = TfLiteTypeGetName(1);
    HEAP32[$5 + 224 >> 2] = $2;
    HEAP32[$5 + 220 >> 2] = 134800;
    HEAP32[$5 + 216 >> 2] = 134730;
    HEAP32[$5 + 212 >> 2] = 68;
    HEAP32[$5 + 208 >> 2] = 134453;
    FUNCTION_TABLE[$0]($1, 134650, $5 + 208 | 0);
    HEAP32[$5 + 300 >> 2] = 1;
    break label$1;
   }
   if (HEAP32[HEAP32[$5 + 288 >> 2] + 28 >> 2] != 1) {
    $0 = HEAP32[HEAP32[$5 + 296 >> 2] + 20 >> 2];
    $1 = HEAP32[$5 + 296 >> 2];
    $2 = TfLiteTypeGetName(HEAP32[HEAP32[$5 + 288 >> 2] + 28 >> 2]);
    HEAP32[$5 + 260 >> 2] = TfLiteTypeGetName(1);
    HEAP32[$5 + 256 >> 2] = $2;
    HEAP32[$5 + 252 >> 2] = 134800;
    HEAP32[$5 + 248 >> 2] = 134676;
    HEAP32[$5 + 244 >> 2] = 69;
    HEAP32[$5 + 240 >> 2] = 134453;
    FUNCTION_TABLE[$0]($1, 134650, $5 + 240 | 0);
    HEAP32[$5 + 300 >> 2] = 1;
    break label$1;
   }
   HEAPF64[HEAP32[$5 + 280 >> 2] >> 3] = HEAPF32[HEAP32[$5 + 284 >> 2] >> 2];
  }
  HEAP32[$5 + 300 >> 2] = 0;
 }
 global$0 = $5 + 304 | 0;
 return HEAP32[$5 + 300 >> 2];
}
function __jspeBinaryExpression($0, $1) {
 var $2 = 0;
 $2 = global$0 - 192 | 0;
 global$0 = $2;
 HEAP32[$2 + 188 >> 2] = $0;
 HEAP32[$2 + 184 >> 2] = $1;
 HEAP32[$2 + 180 >> 2] = jspeGetBinaryExpressionPrecedence(HEAP16[HEAP32[35539] + 2 >> 1]);
 while (1) {
  if (HEAP32[$2 + 180 >> 2] ? HEAPU32[$2 + 180 >> 2] > HEAPU32[$2 + 184 >> 2] : 0) {
   HEAP32[$2 + 176 >> 2] = HEAP16[HEAP32[35539] + 2 >> 1];
   jslGetNextToken();
   label$5 : {
    if (!(HEAP32[$2 + 176 >> 2] != 160 ? HEAP32[$2 + 176 >> 2] != 158 : 0)) {
     HEAP8[$2 + 175 | 0] = jsvGetBoolAndUnLock(jsvSkipName(HEAP32[$2 + 188 >> 2])) & 1;
     label$8 : {
      if (!(!(HEAP8[$2 + 175 | 0] & 1) | HEAP32[$2 + 176 >> 2] != 160 ? !(HEAP32[$2 + 176 >> 2] == 158 ? !(HEAP8[$2 + 175 | 0] & 1) : 0) : 0)) {
       HEAP32[$2 + 168 >> 2] = HEAP32[80549];
       jspSetNoExecute();
       jsvUnLock(__jspeBinaryExpression(jspeUnaryExpression(), HEAP32[$2 + 180 >> 2]));
       HEAP32[80549] = HEAP32[80549] & -1664 | HEAP32[$2 + 168 >> 2] & 1663;
       break label$8;
      }
      jsvUnLock(HEAP32[$2 + 188 >> 2]);
      HEAP32[$2 + 188 >> 2] = __jspeBinaryExpression(jspeUnaryExpression(), HEAP32[$2 + 180 >> 2]);
     }
     break label$5;
    }
    HEAP32[$2 + 164 >> 2] = __jspeBinaryExpression(jspeUnaryExpression(), HEAP32[$2 + 180 >> 2]);
    if ((HEAP32[80549] & 63) == 1) {
     label$13 : {
      if (HEAP32[$2 + 176 >> 2] == 185) {
       HEAP32[$2 + 160 >> 2] = jsvSkipName(HEAP32[$2 + 188 >> 2]);
       HEAP32[$2 + 156 >> 2] = jsvSkipName(HEAP32[$2 + 164 >> 2]);
       label$15 : {
        if (jsvHasChildren(HEAP32[$2 + 156 >> 2]) & 1) {
         HEAP32[$2 + 160 >> 2] = jsvAsArrayIndexAndUnLock(HEAP32[$2 + 160 >> 2]);
         HEAP32[$2 + 152 >> 2] = jspGetVarNamedField(HEAP32[$2 + 156 >> 2], HEAP32[$2 + 160 >> 2], 1);
         jsvUnLock2(HEAP32[$2 + 188 >> 2], HEAP32[$2 + 152 >> 2]);
         HEAP32[$2 + 188 >> 2] = jsvNewFromBool(HEAP32[$2 + 152 >> 2] != 0);
         break label$15;
        }
        HEAP32[$2 + 148 >> 2] = jswGetSymbolListForObjectProto(HEAP32[$2 + 156 >> 2]);
        label$17 : {
         if (HEAP32[$2 + 148 >> 2]) {
          HEAP32[$2 + 144 >> 2] = 0;
          if (jsvGetString(HEAP32[$2 + 160 >> 2], $2 + 80 | 0, 64) >>> 0 < 64) {
           HEAP32[$2 + 144 >> 2] = jswBinarySearch(HEAP32[$2 + 148 >> 2], HEAP32[$2 + 156 >> 2], $2 + 80 | 0);
          }
          HEAP8[$2 + 79 | 0] = HEAP32[$2 + 144 >> 2] != 0;
          jsvUnLock2(HEAP32[$2 + 188 >> 2], HEAP32[$2 + 144 >> 2]);
          label$20 : {
           if (HEAP8[$2 + 79 | 0] & 1) {
            break label$20;
           }
           if (!(jsvIsArrayBuffer(HEAP32[$2 + 156 >> 2]) & 1)) {
            break label$20;
           }
           HEAPF64[$2 + 64 >> 3] = jsvGetFloat(HEAP32[$2 + 160 >> 2]);
           label$21 : {
            if (!(HEAPF64[$2 + 64 >> 3] >= 0) | HEAPF64[$2 + 64 >> 3] != Math_floor(HEAPF64[$2 + 64 >> 3])) {
             break label$21;
            }
            if (!(HEAPF64[$2 + 64 >> 3] < +(jsvGetArrayBufferLength(HEAP32[$2 + 156 >> 2]) >>> 0))) {
             break label$21;
            }
            HEAP8[$2 + 79 | 0] = 1;
           }
          }
          HEAP32[$2 + 188 >> 2] = jsvNewFromBool(HEAP8[$2 + 79 | 0] & 1);
          break label$17;
         }
         HEAP32[$2 >> 2] = HEAP32[$2 + 156 >> 2];
         jsExceptionHere(1, 80465, $2);
         jsvUnLock(HEAP32[$2 + 188 >> 2]);
         HEAP32[$2 + 188 >> 2] = 0;
        }
       }
       jsvUnLock2(HEAP32[$2 + 160 >> 2], HEAP32[$2 + 156 >> 2]);
       break label$13;
      }
      label$22 : {
       if (HEAP32[$2 + 176 >> 2] == 186) {
        HEAP8[$2 + 63 | 0] = 0;
        HEAP32[$2 + 56 >> 2] = jsvSkipName(HEAP32[$2 + 188 >> 2]);
        HEAP32[$2 + 52 >> 2] = jsvSkipName(HEAP32[$2 + 164 >> 2]);
        label$24 : {
         if (!(jsvIsFunction(HEAP32[$2 + 52 >> 2]) & 1)) {
          HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 52 >> 2];
          jsExceptionHere(1, 80505, $2 + 16 | 0);
          break label$24;
         }
         label$26 : {
          if (!(jsvIsObject(HEAP32[$2 + 56 >> 2]) & 1)) {
           if (!(jsvIsFunction(HEAP32[$2 + 56 >> 2]) & 1)) {
            break label$26;
           }
          }
          HEAP32[$2 + 48 >> 2] = jspGetNamedField(HEAP32[$2 + 52 >> 2], 79516, 0);
          HEAP32[$2 + 44 >> 2] = jsvObjectGetChild(HEAP32[$2 + 56 >> 2], 79526, 0);
          while (1) {
           if (HEAP32[$2 + 44 >> 2]) {
            if (HEAP32[$2 + 44 >> 2] == HEAP32[$2 + 48 >> 2]) {
             HEAP8[$2 + 63 | 0] = 1;
            }
            HEAP32[$2 + 40 >> 2] = jsvObjectGetChild(HEAP32[$2 + 44 >> 2], 79526, 0);
            jsvUnLock(HEAP32[$2 + 44 >> 2]);
            HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 40 >> 2];
            continue;
           }
           break;
          }
          if (jspIsConstructor(HEAP32[$2 + 52 >> 2], 79536) & 1) {
           HEAP8[$2 + 63 | 0] = 1;
          }
          jsvUnLock(HEAP32[$2 + 48 >> 2]);
         }
         if (!(HEAP8[$2 + 63 | 0] & 1)) {
          HEAP32[$2 + 36 >> 2] = jswGetBasicObjectName(HEAP32[$2 + 56 >> 2]);
          if (HEAP32[$2 + 36 >> 2]) {
           HEAP8[$2 + 63 | 0] = jspIsConstructor(HEAP32[$2 + 52 >> 2], HEAP32[$2 + 36 >> 2]) & 1;
          }
          label$34 : {
           if (HEAP8[$2 + 63 | 0] & 1) {
            break label$34;
           }
           if (!(jsvIsArray(HEAP32[$2 + 56 >> 2]) & 1)) {
            if (!(jsvIsArrayBuffer(HEAP32[$2 + 56 >> 2]) & 1)) {
             break label$34;
            }
           }
           if (!(jspIsConstructor(HEAP32[$2 + 52 >> 2], 79536) & 1)) {
            break label$34;
           }
           HEAP8[$2 + 63 | 0] = 1;
          }
         }
        }
        jsvUnLock3(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 52 >> 2], HEAP32[$2 + 188 >> 2]);
        HEAP32[$2 + 188 >> 2] = jsvNewFromBool(HEAP8[$2 + 63 | 0] & 1);
        break label$22;
       }
       HEAP32[$2 + 32 >> 2] = jsvMathsOpSkipNames(HEAP32[$2 + 188 >> 2], HEAP32[$2 + 164 >> 2], HEAP32[$2 + 176 >> 2]);
       jsvUnLock(HEAP32[$2 + 188 >> 2]);
       HEAP32[$2 + 188 >> 2] = HEAP32[$2 + 32 >> 2];
      }
     }
    }
    jsvUnLock(HEAP32[$2 + 164 >> 2]);
   }
   HEAP32[$2 + 180 >> 2] = jspeGetBinaryExpressionPrecedence(HEAP16[HEAP32[35539] + 2 >> 1]);
   continue;
  }
  break;
 }
 global$0 = $2 + 192 | 0;
 return HEAP32[$2 + 188 >> 2];
}
function tflite___28anonymous_20namespace_29__AllocationInfoBuilder__AddTensors_28tflite__SubGraph_20const__2c_20int_20const__2c_20TfLiteEvalTensor__29($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 112 | 0;
 global$0 = $4;
 HEAP32[$4 + 104 >> 2] = $0;
 HEAP32[$4 + 100 >> 2] = $1;
 HEAP32[$4 + 96 >> 2] = $2;
 HEAP32[$4 + 92 >> 2] = $3;
 $2 = HEAP32[$4 + 104 >> 2];
 label$1 : {
  if (!HEAP32[$4 + 92 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$4 + 88 >> 2] = 0;
 label$2 : {
  while (1) {
   if (HEAPU32[$4 + 88 >> 2] < HEAPU32[$2 + 8 >> 2]) {
    HEAP32[$4 + 84 >> 2] = HEAP32[$2 + 16 >> 2] + Math_imul(HEAP32[$4 + 88 >> 2], 24);
    HEAP32[HEAP32[$4 + 84 >> 2] + 4 >> 2] = HEAP32[$4 + 92 >> 2] + Math_imul(HEAP32[$4 + 88 >> 2], 12);
    HEAP32[$4 + 80 >> 2] = tflite__TfLiteEvalTensorByteLength_28TfLiteEvalTensor_20const__2c_20unsigned_20long__29(HEAP32[$4 + 92 >> 2] + Math_imul(HEAP32[$4 + 88 >> 2], 12) | 0, HEAP32[$4 + 84 >> 2]);
    if (HEAP32[$4 + 80 >> 2]) {
     HEAP32[$4 + 108 >> 2] = HEAP32[$4 + 80 >> 2];
     break label$2;
    }
    HEAP32[HEAP32[$4 + 84 >> 2] + 8 >> 2] = -1;
    HEAP32[HEAP32[$4 + 84 >> 2] + 12 >> 2] = -1;
    $0 = 0;
    if (!HEAP32[HEAP32[$4 + 92 >> 2] + Math_imul(HEAP32[$4 + 88 >> 2], 12) >> 2]) {
     $0 = tflite__Tensor__is_variable_28_29_20const(flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph__20___Get_28unsigned_20int_29_20const(tflite__Tensor__shape_28_29_20const(HEAP32[$4 + 100 >> 2]), HEAP32[$4 + 88 >> 2])) ^ -1;
    }
    HEAP8[HEAP32[$4 + 84 >> 2] + 20 | 0] = $0 & 1;
    label$7 : {
     if (HEAP32[$4 + 96 >> 2]) {
      HEAP32[HEAP32[$4 + 84 >> 2] + 16 >> 2] = HEAP32[HEAP32[$4 + 96 >> 2] + (HEAP32[$4 + 88 >> 2] << 2) >> 2];
      break label$7;
     }
     HEAP32[HEAP32[$4 + 84 >> 2] + 16 >> 2] = -1;
    }
    HEAP32[$4 + 88 >> 2] = HEAP32[$4 + 88 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$4 + 76 >> 2] = 0;
  while (1) {
   if (HEAPU32[$4 + 76 >> 2] < flatbuffers__Vector_int___size_28_29_20const(tflite__SubGraph__inputs_28_29_20const(HEAP32[$4 + 100 >> 2])) >>> 0) {
    HEAP32[$4 + 72 >> 2] = flatbuffers__Vector_int___Get_28unsigned_20int_29_20const(tflite__SubGraph__inputs_28_29_20const(HEAP32[$4 + 100 >> 2]), HEAP32[$4 + 76 >> 2]);
    HEAP32[$4 + 68 >> 2] = HEAP32[$2 + 16 >> 2] + Math_imul(HEAP32[$4 + 72 >> 2], 24);
    HEAP32[HEAP32[$4 + 68 >> 2] + 8 >> 2] = 0;
    HEAP32[$4 + 76 >> 2] = HEAP32[$4 + 76 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$4 + 64 >> 2] = 0;
  while (1) {
   if (HEAPU32[$4 + 64 >> 2] < flatbuffers__Vector_int___size_28_29_20const(tflite__Model__subgraphs_28_29_20const(HEAP32[$4 + 100 >> 2])) >>> 0) {
    HEAP32[$4 + 60 >> 2] = flatbuffers__Vector_int___Get_28unsigned_20int_29_20const(tflite__Model__subgraphs_28_29_20const(HEAP32[$4 + 100 >> 2]), HEAP32[$4 + 64 >> 2]);
    HEAP32[$4 + 56 >> 2] = HEAP32[$2 + 16 >> 2] + Math_imul(HEAP32[$4 + 60 >> 2], 24);
    $0 = flatbuffers__Vector_int___size_28_29_20const(tflite__SubGraph__operators_28_29_20const(HEAP32[$4 + 100 >> 2]));
    HEAP32[HEAP32[$4 + 56 >> 2] + 12 >> 2] = $0 - 1;
    HEAP32[$4 + 64 >> 2] = HEAP32[$4 + 64 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$4 + 52 >> 2] = flatbuffers__Vector_int___size_28_29_20const(tflite__SubGraph__operators_28_29_20const(HEAP32[$4 + 100 >> 2])) - 1;
  while (1) {
   if (HEAP32[$4 + 52 >> 2] >= 0) {
    HEAP32[$4 + 48 >> 2] = flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph__20___Get_28unsigned_20int_29_20const(tflite__SubGraph__operators_28_29_20const(HEAP32[$4 + 100 >> 2]), HEAP32[$4 + 52 >> 2]);
    HEAP32[$4 + 44 >> 2] = 0;
    while (1) {
     if (HEAPU32[$4 + 44 >> 2] < flatbuffers__Vector_int___size_28_29_20const(tflite__SubGraph__inputs_28_29_20const(HEAP32[$4 + 48 >> 2])) >>> 0) {
      HEAP32[$4 + 40 >> 2] = flatbuffers__Vector_int___Get_28unsigned_20int_29_20const(tflite__SubGraph__inputs_28_29_20const(HEAP32[$4 + 48 >> 2]), HEAP32[$4 + 44 >> 2]);
      HEAP32[$4 + 36 >> 2] = HEAP32[$2 + 16 >> 2] + Math_imul(HEAP32[$4 + 40 >> 2], 24);
      if (!(HEAP32[HEAP32[$4 + 36 >> 2] + 12 >> 2] >= HEAP32[$4 + 52 >> 2] ? HEAP32[HEAP32[$4 + 36 >> 2] + 12 >> 2] != -1 : 0)) {
       HEAP32[HEAP32[$4 + 36 >> 2] + 12 >> 2] = HEAP32[$4 + 52 >> 2];
      }
      HEAP32[$4 + 44 >> 2] = HEAP32[$4 + 44 >> 2] + 1;
      continue;
     }
     break;
    }
    HEAP32[$4 + 32 >> 2] = 0;
    while (1) {
     if (HEAPU32[$4 + 32 >> 2] < flatbuffers__Vector_int___size_28_29_20const(tflite__Model__subgraphs_28_29_20const(HEAP32[$4 + 48 >> 2])) >>> 0) {
      HEAP32[$4 + 28 >> 2] = flatbuffers__Vector_int___Get_28unsigned_20int_29_20const(tflite__Model__subgraphs_28_29_20const(HEAP32[$4 + 48 >> 2]), HEAP32[$4 + 32 >> 2]);
      HEAP32[$4 + 24 >> 2] = HEAP32[$2 + 16 >> 2] + Math_imul(HEAP32[$4 + 28 >> 2], 24);
      if (!(HEAP32[HEAP32[$4 + 24 >> 2] + 8 >> 2] <= HEAP32[$4 + 52 >> 2] ? HEAP32[HEAP32[$4 + 24 >> 2] + 8 >> 2] != -1 : 0)) {
       HEAP32[HEAP32[$4 + 24 >> 2] + 8 >> 2] = HEAP32[$4 + 52 >> 2];
      }
      HEAP32[$4 + 32 >> 2] = HEAP32[$4 + 32 >> 2] + 1;
      continue;
     }
     break;
    }
    HEAP32[$4 + 52 >> 2] = HEAP32[$4 + 52 >> 2] + -1;
    continue;
   }
   break;
  }
  HEAP32[$4 + 20 >> 2] = 0;
  while (1) {
   if (HEAPU32[$4 + 20 >> 2] < HEAPU32[$2 + 8 >> 2]) {
    HEAP32[$4 + 16 >> 2] = HEAP32[$2 + 16 >> 2] + Math_imul(HEAP32[$4 + 20 >> 2], 24);
    HEAP8[$4 + 15 | 0] = HEAP32[HEAP32[$4 + 16 >> 2] + 8 >> 2] == -1 ? HEAP32[HEAP32[$4 + 16 >> 2] + 12 >> 2] != -1 : 0;
    if (HEAP8[$4 + 15 | 0] & 1) {
     HEAP8[HEAP32[$4 + 16 >> 2] + 20 | 0] = 0;
    }
    HEAP8[$4 + 14 | 0] = (HEAP8[$4 + 15 | 0] & 1 ? 0 : HEAP32[HEAP32[$4 + 16 >> 2] + 8 >> 2] != -1 ? HEAP32[HEAP32[$4 + 16 >> 2] + 12 >> 2] == -1 : 1) & 1;
    if (!(!(HEAP8[$4 + 14 | 0] & 1) | !(HEAP8[HEAP32[$4 + 16 >> 2] + 20 | 0] & 1))) {
     $0 = HEAP32[$2 >> 2];
     $1 = HEAP32[$4 + 20 >> 2];
     $2 = HEAP32[HEAP32[$4 + 16 >> 2] + 8 >> 2];
     HEAP32[$4 + 8 >> 2] = HEAP32[HEAP32[$4 + 16 >> 2] + 12 >> 2];
     HEAP32[$4 + 4 >> 2] = $2;
     HEAP32[$4 >> 2] = $1;
     tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 133155, $4);
     HEAP32[$4 + 108 >> 2] = 1;
     break label$2;
    }
    HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 20 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$4 + 108 >> 2] = 0;
 }
 global$0 = $4 + 112 | 0;
 return HEAP32[$4 + 108 >> 2];
}
function ftoa_bounded_extra($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 96 | 0;
 global$0 = $5;
 HEAPF64[$5 + 88 >> 3] = $0;
 HEAP32[$5 + 84 >> 2] = $1;
 HEAP32[$5 + 80 >> 2] = $2;
 HEAP32[$5 + 76 >> 2] = $3;
 HEAP32[$5 + 72 >> 2] = $4;
 HEAPF64[$5 + 64 >> 3] = 1e-7;
 $1 = __DOUBLE_BITS(HEAPF64[$5 + 88 >> 3]);
 $2 = i64toi32_i32$HIGH_BITS & 2147483647;
 label$1 : {
  if (!(($2 | 0) == 2146435072 & $1 >>> 0 <= 0 | $2 >>> 0 < 2146435072)) {
   strcpy(HEAP32[$5 + 84 >> 2], 79458);
   break label$1;
  }
  $1 = __DOUBLE_BITS(HEAPF64[$5 + 88 >> 3]);
  $2 = i64toi32_i32$HIGH_BITS & 2147483647;
  label$4 : {
   if (($2 | 0) == 2146435072 & $1 >>> 0 >= 0 | $2 >>> 0 > 2146435072) {
    if (HEAPF64[$5 + 88 >> 3] < 0) {
     strcpy(HEAP32[$5 + 84 >> 2], 79462);
     break label$4;
    }
    strcpy(HEAP32[$5 + 84 >> 2], 79472);
    break label$4;
   }
   if (HEAPF64[$5 + 88 >> 3] < 0) {
    $1 = HEAP32[$5 + 80 >> 2] + -1 | 0;
    HEAP32[$5 + 80 >> 2] = $1;
    if ($1 >>> 0 <= 0) {
     HEAP8[HEAP32[$5 + 84 >> 2]] = 0;
     break label$1;
    }
    $1 = HEAP32[$5 + 84 >> 2];
    HEAP32[$5 + 84 >> 2] = $1 + 1;
    HEAP8[$1 | 0] = 45;
    HEAPF64[$5 + 88 >> 3] = -HEAPF64[$5 + 88 >> 3];
   }
   HEAP32[$5 + 60 >> 2] = 0;
   if (!(!(HEAPF64[$5 + 88 >> 3] > 0) | HEAP32[$5 + 76 >> 2] != 10)) {
    label$11 : {
     if (HEAPF64[$5 + 88 >> 3] >= 1e+21) {
      while (1) {
       if (HEAPF64[$5 + 88 >> 3] > 1e5) {
        HEAPF64[$5 + 88 >> 3] = HEAPF64[$5 + 88 >> 3] / 1e5;
        HEAP32[$5 + 60 >> 2] = HEAP32[$5 + 60 >> 2] + 5;
        continue;
       }
       break;
      }
      while (1) {
       if (HEAPF64[$5 + 88 >> 3] > 10) {
        HEAPF64[$5 + 88 >> 3] = HEAPF64[$5 + 88 >> 3] / 10;
        HEAP32[$5 + 60 >> 2] = HEAP32[$5 + 60 >> 2] + 1;
        continue;
       }
       break;
      }
      break label$11;
     }
     if (HEAPF64[$5 + 88 >> 3] < 1e-6) {
      while (1) {
       if (HEAPF64[$5 + 88 >> 3] < 1e-5) {
        HEAPF64[$5 + 88 >> 3] = HEAPF64[$5 + 88 >> 3] * 1e5;
        HEAP32[$5 + 60 >> 2] = HEAP32[$5 + 60 >> 2] - 5;
        continue;
       }
       break;
      }
      while (1) {
       if (HEAPF64[$5 + 88 >> 3] < 1) {
        HEAPF64[$5 + 88 >> 3] = HEAPF64[$5 + 88 >> 3] * 10;
        HEAP32[$5 + 60 >> 2] = HEAP32[$5 + 60 >> 2] + -1;
        continue;
       }
       break;
      }
     }
    }
   }
   $0 = HEAPF64[$5 + 88 >> 3] + 1e-7;
   label$22 : {
    if (Math_abs($0) < 2147483648) {
     $1 = ~~$0;
     break label$22;
    }
    $1 = -2147483648;
   }
   $0 = HEAPF64[$5 + 88 >> 3];
   label$24 : {
    if (Math_abs($0) < 2147483648) {
     $2 = ~~$0;
     break label$24;
    }
    $2 = -2147483648;
   }
   if (($1 | 0) == ($2 + 1 | 0)) {
    $1 = $5;
    $0 = HEAPF64[$5 + 88 >> 3];
    label$27 : {
     if (Math_abs($0) < 2147483648) {
      $2 = ~~$0;
      break label$27;
     }
     $2 = -2147483648;
    }
    HEAPF64[$1 + 88 >> 3] = $2 + 1 | 0;
   }
   HEAPF64[$5 + 48 >> 3] = 1;
   while (1) {
    if (HEAPF64[$5 + 48 >> 3] * +HEAP32[$5 + 76 >> 2] <= HEAPF64[$5 + 88 >> 3]) {
     HEAPF64[$5 + 48 >> 3] = HEAPF64[$5 + 48 >> 3] * +HEAP32[$5 + 76 >> 2];
     continue;
    }
    break;
   }
   while (1) {
    if (HEAPF64[$5 + 48 >> 3] >= 1) {
     $1 = $5;
     $0 = HEAPF64[$5 + 88 >> 3] / HEAPF64[$5 + 48 >> 3];
     label$33 : {
      if (Math_abs($0) < 2147483648) {
       $2 = ~~$0;
       break label$33;
      }
      $2 = -2147483648;
     }
     HEAP32[$1 + 44 >> 2] = $2;
     HEAPF64[$5 + 88 >> 3] = HEAPF64[$5 + 88 >> 3] - +HEAP32[$5 + 44 >> 2] * HEAPF64[$5 + 48 >> 3];
     $1 = HEAP32[$5 + 80 >> 2] + -1 | 0;
     HEAP32[$5 + 80 >> 2] = $1;
     if ($1 >>> 0 <= 0) {
      HEAP8[HEAP32[$5 + 84 >> 2]] = 0;
      break label$1;
     }
     $1 = itoch(HEAP32[$5 + 44 >> 2]);
     $2 = HEAP32[$5 + 84 >> 2];
     HEAP32[$5 + 84 >> 2] = $2 + 1;
     HEAP8[$2 | 0] = $1;
     HEAPF64[$5 + 48 >> 3] = HEAPF64[$5 + 48 >> 3] / +HEAP32[$5 + 76 >> 2];
     continue;
    }
    break;
   }
   if (!(HEAP32[$5 + 72 >> 2] <= 0 ? !(HEAPF64[$5 + 88 >> 3] > 0 ? HEAP32[$5 + 72 >> 2] < 0 : 0) : 0)) {
    HEAP8[$5 + 43 | 0] = 0;
    HEAPF64[$5 + 88 >> 3] = HEAPF64[$5 + 88 >> 3] * +HEAP32[$5 + 76 >> 2];
    while (1) {
     label$40 : {
      if (!(HEAP32[$5 + 72 >> 2] <= -12 | HEAP32[$5 + 72 >> 2] >= 0)) {
       $1 = 1;
       if (HEAPF64[$5 + 88 >> 3] > 1e-7) {
        break label$40;
       }
      }
      $1 = HEAP32[$5 + 72 >> 2] > 0;
     }
     if ($1) {
      $1 = $5;
      $0 = HEAPF64[$5 + 88 >> 3] + (HEAP32[$5 + 72 >> 2] == 1 ? .5 : 1e-8);
      label$43 : {
       if (Math_abs($0) < 2147483648) {
        $2 = ~~$0;
        break label$43;
       }
       $2 = -2147483648;
      }
      HEAP32[$1 + 36 >> 2] = $2;
      HEAPF64[$5 + 88 >> 3] = (HEAPF64[$5 + 88 >> 3] - +HEAP32[$5 + 36 >> 2]) * +HEAP32[$5 + 76 >> 2];
      if (HEAP32[$5 + 36 >> 2] == HEAP32[$5 + 76 >> 2]) {
       HEAP32[$5 + 36 >> 2] = HEAP32[$5 + 76 >> 2] - 1;
      }
      if (!(HEAP8[$5 + 43 | 0] & 1)) {
       HEAP8[$5 + 43 | 0] = 1;
       $1 = HEAP32[$5 + 80 >> 2] + -1 | 0;
       HEAP32[$5 + 80 >> 2] = $1;
       if ($1 >>> 0 <= 0) {
        HEAP8[HEAP32[$5 + 84 >> 2]] = 0;
        break label$1;
       }
       $1 = HEAP32[$5 + 84 >> 2];
       HEAP32[$5 + 84 >> 2] = $1 + 1;
       HEAP8[$1 | 0] = 46;
      }
      $1 = HEAP32[$5 + 80 >> 2] + -1 | 0;
      HEAP32[$5 + 80 >> 2] = $1;
      if ($1 >>> 0 <= 0) {
       HEAP8[HEAP32[$5 + 84 >> 2]] = 0;
       break label$1;
      }
      $1 = itoch(HEAP32[$5 + 36 >> 2]);
      $2 = HEAP32[$5 + 84 >> 2];
      HEAP32[$5 + 84 >> 2] = $2 + 1;
      HEAP8[$2 | 0] = $1;
      HEAP32[$5 + 72 >> 2] = HEAP32[$5 + 72 >> 2] + -1;
      continue;
     }
     break;
    }
   }
   if (!(!HEAP32[$5 + 60 >> 2] | HEAPU32[$5 + 80 >> 2] <= 5)) {
    $1 = HEAP32[$5 + 84 >> 2];
    HEAP32[$5 + 84 >> 2] = $1 + 1;
    HEAP8[$1 | 0] = 101;
    if (HEAP32[$5 + 60 >> 2] > 0) {
     $1 = HEAP32[$5 + 84 >> 2];
     HEAP32[$5 + 84 >> 2] = $1 + 1;
     HEAP8[$1 | 0] = 43;
    }
    itostr(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 84 >> 2], 10);
    break label$1;
   }
   $1 = HEAP32[$5 + 84 >> 2];
   HEAP32[$5 + 84 >> 2] = $1 + 1;
   HEAP8[$1 | 0] = 0;
  }
 }
 global$0 = $5 + 96 | 0;
}
function jswrap_string_replace($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $3 = global$0 - 224 | 0;
 global$0 = $3;
 HEAP32[$3 + 216 >> 2] = $0;
 HEAP32[$3 + 212 >> 2] = $1;
 HEAP32[$3 + 208 >> 2] = $2;
 HEAP32[$3 + 204 >> 2] = jsvAsString(HEAP32[$3 + 216 >> 2]);
 label$1 : {
  if (jsvIsInstanceOf(HEAP32[$3 + 212 >> 2], 126e3) & 1) {
   label$3 : {
    label$4 : {
     if (!(jsvIsFunction(HEAP32[$3 + 208 >> 2]) & 1)) {
      if (!(jsvIsString(HEAP32[$3 + 208 >> 2]) & 1)) {
       break label$4;
      }
     }
     HEAP32[$3 + 200 >> 2] = jsvLockAgain(HEAP32[$3 + 208 >> 2]);
     break label$3;
    }
    HEAP32[$3 + 200 >> 2] = jsvAsString(HEAP32[$3 + 208 >> 2]);
   }
   $0 = $3 + 152 | 0;
   jsvObjectSetChildAndUnLock(HEAP32[$3 + 212 >> 2], 126007, jsvNewFromInteger(0));
   HEAP8[$3 + 199 | 0] = jswrap_regexp_hasFlag(HEAP32[$3 + 212 >> 2], 103) & 1;
   HEAP32[$3 + 192 >> 2] = jsvNewWithFlags(27);
   jsvStringIteratorNew($0, HEAP32[$3 + 192 >> 2], 0);
   HEAP32[$3 + 148 >> 2] = 0;
   HEAP32[$3 + 144 >> 2] = jswrap_regexp_exec(HEAP32[$3 + 212 >> 2], HEAP32[$3 + 204 >> 2]);
   while (1) {
    $0 = 0;
    label$7 : {
     if (!HEAP32[$3 + 144 >> 2]) {
      break label$7;
     }
     $1 = jsvIsNull(HEAP32[$3 + 144 >> 2]) & 1;
     $0 = 0;
     if ($1) {
      break label$7;
     }
     $0 = jspIsInterrupted() ^ -1;
    }
    if ($0 & 1) {
     $0 = $3 + 152 | 0;
     HEAP32[$3 + 140 >> 2] = jsvGetArrayItem(HEAP32[$3 + 144 >> 2], 0);
     HEAP32[$3 + 136 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$3 + 144 >> 2], 126017, 0));
     HEAP32[$3 + 132 >> 2] = jsvGetStringLength(HEAP32[$3 + 140 >> 2]);
     jsvStringIteratorAppendString($0, HEAP32[$3 + 204 >> 2], HEAP32[$3 + 148 >> 2], HEAP32[$3 + 136 >> 2] - HEAP32[$3 + 148 >> 2] | 0);
     label$9 : {
      if (jsvIsFunction(HEAP32[$3 + 200 >> 2]) & 1) {
       $0 = $3 - -64 | 0;
       HEAP32[$3 + 128 >> 2] = 0;
       $1 = jsvLockAgain(HEAP32[$3 + 140 >> 2]);
       $2 = HEAP32[$3 + 128 >> 2];
       HEAP32[$3 + 128 >> 2] = $2 + 1;
       HEAP32[$0 + ($2 << 2) >> 2] = $1;
       while (1) {
        $0 = jsvGetArrayItem(HEAP32[$3 + 144 >> 2], HEAP32[$3 + 128 >> 2]);
        HEAP32[$3 + 60 >> 2] = $0;
        if ($0) {
         $0 = HEAP32[$3 + 60 >> 2];
         $1 = HEAP32[$3 + 128 >> 2];
         HEAP32[$3 + 128 >> 2] = $1 + 1;
         HEAP32[($3 - -64 | 0) + ($1 << 2) >> 2] = $0;
         continue;
        }
        break;
       }
       $1 = $3 + 152 | 0;
       $0 = $3 - -64 | 0;
       $2 = jsvObjectGetChild(HEAP32[$3 + 144 >> 2], 126017, 0);
       $4 = HEAP32[$3 + 128 >> 2];
       HEAP32[$3 + 128 >> 2] = $4 + 1;
       HEAP32[$0 + ($4 << 2) >> 2] = $2;
       $2 = jsvObjectGetChild(HEAP32[$3 + 144 >> 2], 126023, 0);
       $4 = HEAP32[$3 + 128 >> 2];
       HEAP32[$3 + 128 >> 2] = $4 + 1;
       HEAP32[$0 + ($4 << 2) >> 2] = $2;
       HEAP32[$3 + 56 >> 2] = jsvAsStringAndUnLock(jspeFunctionCall(HEAP32[$3 + 200 >> 2], 0, 0, 0, HEAP32[$3 + 128 >> 2], $0));
       jsvUnLockMany(HEAP32[$3 + 128 >> 2], $0);
       jsvStringIteratorAppendString($1, HEAP32[$3 + 56 >> 2], 0, 2147483647);
       jsvUnLock(HEAP32[$3 + 56 >> 2]);
       break label$9;
      }
      jsvStringIteratorNew($3 + 16 | 0, HEAP32[$3 + 200 >> 2], 0);
      while (1) {
       if (jsvStringIteratorHasChar($3 + 16 | 0) & 1) {
        HEAP8[$3 + 15 | 0] = jsvStringIteratorGetCharAndNext($3 + 16 | 0);
        label$15 : {
         if (HEAP8[$3 + 15 | 0] == 36) {
          HEAP8[$3 + 15 | 0] = jsvStringIteratorGetCharAndNext($3 + 16 | 0);
          HEAP32[$3 + 8 >> 2] = 0;
          if (!(HEAP8[$3 + 15 | 0] <= 48 | HEAP8[$3 + 15 | 0] > 57)) {
           HEAP32[$3 + 8 >> 2] = jsvGetArrayItem(HEAP32[$3 + 144 >> 2], HEAP8[$3 + 15 | 0] - 48 | 0);
          }
          label$18 : {
           if (HEAP32[$3 + 8 >> 2]) {
            jsvStringIteratorAppendString($3 + 152 | 0, HEAP32[$3 + 8 >> 2], 0, 2147483647);
            jsvUnLock(HEAP32[$3 + 8 >> 2]);
            break label$18;
           }
           $0 = $3 + 152 | 0;
           jsvStringIteratorAppend($0, 36);
           jsvStringIteratorAppend($0, HEAP8[$3 + 15 | 0]);
          }
          break label$15;
         }
         jsvStringIteratorAppend($3 + 152 | 0, HEAP8[$3 + 15 | 0]);
        }
        continue;
       }
       break;
      }
      jsvStringIteratorFree($3 + 16 | 0);
     }
     HEAP32[$3 + 148 >> 2] = HEAP32[$3 + 136 >> 2] + HEAP32[$3 + 132 >> 2];
     jsvUnLock(HEAP32[$3 + 140 >> 2]);
     jsvUnLock(HEAP32[$3 + 144 >> 2]);
     HEAP32[$3 + 144 >> 2] = 0;
     if (HEAP8[$3 + 199 | 0] & 1) {
      jsvObjectSetChildAndUnLock(HEAP32[$3 + 212 >> 2], 126007, jsvNewFromInteger(HEAP32[$3 + 148 >> 2] + (HEAP32[$3 + 132 >> 2] ? 0 : 1) | 0));
      HEAP32[$3 + 144 >> 2] = jswrap_regexp_exec(HEAP32[$3 + 212 >> 2], HEAP32[$3 + 204 >> 2]);
     }
     continue;
    }
    break;
   }
   $0 = $3 + 152 | 0;
   jsvStringIteratorAppendString($0, HEAP32[$3 + 204 >> 2], HEAP32[$3 + 148 >> 2], 2147483647);
   jsvStringIteratorFree($0);
   jsvUnLock3(HEAP32[$3 + 144 >> 2], HEAP32[$3 + 200 >> 2], HEAP32[$3 + 204 >> 2]);
   if (HEAP8[$3 + 199 | 0] & 1) {
    jsvObjectSetChildAndUnLock(HEAP32[$3 + 212 >> 2], 126007, jsvNewFromInteger(0));
   }
   HEAP32[$3 + 220 >> 2] = HEAP32[$3 + 192 >> 2];
   break label$1;
  }
  HEAP32[$3 + 208 >> 2] = jsvAsString(HEAP32[$3 + 208 >> 2]);
  HEAP32[$3 + 212 >> 2] = jsvAsString(HEAP32[$3 + 212 >> 2]);
  HEAP32[$3 + 4 >> 2] = jswrap_string_indexOf(HEAP32[$3 + 216 >> 2], HEAP32[$3 + 212 >> 2], 0, 0);
  if (HEAP32[$3 + 4 >> 2] >= 0) {
   HEAP32[$3 >> 2] = jsvNewFromStringVar(HEAP32[$3 + 204 >> 2], 0, HEAP32[$3 + 4 >> 2]);
   jsvAppendStringVar(HEAP32[$3 >> 2], HEAP32[$3 + 208 >> 2], 0, 2147483647);
   jsvAppendStringVar(HEAP32[$3 >> 2], HEAP32[$3 + 204 >> 2], HEAP32[$3 + 4 >> 2] + jsvGetStringLength(HEAP32[$3 + 212 >> 2]) | 0, 2147483647);
   jsvUnLock(HEAP32[$3 + 204 >> 2]);
   HEAP32[$3 + 204 >> 2] = HEAP32[$3 >> 2];
  }
  jsvUnLock2(HEAP32[$3 + 212 >> 2], HEAP32[$3 + 208 >> 2]);
  HEAP32[$3 + 220 >> 2] = HEAP32[$3 + 204 >> 2];
 }
 global$0 = $3 + 224 | 0;
 return HEAP32[$3 + 220 >> 2];
}
function graphicsFillPoly($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 288 | 0;
 global$0 = $3;
 HEAP32[$3 + 284 >> 2] = $0;
 HEAP32[$3 + 280 >> 2] = $1;
 HEAP32[$3 + 276 >> 2] = $2;
 HEAP32[$3 + 272 >> 2] = HEAP32[$3 + 276 >> 2];
 $0 = HEAP32[$3 + 284 >> 2];
 HEAP32[$3 + 256 >> 2] = (HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8) - 1;
 HEAP32[$3 + 252 >> 2] = 0;
 HEAP32[$3 + 268 >> 2] = 0;
 while (1) {
  if (HEAP32[$3 + 268 >> 2] < HEAP32[$3 + 280 >> 2]) {
   HEAP32[$3 + 248 >> 2] = HEAP16[HEAP32[$3 + 272 >> 2] + (HEAP32[$3 + 268 >> 2] << 2) >> 1];
   HEAP32[$3 + 244 >> 2] = HEAP16[(HEAP32[$3 + 272 >> 2] + (HEAP32[$3 + 268 >> 2] << 2) | 0) + 2 >> 1];
   graphicsToDeviceCoordinates16x(HEAP32[$3 + 284 >> 2], $3 + 248 | 0, $3 + 244 | 0);
   HEAP16[HEAP32[$3 + 272 >> 2] + (HEAP32[$3 + 268 >> 2] << 2) >> 1] = HEAP32[$3 + 248 >> 2];
   HEAP16[(HEAP32[$3 + 272 >> 2] + (HEAP32[$3 + 268 >> 2] << 2) | 0) + 2 >> 1] = HEAP32[$3 + 244 >> 2];
   HEAP16[$3 + 242 >> 1] = HEAP16[(HEAP32[$3 + 272 >> 2] + (HEAP32[$3 + 268 >> 2] << 2) | 0) + 2 >> 1] >> 4;
   if (HEAP16[$3 + 242 >> 1] < HEAP32[$3 + 256 >> 2]) {
    HEAP32[$3 + 256 >> 2] = HEAP16[$3 + 242 >> 1];
   }
   if (HEAP16[$3 + 242 >> 1] > HEAP32[$3 + 252 >> 2]) {
    HEAP32[$3 + 252 >> 2] = HEAP16[$3 + 242 >> 1];
   }
   HEAP32[$3 + 268 >> 2] = HEAP32[$3 + 268 >> 2] + 1;
   continue;
  }
  break;
 }
 $0 = HEAP32[$3 + 284 >> 2];
 if (HEAP32[$3 + 256 >> 2] < (HEAPU8[$0 + 34 | 0] | HEAPU8[$0 + 35 | 0] << 8)) {
  $0 = HEAP32[$3 + 284 >> 2];
  HEAP32[$3 + 256 >> 2] = HEAPU8[$0 + 34 | 0] | HEAPU8[$0 + 35 | 0] << 8;
 }
 $0 = HEAP32[$3 + 284 >> 2];
 if (HEAP32[$3 + 252 >> 2] > (HEAPU8[$0 + 38 | 0] | HEAPU8[$0 + 39 | 0] << 8)) {
  $0 = HEAP32[$3 + 284 >> 2];
  HEAP32[$3 + 252 >> 2] = HEAPU8[$0 + 38 | 0] | HEAPU8[$0 + 39 | 0] << 8;
 }
 HEAP32[$3 + 236 >> 2] = 64;
 HEAP32[$3 + 260 >> 2] = HEAP32[$3 + 256 >> 2] << 4;
 while (1) {
  if (HEAP32[$3 + 260 >> 2] <= HEAP32[$3 + 252 >> 2] << 4) {
   HEAP32[$3 + 232 >> 2] = HEAP32[$3 + 260 >> 2] >> 4;
   HEAP32[$3 + 28 >> 2] = 0;
   HEAP32[$3 + 264 >> 2] = HEAP32[$3 + 280 >> 2] - 1;
   HEAP32[$3 + 268 >> 2] = 0;
   while (1) {
    if (HEAP32[$3 + 268 >> 2] < HEAP32[$3 + 280 >> 2]) {
     if (!(HEAP16[(HEAP32[$3 + 272 >> 2] + (HEAP32[$3 + 268 >> 2] << 2) | 0) + 2 >> 1] <= HEAP32[$3 + 260 >> 2] | HEAP16[(HEAP32[$3 + 272 >> 2] + (HEAP32[$3 + 264 >> 2] << 2) | 0) + 2 >> 1] > HEAP32[$3 + 260 >> 2] ? !(HEAP16[(HEAP32[$3 + 272 >> 2] + (HEAP32[$3 + 264 >> 2] << 2) | 0) + 2 >> 1] > HEAP32[$3 + 260 >> 2] ? HEAP16[(HEAP32[$3 + 272 >> 2] + (HEAP32[$3 + 268 >> 2] << 2) | 0) + 2 >> 1] <= HEAP32[$3 + 260 >> 2] : 0) : 0)) {
      if (HEAP32[$3 + 28 >> 2] < 64) {
       HEAP32[$3 + 24 >> 2] = HEAP16[(HEAP32[$3 + 272 >> 2] + (HEAP32[$3 + 264 >> 2] << 2) | 0) + 2 >> 1] - HEAP16[(HEAP32[$3 + 272 >> 2] + (HEAP32[$3 + 268 >> 2] << 2) | 0) + 2 >> 1];
       if (HEAP32[$3 + 24 >> 2]) {
        HEAP16[($3 + 96 | 0) + (HEAP32[$3 + 28 >> 2] << 1) >> 1] = HEAP16[HEAP32[$3 + 272 >> 2] + (HEAP32[$3 + 268 >> 2] << 2) >> 1] + ((Math_imul(HEAP32[$3 + 260 >> 2] - HEAP16[(HEAP32[$3 + 272 >> 2] + (HEAP32[$3 + 268 >> 2] << 2) | 0) + 2 >> 1] | 0, HEAP16[HEAP32[$3 + 272 >> 2] + (HEAP32[$3 + 264 >> 2] << 2) >> 1] - HEAP16[HEAP32[$3 + 272 >> 2] + (HEAP32[$3 + 268 >> 2] << 2) >> 1] | 0) | 0) / HEAP32[$3 + 24 >> 2] | 0);
        HEAP8[HEAP32[$3 + 28 >> 2] + ($3 + 32 | 0) | 0] = ((HEAP32[$3 + 24 >> 2] > 1 ? 1 : 0) | 0) != 0;
        HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 28 >> 2] + 1;
       }
      }
     }
     HEAP32[$3 + 264 >> 2] = HEAP32[$3 + 268 >> 2];
     HEAP32[$3 + 268 >> 2] = HEAP32[$3 + 268 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$3 + 268 >> 2] = 0;
   while (1) {
    if (HEAP32[$3 + 268 >> 2] < (HEAP32[$3 + 28 >> 2] - 1 | 0)) {
     $0 = $3 + 96 | 0;
     if (HEAP16[$0 + (HEAP32[$3 + 268 >> 2] << 1) >> 1] > HEAP16[$0 + (HEAP32[$3 + 268 >> 2] + 1 << 1) >> 1]) {
      $0 = $3 + 96 | 0;
      HEAP16[$3 + 22 >> 1] = HEAPU16[$0 + (HEAP32[$3 + 268 >> 2] << 1) >> 1];
      HEAP16[$0 + (HEAP32[$3 + 268 >> 2] << 1) >> 1] = HEAPU16[$0 + (HEAP32[$3 + 268 >> 2] + 1 << 1) >> 1];
      HEAP16[$0 + (HEAP32[$3 + 268 >> 2] + 1 << 1) >> 1] = HEAPU16[$3 + 22 >> 1];
      $0 = $3 + 32 | 0;
      HEAP8[$3 + 21 | 0] = HEAP8[$0 + HEAP32[$3 + 268 >> 2] | 0] & 1;
      HEAP8[$0 + HEAP32[$3 + 268 >> 2] | 0] = HEAP8[$0 + (HEAP32[$3 + 268 >> 2] + 1 | 0) | 0] & 1;
      HEAP8[$0 + (HEAP32[$3 + 268 >> 2] + 1 | 0) | 0] = HEAP8[$3 + 21 | 0] & 1;
      if (HEAP32[$3 + 268 >> 2]) {
       HEAP32[$3 + 268 >> 2] = HEAP32[$3 + 268 >> 2] + -1;
      }
      continue;
     }
     HEAP32[$3 + 268 >> 2] = HEAP32[$3 + 268 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$3 + 16 >> 2] = 0;
   HEAP32[$3 + 12 >> 2] = 0;
   HEAP32[$3 + 268 >> 2] = 0;
   while (1) {
    label$21 : {
     if (HEAP32[$3 + 268 >> 2] >= HEAP32[$3 + 28 >> 2]) {
      break label$21;
     }
     if (!HEAP32[$3 + 12 >> 2]) {
      HEAP32[$3 + 16 >> 2] = HEAP16[($3 + 96 | 0) + (HEAP32[$3 + 268 >> 2] << 1) >> 1];
     }
     label$23 : {
      if (HEAP8[HEAP32[$3 + 268 >> 2] + ($3 + 32 | 0) | 0] & 1) {
       HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + 1;
       break label$23;
      }
      HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + -1;
     }
     if (!(HEAP32[$3 + 268 >> 2] != (HEAP32[$3 + 28 >> 2] - 1 | 0) ? HEAP32[$3 + 12 >> 2] : 0)) {
      HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 16 >> 2] + 15 >> 4;
      HEAP32[$3 + 4 >> 2] = HEAP16[($3 + 96 | 0) + (HEAP32[$3 + 268 >> 2] << 1) >> 1] + 15 >> 4;
      if (HEAP32[$3 + 4 >> 2] > HEAP32[$3 + 8 >> 2]) {
       $0 = HEAP32[$3 + 284 >> 2];
       graphicsFillRectDevice(HEAP32[$3 + 284 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 232 >> 2], HEAP32[$3 + 4 >> 2] - 1 | 0, HEAP32[$3 + 232 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
      }
     }
     if (jspIsInterrupted() & 1) {
      break label$21;
     }
     HEAP32[$3 + 268 >> 2] = HEAP32[$3 + 268 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$3 + 260 >> 2] = HEAP32[$3 + 260 >> 2] + 16;
   continue;
  }
  break;
 }
 global$0 = $3 + 288 | 0;
}
function jsiDebuggerLine($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 192 | 0;
 global$0 = $1;
 HEAP32[$1 + 188 >> 2] = $0;
 HEAP32[$1 + 60 >> 2] = jslSetLex($1 - -64 | 0);
 jslInit(HEAP32[$1 + 188 >> 2]);
 HEAP8[$1 + 59 | 0] = 0;
 if (!(HEAP16[$1 + 66 >> 1] != 169 ? HEAP16[$1 + 66 >> 1] != 128 : 0)) {
  HEAP8[$1 + 59 | 0] = 1;
  HEAP32[$1 + 52 >> 2] = jslGetTokenValueAsString();
  label$3 : {
   label$4 : {
    if (strcmp(HEAP32[$1 + 52 >> 2], 82308)) {
     if (strcmp(HEAP32[$1 + 52 >> 2], 82313)) {
      break label$4;
     }
    }
    jsiConsolePrintString(82315);
    break label$3;
   }
   label$6 : {
    label$7 : {
     if (strcmp(HEAP32[$1 + 52 >> 2], 82834)) {
      if (strcmp(HEAP32[$1 + 52 >> 2], 82839)) {
       break label$7;
      }
     }
     HEAP16[161112] = HEAPU16[161112] | 16;
     HEAP32[80549] = HEAP32[80549] | 16;
     break label$6;
    }
    label$9 : {
     if (!strcmp(HEAP32[$1 + 52 >> 2], 82841)) {
      HEAP16[161112] = HEAPU16[161112] & -225 | 144;
      HEAP32[80549] = HEAP32[80549] | 16;
      break label$9;
     }
     label$11 : {
      label$12 : {
       if (strcmp(HEAP32[$1 + 52 >> 2], 82847)) {
        if (strcmp(HEAP32[$1 + 52 >> 2], 82856)) {
         break label$12;
        }
       }
       HEAP16[161112] = HEAPU16[161112] | 16;
       break label$11;
      }
      label$14 : {
       label$15 : {
        if (strcmp(HEAP32[$1 + 52 >> 2], 82858)) {
         if (strcmp(HEAP32[$1 + 52 >> 2], 82863)) {
          break label$15;
         }
        }
        HEAP16[161112] = HEAPU16[161112] | 16;
        HEAP32[80549] = HEAP32[80549] | 8192;
        break label$14;
       }
       label$17 : {
        label$18 : {
         if (strcmp(HEAP32[$1 + 52 >> 2], 82865)) {
          if (strcmp(HEAP32[$1 + 52 >> 2], 82870)) {
           break label$18;
          }
         }
         HEAP16[161112] = HEAPU16[161112] | 16;
         HEAP32[80549] = HEAP32[80549] | 24576;
         break label$17;
        }
        label$20 : {
         label$21 : {
          if (strcmp(HEAP32[$1 + 52 >> 2], 82872)) {
           if (strcmp(HEAP32[$1 + 52 >> 2], 82879)) {
            break label$21;
           }
          }
          HEAP16[161112] = HEAPU16[161112] | 16;
          HEAP32[80549] = HEAP32[80549] | 32768;
          break label$20;
         }
         label$23 : {
          label$24 : {
           if (strcmp(HEAP32[$1 + 52 >> 2], 82881)) {
            if (strcmp(HEAP32[$1 + 52 >> 2], 82887)) {
             break label$24;
            }
           }
           $0 = $1 + 32 | 0;
           jslGetNextToken();
           HEAP32[$0 + 16 >> 2] = HEAP32[80549];
           $2 = HEAP32[80548];
           HEAP32[$0 + 8 >> 2] = HEAP32[80547];
           HEAP32[$0 + 12 >> 2] = $2;
           $2 = HEAP32[80546];
           HEAP32[$0 >> 2] = HEAP32[80545];
           HEAP32[$0 + 4 >> 2] = $2;
           HEAP32[80549] = 1;
           HEAP32[$1 + 28 >> 2] = jsvSkipNameAndUnLock(jspParse());
           $2 = HEAP32[$0 + 4 >> 2];
           HEAP32[80545] = HEAP32[$0 >> 2];
           HEAP32[80546] = $2;
           HEAP32[80549] = HEAP32[$0 + 16 >> 2];
           $2 = HEAP32[$0 + 12 >> 2];
           HEAP32[80547] = HEAP32[$0 + 8 >> 2];
           HEAP32[80548] = $2;
           jsiConsolePrintChar(61);
           jsfPrintJSON(HEAP32[$1 + 28 >> 2], 301);
           jsiConsolePrintString(81553);
           jsvUnLock(HEAP32[$1 + 28 >> 2]);
           break label$23;
          }
          label$26 : {
           label$27 : {
            if (strcmp(HEAP32[$1 + 52 >> 2], 82889)) {
             if (strcmp(HEAP32[$1 + 52 >> 2], 82894)) {
              break label$27;
             }
            }
            jslGetNextToken();
            HEAP32[$1 + 52 >> 2] = jslGetTokenValueAsString();
            label$29 : {
             label$30 : {
              if (strcmp(HEAP32[$1 + 52 >> 2], 82896)) {
               if (strcmp(HEAP32[$1 + 52 >> 2], 82903)) {
                break label$30;
               }
              }
              HEAP32[$1 + 24 >> 2] = jspeiGetTopScope();
              label$32 : {
               if (HEAP32[$1 + 24 >> 2] == HEAP32[80545]) {
                jsiConsolePrintString(82905);
                break label$32;
               }
               jsiConsolePrintf(82922, 0);
               jsiDebuggerPrintScope(HEAP32[$1 + 24 >> 2]);
               jsiConsolePrintString(81737);
              }
              jsvUnLock(HEAP32[$1 + 24 >> 2]);
              break label$29;
             }
             label$34 : {
              label$35 : {
               if (strcmp(HEAP32[$1 + 52 >> 2], 82964)) {
                if (strcmp(HEAP32[$1 + 52 >> 2], 82870)) {
                 break label$35;
                }
               }
               HEAP32[$1 + 20 >> 2] = jspeiGetTopScope();
               if (HEAP32[$1 + 20 >> 2] == HEAP32[80545]) {
                jsiConsolePrintString(82975);
               }
               jsvUnLock(HEAP32[$1 + 20 >> 2]);
               HEAP32[$1 + 12 >> 2] = jsvGetArrayLength(HEAP32[80547]);
               HEAP32[$1 + 16 >> 2] = 0;
               while (1) {
                if (HEAP32[$1 + 16 >> 2] < HEAP32[$1 + 12 >> 2]) {
                 HEAP32[$1 + 20 >> 2] = jsvGetArrayItem(HEAP32[80547], HEAP32[$1 + 16 >> 2]);
                 HEAP32[$1 >> 2] = HEAP32[$1 + 16 >> 2];
                 jsiConsolePrintf(82992, $1);
                 jsiDebuggerPrintScope(HEAP32[$1 + 20 >> 2]);
                 jsiConsolePrintString(81737);
                 jsvUnLock(HEAP32[$1 + 20 >> 2]);
                 HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 16 >> 2] + 1;
                 continue;
                }
                break;
               }
               break label$34;
              }
              jsiConsolePrintString(83036);
             }
            }
            break label$26;
           }
           HEAP8[$1 + 59 | 0] = 0;
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
 if (!(HEAP8[$1 + 59 | 0] & 1)) {
  jsiConsolePrintString(83053);
 }
 jslKill();
 jslSetLex(HEAP32[$1 + 60 >> 2]);
 global$0 = $1 + 192 | 0;
}
function matchcharacter($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 48 | 0;
 global$0 = $4;
 HEAP32[$4 + 40 >> 2] = $0;
 HEAP32[$4 + 36 >> 2] = $1;
 HEAP32[$4 + 32 >> 2] = $2;
 HEAP32[$4 + 28 >> 2] = $3;
 HEAP32[HEAP32[$4 + 32 >> 2] >> 2] = 1;
 HEAP8[$4 + 27 | 0] = jsvStringIteratorGetChar(HEAP32[$4 + 36 >> 2]);
 label$1 : {
  if (HEAP8[HEAP32[$4 + 40 >> 2]] == 46) {
   HEAP8[$4 + 47 | 0] = 1;
   break label$1;
  }
  if (HEAP8[HEAP32[$4 + 40 >> 2]] == 91) {
   HEAP8[HEAP32[$4 + 28 >> 2] + 9 | 0] = 1;
   HEAP8[$4 + 26 | 0] = HEAP8[HEAP32[$4 + 40 >> 2] + 1 | 0] == 94;
   if (HEAP8[$4 + 26 | 0] & 1) {
    $0 = HEAP32[$4 + 32 >> 2];
    HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
   }
   HEAP8[$4 + 25 | 0] = 0;
   while (1) {
    if (HEAP8[HEAP32[$4 + 40 >> 2] + HEAP32[HEAP32[$4 + 32 >> 2] >> 2] | 0] ? HEAP8[HEAP32[$4 + 40 >> 2] + HEAP32[HEAP32[$4 + 32 >> 2] >> 2] | 0] != 93 : 0) {
     if (HEAP8[HEAP32[$4 + 40 >> 2] + HEAP32[HEAP32[$4 + 32 >> 2] >> 2] | 0] == 46) {
      HEAP8[$4 + 25 | 0] = (HEAP8[$4 + 25 | 0] & 1 | HEAP8[$4 + 27 | 0] == 46) != 0;
      $0 = HEAP32[$4 + 32 >> 2];
      HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
      continue;
     }
     HEAP8[$4 + 25 | 0] = (matchcharacter(HEAP32[$4 + 40 >> 2] + HEAP32[HEAP32[$4 + 32 >> 2] >> 2] | 0, HEAP32[$4 + 36 >> 2], $4 + 20 | 0, HEAP32[$4 + 28 >> 2]) & 1 | HEAP8[$4 + 25 | 0] & 1) != 0;
     $0 = HEAP32[$4 + 32 >> 2];
     HEAP32[$0 >> 2] = HEAP32[$4 + 20 >> 2] + HEAP32[$0 >> 2];
     continue;
    }
    break;
   }
   label$10 : {
    if (HEAP8[HEAP32[$4 + 40 >> 2] + HEAP32[HEAP32[$4 + 32 >> 2] >> 2] | 0] == 93) {
     $0 = HEAP32[$4 + 32 >> 2];
     HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
     break label$10;
    }
    jsExceptionHere(1, 125258, 0);
    HEAP8[$4 + 47 | 0] = 0;
    break label$1;
   }
   HEAP8[HEAP32[$4 + 28 >> 2] + 9 | 0] = 0;
   HEAP8[$4 + 47 | 0] = (HEAP8[$4 + 25 | 0] & 1) != (HEAP8[$4 + 26 | 0] & 1);
   break label$1;
  }
  HEAP8[$4 + 19 | 0] = HEAPU8[HEAP32[$4 + 40 >> 2]];
  label$12 : {
   if (HEAP8[$4 + 19 | 0] != 92) {
    break label$12;
   }
   HEAP32[HEAP32[$4 + 32 >> 2] >> 2] = 2;
   HEAP8[$4 + 19 | 0] = HEAPU8[HEAP32[$4 + 40 >> 2] + 1 | 0];
   if (HEAP8[$4 + 19 | 0] == 100) {
    HEAP8[$4 + 47 | 0] = isNumeric(HEAP8[$4 + 27 | 0]) & 1;
    break label$1;
   }
   if (HEAP8[$4 + 19 | 0] == 68) {
    HEAP8[$4 + 47 | 0] = (isNumeric(HEAP8[$4 + 27 | 0]) ^ -1) & 1;
    break label$1;
   }
   if (HEAP8[$4 + 19 | 0] == 102) {
    HEAP8[$4 + 19 | 0] = 12;
    break label$12;
   }
   if (HEAP8[$4 + 19 | 0] == 98) {
    HEAP8[$4 + 19 | 0] = 8;
    break label$12;
   }
   if (HEAP8[$4 + 19 | 0] == 110) {
    HEAP8[$4 + 19 | 0] = 10;
    break label$12;
   }
   if (HEAP8[$4 + 19 | 0] == 114) {
    HEAP8[$4 + 19 | 0] = 13;
    break label$12;
   }
   if (HEAP8[$4 + 19 | 0] == 115) {
    HEAP8[$4 + 47 | 0] = isWhitespace(HEAP8[$4 + 27 | 0]) & 1;
    break label$1;
   }
   if (HEAP8[$4 + 19 | 0] == 83) {
    HEAP8[$4 + 47 | 0] = (isWhitespace(HEAP8[$4 + 27 | 0]) ^ -1) & 1;
    break label$1;
   }
   if (HEAP8[$4 + 19 | 0] == 116) {
    HEAP8[$4 + 19 | 0] = 9;
    break label$12;
   }
   if (HEAP8[$4 + 19 | 0] == 118) {
    HEAP8[$4 + 19 | 0] = 11;
    break label$12;
   }
   if (HEAP8[$4 + 19 | 0] == 119) {
    $2 = isNumeric(HEAP8[$4 + 27 | 0]);
    $0 = $4;
    $1 = 1;
    label$24 : {
     if ($2 & 1) {
      break label$24;
     }
     $2 = isAlpha(HEAP8[$4 + 27 | 0]) & 1;
     $1 = 1;
     if ($2) {
      break label$24;
     }
     $1 = HEAP8[$4 + 27 | 0] == 95;
    }
    HEAP8[$0 + 47 | 0] = $1;
    break label$1;
   }
   if (HEAP8[$4 + 19 | 0] == 87) {
    $2 = isNumeric(HEAP8[$4 + 27 | 0]);
    $0 = $4;
    $1 = 1;
    label$26 : {
     if ($2 & 1) {
      break label$26;
     }
     $2 = isAlpha(HEAP8[$4 + 27 | 0]) & 1;
     $1 = 1;
     if ($2) {
      break label$26;
     }
     $1 = HEAP8[$4 + 27 | 0] == 95;
    }
    HEAP8[$0 + 47 | 0] = ($1 ^ -1) & 1;
    break label$1;
   }
   if (HEAP8[$4 + 19 | 0] == 48) {
    HEAP8[$4 + 19 | 0] = 0;
    break label$12;
   }
   if (!(HEAP8[$4 + 19 | 0] < 49 | HEAP8[$4 + 19 | 0] > 57)) {
    jsExceptionHere(1, 125292, 0);
    HEAP8[$4 + 47 | 0] = 0;
    break label$1;
   }
   if (!(!HEAP8[HEAP32[$4 + 40 >> 2] + 3 | 0] | (!HEAP8[HEAP32[$4 + 40 >> 2] + 2 | 0] | HEAP8[$4 + 19 | 0] != 120))) {
    HEAP32[HEAP32[$4 + 32 >> 2] >> 2] = 4;
    HEAP8[$4 + 19 | 0] = hexToByte(HEAP8[HEAP32[$4 + 40 >> 2] + 2 | 0], HEAP8[HEAP32[$4 + 40 >> 2] + 3 | 0]);
   }
  }
  if (!(!(HEAP8[HEAP32[$4 + 28 >> 2] + 9 | 0] & 1) | HEAP8[HEAP32[$4 + 40 >> 2] + HEAP32[HEAP32[$4 + 32 >> 2] >> 2] | 0] != 45 | HEAP8[HEAP32[$4 + 40 >> 2] + (HEAP32[HEAP32[$4 + 32 >> 2] >> 2] + 1 | 0) | 0] == 93)) {
   HEAP16[HEAP32[$4 + 28 >> 2] + 10 >> 1] = HEAP8[$4 + 19 | 0];
   $0 = HEAP32[$4 + 32 >> 2];
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
   HEAP8[$4 + 11 | 0] = matchcharacter(HEAP32[$4 + 40 >> 2] + HEAP32[HEAP32[$4 + 32 >> 2] >> 2] | 0, HEAP32[$4 + 36 >> 2], $4 + 12 | 0, HEAP32[$4 + 28 >> 2]) & 1;
   $0 = HEAP32[$4 + 32 >> 2];
   HEAP32[$0 >> 2] = HEAP32[$4 + 12 >> 2] + HEAP32[$0 >> 2];
   HEAP8[$4 + 47 | 0] = HEAP8[$4 + 11 | 0] & 1;
   break label$1;
  }
  if (HEAP8[HEAP32[$4 + 28 >> 2] + 8 | 0] & 1) {
   HEAP8[$4 + 27 | 0] = charToLowerCase(HEAP8[$4 + 27 | 0]);
   HEAP8[$4 + 19 | 0] = charToLowerCase(HEAP8[$4 + 19 | 0]);
  }
  if (HEAP16[HEAP32[$4 + 28 >> 2] + 10 >> 1] != 256) {
   HEAP8[$4 + 10 | 0] = HEAPU16[HEAP32[$4 + 28 >> 2] + 10 >> 1];
   if (HEAP8[HEAP32[$4 + 28 >> 2] + 8 | 0] & 1) {
    HEAP8[$4 + 10 | 0] = charToLowerCase(HEAP8[$4 + 10 | 0]);
   }
   HEAP16[HEAP32[$4 + 28 >> 2] + 10 >> 1] = 256;
   $0 = $4;
   $1 = 0;
   label$34 : {
    if (HEAP8[$4 + 27 | 0] < HEAP8[$4 + 10 | 0]) {
     break label$34;
    }
    $1 = 0;
    if (HEAP8[$4 + 27 | 0] > HEAP8[$4 + 19 | 0]) {
     break label$34;
    }
    $1 = HEAP8[$4 + 10 | 0] < HEAP8[$4 + 19 | 0];
   }
   HEAP8[$0 + 47 | 0] = $1;
   break label$1;
  }
  HEAP8[$4 + 47 | 0] = HEAP8[$4 + 19 | 0] == HEAP8[$4 + 27 | 0];
 }
 global$0 = $4 + 48 | 0;
 return HEAP8[$4 + 47 | 0] & 1;
}
function tflite__reference_ops__MaxPool_28tflite__PoolParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 144 | 0;
 global$0 = $5;
 HEAP32[$5 + 140 >> 2] = $0;
 HEAP32[$5 + 136 >> 2] = $1;
 HEAP32[$5 + 132 >> 2] = $2;
 HEAP32[$5 + 128 >> 2] = $3;
 HEAP32[$5 + 124 >> 2] = $4;
 label$1 : {
  if (HEAP32[HEAP32[$5 + 140 >> 2] + 28 >> 2] > HEAP32[HEAP32[$5 + 140 >> 2] + 32 >> 2]) {
   break label$1;
  }
 }
 label$2 : {
  if (HEAP32[HEAP32[$5 + 140 >> 2] + 28 >> 2] < 0) {
   break label$2;
  }
 }
 label$3 : {
  if (HEAP32[HEAP32[$5 + 140 >> 2] + 32 >> 2] > 255) {
   break label$3;
  }
 }
 label$4 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 136 >> 2]) | 0) != 4) {
   break label$4;
  }
 }
 label$5 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 128 >> 2]) | 0) != 4) {
   break label$5;
  }
 }
 HEAP32[$5 + 120 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 136 >> 2], 0, HEAP32[$5 + 128 >> 2], 0);
 HEAP32[$5 + 116 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 136 >> 2], 3, HEAP32[$5 + 128 >> 2], 3);
 HEAP32[$5 + 112 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 136 >> 2], 1);
 HEAP32[$5 + 108 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 136 >> 2], 2);
 HEAP32[$5 + 104 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 128 >> 2], 1);
 HEAP32[$5 + 100 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 128 >> 2], 2);
 HEAP32[$5 + 96 >> 2] = HEAP32[HEAP32[$5 + 140 >> 2] + 12 >> 2];
 HEAP32[$5 + 92 >> 2] = HEAP32[HEAP32[$5 + 140 >> 2] + 16 >> 2];
 HEAP32[$5 + 88 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 88 >> 2] < HEAP32[$5 + 120 >> 2]) {
   HEAP32[$5 + 84 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 84 >> 2] < HEAP32[$5 + 104 >> 2]) {
     HEAP32[$5 + 80 >> 2] = 0;
     while (1) {
      if (HEAP32[$5 + 80 >> 2] < HEAP32[$5 + 100 >> 2]) {
       HEAP32[$5 + 76 >> 2] = 0;
       while (1) {
        if (HEAP32[$5 + 76 >> 2] < HEAP32[$5 + 116 >> 2]) {
         $0 = $5 + 28 | 0;
         $1 = $5 + 40 | 0;
         $2 = $5 + 36 | 0;
         $3 = $5 + 48 | 0;
         HEAP32[$5 + 72 >> 2] = Math_imul(HEAP32[$5 + 80 >> 2], HEAP32[$5 + 92 >> 2]) - HEAP16[HEAP32[$5 + 140 >> 2] + 2 >> 1];
         HEAP32[$5 + 68 >> 2] = Math_imul(HEAP32[$5 + 84 >> 2], HEAP32[$5 + 96 >> 2]) - HEAP16[HEAP32[$5 + 140 >> 2] + 4 >> 1];
         HEAP32[$5 + 60 >> 2] = 0;
         HEAP32[$5 + 56 >> 2] = 0 - HEAP32[$5 + 72 >> 2];
         HEAP32[$5 + 64 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($5 + 60 | 0, $5 + 56 | 0) >> 2];
         $4 = HEAP32[$5 + 140 >> 2] + 24 | 0;
         HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 108 >> 2] - HEAP32[$5 + 72 >> 2];
         HEAP32[$5 + 52 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($4, $3) >> 2];
         HEAP32[$5 + 40 >> 2] = 0;
         HEAP32[$5 + 36 >> 2] = 0 - HEAP32[$5 + 68 >> 2];
         HEAP32[$5 + 44 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($1, $2) >> 2];
         $1 = HEAP32[$5 + 140 >> 2] + 20 | 0;
         HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 112 >> 2] - HEAP32[$5 + 68 >> 2];
         HEAP32[$5 + 32 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($1, $0) >> 2];
         HEAP8[$5 + 27 | 0] = 0;
         HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 44 >> 2];
         while (1) {
          if (HEAP32[$5 + 20 >> 2] < HEAP32[$5 + 32 >> 2]) {
           HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 64 >> 2];
           while (1) {
            if (HEAP32[$5 + 16 >> 2] < HEAP32[$5 + 52 >> 2]) {
             HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 72 >> 2] + HEAP32[$5 + 16 >> 2];
             HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 68 >> 2] + HEAP32[$5 + 20 >> 2];
             HEAP8[$5 + 27 | 0] = HEAPU8[unsigned_20char_20const__20std____2__max_unsigned_20char__28unsigned_20char_20const__2c_20unsigned_20char_20const__29($5 + 27 | 0, HEAP32[$5 + 132 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$5 + 136 >> 2], HEAP32[$5 + 88 >> 2], HEAP32[$5 + 8 >> 2], HEAP32[$5 + 12 >> 2], HEAP32[$5 + 76 >> 2]) | 0) | 0];
             HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 16 >> 2] + 1;
             continue;
            }
            break;
           }
           HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 20 >> 2] + 1;
           continue;
          }
          break;
         }
         $0 = $5 + 6 | 0;
         HEAP8[$5 + 7 | 0] = HEAP32[HEAP32[$5 + 140 >> 2] + 28 >> 2];
         $1 = $5 + 27 | 0;
         HEAP8[$5 + 27 | 0] = HEAPU8[unsigned_20char_20const__20std____2__max_unsigned_20char__28unsigned_20char_20const__2c_20unsigned_20char_20const__29($1, $5 + 7 | 0) | 0];
         HEAP8[$5 + 6 | 0] = HEAP32[HEAP32[$5 + 140 >> 2] + 32 >> 2];
         HEAP8[$5 + 27 | 0] = HEAPU8[unsigned_20char_20const__20std____2__min_unsigned_20char__28unsigned_20char_20const__2c_20unsigned_20char_20const__29($1, $0) | 0];
         $0 = HEAPU8[$5 + 27 | 0];
         HEAP8[HEAP32[$5 + 124 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$5 + 128 >> 2], HEAP32[$5 + 88 >> 2], HEAP32[$5 + 84 >> 2], HEAP32[$5 + 80 >> 2], HEAP32[$5 + 76 >> 2]) | 0] = $0;
         HEAP32[$5 + 76 >> 2] = HEAP32[$5 + 76 >> 2] + 1;
         continue;
        }
        break;
       }
       HEAP32[$5 + 80 >> 2] = HEAP32[$5 + 80 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$5 + 84 >> 2] = HEAP32[$5 + 84 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 88 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $5 + 144 | 0;
}
function jsvCopy($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = global$0 + -64 | 0;
 global$0 = $2;
 HEAP32[$2 + 56 >> 2] = $0;
 HEAP8[$2 + 55 | 0] = $1;
 label$1 : {
  if (jsvIsFlatString(HEAP32[$2 + 56 >> 2]) & 1) {
   HEAP32[$2 + 60 >> 2] = jsvNewFromStringVar(HEAP32[$2 + 56 >> 2], 0, 2147483647);
   break label$1;
  }
  $0 = HEAP32[$2 + 56 >> 2];
  HEAP32[$2 + 48 >> 2] = jsvNewWithFlags((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 127);
  if (!HEAP32[$2 + 48 >> 2]) {
   HEAP32[$2 + 60 >> 2] = 0;
   break label$1;
  }
  label$4 : {
   if (!(jsvIsStringExt(HEAP32[$2 + 56 >> 2]) & 1)) {
    $3 = jsvIsBasicString(HEAP32[$2 + 56 >> 2]) & 1;
    $0 = $2;
    $1 = 1;
    label$6 : {
     if ($3) {
      break label$6;
     }
     $3 = jsvIsNativeString(HEAP32[$2 + 56 >> 2]) & 1;
     $1 = 1;
     if ($3) {
      break label$6;
     }
     $3 = jsvIsFlashString(HEAP32[$2 + 56 >> 2]) & 1;
     $1 = 1;
     if ($3) {
      break label$6;
     }
     $1 = jsvIsNativeFunction(HEAP32[$2 + 56 >> 2]);
    }
    HEAP8[$0 + 47 | 0] = $1 & 1;
    memcpy(HEAP32[$2 + 48 >> 2], HEAP32[$2 + 56 >> 2], HEAP8[$2 + 47 | 0] & 1 ? 10 : 4);
    if (jsvIsNativeFunction(HEAP32[$2 + 56 >> 2]) & 1) {
     jsvSetFirstChild(HEAP32[$2 + 48 >> 2], 0);
    }
    label$8 : {
     if (HEAP8[$2 + 47 | 0] & 1) {
      break label$8;
     }
    }
    break label$4;
   }
   $1 = HEAP32[$2 + 56 >> 2];
   $3 = HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8 | (HEAPU8[$1 + 6 | 0] << 16 | HEAPU8[$1 + 7 | 0] << 24);
   $0 = HEAP32[$2 + 48 >> 2];
   $4 = HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24);
   HEAP8[$0 | 0] = $4;
   HEAP8[$0 + 1 | 0] = $4 >>> 8;
   HEAP8[$0 + 2 | 0] = $4 >>> 16;
   HEAP8[$0 + 3 | 0] = $4 >>> 24;
   HEAP8[$0 + 4 | 0] = $3;
   HEAP8[$0 + 5 | 0] = $3 >>> 8;
   HEAP8[$0 + 6 | 0] = $3 >>> 16;
   HEAP8[$0 + 7 | 0] = $3 >>> 24;
   $1 = HEAPU8[$1 + 7 | 0] | HEAPU8[$1 + 8 | 0] << 8 | (HEAPU8[$1 + 9 | 0] << 16 | HEAPU8[$1 + 10 | 0] << 24);
   HEAP8[$0 + 7 | 0] = $1;
   HEAP8[$0 + 8 | 0] = $1 >>> 8;
   HEAP8[$0 + 9 | 0] = $1 >>> 16;
   HEAP8[$0 + 10 | 0] = $1 >>> 24;
  }
  label$9 : {
   if (!(HEAP8[$2 + 55 | 0] & 1)) {
    break label$9;
   }
   if (!(jsvIsName(HEAP32[$2 + 56 >> 2]) & 1)) {
    break label$9;
   }
   if (jsvGetFirstChild(HEAP32[$2 + 56 >> 2]) & 65535) {
    label$11 : {
     if (jsvIsNameWithValue(HEAP32[$2 + 56 >> 2]) & 1) {
      jsvSetFirstChild(HEAP32[$2 + 48 >> 2], jsvGetFirstChild(HEAP32[$2 + 56 >> 2]) & 65535);
      break label$11;
     }
     HEAP32[$2 + 40 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$2 + 56 >> 2]) & 65535);
     HEAP32[$2 + 36 >> 2] = jsvRef(jsvCopy(HEAP32[$2 + 40 >> 2], 1));
     jsvUnLock(HEAP32[$2 + 40 >> 2]);
     if (HEAP32[$2 + 36 >> 2]) {
      jsvSetFirstChild(HEAP32[$2 + 48 >> 2], jsvGetRef(HEAP32[$2 + 36 >> 2]) & 65535);
      jsvUnLock(HEAP32[$2 + 36 >> 2]);
     }
    }
   }
  }
  label$14 : {
   if (jsvHasCharacterData(HEAP32[$2 + 56 >> 2]) & 1) {
    HEAP32[$2 + 56 >> 2] = jsvLockAgain(HEAP32[$2 + 56 >> 2]);
    HEAP32[$2 + 32 >> 2] = jsvLockAgain(HEAP32[$2 + 48 >> 2]);
    while (1) {
     if (jsvGetLastChild(HEAP32[$2 + 56 >> 2]) & 65535) {
      HEAP32[$2 + 28 >> 2] = jsvLock(jsvGetLastChild(HEAP32[$2 + 56 >> 2]) & 65535);
      label$18 : {
       if (jsvIsStringExt(HEAP32[$2 + 28 >> 2]) & 1) {
        $0 = HEAP32[$2 + 28 >> 2];
        HEAP32[$2 + 24 >> 2] = jsvNewWithFlags((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 127);
        if (HEAP32[$2 + 24 >> 2]) {
         $3 = HEAP32[$2 + 28 >> 2];
         $0 = HEAPU8[$3 + 4 | 0] | HEAPU8[$3 + 5 | 0] << 8 | (HEAPU8[$3 + 6 | 0] << 16 | HEAPU8[$3 + 7 | 0] << 24);
         $1 = HEAP32[$2 + 24 >> 2];
         $4 = HEAPU8[$3 | 0] | HEAPU8[$3 + 1 | 0] << 8 | (HEAPU8[$3 + 2 | 0] << 16 | HEAPU8[$3 + 3 | 0] << 24);
         HEAP8[$1 | 0] = $4;
         HEAP8[$1 + 1 | 0] = $4 >>> 8;
         HEAP8[$1 + 2 | 0] = $4 >>> 16;
         HEAP8[$1 + 3 | 0] = $4 >>> 24;
         HEAP8[$1 + 4 | 0] = $0;
         HEAP8[$1 + 5 | 0] = $0 >>> 8;
         HEAP8[$1 + 6 | 0] = $0 >>> 16;
         HEAP8[$1 + 7 | 0] = $0 >>> 24;
         $0 = HEAPU8[$3 + 7 | 0] | HEAPU8[$3 + 8 | 0] << 8 | (HEAPU8[$3 + 9 | 0] << 16 | HEAPU8[$3 + 10 | 0] << 24);
         HEAP8[$1 + 7 | 0] = $0;
         HEAP8[$1 + 8 | 0] = $0 >>> 8;
         HEAP8[$1 + 9 | 0] = $0 >>> 16;
         HEAP8[$1 + 10 | 0] = $0 >>> 24;
         jsvSetLastChild(HEAP32[$2 + 32 >> 2], jsvGetRef(HEAP32[$2 + 24 >> 2]) & 65535);
        }
        jsvUnLock2(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 32 >> 2]);
        HEAP32[$2 + 56 >> 2] = HEAP32[$2 + 28 >> 2];
        HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 24 >> 2];
        break label$18;
       }
       HEAP32[$2 + 20 >> 2] = jsvCopy(HEAP32[$2 + 28 >> 2], 1);
       if (HEAP32[$2 + 20 >> 2]) {
        jsvSetLastChild(HEAP32[$2 + 32 >> 2], jsvGetRef(HEAP32[$2 + 20 >> 2]) & 65535);
        jsvUnLock(HEAP32[$2 + 20 >> 2]);
       }
       jsvUnLock2(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 32 >> 2]);
       HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 48 >> 2];
       break label$1;
      }
      continue;
     }
     break;
    }
    jsvUnLock2(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 32 >> 2]);
    break label$14;
   }
   if (jsvHasChildren(HEAP32[$2 + 56 >> 2]) & 1) {
    if (HEAP8[$2 + 55 | 0] & 1) {
     HEAP16[$2 + 18 >> 1] = jsvGetFirstChild(HEAP32[$2 + 56 >> 2]);
     while (1) {
      if (HEAPU16[$2 + 18 >> 1]) {
       HEAP32[$2 + 12 >> 2] = jsvLock(HEAPU16[$2 + 18 >> 1]);
       HEAP32[$2 + 8 >> 2] = jsvCopyNameOnly(HEAP32[$2 + 12 >> 2], 1, 1);
       if (HEAP32[$2 + 8 >> 2]) {
        jsvAddName(HEAP32[$2 + 48 >> 2], HEAP32[$2 + 8 >> 2]);
        jsvUnLock(HEAP32[$2 + 8 >> 2]);
       }
       HEAP16[$2 + 18 >> 1] = jsvGetNextSibling(HEAP32[$2 + 12 >> 2]);
       jsvUnLock(HEAP32[$2 + 12 >> 2]);
       continue;
      }
      break;
     }
    }
   }
  }
  HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 48 >> 2];
 }
 global$0 = $2 - -64 | 0;
 return HEAP32[$2 + 60 >> 2];
}
function tflite__reference_integer_ops__MaxPool_28tflite__PoolParams_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 144 | 0;
 global$0 = $5;
 HEAP32[$5 + 140 >> 2] = $0;
 HEAP32[$5 + 136 >> 2] = $1;
 HEAP32[$5 + 132 >> 2] = $2;
 HEAP32[$5 + 128 >> 2] = $3;
 HEAP32[$5 + 124 >> 2] = $4;
 label$1 : {
  if (HEAP32[HEAP32[$5 + 140 >> 2] + 28 >> 2] > HEAP32[HEAP32[$5 + 140 >> 2] + 32 >> 2]) {
   break label$1;
  }
 }
 label$2 : {
  if (HEAP32[HEAP32[$5 + 140 >> 2] + 28 >> 2] < -128) {
   break label$2;
  }
 }
 label$3 : {
  if (HEAP32[HEAP32[$5 + 140 >> 2] + 32 >> 2] > 127) {
   break label$3;
  }
 }
 label$4 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 136 >> 2]) | 0) != 4) {
   break label$4;
  }
 }
 label$5 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 128 >> 2]) | 0) != 4) {
   break label$5;
  }
 }
 HEAP32[$5 + 120 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 136 >> 2], 0, HEAP32[$5 + 128 >> 2], 0);
 HEAP32[$5 + 116 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 136 >> 2], 3, HEAP32[$5 + 128 >> 2], 3);
 HEAP32[$5 + 112 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 136 >> 2], 1);
 HEAP32[$5 + 108 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 136 >> 2], 2);
 HEAP32[$5 + 104 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 128 >> 2], 1);
 HEAP32[$5 + 100 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 128 >> 2], 2);
 HEAP32[$5 + 96 >> 2] = HEAP32[HEAP32[$5 + 140 >> 2] + 12 >> 2];
 HEAP32[$5 + 92 >> 2] = HEAP32[HEAP32[$5 + 140 >> 2] + 16 >> 2];
 HEAP32[$5 + 88 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 88 >> 2] < HEAP32[$5 + 120 >> 2]) {
   HEAP32[$5 + 84 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 84 >> 2] < HEAP32[$5 + 104 >> 2]) {
     HEAP32[$5 + 80 >> 2] = 0;
     while (1) {
      if (HEAP32[$5 + 80 >> 2] < HEAP32[$5 + 100 >> 2]) {
       HEAP32[$5 + 76 >> 2] = 0;
       while (1) {
        if (HEAP32[$5 + 76 >> 2] < HEAP32[$5 + 116 >> 2]) {
         $0 = $5 + 28 | 0;
         $1 = $5 + 40 | 0;
         $2 = $5 + 36 | 0;
         $3 = $5 + 48 | 0;
         HEAP32[$5 + 72 >> 2] = Math_imul(HEAP32[$5 + 80 >> 2], HEAP32[$5 + 92 >> 2]) - HEAP16[HEAP32[$5 + 140 >> 2] + 2 >> 1];
         HEAP32[$5 + 68 >> 2] = Math_imul(HEAP32[$5 + 84 >> 2], HEAP32[$5 + 96 >> 2]) - HEAP16[HEAP32[$5 + 140 >> 2] + 4 >> 1];
         HEAP32[$5 + 60 >> 2] = 0;
         HEAP32[$5 + 56 >> 2] = 0 - HEAP32[$5 + 72 >> 2];
         HEAP32[$5 + 64 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($5 + 60 | 0, $5 + 56 | 0) >> 2];
         $4 = HEAP32[$5 + 140 >> 2] + 24 | 0;
         HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 108 >> 2] - HEAP32[$5 + 72 >> 2];
         HEAP32[$5 + 52 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($4, $3) >> 2];
         HEAP32[$5 + 40 >> 2] = 0;
         HEAP32[$5 + 36 >> 2] = 0 - HEAP32[$5 + 68 >> 2];
         HEAP32[$5 + 44 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($1, $2) >> 2];
         $1 = HEAP32[$5 + 140 >> 2] + 20 | 0;
         HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 112 >> 2] - HEAP32[$5 + 68 >> 2];
         HEAP32[$5 + 32 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($1, $0) >> 2];
         HEAP8[$5 + 27 | 0] = -128;
         HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 44 >> 2];
         while (1) {
          if (HEAP32[$5 + 20 >> 2] < HEAP32[$5 + 32 >> 2]) {
           HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 64 >> 2];
           while (1) {
            if (HEAP32[$5 + 16 >> 2] < HEAP32[$5 + 52 >> 2]) {
             HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 72 >> 2] + HEAP32[$5 + 16 >> 2];
             HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 68 >> 2] + HEAP32[$5 + 20 >> 2];
             HEAP8[$5 + 27 | 0] = HEAPU8[signed_20char_20const__20std____2__max_signed_20char__28signed_20char_20const__2c_20signed_20char_20const__29($5 + 27 | 0, HEAP32[$5 + 132 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$5 + 136 >> 2], HEAP32[$5 + 88 >> 2], HEAP32[$5 + 8 >> 2], HEAP32[$5 + 12 >> 2], HEAP32[$5 + 76 >> 2]) | 0) | 0];
             HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 16 >> 2] + 1;
             continue;
            }
            break;
           }
           HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 20 >> 2] + 1;
           continue;
          }
          break;
         }
         $0 = $5 + 6 | 0;
         HEAP8[$5 + 7 | 0] = HEAP32[HEAP32[$5 + 140 >> 2] + 28 >> 2];
         $1 = $5 + 27 | 0;
         HEAP8[$5 + 27 | 0] = HEAPU8[signed_20char_20const__20std____2__max_signed_20char__28signed_20char_20const__2c_20signed_20char_20const__29($1, $5 + 7 | 0) | 0];
         HEAP8[$5 + 6 | 0] = HEAP32[HEAP32[$5 + 140 >> 2] + 32 >> 2];
         HEAP8[$5 + 27 | 0] = HEAPU8[signed_20char_20const__20std____2__min_signed_20char__28signed_20char_20const__2c_20signed_20char_20const__29($1, $0) | 0];
         $0 = HEAPU8[$5 + 27 | 0];
         HEAP8[HEAP32[$5 + 124 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$5 + 128 >> 2], HEAP32[$5 + 88 >> 2], HEAP32[$5 + 84 >> 2], HEAP32[$5 + 80 >> 2], HEAP32[$5 + 76 >> 2]) | 0] = $0;
         HEAP32[$5 + 76 >> 2] = HEAP32[$5 + 76 >> 2] + 1;
         continue;
        }
        break;
       }
       HEAP32[$5 + 80 >> 2] = HEAP32[$5 + 80 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$5 + 84 >> 2] = HEAP32[$5 + 84 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 88 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $5 + 144 | 0;
}
function tflite__reference_integer_ops__AveragePool_28tflite__PoolParams_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 144 | 0;
 global$0 = $5;
 HEAP32[$5 + 140 >> 2] = $0;
 HEAP32[$5 + 136 >> 2] = $1;
 HEAP32[$5 + 132 >> 2] = $2;
 HEAP32[$5 + 128 >> 2] = $3;
 HEAP32[$5 + 124 >> 2] = $4;
 label$1 : {
  if (HEAP32[HEAP32[$5 + 140 >> 2] + 28 >> 2] > HEAP32[HEAP32[$5 + 140 >> 2] + 32 >> 2]) {
   break label$1;
  }
 }
 label$2 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 136 >> 2]) | 0) != 4) {
   break label$2;
  }
 }
 label$3 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 128 >> 2]) | 0) != 4) {
   break label$3;
  }
 }
 HEAP32[$5 + 120 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 136 >> 2], 0, HEAP32[$5 + 128 >> 2], 0);
 HEAP32[$5 + 116 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 136 >> 2], 3, HEAP32[$5 + 128 >> 2], 3);
 HEAP32[$5 + 112 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 136 >> 2], 1);
 HEAP32[$5 + 108 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 136 >> 2], 2);
 HEAP32[$5 + 104 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 128 >> 2], 1);
 HEAP32[$5 + 100 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 128 >> 2], 2);
 HEAP32[$5 + 96 >> 2] = HEAP32[HEAP32[$5 + 140 >> 2] + 12 >> 2];
 HEAP32[$5 + 92 >> 2] = HEAP32[HEAP32[$5 + 140 >> 2] + 16 >> 2];
 HEAP32[$5 + 88 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 88 >> 2] < HEAP32[$5 + 120 >> 2]) {
   HEAP32[$5 + 84 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 84 >> 2] < HEAP32[$5 + 104 >> 2]) {
     HEAP32[$5 + 80 >> 2] = 0;
     while (1) {
      if (HEAP32[$5 + 80 >> 2] < HEAP32[$5 + 100 >> 2]) {
       HEAP32[$5 + 76 >> 2] = 0;
       while (1) {
        if (HEAP32[$5 + 76 >> 2] < HEAP32[$5 + 116 >> 2]) {
         $0 = $5 + 28 | 0;
         $1 = $5 + 40 | 0;
         $2 = $5 + 36 | 0;
         $3 = $5 + 48 | 0;
         HEAP32[$5 + 72 >> 2] = Math_imul(HEAP32[$5 + 80 >> 2], HEAP32[$5 + 92 >> 2]) - HEAP16[HEAP32[$5 + 140 >> 2] + 2 >> 1];
         HEAP32[$5 + 68 >> 2] = Math_imul(HEAP32[$5 + 84 >> 2], HEAP32[$5 + 96 >> 2]) - HEAP16[HEAP32[$5 + 140 >> 2] + 4 >> 1];
         HEAP32[$5 + 60 >> 2] = 0;
         HEAP32[$5 + 56 >> 2] = 0 - HEAP32[$5 + 72 >> 2];
         HEAP32[$5 + 64 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($5 + 60 | 0, $5 + 56 | 0) >> 2];
         $4 = HEAP32[$5 + 140 >> 2] + 24 | 0;
         HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 108 >> 2] - HEAP32[$5 + 72 >> 2];
         HEAP32[$5 + 52 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($4, $3) >> 2];
         HEAP32[$5 + 40 >> 2] = 0;
         HEAP32[$5 + 36 >> 2] = 0 - HEAP32[$5 + 68 >> 2];
         HEAP32[$5 + 44 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($1, $2) >> 2];
         $1 = HEAP32[$5 + 140 >> 2] + 20 | 0;
         HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 112 >> 2] - HEAP32[$5 + 68 >> 2];
         HEAP32[$5 + 32 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($1, $0) >> 2];
         HEAP32[$5 + 24 >> 2] = 0;
         HEAP32[$5 + 20 >> 2] = 0;
         HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 44 >> 2];
         while (1) {
          if (HEAP32[$5 + 16 >> 2] < HEAP32[$5 + 32 >> 2]) {
           HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 64 >> 2];
           while (1) {
            if (HEAP32[$5 + 12 >> 2] < HEAP32[$5 + 52 >> 2]) {
             HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 72 >> 2] + HEAP32[$5 + 12 >> 2];
             HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 68 >> 2] + HEAP32[$5 + 16 >> 2];
             HEAP32[$5 + 24 >> 2] = HEAP8[HEAP32[$5 + 132 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$5 + 136 >> 2], HEAP32[$5 + 88 >> 2], HEAP32[$5 + 4 >> 2], HEAP32[$5 + 8 >> 2], HEAP32[$5 + 76 >> 2]) | 0] + HEAP32[$5 + 24 >> 2];
             HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 20 >> 2] + 1;
             HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 12 >> 2] + 1;
             continue;
            }
            break;
           }
           HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 16 >> 2] + 1;
           continue;
          }
          break;
         }
         $0 = $5;
         if (HEAP32[$5 + 24 >> 2] > 0) {
          $1 = (HEAP32[$5 + 24 >> 2] + (HEAP32[$5 + 20 >> 2] / 2 | 0) | 0) / HEAP32[$5 + 20 >> 2] | 0;
         } else {
          $1 = (HEAP32[$5 + 24 >> 2] - (HEAP32[$5 + 20 >> 2] / 2 | 0) | 0) / HEAP32[$5 + 20 >> 2] | 0;
         }
         HEAP32[$0 + 24 >> 2] = $1;
         $0 = $5 + 24 | 0;
         HEAP32[$5 + 24 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($0, HEAP32[$5 + 140 >> 2] + 28 | 0) >> 2];
         HEAP32[$5 + 24 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($0, HEAP32[$5 + 140 >> 2] + 32 | 0) >> 2];
         $0 = HEAP32[$5 + 24 >> 2];
         HEAP8[HEAP32[$5 + 124 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$5 + 128 >> 2], HEAP32[$5 + 88 >> 2], HEAP32[$5 + 84 >> 2], HEAP32[$5 + 80 >> 2], HEAP32[$5 + 76 >> 2]) | 0] = $0;
         HEAP32[$5 + 76 >> 2] = HEAP32[$5 + 76 >> 2] + 1;
         continue;
        }
        break;
       }
       HEAP32[$5 + 80 >> 2] = HEAP32[$5 + 80 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$5 + 84 >> 2] = HEAP32[$5 + 84 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 88 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $5 + 144 | 0;
}
function tflite__MicroAllocator__CommitStaticMemoryPlan_28tflite__Model_20const__2c_20tflite__SubGraph_20const__2c_20TfLiteEvalTensor__29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0, $5 = 0;
 $4 = global$0 - 224 | 0;
 global$0 = $4;
 $5 = $4 + 144 | 0;
 HEAP32[$4 + 216 >> 2] = $0;
 HEAP32[$4 + 212 >> 2] = $1;
 HEAP32[$4 + 208 >> 2] = $2;
 HEAP32[$4 + 204 >> 2] = $3;
 $0 = HEAP32[$4 + 216 >> 2];
 HEAP32[$4 + 200 >> 2] = 0;
 $1 = $4 + 168 | 0;
 tflite__SimpleMemoryAllocator__SimpleMemoryAllocator_28tflite__ErrorReporter__2c_20unsigned_20char__2c_20unsigned_20char__29($1, HEAP32[$0 + 8 >> 2], tflite__SimpleMemoryAllocator__GetBufferHead_28_29_20const(HEAP32[$0 + 4 >> 2]), tflite__SimpleMemoryAllocator__GetTail_28_29_20const(HEAP32[$0 + 4 >> 2]));
 tflite___28anonymous_20namespace_29__AllocationInfoBuilder__AllocationInfoBuilder_28tflite__ErrorReporter__2c_20tflite__SimpleMemoryAllocator__29($5, HEAP32[$0 + 8 >> 2], $1);
 HEAP32[$4 + 132 >> 2] = tflite___28anonymous_20namespace_29__AllocationInfoBuilder__Init_28unsigned_20long_2c_20unsigned_20long_29($4 + 144 | 0, flatbuffers__Vector_int___size_28_29_20const(tflite__Tensor__shape_28_29_20const(HEAP32[$4 + 208 >> 2])), HEAP32[$0 + 20 >> 2]);
 label$1 : {
  if (HEAP32[$4 + 132 >> 2]) {
   HEAP32[$4 + 220 >> 2] = HEAP32[$4 + 132 >> 2];
   HEAP32[$4 + 128 >> 2] = 1;
   break label$1;
  }
  HEAP32[$4 + 124 >> 2] = 0;
  HEAP32[$4 + 120 >> 2] = tflite___28anonymous_20namespace_29__AllocationInfoBuilder__GetOfflinePlannedOffsets_28tflite__Model_20const__2c_20int_20const___29($4 + 144 | 0, HEAP32[$4 + 212 >> 2], $4 + 124 | 0);
  if (HEAP32[$4 + 120 >> 2]) {
   HEAP32[$4 + 220 >> 2] = HEAP32[$4 + 120 >> 2];
   HEAP32[$4 + 128 >> 2] = 1;
   break label$1;
  }
  HEAP32[$4 + 116 >> 2] = tflite___28anonymous_20namespace_29__AllocationInfoBuilder__AddTensors_28tflite__SubGraph_20const__2c_20int_20const__2c_20TfLiteEvalTensor__29($4 + 144 | 0, HEAP32[$4 + 208 >> 2], HEAP32[$4 + 124 >> 2], HEAP32[$4 + 204 >> 2]);
  if (HEAP32[$4 + 116 >> 2]) {
   HEAP32[$4 + 220 >> 2] = HEAP32[$4 + 116 >> 2];
   HEAP32[$4 + 128 >> 2] = 1;
   break label$1;
  }
  HEAP32[$4 + 112 >> 2] = tflite___28anonymous_20namespace_29__AllocationInfoBuilder__AddScratchBuffers_28tflite__internal__ScratchBufferHandle__29($4 + 144 | 0, HEAP32[$0 + 16 >> 2]);
  if (HEAP32[$4 + 112 >> 2]) {
   HEAP32[$4 + 220 >> 2] = HEAP32[$4 + 112 >> 2];
   HEAP32[$4 + 128 >> 2] = 1;
   break label$1;
  }
  $1 = global$0 - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $4 + 144;
  HEAP32[$4 + 108 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2];
  HEAP32[$4 + 104 >> 2] = tflite__SimpleMemoryAllocator__GetAvailableMemory_28unsigned_20long_29_20const($4 + 168 | 0);
  HEAP32[$4 + 100 >> 2] = tflite__SimpleMemoryAllocator__AllocateTemp_28unsigned_20long_2c_20unsigned_20long_29($4 + 168 | 0, HEAP32[$4 + 104 >> 2], 16);
  if (!HEAP32[$4 + 100 >> 2]) {
   $1 = HEAP32[$0 + 8 >> 2];
   $2 = HEAP32[$0 + 8 >> 2];
   HEAP32[$4 + 24 >> 2] = 132829;
   HEAP32[$4 + 20 >> 2] = 1047;
   HEAP32[$4 + 16 >> 2] = 132744;
   tflite__ErrorReporter__ReportError_28void__2c_20char_20const__2c_20____29($1, $2, 132721, $4 + 16 | 0);
   HEAP32[$4 + 220 >> 2] = 1;
   HEAP32[$4 + 128 >> 2] = 1;
   break label$1;
  }
  tflite__GreedyMemoryPlanner__GreedyMemoryPlanner_28unsigned_20char__2c_20int_29($4 + 56 | 0, HEAP32[$4 + 100 >> 2], HEAP32[$4 + 104 >> 2]);
  HEAP32[$4 + 52 >> 2] = tflite___28anonymous_20namespace_29__CreatePlan_28tflite__ErrorReporter__2c_20tflite__GreedyMemoryPlanner__2c_20tflite___28anonymous_20namespace_29__AllocationInfo_20const__2c_20unsigned_20long_29(HEAP32[$0 + 8 >> 2], $4 + 56 | 0, HEAP32[$4 + 108 >> 2], tflite___28anonymous_20namespace_29__AllocationInfoBuilder__Size_28_29_20const($4 + 144 | 0));
  label$7 : {
   if (HEAP32[$4 + 52 >> 2]) {
    HEAP32[$4 + 220 >> 2] = HEAP32[$4 + 52 >> 2];
    HEAP32[$4 + 128 >> 2] = 1;
    break label$7;
   }
   HEAP32[$4 + 48 >> 2] = tflite__SimpleMemoryAllocator__GetAvailableMemory_28unsigned_20long_29_20const(HEAP32[$0 + 4 >> 2]);
   if (tflite__GreedyMemoryPlanner__GetMaximumMemorySize_28_29($4 + 56 | 0) >>> 0 > HEAPU32[$4 + 48 >> 2]) {
    $1 = HEAP32[$0 + 8 >> 2];
    $2 = tflite__GreedyMemoryPlanner__GetMaximumMemorySize_28_29($4 + 56 | 0);
    HEAP32[$4 + 4 >> 2] = HEAP32[$4 + 48 >> 2];
    HEAP32[$4 >> 2] = $2;
    tflite__ErrorReporter__Report_28char_20const__2c_20____29($1, 132854, $4);
    HEAP32[$4 + 220 >> 2] = 1;
    HEAP32[$4 + 128 >> 2] = 1;
    break label$7;
   }
   HEAP32[$4 + 44 >> 2] = tflite___28anonymous_20namespace_29__CommitPlan_28tflite__ErrorReporter__2c_20tflite__MemoryPlanner__2c_20unsigned_20char__2c_20tflite___28anonymous_20namespace_29__AllocationInfo_20const__2c_20unsigned_20long_29(HEAP32[$0 + 8 >> 2], $4 + 56 | 0, tflite__SimpleMemoryAllocator__GetBufferHead_28_29_20const(HEAP32[$0 + 4 >> 2]), HEAP32[$4 + 108 >> 2], tflite___28anonymous_20namespace_29__AllocationInfoBuilder__Size_28_29_20const($4 + 144 | 0));
   if (HEAP32[$4 + 44 >> 2]) {
    HEAP32[$4 + 220 >> 2] = HEAP32[$4 + 44 >> 2];
    HEAP32[$4 + 128 >> 2] = 1;
    break label$7;
   }
   HEAP32[$4 + 200 >> 2] = tflite__GreedyMemoryPlanner__GetMaximumMemorySize_28_29($4 + 56 | 0);
   HEAP32[$4 + 128 >> 2] = 0;
  }
  tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator___MicroBuiltinDataAllocator_28_29($4 + 56 | 0);
 }
 tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($4 + 168 | 0);
 label$11 : {
  if (!(HEAP32[$4 + 128 >> 2] - 1)) {
   break label$11;
  }
  $0 = HEAP32[$0 + 4 >> 2];
  HEAP32[$4 + 40 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 8 >> 2]]($0, HEAP32[$4 + 200 >> 2], 16);
  if (HEAP32[$4 + 40 >> 2]) {
   HEAP32[$4 + 220 >> 2] = HEAP32[$4 + 40 >> 2];
   break label$11;
  }
  HEAP32[$4 + 220 >> 2] = 0;
 }
 global$0 = $4 + 224 | 0;
 return HEAP32[$4 + 220 >> 2];
}
function void_20tflite__reference_ops__Softmax_unsigned_20char_2c_20unsigned_20char__28tflite__SoftmaxParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 208 | 0;
 global$0 = $5;
 HEAP32[$5 + 204 >> 2] = $0;
 HEAP32[$5 + 200 >> 2] = $1;
 HEAP32[$5 + 196 >> 2] = $2;
 HEAP32[$5 + 192 >> 2] = $3;
 HEAP32[$5 + 188 >> 2] = $4;
 HEAP32[$5 + 184 >> 2] = HEAP32[HEAP32[$5 + 204 >> 2] + 8 >> 2];
 HEAP32[$5 + 180 >> 2] = HEAP32[HEAP32[$5 + 204 >> 2] + 12 >> 2];
 HEAP32[$5 + 176 >> 2] = HEAP32[HEAP32[$5 + 204 >> 2] + 24 >> 2];
 HEAP32[$5 + 172 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 200 >> 2]) - 1;
 HEAP32[$5 + 168 >> 2] = tflite__MatchingFlatSizeSkipDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__29(HEAP32[$5 + 200 >> 2], HEAP32[$5 + 172 >> 2], HEAP32[$5 + 192 >> 2]);
 HEAP32[$5 + 164 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 200 >> 2], HEAP32[$5 + 172 >> 2], HEAP32[$5 + 192 >> 2], HEAP32[$5 + 172 >> 2]);
 HEAP32[$5 + 160 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 160 >> 2] < HEAP32[$5 + 168 >> 2]) {
   HEAP8[$5 + 159 | 0] = 0;
   HEAP32[$5 + 152 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 152 >> 2] < HEAP32[$5 + 164 >> 2]) {
     HEAP8[$5 + 159 | 0] = HEAPU8[unsigned_20char_20const__20std____2__max_unsigned_20char__28unsigned_20char_20const__2c_20unsigned_20char_20const__29($5 + 159 | 0, HEAP32[$5 + 196 >> 2] + (HEAP32[$5 + 152 >> 2] + Math_imul(HEAP32[$5 + 160 >> 2], HEAP32[$5 + 164 >> 2]) | 0) | 0) | 0];
     HEAP32[$5 + 152 >> 2] = HEAP32[$5 + 152 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 144 >> 2] = gemmlowp__FixedPoint_int_2c_2012___Zero_28_29();
   HEAP32[$5 + 140 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 140 >> 2] < HEAP32[$5 + 164 >> 2]) {
     HEAP32[$5 + 136 >> 2] = HEAPU8[HEAP32[$5 + 196 >> 2] + (HEAP32[$5 + 140 >> 2] + Math_imul(HEAP32[$5 + 160 >> 2], HEAP32[$5 + 164 >> 2]) | 0) | 0] - HEAPU8[$5 + 159 | 0];
     if (HEAP32[$5 + 136 >> 2] >= HEAP32[$5 + 176 >> 2]) {
      HEAP32[$5 + 132 >> 2] = tflite__MultiplyByQuantizedMultiplierGreaterThanOne_28int_2c_20int_2c_20int_29(HEAP32[$5 + 136 >> 2], HEAP32[$5 + 184 >> 2], HEAP32[$5 + 180 >> 2]);
      HEAP32[$5 + 128 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29(HEAP32[$5 + 132 >> 2]);
      HEAP32[$5 + 112 >> 2] = HEAP32[$5 + 144 >> 2];
      HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 128 >> 2];
      HEAP32[$5 + 96 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__exp_on_negative_values_int_2c_205__28gemmlowp__FixedPoint_int_2c_205__29(HEAP32[$5 + 88 >> 2]);
      HEAP32[$5 + 104 >> 2] = gemmlowp__FixedPoint_int_2c_2012__20gemmlowp__Rescale_12_2c_20int_2c_200__28gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$5 + 96 >> 2]);
      HEAP32[$5 + 120 >> 2] = gemmlowp__FixedPoint_int_2c_2012__20gemmlowp__operator__int_2c_2012__28gemmlowp__FixedPoint_int_2c_2012__2c_20gemmlowp__FixedPoint_int_2c_2012__29(HEAP32[$5 + 112 >> 2], HEAP32[$5 + 104 >> 2]);
      HEAP32[$5 + 144 >> 2] = HEAP32[$5 + 120 >> 2];
     }
     HEAP32[$5 + 140 >> 2] = HEAP32[$5 + 140 >> 2] + 1;
     continue;
    }
    break;
   }
   $0 = $5 + 84 | 0;
   HEAP32[$5 + 80 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29(tflite__GetReciprocal_28int_2c_20int_2c_20int__29(HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($5 + 144 | 0) >> 2], $0));
   HEAP32[$5 + 76 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 76 >> 2] < HEAP32[$5 + 164 >> 2]) {
     HEAP32[$5 + 72 >> 2] = HEAPU8[HEAP32[$5 + 196 >> 2] + (HEAP32[$5 + 76 >> 2] + Math_imul(HEAP32[$5 + 160 >> 2], HEAP32[$5 + 164 >> 2]) | 0) | 0] - HEAPU8[$5 + 159 | 0];
     label$10 : {
      if (HEAP32[$5 + 72 >> 2] >= HEAP32[$5 + 176 >> 2]) {
       $0 = $5 + 12 | 0;
       $1 = $5 + 20 | 0;
       $2 = $5 + 16 | 0;
       $3 = $5 + 40 | 0;
       $4 = $5 - -64 | 0;
       HEAP32[$5 + 68 >> 2] = tflite__MultiplyByQuantizedMultiplierGreaterThanOne_28int_2c_20int_2c_20int_29(HEAP32[$5 + 72 >> 2], HEAP32[$5 + 184 >> 2], HEAP32[$5 + 180 >> 2]);
       HEAP32[$5 + 64 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29(HEAP32[$5 + 68 >> 2]);
       HEAP32[$5 + 48 >> 2] = HEAP32[$4 >> 2];
       HEAP32[$5 + 56 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__exp_on_negative_values_int_2c_205__28gemmlowp__FixedPoint_int_2c_205__29(HEAP32[$5 + 48 >> 2]);
       HEAP32[$5 + 32 >> 2] = HEAP32[$5 + 80 >> 2];
       HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 56 >> 2];
       HEAP32[$5 + 40 >> 2] = gemmlowp__FixedPoint_int_2c_20_280_29_20__20_280_29__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$5 + 32 >> 2], HEAP32[$5 + 24 >> 2]);
       HEAP32[$5 + 44 >> 2] = int_20gemmlowp__RoundingDivideByPOT_int__28int_2c_20int_29(HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($3) >> 2], HEAP32[$5 + 84 >> 2] + 23 | 0);
       HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 44 >> 2];
       HEAP32[$5 + 16 >> 2] = 255;
       $1 = int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($1, $2);
       HEAP32[$5 + 12 >> 2] = 0;
       $0 = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($1, $0) >> 2];
       break label$10;
      }
      $0 = 0;
     }
     HEAP8[HEAP32[$5 + 188 >> 2] + (HEAP32[$5 + 76 >> 2] + Math_imul(HEAP32[$5 + 160 >> 2], HEAP32[$5 + 164 >> 2]) | 0) | 0] = $0;
     HEAP32[$5 + 76 >> 2] = HEAP32[$5 + 76 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 160 >> 2] = HEAP32[$5 + 160 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $5 + 208 | 0;
}
function void_20tflite__reference_ops__Softmax_signed_20char_2c_20signed_20char__28tflite__SoftmaxParams_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 208 | 0;
 global$0 = $5;
 HEAP32[$5 + 204 >> 2] = $0;
 HEAP32[$5 + 200 >> 2] = $1;
 HEAP32[$5 + 196 >> 2] = $2;
 HEAP32[$5 + 192 >> 2] = $3;
 HEAP32[$5 + 188 >> 2] = $4;
 HEAP32[$5 + 184 >> 2] = HEAP32[HEAP32[$5 + 204 >> 2] + 8 >> 2];
 HEAP32[$5 + 180 >> 2] = HEAP32[HEAP32[$5 + 204 >> 2] + 12 >> 2];
 HEAP32[$5 + 176 >> 2] = HEAP32[HEAP32[$5 + 204 >> 2] + 24 >> 2];
 HEAP32[$5 + 172 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 200 >> 2]) - 1;
 HEAP32[$5 + 168 >> 2] = tflite__MatchingFlatSizeSkipDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__29(HEAP32[$5 + 200 >> 2], HEAP32[$5 + 172 >> 2], HEAP32[$5 + 192 >> 2]);
 HEAP32[$5 + 164 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 200 >> 2], HEAP32[$5 + 172 >> 2], HEAP32[$5 + 192 >> 2], HEAP32[$5 + 172 >> 2]);
 HEAP32[$5 + 160 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 160 >> 2] < HEAP32[$5 + 168 >> 2]) {
   HEAP8[$5 + 159 | 0] = -128;
   HEAP32[$5 + 152 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 152 >> 2] < HEAP32[$5 + 164 >> 2]) {
     HEAP8[$5 + 159 | 0] = HEAPU8[signed_20char_20const__20std____2__max_signed_20char__28signed_20char_20const__2c_20signed_20char_20const__29($5 + 159 | 0, HEAP32[$5 + 196 >> 2] + (HEAP32[$5 + 152 >> 2] + Math_imul(HEAP32[$5 + 160 >> 2], HEAP32[$5 + 164 >> 2]) | 0) | 0) | 0];
     HEAP32[$5 + 152 >> 2] = HEAP32[$5 + 152 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 144 >> 2] = gemmlowp__FixedPoint_int_2c_2012___Zero_28_29();
   HEAP32[$5 + 140 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 140 >> 2] < HEAP32[$5 + 164 >> 2]) {
     HEAP32[$5 + 136 >> 2] = HEAP8[HEAP32[$5 + 196 >> 2] + (HEAP32[$5 + 140 >> 2] + Math_imul(HEAP32[$5 + 160 >> 2], HEAP32[$5 + 164 >> 2]) | 0) | 0] - HEAP8[$5 + 159 | 0];
     if (HEAP32[$5 + 136 >> 2] >= HEAP32[$5 + 176 >> 2]) {
      HEAP32[$5 + 132 >> 2] = tflite__MultiplyByQuantizedMultiplierGreaterThanOne_28int_2c_20int_2c_20int_29(HEAP32[$5 + 136 >> 2], HEAP32[$5 + 184 >> 2], HEAP32[$5 + 180 >> 2]);
      HEAP32[$5 + 128 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29(HEAP32[$5 + 132 >> 2]);
      HEAP32[$5 + 112 >> 2] = HEAP32[$5 + 144 >> 2];
      HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 128 >> 2];
      HEAP32[$5 + 96 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__exp_on_negative_values_int_2c_205__28gemmlowp__FixedPoint_int_2c_205__29(HEAP32[$5 + 88 >> 2]);
      HEAP32[$5 + 104 >> 2] = gemmlowp__FixedPoint_int_2c_2012__20gemmlowp__Rescale_12_2c_20int_2c_200__28gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$5 + 96 >> 2]);
      HEAP32[$5 + 120 >> 2] = gemmlowp__FixedPoint_int_2c_2012__20gemmlowp__operator__int_2c_2012__28gemmlowp__FixedPoint_int_2c_2012__2c_20gemmlowp__FixedPoint_int_2c_2012__29(HEAP32[$5 + 112 >> 2], HEAP32[$5 + 104 >> 2]);
      HEAP32[$5 + 144 >> 2] = HEAP32[$5 + 120 >> 2];
     }
     HEAP32[$5 + 140 >> 2] = HEAP32[$5 + 140 >> 2] + 1;
     continue;
    }
    break;
   }
   $0 = $5 + 84 | 0;
   HEAP32[$5 + 80 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29(tflite__GetReciprocal_28int_2c_20int_2c_20int__29(HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($5 + 144 | 0) >> 2], $0));
   HEAP32[$5 + 76 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 76 >> 2] < HEAP32[$5 + 164 >> 2]) {
     HEAP32[$5 + 72 >> 2] = HEAP8[HEAP32[$5 + 196 >> 2] + (HEAP32[$5 + 76 >> 2] + Math_imul(HEAP32[$5 + 160 >> 2], HEAP32[$5 + 164 >> 2]) | 0) | 0] - HEAP8[$5 + 159 | 0];
     label$10 : {
      if (HEAP32[$5 + 72 >> 2] >= HEAP32[$5 + 176 >> 2]) {
       $0 = $5 + 12 | 0;
       $1 = $5 + 20 | 0;
       $2 = $5 + 16 | 0;
       $3 = $5 + 40 | 0;
       $4 = $5 - -64 | 0;
       HEAP32[$5 + 68 >> 2] = tflite__MultiplyByQuantizedMultiplierGreaterThanOne_28int_2c_20int_2c_20int_29(HEAP32[$5 + 72 >> 2], HEAP32[$5 + 184 >> 2], HEAP32[$5 + 180 >> 2]);
       HEAP32[$5 + 64 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29(HEAP32[$5 + 68 >> 2]);
       HEAP32[$5 + 48 >> 2] = HEAP32[$4 >> 2];
       HEAP32[$5 + 56 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__exp_on_negative_values_int_2c_205__28gemmlowp__FixedPoint_int_2c_205__29(HEAP32[$5 + 48 >> 2]);
       HEAP32[$5 + 32 >> 2] = HEAP32[$5 + 80 >> 2];
       HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 56 >> 2];
       HEAP32[$5 + 40 >> 2] = gemmlowp__FixedPoint_int_2c_20_280_29_20__20_280_29__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$5 + 32 >> 2], HEAP32[$5 + 24 >> 2]);
       HEAP32[$5 + 44 >> 2] = int_20gemmlowp__RoundingDivideByPOT_int__28int_2c_20int_29(HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($3) >> 2], HEAP32[$5 + 84 >> 2] + 23 | 0);
       HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 44 >> 2] + -128;
       HEAP32[$5 + 16 >> 2] = 127;
       $1 = int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($1, $2);
       HEAP32[$5 + 12 >> 2] = -128;
       $0 = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($1, $0) >> 2];
       break label$10;
      }
      $0 = -128;
     }
     HEAP8[HEAP32[$5 + 188 >> 2] + (HEAP32[$5 + 76 >> 2] + Math_imul(HEAP32[$5 + 160 >> 2], HEAP32[$5 + 164 >> 2]) | 0) | 0] = $0;
     HEAP32[$5 + 76 >> 2] = HEAP32[$5 + 76 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 160 >> 2] = HEAP32[$5 + 160 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $5 + 208 | 0;
}
function void_20tflite__reference_ops__Softmax_signed_20char_2c_20short__28tflite__SoftmaxParams_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20short__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 208 | 0;
 global$0 = $5;
 HEAP32[$5 + 204 >> 2] = $0;
 HEAP32[$5 + 200 >> 2] = $1;
 HEAP32[$5 + 196 >> 2] = $2;
 HEAP32[$5 + 192 >> 2] = $3;
 HEAP32[$5 + 188 >> 2] = $4;
 HEAP32[$5 + 184 >> 2] = HEAP32[HEAP32[$5 + 204 >> 2] + 8 >> 2];
 HEAP32[$5 + 180 >> 2] = HEAP32[HEAP32[$5 + 204 >> 2] + 12 >> 2];
 HEAP32[$5 + 176 >> 2] = HEAP32[HEAP32[$5 + 204 >> 2] + 24 >> 2];
 HEAP32[$5 + 172 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 200 >> 2]) - 1;
 HEAP32[$5 + 168 >> 2] = tflite__MatchingFlatSizeSkipDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__29(HEAP32[$5 + 200 >> 2], HEAP32[$5 + 172 >> 2], HEAP32[$5 + 192 >> 2]);
 HEAP32[$5 + 164 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 200 >> 2], HEAP32[$5 + 172 >> 2], HEAP32[$5 + 192 >> 2], HEAP32[$5 + 172 >> 2]);
 HEAP32[$5 + 160 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 160 >> 2] < HEAP32[$5 + 168 >> 2]) {
   HEAP8[$5 + 159 | 0] = -128;
   HEAP32[$5 + 152 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 152 >> 2] < HEAP32[$5 + 164 >> 2]) {
     HEAP8[$5 + 159 | 0] = HEAPU8[signed_20char_20const__20std____2__max_signed_20char__28signed_20char_20const__2c_20signed_20char_20const__29($5 + 159 | 0, HEAP32[$5 + 196 >> 2] + (HEAP32[$5 + 152 >> 2] + Math_imul(HEAP32[$5 + 160 >> 2], HEAP32[$5 + 164 >> 2]) | 0) | 0) | 0];
     HEAP32[$5 + 152 >> 2] = HEAP32[$5 + 152 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 144 >> 2] = gemmlowp__FixedPoint_int_2c_2012___Zero_28_29();
   HEAP32[$5 + 140 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 140 >> 2] < HEAP32[$5 + 164 >> 2]) {
     HEAP32[$5 + 136 >> 2] = HEAP8[HEAP32[$5 + 196 >> 2] + (HEAP32[$5 + 140 >> 2] + Math_imul(HEAP32[$5 + 160 >> 2], HEAP32[$5 + 164 >> 2]) | 0) | 0] - HEAP8[$5 + 159 | 0];
     if (HEAP32[$5 + 136 >> 2] >= HEAP32[$5 + 176 >> 2]) {
      HEAP32[$5 + 132 >> 2] = tflite__MultiplyByQuantizedMultiplierGreaterThanOne_28int_2c_20int_2c_20int_29(HEAP32[$5 + 136 >> 2], HEAP32[$5 + 184 >> 2], HEAP32[$5 + 180 >> 2]);
      HEAP32[$5 + 128 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29(HEAP32[$5 + 132 >> 2]);
      HEAP32[$5 + 112 >> 2] = HEAP32[$5 + 144 >> 2];
      HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 128 >> 2];
      HEAP32[$5 + 96 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__exp_on_negative_values_int_2c_205__28gemmlowp__FixedPoint_int_2c_205__29(HEAP32[$5 + 88 >> 2]);
      HEAP32[$5 + 104 >> 2] = gemmlowp__FixedPoint_int_2c_2012__20gemmlowp__Rescale_12_2c_20int_2c_200__28gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$5 + 96 >> 2]);
      HEAP32[$5 + 120 >> 2] = gemmlowp__FixedPoint_int_2c_2012__20gemmlowp__operator__int_2c_2012__28gemmlowp__FixedPoint_int_2c_2012__2c_20gemmlowp__FixedPoint_int_2c_2012__29(HEAP32[$5 + 112 >> 2], HEAP32[$5 + 104 >> 2]);
      HEAP32[$5 + 144 >> 2] = HEAP32[$5 + 120 >> 2];
     }
     HEAP32[$5 + 140 >> 2] = HEAP32[$5 + 140 >> 2] + 1;
     continue;
    }
    break;
   }
   $0 = $5 + 84 | 0;
   HEAP32[$5 + 80 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29(tflite__GetReciprocal_28int_2c_20int_2c_20int__29(HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($5 + 144 | 0) >> 2], $0));
   HEAP32[$5 + 76 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 76 >> 2] < HEAP32[$5 + 164 >> 2]) {
     HEAP32[$5 + 72 >> 2] = HEAP8[HEAP32[$5 + 196 >> 2] + (HEAP32[$5 + 76 >> 2] + Math_imul(HEAP32[$5 + 160 >> 2], HEAP32[$5 + 164 >> 2]) | 0) | 0] - HEAP8[$5 + 159 | 0];
     label$10 : {
      if (HEAP32[$5 + 72 >> 2] >= HEAP32[$5 + 176 >> 2]) {
       $0 = $5 + 12 | 0;
       $1 = $5 + 20 | 0;
       $2 = $5 + 16 | 0;
       $3 = $5 + 40 | 0;
       $4 = $5 - -64 | 0;
       HEAP32[$5 + 68 >> 2] = tflite__MultiplyByQuantizedMultiplierGreaterThanOne_28int_2c_20int_2c_20int_29(HEAP32[$5 + 72 >> 2], HEAP32[$5 + 184 >> 2], HEAP32[$5 + 180 >> 2]);
       HEAP32[$5 + 64 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29(HEAP32[$5 + 68 >> 2]);
       HEAP32[$5 + 48 >> 2] = HEAP32[$4 >> 2];
       HEAP32[$5 + 56 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__exp_on_negative_values_int_2c_205__28gemmlowp__FixedPoint_int_2c_205__29(HEAP32[$5 + 48 >> 2]);
       HEAP32[$5 + 32 >> 2] = HEAP32[$5 + 80 >> 2];
       HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 56 >> 2];
       HEAP32[$5 + 40 >> 2] = gemmlowp__FixedPoint_int_2c_20_280_29_20__20_280_29__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$5 + 32 >> 2], HEAP32[$5 + 24 >> 2]);
       HEAP32[$5 + 44 >> 2] = int_20gemmlowp__RoundingDivideByPOT_int__28int_2c_20int_29(HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($3) >> 2], HEAP32[$5 + 84 >> 2] + 15 | 0);
       HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 44 >> 2] + -32768;
       HEAP32[$5 + 16 >> 2] = 32767;
       $1 = int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($1, $2);
       HEAP32[$5 + 12 >> 2] = -32768;
       $0 = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($1, $0) >> 2];
       break label$10;
      }
      $0 = -32768;
     }
     HEAP16[HEAP32[$5 + 188 >> 2] + (HEAP32[$5 + 76 >> 2] + Math_imul(HEAP32[$5 + 160 >> 2], HEAP32[$5 + 164 >> 2]) << 1) >> 1] = $0;
     HEAP32[$5 + 76 >> 2] = HEAP32[$5 + 76 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 160 >> 2] = HEAP32[$5 + 160 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $5 + 208 | 0;
}
function tflite__reference_ops__AveragePool_28tflite__PoolParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 144 | 0;
 global$0 = $5;
 HEAP32[$5 + 140 >> 2] = $0;
 HEAP32[$5 + 136 >> 2] = $1;
 HEAP32[$5 + 132 >> 2] = $2;
 HEAP32[$5 + 128 >> 2] = $3;
 HEAP32[$5 + 124 >> 2] = $4;
 label$1 : {
  if (HEAP32[HEAP32[$5 + 140 >> 2] + 28 >> 2] > HEAP32[HEAP32[$5 + 140 >> 2] + 32 >> 2]) {
   break label$1;
  }
 }
 label$2 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 136 >> 2]) | 0) != 4) {
   break label$2;
  }
 }
 label$3 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 128 >> 2]) | 0) != 4) {
   break label$3;
  }
 }
 HEAP32[$5 + 120 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 136 >> 2], 0, HEAP32[$5 + 128 >> 2], 0);
 HEAP32[$5 + 116 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 136 >> 2], 3, HEAP32[$5 + 128 >> 2], 3);
 HEAP32[$5 + 112 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 136 >> 2], 1);
 HEAP32[$5 + 108 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 136 >> 2], 2);
 HEAP32[$5 + 104 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 128 >> 2], 1);
 HEAP32[$5 + 100 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 128 >> 2], 2);
 HEAP32[$5 + 96 >> 2] = HEAP32[HEAP32[$5 + 140 >> 2] + 12 >> 2];
 HEAP32[$5 + 92 >> 2] = HEAP32[HEAP32[$5 + 140 >> 2] + 16 >> 2];
 HEAP32[$5 + 88 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 88 >> 2] < HEAP32[$5 + 120 >> 2]) {
   HEAP32[$5 + 84 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 84 >> 2] < HEAP32[$5 + 104 >> 2]) {
     HEAP32[$5 + 80 >> 2] = 0;
     while (1) {
      if (HEAP32[$5 + 80 >> 2] < HEAP32[$5 + 100 >> 2]) {
       HEAP32[$5 + 76 >> 2] = 0;
       while (1) {
        if (HEAP32[$5 + 76 >> 2] < HEAP32[$5 + 116 >> 2]) {
         $0 = $5 + 28 | 0;
         $1 = $5 + 40 | 0;
         $2 = $5 + 36 | 0;
         $3 = $5 + 48 | 0;
         HEAP32[$5 + 72 >> 2] = Math_imul(HEAP32[$5 + 80 >> 2], HEAP32[$5 + 92 >> 2]) - HEAP16[HEAP32[$5 + 140 >> 2] + 2 >> 1];
         HEAP32[$5 + 68 >> 2] = Math_imul(HEAP32[$5 + 84 >> 2], HEAP32[$5 + 96 >> 2]) - HEAP16[HEAP32[$5 + 140 >> 2] + 4 >> 1];
         HEAP32[$5 + 60 >> 2] = 0;
         HEAP32[$5 + 56 >> 2] = 0 - HEAP32[$5 + 72 >> 2];
         HEAP32[$5 + 64 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($5 + 60 | 0, $5 + 56 | 0) >> 2];
         $4 = HEAP32[$5 + 140 >> 2] + 24 | 0;
         HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 108 >> 2] - HEAP32[$5 + 72 >> 2];
         HEAP32[$5 + 52 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($4, $3) >> 2];
         HEAP32[$5 + 40 >> 2] = 0;
         HEAP32[$5 + 36 >> 2] = 0 - HEAP32[$5 + 68 >> 2];
         HEAP32[$5 + 44 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($1, $2) >> 2];
         $1 = HEAP32[$5 + 140 >> 2] + 20 | 0;
         HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 112 >> 2] - HEAP32[$5 + 68 >> 2];
         HEAP32[$5 + 32 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($1, $0) >> 2];
         HEAP32[$5 + 24 >> 2] = 0;
         HEAP32[$5 + 20 >> 2] = 0;
         HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 44 >> 2];
         while (1) {
          if (HEAP32[$5 + 16 >> 2] < HEAP32[$5 + 32 >> 2]) {
           HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 64 >> 2];
           while (1) {
            if (HEAP32[$5 + 12 >> 2] < HEAP32[$5 + 52 >> 2]) {
             HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 72 >> 2] + HEAP32[$5 + 12 >> 2];
             HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 68 >> 2] + HEAP32[$5 + 16 >> 2];
             HEAP32[$5 + 24 >> 2] = HEAPU8[HEAP32[$5 + 132 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$5 + 136 >> 2], HEAP32[$5 + 88 >> 2], HEAP32[$5 + 4 >> 2], HEAP32[$5 + 8 >> 2], HEAP32[$5 + 76 >> 2]) | 0] + HEAP32[$5 + 24 >> 2];
             HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 20 >> 2] + 1;
             HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 12 >> 2] + 1;
             continue;
            }
            break;
           }
           HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 16 >> 2] + 1;
           continue;
          }
          break;
         }
         HEAP32[$5 + 24 >> 2] = (HEAP32[$5 + 24 >> 2] + (HEAP32[$5 + 20 >> 2] / 2 | 0) | 0) / HEAP32[$5 + 20 >> 2];
         $0 = $5 + 24 | 0;
         HEAP32[$5 + 24 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($0, HEAP32[$5 + 140 >> 2] + 28 | 0) >> 2];
         HEAP32[$5 + 24 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($0, HEAP32[$5 + 140 >> 2] + 32 | 0) >> 2];
         $0 = HEAP32[$5 + 24 >> 2];
         HEAP8[HEAP32[$5 + 124 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$5 + 128 >> 2], HEAP32[$5 + 88 >> 2], HEAP32[$5 + 84 >> 2], HEAP32[$5 + 80 >> 2], HEAP32[$5 + 76 >> 2]) | 0] = $0;
         HEAP32[$5 + 76 >> 2] = HEAP32[$5 + 76 >> 2] + 1;
         continue;
        }
        break;
       }
       HEAP32[$5 + 80 >> 2] = HEAP32[$5 + 80 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$5 + 84 >> 2] = HEAP32[$5 + 84 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 88 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $5 + 144 | 0;
}
function jswrap_graphics_createArrayBuffer($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 112 | 0;
 global$0 = $4;
 HEAP32[$4 + 104 >> 2] = $0;
 HEAP32[$4 + 100 >> 2] = $1;
 HEAP32[$4 + 96 >> 2] = $2;
 HEAP32[$4 + 92 >> 2] = $3;
 label$1 : {
  label$2 : {
   if (!(HEAP32[$4 + 104 >> 2] <= 0 | HEAP32[$4 + 100 >> 2] <= 0 | HEAP32[$4 + 104 >> 2] > 32767)) {
    if (HEAP32[$4 + 100 >> 2] <= 32767) {
     break label$2;
    }
   }
   jsExceptionHere(1, 127108, 0);
   HEAP32[$4 + 108 >> 2] = 0;
   break label$1;
  }
  if (!(isValidBPP(HEAP32[$4 + 96 >> 2]) & 1)) {
   jsExceptionHere(1, 127121, 0);
   HEAP32[$4 + 108 >> 2] = 0;
   break label$1;
  }
  HEAP32[$4 + 88 >> 2] = jspNewObject(0, 127133);
  if (!HEAP32[$4 + 88 >> 2]) {
   HEAP32[$4 + 108 >> 2] = 0;
   break label$1;
  }
  HEAP8[$4 + 20 | 0] = 0;
  HEAP8[$4 + 21 | 0] = 0;
  HEAP8[$4 + 22 | 0] = 0;
  HEAP8[$4 + 23 | 0] = 0;
  graphicsStructInit($4 + 16 | 0, HEAP32[$4 + 104 >> 2], HEAP32[$4 + 100 >> 2], HEAP32[$4 + 96 >> 2]);
  HEAP8[$4 + 24 | 0] = 0;
  HEAP8[$4 + 25 | 0] = 0;
  HEAP8[$4 + 26 | 0] = 0;
  HEAP8[$4 + 27 | 0] = 0;
  $0 = HEAP32[$4 + 88 >> 2];
  HEAP8[$4 + 16 | 0] = $0;
  HEAP8[$4 + 17 | 0] = $0 >>> 8;
  HEAP8[$4 + 18 | 0] = $0 >>> 16;
  HEAP8[$4 + 19 | 0] = $0 >>> 24;
  if (jsvIsObject(HEAP32[$4 + 92 >> 2]) & 1) {
   if (jsvGetBoolAndUnLock(jsvObjectGetChild(HEAP32[$4 + 92 >> 2], 127142, 0)) & 1) {
    $0 = HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24) | 1;
    HEAP8[$4 + 24 | 0] = $0;
    HEAP8[$4 + 25 | 0] = $0 >>> 8;
    HEAP8[$4 + 26 | 0] = $0 >>> 16;
    HEAP8[$4 + 27 | 0] = $0 >>> 24;
   }
   if (jsvGetBoolAndUnLock(jsvObjectGetChild(HEAP32[$4 + 92 >> 2], 127149, 0)) & 1) {
    $0 = HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24) | 4;
    HEAP8[$4 + 24 | 0] = $0;
    HEAP8[$4 + 25 | 0] = $0 >>> 8;
    HEAP8[$4 + 26 | 0] = $0 >>> 16;
    HEAP8[$4 + 27 | 0] = $0 >>> 24;
   }
   if (jsvGetBoolAndUnLock(jsvObjectGetChild(HEAP32[$4 + 92 >> 2], 127153, 0)) & 1) {
    $0 = HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24) | 8;
    HEAP8[$4 + 24 | 0] = $0;
    HEAP8[$4 + 25 | 0] = $0 >>> 8;
    HEAP8[$4 + 26 | 0] = $0 >>> 16;
    HEAP8[$4 + 27 | 0] = $0 >>> 24;
   }
   if (jsvGetBoolAndUnLock(jsvObjectGetChild(HEAP32[$4 + 92 >> 2], 127165, 0)) & 1) {
    label$11 : {
     if (HEAPU8[$4 + 32 | 0] == 1) {
      $0 = HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24) | 2;
      HEAP8[$4 + 24 | 0] = $0;
      HEAP8[$4 + 25 | 0] = $0 >>> 8;
      HEAP8[$4 + 26 | 0] = $0 >>> 16;
      HEAP8[$4 + 27 | 0] = $0 >>> 24;
      break label$11;
     }
     jsExceptionHere(1, 127179, 0);
     HEAP32[$4 + 108 >> 2] = 0;
     break label$1;
    }
    if ((HEAPU8[$4 + 30 | 0] | HEAPU8[$4 + 31 | 0] << 8) & 7) {
     jsExceptionHere(1, 127227, 0);
     HEAP32[$4 + 108 >> 2] = 0;
     break label$1;
    }
   }
   HEAP32[$4 + 12 >> 2] = jsvObjectGetChild(HEAP32[$4 + 92 >> 2], 127284, 0);
   if (HEAP32[$4 + 12 >> 2]) {
    if (!(jsvIsStringEqual(HEAP32[$4 + 12 >> 2], 127296) & 1)) {
     label$16 : {
      if (!(jsvIsStringEqual(HEAP32[$4 + 12 >> 2], 127300) & 1)) {
       $0 = HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24) | 128;
       HEAP8[$4 + 24 | 0] = $0;
       HEAP8[$4 + 25 | 0] = $0 >>> 8;
       HEAP8[$4 + 26 | 0] = $0 >>> 16;
       HEAP8[$4 + 27 | 0] = $0 >>> 24;
       break label$16;
      }
      label$18 : {
       if (!(jsvIsStringEqual(HEAP32[$4 + 12 >> 2], 127304) & 1)) {
        $0 = HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24) | 256;
        HEAP8[$4 + 24 | 0] = $0;
        HEAP8[$4 + 25 | 0] = $0 >>> 8;
        HEAP8[$4 + 26 | 0] = $0 >>> 16;
        HEAP8[$4 + 27 | 0] = $0 >>> 24;
        break label$18;
       }
       label$20 : {
        if (!(jsvIsStringEqual(HEAP32[$4 + 12 >> 2], 127308) & 1)) {
         $0 = HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24) | 384;
         HEAP8[$4 + 24 | 0] = $0;
         HEAP8[$4 + 25 | 0] = $0 >>> 8;
         HEAP8[$4 + 26 | 0] = $0 >>> 16;
         HEAP8[$4 + 27 | 0] = $0 >>> 24;
         break label$20;
        }
        label$22 : {
         if (!(jsvIsStringEqual(HEAP32[$4 + 12 >> 2], 127312) & 1)) {
          $0 = HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24) | 512;
          HEAP8[$4 + 24 | 0] = $0;
          HEAP8[$4 + 25 | 0] = $0 >>> 8;
          HEAP8[$4 + 26 | 0] = $0 >>> 16;
          HEAP8[$4 + 27 | 0] = $0 >>> 24;
          break label$22;
         }
         label$24 : {
          if (!(jsvIsStringEqual(HEAP32[$4 + 12 >> 2], 127316) & 1)) {
           $0 = HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24) | 640;
           HEAP8[$4 + 24 | 0] = $0;
           HEAP8[$4 + 25 | 0] = $0 >>> 8;
           HEAP8[$4 + 26 | 0] = $0 >>> 16;
           HEAP8[$4 + 27 | 0] = $0 >>> 24;
           break label$24;
          }
          jsWarn(127320);
         }
        }
       }
      }
     }
    }
    jsvUnLock(HEAP32[$4 + 12 >> 2]);
   }
  }
  $0 = $4 + 16 | 0;
  lcdInit_ArrayBuffer($0);
  graphicsSetVar($0);
  HEAP32[$4 + 108 >> 2] = HEAP32[$4 + 88 >> 2];
 }
 global$0 = $4 + 112 | 0;
 return HEAP32[$4 + 108 >> 2];
}
function tflite__ops__micro__depthwise_conv__Prepare_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = global$0 - 192 | 0;
 global$0 = $2;
 HEAP32[$2 + 184 >> 2] = $0;
 HEAP32[$2 + 180 >> 2] = $1;
 label$1 : {
  if (!HEAP32[HEAP32[$2 + 180 >> 2] + 8 >> 2]) {
   break label$1;
  }
 }
 label$2 : {
  if (!HEAP32[HEAP32[$2 + 180 >> 2] + 12 >> 2]) {
   break label$2;
  }
 }
 HEAP32[$2 + 176 >> 2] = HEAP32[HEAP32[$2 + 180 >> 2] + 12 >> 2];
 HEAP32[$2 + 172 >> 2] = HEAP32[HEAP32[$2 + 180 >> 2] + 8 >> 2];
 HEAP32[$2 + 168 >> 2] = tflite__GetOutput_28TfLiteContext__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 184 >> 2], HEAP32[$2 + 180 >> 2]);
 HEAP32[$2 + 164 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 184 >> 2], HEAP32[$2 + 180 >> 2], 0);
 HEAP32[$2 + 160 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 184 >> 2], HEAP32[$2 + 180 >> 2], 1);
 HEAP32[$2 + 156 >> 2] = HEAP32[HEAP32[$2 + 164 >> 2] + 28 >> 2];
 HEAP32[$2 + 152 >> 2] = tflite__SizeOfDimension_28TfLiteTensor_20const__2c_20int_29(HEAP32[$2 + 164 >> 2], 2);
 HEAP32[$2 + 148 >> 2] = tflite__SizeOfDimension_28TfLiteTensor_20const__2c_20int_29(HEAP32[$2 + 164 >> 2], 1);
 HEAP32[$2 + 144 >> 2] = tflite__SizeOfDimension_28TfLiteTensor_20const__2c_20int_29(HEAP32[$2 + 160 >> 2], 2);
 HEAP32[$2 + 140 >> 2] = tflite__SizeOfDimension_28TfLiteTensor_20const__2c_20int_29(HEAP32[$2 + 160 >> 2], 1);
 HEAP32[$2 + 136 >> 2] = HEAP32[HEAP32[HEAP32[$2 + 160 >> 2] + 20 >> 2] + 16 >> 2];
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$2 + 184 >> 2] + 56 >> 2]](HEAP32[$2 + 184 >> 2], HEAP32[$2 + 136 >> 2] << 2) | 0;
 HEAP32[HEAP32[$2 + 172 >> 2] + 36 >> 2] = $0;
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$2 + 184 >> 2] + 56 >> 2]](HEAP32[$2 + 184 >> 2], HEAP32[$2 + 136 >> 2] << 2) | 0;
 HEAP32[HEAP32[$2 + 172 >> 2] + 40 >> 2] = $0;
 label$3 : {
  if (HEAP32[HEAP32[$2 + 164 >> 2] + 28 >> 2] == 9) {
   if (HEAP32[HEAP32[$2 + 160 >> 2] >> 2] != 1) {
    $0 = HEAP32[HEAP32[$2 + 184 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 184 >> 2];
    $3 = HEAP32[HEAP32[$2 + 160 >> 2] >> 2];
    HEAP32[$2 + 20 >> 2] = 1;
    HEAP32[$2 + 16 >> 2] = $3;
    HEAP32[$2 + 12 >> 2] = 133398;
    HEAP32[$2 + 8 >> 2] = 133372;
    HEAP32[$2 + 4 >> 2] = 140;
    HEAP32[$2 >> 2] = 133280;
    FUNCTION_TABLE[$0]($1, 133254, $2);
    HEAP32[$2 + 188 >> 2] = 1;
    break label$3;
   }
   HEAP32[$2 + 132 >> 2] = HEAP32[HEAP32[$2 + 160 >> 2] + 4 >> 2];
   if (!HEAP32[$2 + 132 >> 2]) {
    $0 = HEAP32[HEAP32[$2 + 184 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 184 >> 2];
    HEAP32[$2 + 120 >> 2] = 133447;
    HEAP32[$2 + 116 >> 2] = 145;
    HEAP32[$2 + 112 >> 2] = 133280;
    FUNCTION_TABLE[$0]($1, 133424, $2 + 112 | 0);
    HEAP32[$2 + 188 >> 2] = 1;
    break label$3;
   }
   if (!HEAP32[HEAP32[$2 + 132 >> 2] >> 2]) {
    $0 = HEAP32[HEAP32[$2 + 184 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 184 >> 2];
    HEAP32[$2 + 104 >> 2] = 133467;
    HEAP32[$2 + 100 >> 2] = 146;
    HEAP32[$2 + 96 >> 2] = 133280;
    FUNCTION_TABLE[$0]($1, 133424, $2 + 96 | 0);
    HEAP32[$2 + 188 >> 2] = 1;
    break label$3;
   }
   if (!HEAP32[HEAP32[$2 + 132 >> 2] + 4 >> 2]) {
    $0 = HEAP32[HEAP32[$2 + 184 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 184 >> 2];
    HEAP32[$2 + 88 >> 2] = 133494;
    HEAP32[$2 + 84 >> 2] = 147;
    HEAP32[$2 + 80 >> 2] = 133280;
    FUNCTION_TABLE[$0]($1, 133424, $2 + 80 | 0);
    HEAP32[$2 + 188 >> 2] = 1;
    break label$3;
   }
   if (!(HEAP32[HEAP32[HEAP32[$2 + 132 >> 2] >> 2] >> 2] == 1 | HEAP32[HEAP32[HEAP32[$2 + 132 >> 2] >> 2] >> 2] == HEAP32[HEAP32[HEAP32[$2 + 160 >> 2] + 20 >> 2] + 16 >> 2])) {
    $0 = HEAP32[HEAP32[$2 + 184 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 184 >> 2];
    HEAP32[$2 + 72 >> 2] = 133526;
    HEAP32[$2 + 68 >> 2] = 151;
    HEAP32[$2 + 64 >> 2] = 133280;
    FUNCTION_TABLE[$0]($1, 133424, $2 - -64 | 0);
    HEAP32[$2 + 188 >> 2] = 1;
    break label$3;
   }
   if (HEAP32[HEAP32[HEAP32[$2 + 132 >> 2] >> 2] >> 2] != HEAP32[HEAP32[HEAP32[$2 + 132 >> 2] + 4 >> 2] >> 2]) {
    $0 = HEAP32[HEAP32[$2 + 184 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 184 >> 2];
    $3 = HEAP32[HEAP32[HEAP32[$2 + 132 >> 2] >> 2] >> 2];
    HEAP32[$2 + 52 >> 2] = HEAP32[HEAP32[HEAP32[$2 + 132 >> 2] + 4 >> 2] >> 2];
    HEAP32[$2 + 48 >> 2] = $3;
    HEAP32[$2 + 44 >> 2] = 133689;
    HEAP32[$2 + 40 >> 2] = 133656;
    HEAP32[$2 + 36 >> 2] = 153;
    HEAP32[$2 + 32 >> 2] = 133280;
    FUNCTION_TABLE[$0]($1, 133254, $2 + 32 | 0);
    HEAP32[$2 + 188 >> 2] = 1;
    break label$3;
   }
  }
  HEAP32[$2 + 128 >> 2] = tflite__ops__micro__depthwise_conv___28anonymous_20namespace_29__CalculateOpData_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteDepthwiseConvParams__2c_20int_2c_20int_2c_20int_2c_20int_2c_20TfLiteType_2c_20tflite__ops__micro__depthwise_conv___28anonymous_20namespace_29__OpData__29(HEAP32[$2 + 184 >> 2], HEAP32[$2 + 180 >> 2], HEAP32[$2 + 176 >> 2], HEAP32[$2 + 152 >> 2], HEAP32[$2 + 148 >> 2], HEAP32[$2 + 144 >> 2], HEAP32[$2 + 140 >> 2], HEAP32[$2 + 156 >> 2], HEAP32[$2 + 172 >> 2]);
  if (HEAP32[$2 + 128 >> 2]) {
   HEAP32[$2 + 188 >> 2] = HEAP32[$2 + 128 >> 2];
   break label$3;
  }
  HEAP32[HEAP32[$2 + 172 >> 2] + 16 >> 2] = HEAP32[HEAP32[$2 + 164 >> 2] + 12 >> 2];
  HEAP32[HEAP32[$2 + 172 >> 2] + 20 >> 2] = HEAP32[HEAP32[$2 + 160 >> 2] + 12 >> 2];
  HEAP32[HEAP32[$2 + 172 >> 2] + 24 >> 2] = HEAP32[HEAP32[$2 + 168 >> 2] + 12 >> 2];
  HEAP32[$2 + 188 >> 2] = 0;
 }
 global$0 = $2 + 192 | 0;
 return HEAP32[$2 + 188 >> 2];
}
function jswrap_interface_setWatch($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 80 | 0;
 global$0 = $3;
 HEAP32[$3 + 72 >> 2] = $0;
 HEAP8[$3 + 71 | 0] = $1;
 HEAP32[$3 + 64 >> 2] = $2;
 label$1 : {
  if (!(jshIsPinValid(HEAPU8[$3 + 71 | 0]) & 1)) {
   jsError(121944, 0);
   HEAP32[$3 + 76 >> 2] = 0;
   break label$1;
  }
  label$3 : {
   if (jsiIsWatchingPin(HEAPU8[$3 + 71 | 0]) & 1) {
    break label$3;
   }
   if (jshIsDeviceInitialised(HEAPU8[$3 + 71 | 0]) & 1) {
    break label$3;
   }
   jsWarn(122121);
   HEAP32[$3 + 76 >> 2] = 0;
   break label$1;
  }
  HEAP8[$3 + 63 | 0] = 0;
  HEAPF64[$3 + 48 >> 3] = 0;
  HEAP32[$3 + 44 >> 2] = 0;
  HEAP8[$3 + 43 | 0] = 0;
  HEAP8[$3 + 42 | 0] = 255;
  if (HEAPU8[$3 + 71 | 0] == 17) {
   HEAP32[$3 + 44 >> 2] = 1;
   HEAPF64[$3 + 48 >> 3] = 25;
  }
  label$5 : {
   if (jsvIsObject(HEAP32[$3 + 64 >> 2]) & 1) {
    HEAP32[$3 + 36 >> 2] = jsvObjectGetChild(HEAP32[$3 + 64 >> 2], 122087, 0);
    if (HEAP32[$3 + 36 >> 2]) {
     HEAP8[$3 + 63 | 0] = jsvGetBoolAndUnLock(HEAP32[$3 + 36 >> 2]) & 1;
    }
    HEAP32[$3 + 36 >> 2] = jsvObjectGetChild(HEAP32[$3 + 64 >> 2], 122256, 0);
    if (HEAP32[$3 + 36 >> 2]) {
     HEAPF64[$3 + 48 >> 3] = jsvGetFloatAndUnLock(HEAP32[$3 + 36 >> 2]);
    }
    $0 = __DOUBLE_BITS(HEAPF64[$3 + 48 >> 3]);
    $1 = i64toi32_i32$HIGH_BITS & 2147483647;
    if (!(HEAPF64[$3 + 48 >> 3] < 0 ? 0 : ($1 | 0) == 2146435072 & $0 >>> 0 <= 0 | $1 >>> 0 < 2146435072)) {
     HEAPF64[$3 + 48 >> 3] = 0;
    }
    HEAP32[$3 + 36 >> 2] = jsvObjectGetChild(HEAP32[$3 + 64 >> 2], 122265, 0);
    if (!(jsvIsUndefined(HEAP32[$3 + 36 >> 2]) & 1)) {
     label$12 : {
      if (jsvIsNumeric(HEAP32[$3 + 36 >> 2]) & 1) {
       HEAP32[$3 + 32 >> 2] = jsvGetInteger(HEAP32[$3 + 36 >> 2]);
       $0 = $3;
       if (HEAP32[$3 + 32 >> 2] > 0) {
        $1 = 1;
       } else {
        $1 = HEAP32[$3 + 32 >> 2] < 0 ? -1 : 0;
       }
       HEAP32[$0 + 44 >> 2] = $1;
       break label$12;
      }
      HEAP32[$3 + 44 >> 2] = -1e3;
      if (jsvIsString(HEAP32[$3 + 36 >> 2]) & 1) {
       label$16 : {
        if (jsvIsStringEqual(HEAP32[$3 + 36 >> 2], 122270) & 1) {
         HEAP32[$3 + 44 >> 2] = 1;
         break label$16;
        }
        label$18 : {
         if (jsvIsStringEqual(HEAP32[$3 + 36 >> 2], 122277) & 1) {
          HEAP32[$3 + 44 >> 2] = -1;
          break label$18;
         }
         if (jsvIsStringEqual(HEAP32[$3 + 36 >> 2], 122285) & 1) {
          HEAP32[$3 + 44 >> 2] = 0;
         }
        }
       }
      }
     }
    }
    jsvUnLock(HEAP32[$3 + 36 >> 2]);
    if (!(HEAP32[$3 + 44 >> 2] <= 1 ? HEAP32[$3 + 44 >> 2] >= -1 : 0)) {
     jsExceptionHere(3, 122290, 0);
     HEAP32[$3 + 76 >> 2] = 0;
     break label$1;
    }
    HEAP8[$3 + 43 | 0] = jsvGetBoolAndUnLock(jsvObjectGetChild(HEAP32[$3 + 64 >> 2], 122359, 0)) & 1;
    HEAP8[$3 + 42 | 0] = jshGetPinFromVarAndUnLock(jsvObjectGetChild(HEAP32[$3 + 64 >> 2], 122363, 0));
    break label$5;
   }
   HEAP8[$3 + 63 | 0] = jsvGetBool(HEAP32[$3 + 64 >> 2]) & 1;
  }
  HEAP32[$3 + 28 >> 2] = -1;
  label$23 : {
   label$24 : {
    if (jsvIsFunction(HEAP32[$3 + 72 >> 2]) & 1) {
     break label$24;
    }
    if (jsvIsString(HEAP32[$3 + 72 >> 2]) & 1) {
     break label$24;
    }
    jsExceptionHere(1, 122368, 0);
    break label$23;
   }
   HEAP32[$3 + 24 >> 2] = jsvNewWithFlags(5);
   if (HEAP32[$3 + 24 >> 2]) {
    jsvObjectSetChildAndUnLock(HEAP32[$3 + 24 >> 2], 122401, jsvNewFromPin(HEAPU8[$3 + 71 | 0]));
    if (HEAP8[$3 + 63 | 0] & 1) {
     jsvObjectSetChildAndUnLock(HEAP32[$3 + 24 >> 2], 122405, jsvNewFromBool(HEAP8[$3 + 63 | 0] & 1));
    }
    if (HEAPF64[$3 + 48 >> 3] > 0) {
     jsvObjectSetChildAndUnLock(HEAP32[$3 + 24 >> 2], 122256, jsvNewFromInteger(jshGetTimeFromMilliseconds(HEAPF64[$3 + 48 >> 3])));
    }
    if (HEAP32[$3 + 44 >> 2]) {
     jsvObjectSetChildAndUnLock(HEAP32[$3 + 24 >> 2], 122265, jsvNewFromInteger(HEAP32[$3 + 44 >> 2]));
    }
    jsvObjectSetChild(HEAP32[$3 + 24 >> 2], 122411, HEAP32[$3 + 72 >> 2]);
    jsvObjectSetChildAndUnLock(HEAP32[$3 + 24 >> 2], 122420, jsvNewFromBool(jshPinInput(HEAPU8[$3 + 71 | 0]) & 1));
   }
   HEAP8[$3 + 23 | 0] = 0;
   if (!(jsiIsWatchingPin(HEAPU8[$3 + 71 | 0]) & 1)) {
    HEAP8[$3 + 23 | 0] = jshPinWatch(HEAPU8[$3 + 71 | 0], 1);
   }
   label$30 : {
    if (HEAPU8[$3 + 23 | 0]) {
     jshSetEventCallback(HEAPU8[$3 + 23 | 0], 0);
     if (jshIsPinValid(HEAPU8[$3 + 42 | 0]) & 1) {
      jshSetEventDataPin(HEAPU8[$3 + 23 | 0], HEAPU8[$3 + 42 | 0]);
     }
     if (HEAP8[$3 + 43 | 0] & 1) {
      label$34 : {
       if (jsvIsNativeFunction(HEAP32[$3 + 72 >> 2]) & 1) {
        jshSetEventCallback(HEAPU8[$3 + 23 | 0], jsvGetNativeFunctionPtr(HEAP32[$3 + 72 >> 2]));
        break label$34;
       }
       label$36 : {
        if (jshIsPinValid(HEAPU8[$3 + 42 | 0]) & 1) {
         jsExceptionHere(1, 122426, 0);
         break label$36;
        }
        jsExceptionHere(1, 122461, 0);
       }
      }
     }
     break label$30;
    }
    if (HEAP8[$3 + 43 | 0] & 1) {
     jsExceptionHere(1, 122513, 0);
    }
   }
   HEAP32[$3 + 16 >> 2] = jsvLock(HEAPU16[161111]);
   HEAP32[$3 + 28 >> 2] = jsvArrayAddToEnd(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 24 >> 2]) - 1;
   jsvUnLock2(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 24 >> 2]);
  }
  $0 = $3;
  label$39 : {
   if (HEAP32[$3 + 28 >> 2] >= 0) {
    $1 = jsvNewFromInteger(HEAP32[$3 + 28 >> 2]);
    break label$39;
   }
   $1 = 0;
  }
  HEAP32[$0 + 76 >> 2] = $1;
 }
 global$0 = $3 + 80 | 0;
 return HEAP32[$3 + 76 >> 2];
}
function tflite__ops__micro__conv__Prepare_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = global$0 - 192 | 0;
 global$0 = $2;
 HEAP32[$2 + 184 >> 2] = $0;
 HEAP32[$2 + 180 >> 2] = $1;
 label$1 : {
  if (!HEAP32[HEAP32[$2 + 180 >> 2] + 8 >> 2]) {
   break label$1;
  }
 }
 label$2 : {
  if (!HEAP32[HEAP32[$2 + 180 >> 2] + 12 >> 2]) {
   break label$2;
  }
 }
 HEAP32[$2 + 176 >> 2] = HEAP32[HEAP32[$2 + 180 >> 2] + 8 >> 2];
 HEAP32[$2 + 172 >> 2] = HEAP32[HEAP32[$2 + 180 >> 2] + 12 >> 2];
 HEAP32[$2 + 168 >> 2] = tflite__GetOutput_28TfLiteContext__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 184 >> 2], HEAP32[$2 + 180 >> 2]);
 HEAP32[$2 + 164 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 184 >> 2], HEAP32[$2 + 180 >> 2], 0);
 HEAP32[$2 + 160 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 184 >> 2], HEAP32[$2 + 180 >> 2], 1);
 HEAP32[$2 + 156 >> 2] = HEAP32[HEAP32[HEAP32[$2 + 164 >> 2] + 20 >> 2] + 12 >> 2];
 HEAP32[$2 + 152 >> 2] = HEAP32[HEAP32[HEAP32[$2 + 164 >> 2] + 20 >> 2] + 8 >> 2];
 HEAP32[$2 + 148 >> 2] = HEAP32[HEAP32[HEAP32[$2 + 160 >> 2] + 20 >> 2] + 12 >> 2];
 HEAP32[$2 + 144 >> 2] = HEAP32[HEAP32[HEAP32[$2 + 160 >> 2] + 20 >> 2] + 8 >> 2];
 HEAP32[$2 + 140 >> 2] = HEAP32[HEAP32[HEAP32[$2 + 168 >> 2] + 20 >> 2] + 12 >> 2];
 HEAP32[$2 + 136 >> 2] = HEAP32[HEAP32[HEAP32[$2 + 168 >> 2] + 20 >> 2] + 8 >> 2];
 HEAP32[$2 + 132 >> 2] = HEAP32[HEAP32[HEAP32[$2 + 160 >> 2] + 20 >> 2] + 4 >> 2];
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$2 + 184 >> 2] + 56 >> 2]](HEAP32[$2 + 184 >> 2], HEAP32[$2 + 132 >> 2] << 2) | 0;
 HEAP32[HEAP32[$2 + 176 >> 2] + 36 >> 2] = $0;
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$2 + 184 >> 2] + 56 >> 2]](HEAP32[$2 + 184 >> 2], HEAP32[$2 + 132 >> 2] << 2) | 0;
 HEAP32[HEAP32[$2 + 176 >> 2] + 40 >> 2] = $0;
 label$3 : {
  if (HEAP32[HEAP32[$2 + 164 >> 2] + 28 >> 2] == 9) {
   if (HEAP32[HEAP32[$2 + 160 >> 2] >> 2] != 1) {
    $0 = HEAP32[HEAP32[$2 + 184 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 184 >> 2];
    $3 = HEAP32[HEAP32[$2 + 160 >> 2] >> 2];
    HEAP32[$2 + 20 >> 2] = 1;
    HEAP32[$2 + 16 >> 2] = $3;
    HEAP32[$2 + 12 >> 2] = 134028;
    HEAP32[$2 + 8 >> 2] = 134002;
    HEAP32[$2 + 4 >> 2] = 152;
    HEAP32[$2 >> 2] = 133836;
    FUNCTION_TABLE[$0]($1, 133954, $2);
    HEAP32[$2 + 188 >> 2] = 1;
    break label$3;
   }
   HEAP32[$2 + 128 >> 2] = HEAP32[HEAP32[$2 + 160 >> 2] + 4 >> 2];
   if (!HEAP32[$2 + 128 >> 2]) {
    $0 = HEAP32[HEAP32[$2 + 184 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 184 >> 2];
    HEAP32[$2 + 120 >> 2] = 134054;
    HEAP32[$2 + 116 >> 2] = 156;
    HEAP32[$2 + 112 >> 2] = 133836;
    FUNCTION_TABLE[$0]($1, 133813, $2 + 112 | 0);
    HEAP32[$2 + 188 >> 2] = 1;
    break label$3;
   }
   if (!HEAP32[HEAP32[$2 + 128 >> 2] >> 2]) {
    $0 = HEAP32[HEAP32[$2 + 184 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 184 >> 2];
    HEAP32[$2 + 104 >> 2] = 134074;
    HEAP32[$2 + 100 >> 2] = 157;
    HEAP32[$2 + 96 >> 2] = 133836;
    FUNCTION_TABLE[$0]($1, 133813, $2 + 96 | 0);
    HEAP32[$2 + 188 >> 2] = 1;
    break label$3;
   }
   if (!HEAP32[HEAP32[$2 + 128 >> 2] + 4 >> 2]) {
    $0 = HEAP32[HEAP32[$2 + 184 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 184 >> 2];
    HEAP32[$2 + 88 >> 2] = 134101;
    HEAP32[$2 + 84 >> 2] = 158;
    HEAP32[$2 + 80 >> 2] = 133836;
    FUNCTION_TABLE[$0]($1, 133813, $2 + 80 | 0);
    HEAP32[$2 + 188 >> 2] = 1;
    break label$3;
   }
   if (!(HEAP32[HEAP32[HEAP32[$2 + 128 >> 2] >> 2] >> 2] == 1 | HEAP32[HEAP32[HEAP32[$2 + 128 >> 2] >> 2] >> 2] == HEAP32[HEAP32[HEAP32[$2 + 160 >> 2] + 20 >> 2] + 4 >> 2])) {
    $0 = HEAP32[HEAP32[$2 + 184 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 184 >> 2];
    HEAP32[$2 + 72 >> 2] = 134133;
    HEAP32[$2 + 68 >> 2] = 163;
    HEAP32[$2 + 64 >> 2] = 133836;
    FUNCTION_TABLE[$0]($1, 133813, $2 - -64 | 0);
    HEAP32[$2 + 188 >> 2] = 1;
    break label$3;
   }
   if (HEAP32[HEAP32[HEAP32[$2 + 128 >> 2] >> 2] >> 2] != HEAP32[HEAP32[HEAP32[$2 + 128 >> 2] + 4 >> 2] >> 2]) {
    $0 = HEAP32[HEAP32[$2 + 184 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 184 >> 2];
    $3 = HEAP32[HEAP32[HEAP32[$2 + 128 >> 2] >> 2] >> 2];
    HEAP32[$2 + 52 >> 2] = HEAP32[HEAP32[HEAP32[$2 + 128 >> 2] + 4 >> 2] >> 2];
    HEAP32[$2 + 48 >> 2] = $3;
    HEAP32[$2 + 44 >> 2] = 134287;
    HEAP32[$2 + 40 >> 2] = 134254;
    HEAP32[$2 + 36 >> 2] = 165;
    HEAP32[$2 + 32 >> 2] = 133836;
    FUNCTION_TABLE[$0]($1, 133954, $2 + 32 | 0);
    HEAP32[$2 + 188 >> 2] = 1;
    break label$3;
   }
  }
  HEAP32[$2 + 124 >> 2] = tflite__ops__micro__conv__CalculateOpData_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteConvParams_20const__2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20TfLiteType_2c_20tflite__ops__micro__conv__OpData__29(HEAP32[$2 + 184 >> 2], HEAP32[$2 + 180 >> 2], HEAP32[$2 + 172 >> 2], HEAP32[$2 + 156 >> 2], HEAP32[$2 + 152 >> 2], HEAP32[$2 + 148 >> 2], HEAP32[$2 + 144 >> 2], HEAP32[$2 + 140 >> 2], HEAP32[$2 + 136 >> 2], HEAP32[HEAP32[$2 + 164 >> 2] + 28 >> 2], HEAP32[$2 + 176 >> 2]);
  if (HEAP32[$2 + 124 >> 2]) {
   HEAP32[$2 + 188 >> 2] = HEAP32[$2 + 124 >> 2];
   break label$3;
  }
  HEAP32[HEAP32[$2 + 176 >> 2] + 16 >> 2] = HEAP32[HEAP32[$2 + 164 >> 2] + 12 >> 2];
  HEAP32[HEAP32[$2 + 176 >> 2] + 20 >> 2] = HEAP32[HEAP32[$2 + 160 >> 2] + 12 >> 2];
  HEAP32[HEAP32[$2 + 176 >> 2] + 24 >> 2] = HEAP32[HEAP32[$2 + 168 >> 2] + 12 >> 2];
  HEAP32[$2 + 188 >> 2] = 0;
 }
 global$0 = $2 + 192 | 0;
 return HEAP32[$2 + 188 >> 2];
}
function tflite__GreedyMemoryPlanner__CalculateOffsetsIfNeeded_28_29($0) {
 var $1 = 0;
 $1 = global$0 - 96 | 0;
 global$0 = $1;
 HEAP32[$1 + 92 >> 2] = $0;
 label$1 : {
  $0 = HEAP32[$1 + 92 >> 2];
  if (!(HEAP8[$0 + 40 | 0] & 1) | !HEAP32[$0 + 8 >> 2]) {
   break label$1;
  }
  HEAP8[$0 + 40 | 0] = 0;
  HEAP32[$1 + 88 >> 2] = HEAP32[$0 + 8 >> 2];
  HEAP32[$1 + 84 >> 2] = 0;
  HEAP32[$1 + 80 >> 2] = 0;
  while (1) {
   if (HEAP32[$1 + 80 >> 2] < HEAP32[$0 + 8 >> 2]) {
    label$5 : {
     if (HEAP32[(HEAP32[$0 + 12 >> 2] + (HEAP32[$1 + 80 >> 2] << 4) | 0) + 4 >> 2] == -1) {
      HEAP32[$1 + 88 >> 2] = HEAP32[$1 + 88 >> 2] + -1;
      HEAP32[HEAP32[$0 + 16 >> 2] + (HEAP32[$1 + 88 >> 2] << 2) >> 2] = HEAP32[HEAP32[$0 + 12 >> 2] + (HEAP32[$1 + 80 >> 2] << 4) >> 2];
      HEAP32[HEAP32[$0 + 20 >> 2] + (HEAP32[$1 + 88 >> 2] << 2) >> 2] = HEAP32[$1 + 80 >> 2];
      HEAP32[HEAP32[$0 + 36 >> 2] + (HEAP32[$1 + 80 >> 2] << 2) >> 2] = -1;
      break label$5;
     }
     HEAP32[HEAP32[$0 + 16 >> 2] + (HEAP32[$1 + 84 >> 2] << 2) >> 2] = HEAP32[HEAP32[$0 + 12 >> 2] + (HEAP32[$1 + 80 >> 2] << 4) >> 2];
     HEAP32[HEAP32[$0 + 20 >> 2] + (HEAP32[$1 + 84 >> 2] << 2) >> 2] = HEAP32[$1 + 80 >> 2];
     HEAP32[HEAP32[$0 + 36 >> 2] + (HEAP32[$1 + 80 >> 2] << 2) >> 2] = HEAP32[(HEAP32[$0 + 12 >> 2] + (HEAP32[$1 + 80 >> 2] << 4) | 0) + 4 >> 2];
     HEAP32[$1 + 84 >> 2] = HEAP32[$1 + 84 >> 2] + 1;
    }
    HEAP32[$1 + 80 >> 2] = HEAP32[$1 + 80 >> 2] + 1;
    continue;
   }
   break;
  }
  tflite__ReverseSortInPlace_28int__2c_20int__2c_20int_29(HEAP32[$0 + 16 >> 2] + (HEAP32[$1 + 84 >> 2] << 2) | 0, HEAP32[$0 + 20 >> 2] + (HEAP32[$1 + 84 >> 2] << 2) | 0, HEAP32[$0 + 8 >> 2] - HEAP32[$1 + 84 >> 2] | 0);
  HEAP32[$0 + 32 >> 2] = 0;
  HEAP32[$0 + 28 >> 2] = 1;
  HEAP32[$1 + 76 >> 2] = HEAP32[$0 + 24 >> 2] + Math_imul(HEAP32[$0 + 32 >> 2], 12);
  HEAP32[HEAP32[$1 + 76 >> 2] + 8 >> 2] = -1;
  HEAP32[$1 + 72 >> 2] = HEAP32[HEAP32[$0 + 20 >> 2] >> 2];
  HEAP32[HEAP32[$1 + 76 >> 2] + 4 >> 2] = HEAP32[$1 + 72 >> 2];
  if (HEAP32[(HEAP32[$0 + 12 >> 2] + (HEAP32[$1 + 72 >> 2] << 4) | 0) + 4 >> 2] == -1) {
   HEAP32[HEAP32[$0 + 36 >> 2] + (HEAP32[$1 + 72 >> 2] << 2) >> 2] = 0;
  }
  HEAP32[HEAP32[$1 + 76 >> 2] >> 2] = HEAP32[HEAP32[$0 + 36 >> 2] + (HEAP32[$1 + 72 >> 2] << 2) >> 2];
  HEAP32[$1 + 68 >> 2] = 1;
  while (1) {
   if (HEAP32[$1 + 68 >> 2] >= HEAP32[$0 + 8 >> 2]) {
    break label$1;
   }
   HEAP32[$1 + 72 >> 2] = HEAP32[HEAP32[$0 + 20 >> 2] + (HEAP32[$1 + 68 >> 2] << 2) >> 2];
   HEAP32[$1 + 64 >> 2] = HEAP32[$0 + 12 >> 2] + (HEAP32[$1 + 72 >> 2] << 4);
   HEAP32[$1 + 60 >> 2] = HEAP32[HEAP32[$1 + 64 >> 2] >> 2];
   HEAP32[$1 + 56 >> 2] = HEAP32[HEAP32[$1 + 64 >> 2] + 8 >> 2];
   HEAP32[$1 + 52 >> 2] = HEAP32[HEAP32[$1 + 64 >> 2] + 12 >> 2];
   HEAP32[$1 + 48 >> 2] = 0;
   label$9 : {
    if (HEAP32[HEAP32[$1 + 64 >> 2] + 4 >> 2] == -1) {
     HEAP32[$1 + 44 >> 2] = 0;
     while (1) {
      HEAP32[$1 + 40 >> 2] = tflite__GreedyMemoryPlanner__NextSimultaneouslyActiveBuffer_28tflite__GreedyMemoryPlanner__ListEntry_20const__2c_20int_2c_20int_29($0, HEAP32[$1 + 44 >> 2], HEAP32[$1 + 56 >> 2], HEAP32[$1 + 52 >> 2]);
      if (HEAP32[$1 + 44 >> 2]) {
       HEAP32[$1 + 36 >> 2] = HEAP32[$0 + 12 >> 2] + (HEAP32[HEAP32[$1 + 44 >> 2] + 4 >> 2] << 4);
       HEAP32[$1 + 32 >> 2] = HEAP32[HEAP32[$1 + 44 >> 2] >> 2] + HEAP32[HEAP32[$1 + 36 >> 2] >> 2];
       if (HEAP32[$1 + 32 >> 2] > HEAP32[$1 + 48 >> 2]) {
        HEAP32[$1 + 48 >> 2] = HEAP32[$1 + 32 >> 2];
       }
      }
      label$14 : {
       if (!HEAP32[$1 + 40 >> 2]) {
        break label$14;
       }
       HEAP32[$1 + 28 >> 2] = HEAP32[HEAP32[$1 + 40 >> 2] >> 2] - HEAP32[$1 + 48 >> 2];
       if (HEAP32[$1 + 28 >> 2] >= HEAP32[$1 + 60 >> 2]) {
        break label$14;
       }
       HEAP32[$1 + 44 >> 2] = HEAP32[$1 + 40 >> 2];
       continue;
      }
      break;
     }
     break label$9;
    }
    HEAP32[$1 + 48 >> 2] = HEAP32[HEAP32[$1 + 64 >> 2] + 4 >> 2];
   }
   HEAP32[HEAP32[$0 + 36 >> 2] + (HEAP32[$1 + 72 >> 2] << 2) >> 2] = HEAP32[$1 + 48 >> 2];
   HEAP32[$1 + 24 >> 2] = HEAP32[$0 + 24 >> 2] + Math_imul(HEAP32[$0 + 28 >> 2], 12);
   HEAP32[HEAP32[$1 + 24 >> 2] >> 2] = HEAP32[$1 + 48 >> 2];
   HEAP32[HEAP32[$1 + 24 >> 2] + 4 >> 2] = HEAP32[$1 + 72 >> 2];
   HEAP32[$1 + 20 >> 2] = HEAP32[$0 + 28 >> 2];
   HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 28 >> 2] + 1;
   label$15 : {
    if (HEAP32[HEAP32[$1 + 76 >> 2] >> 2] > HEAP32[$1 + 48 >> 2]) {
     HEAP32[$1 + 76 >> 2] = HEAP32[$1 + 24 >> 2];
     HEAP32[HEAP32[$1 + 76 >> 2] + 8 >> 2] = HEAP32[$0 + 32 >> 2];
     HEAP32[$0 + 32 >> 2] = HEAP32[$1 + 20 >> 2];
     break label$15;
    }
    HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 76 >> 2];
    while (1) {
     HEAP32[$1 + 12 >> 2] = HEAP32[HEAP32[$1 + 16 >> 2] + 8 >> 2];
     label$18 : {
      if (HEAP32[$1 + 12 >> 2] == -1) {
       HEAP32[HEAP32[$1 + 16 >> 2] + 8 >> 2] = HEAP32[$1 + 20 >> 2];
       HEAP32[HEAP32[$1 + 24 >> 2] + 8 >> 2] = -1;
       break label$18;
      }
      HEAP32[$1 + 8 >> 2] = HEAP32[$0 + 24 >> 2] + Math_imul(HEAP32[$1 + 12 >> 2], 12);
      if (HEAP32[HEAP32[$1 + 8 >> 2] >> 2] > HEAP32[$1 + 48 >> 2]) {
       HEAP32[HEAP32[$1 + 24 >> 2] + 8 >> 2] = HEAP32[HEAP32[$1 + 16 >> 2] + 8 >> 2];
       HEAP32[HEAP32[$1 + 16 >> 2] + 8 >> 2] = HEAP32[$1 + 20 >> 2];
      } else {
       HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 8 >> 2];
       continue;
      }
     }
     break;
    }
   }
   HEAP32[$1 + 68 >> 2] = HEAP32[$1 + 68 >> 2] + 1;
   continue;
  }
 }
 global$0 = $1 + 96 | 0;
}
function terminalSendChar($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 176 | 0;
 global$0 = $1;
 HEAP8[$1 + 175 | 0] = $0;
 label$1 : {
  if (!HEAP8[336940]) {
   if (HEAP8[$1 + 175 | 0] == 8) {
    if (HEAPU8[336938] > 0) {
     HEAP8[336938] = HEAPU8[336938] + -1;
    }
    break label$1;
   }
   label$5 : {
    if (HEAP8[$1 + 175 | 0] == 10) {
     HEAP8[336938] = 0;
     HEAP8[141724] = HEAPU8[141724] + 1;
     while (1) {
      if (HEAPU8[141724] >= 22) {
       terminalScroll();
       continue;
      }
      break;
     }
     break label$5;
    }
    label$9 : {
     if (HEAP8[$1 + 175 | 0] == 13) {
      HEAP8[336938] = 0;
      break label$9;
     }
     label$11 : {
      if (HEAP8[$1 + 175 | 0] == 27) {
       HEAP8[336940] = 27;
       break label$11;
      }
      if (!(HEAP8[$1 + 175 | 0] == 19 | HEAP8[$1 + 175 | 0] == 17)) {
       if (terminalGetGFX($1 + 96 | 0) & 1) {
        HEAP16[$1 + 94 >> 1] = Math_imul(HEAPU8[336938], 6);
        HEAP16[$1 + 92 >> 1] = ((HEAPU8[$1 + 110 | 0] | HEAPU8[$1 + 111 | 0] << 8) + (HEAPU8[141724] << 3) | 0) - 176;
        HEAP32[$1 + 88 >> 2] = HEAPU8[$1 + 113 | 0] | HEAPU8[$1 + 114 | 0] << 8 | (HEAPU8[$1 + 115 | 0] << 16 | HEAPU8[$1 + 116 | 0] << 24);
        HEAP32[$1 + 84 >> 2] = HEAPU8[$1 + 117 | 0] | HEAPU8[$1 + 118 | 0] << 8 | (HEAPU8[$1 + 119 | 0] << 16 | HEAPU8[$1 + 120 | 0] << 24);
        $0 = HEAPU8[324592] | HEAPU8[324593] << 8;
        HEAP8[$1 + 113 | 0] = $0;
        HEAP8[$1 + 114 | 0] = $0 >>> 8;
        HEAP8[$1 + 115 | 0] = $0 >>> 16;
        HEAP8[$1 + 116 | 0] = $0 >>> 24;
        $0 = HEAPU8[324594] | HEAPU8[324595] << 8;
        HEAP8[$1 + 117 | 0] = $0;
        HEAP8[$1 + 118 | 0] = $0 >>> 8;
        HEAP8[$1 + 119 | 0] = $0 >>> 16;
        HEAP8[$1 + 120 | 0] = $0 >>> 24;
        $2 = $1 + 96 | 0;
        graphicsDrawChar6x8($2, HEAP16[$1 + 94 >> 1], HEAP16[$1 + 92 >> 1], HEAP8[$1 + 175 | 0], 1, 1, 1);
        $0 = HEAP32[$1 + 88 >> 2];
        HEAP8[$1 + 113 | 0] = $0;
        HEAP8[$1 + 114 | 0] = $0 >>> 8;
        HEAP8[$1 + 115 | 0] = $0 >>> 16;
        HEAP8[$1 + 116 | 0] = $0 >>> 24;
        $0 = HEAP32[$1 + 84 >> 2];
        HEAP8[$1 + 117 | 0] = $0;
        HEAP8[$1 + 118 | 0] = $0 >>> 8;
        HEAP8[$1 + 119 | 0] = $0 >>> 16;
        HEAP8[$1 + 120 | 0] = $0 >>> 24;
        terminalSetGFX($2);
       }
       if (HEAPU8[336938] < 255) {
        HEAP8[336938] = HEAPU8[336938] + 1;
       }
      }
     }
    }
   }
   break label$1;
  }
  label$17 : {
   if (HEAP8[336940] == 27) {
    if (HEAP8[336941] == 91) {
     if (HEAP8[336942] == 63) {
      if (HEAP8[336943] == 55) {
       terminalControlCharsReset();
       break label$17;
      }
      label$22 : {
       if (HEAP8[$1 + 175 | 0] == 55) {
        HEAP8[336943] = 55;
        break label$22;
       }
       terminalControlCharsReset();
      }
      break label$17;
     }
     label$24 : {
      if (HEAP8[$1 + 175 | 0] == 63) {
       HEAP8[336942] = 63;
       break label$24;
      }
      terminalControlCharsReset();
      $0 = HEAP8[$1 + 175 | 0] + -65 | 0;
      label$26 : {
       if ($0 >>> 0 > 9) {
        break label$26;
       }
       label$27 : {
        switch ($0 - 1 | 0) {
        default:
         if (HEAPU8[141724] > 0) {
          HEAP8[141724] = HEAPU8[141724] + -1;
         }
         break label$26;
        case 0:
         HEAP8[141724] = HEAPU8[141724] + 1;
         while (1) {
          if (HEAPU8[141724] >= 22) {
           terminalScroll();
           continue;
          }
          break;
         }
         break label$26;
        case 1:
         if (HEAPU8[336938] < 255) {
          HEAP8[336938] = HEAPU8[336938] + 1;
         }
         break label$26;
        case 2:
         if (HEAPU8[336938] > 0) {
          HEAP8[336938] = HEAPU8[336938] + -1;
         }
         break label$26;
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
         break label$26;
        case 8:
         break label$27;
        }
       }
       if (terminalGetGFX($1 + 8 | 0) & 1) {
        HEAP16[$1 + 6 >> 1] = Math_imul(HEAPU8[336938], 6);
        HEAP16[$1 + 4 >> 1] = ((HEAPU8[$1 + 22 | 0] | HEAPU8[$1 + 23 | 0] << 8) + (HEAPU8[141724] << 3) | 0) - 176;
        $0 = $1;
        if ((HEAPU8[$1 + 16 | 0] | HEAPU8[$1 + 17 | 0] << 8 | (HEAPU8[$1 + 18 | 0] << 16 | HEAPU8[$1 + 19 | 0] << 24)) & 16) {
         $2 = HEAPU8[$1 + 22 | 0] | HEAPU8[$1 + 23 | 0] << 8;
        } else {
         $2 = HEAPU8[$1 + 20 | 0] | HEAPU8[$1 + 21 | 0] << 8;
        }
        HEAP16[$0 + 2 >> 1] = $2;
        $0 = $1;
        if ((HEAPU8[$1 + 16 | 0] | HEAPU8[$1 + 17 | 0] << 8 | (HEAPU8[$1 + 18 | 0] << 16 | HEAPU8[$1 + 19 | 0] << 24)) & 16) {
         $2 = HEAPU8[$1 + 20 | 0] | HEAPU8[$1 + 21 | 0] << 8;
        } else {
         $2 = HEAPU8[$1 + 22 | 0] | HEAPU8[$1 + 23 | 0] << 8;
        }
        HEAP16[$0 >> 1] = $2;
        $0 = $1 + 8 | 0;
        graphicsFillRect($0, HEAP16[$1 + 6 >> 1], HEAP16[$1 + 4 >> 1], HEAP16[$1 + 2 >> 1] - 1 | 0, HEAP16[$1 + 4 >> 1] + 7 | 0, 0);
        graphicsFillRect($0, 0, HEAP16[$1 + 4 >> 1] + 8 | 0, HEAP16[$1 + 2 >> 1] - 1 | 0, HEAP16[$1 >> 1] - 1 | 0, 0);
        terminalSetGFX($0);
       }
      }
     }
     break label$17;
    }
    label$42 : {
     if (HEAP8[$1 + 175 | 0] == 91) {
      HEAP8[336941] = 91;
      break label$42;
     }
     terminalControlCharsReset();
    }
    break label$17;
   }
   terminalControlCharsReset();
  }
 }
 global$0 = $1 + 176 | 0;
}
function jswGetSymbolListForObject($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (jsvIsNativeFunction(HEAP32[$1 + 8 >> 2]) & 1) {
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 37) {
    HEAP32[$1 + 12 >> 2] = 93193;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 38) {
    HEAP32[$1 + 12 >> 2] = 93202;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 39) {
    HEAP32[$1 + 12 >> 2] = 93220;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 40) {
    HEAP32[$1 + 12 >> 2] = 93229;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 41) {
    HEAP32[$1 + 12 >> 2] = 93247;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 22) {
    HEAP32[$1 + 12 >> 2] = 93283;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 42) {
    HEAP32[$1 + 12 >> 2] = 93346;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 43) {
    HEAP32[$1 + 12 >> 2] = 93355;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 44) {
    HEAP32[$1 + 12 >> 2] = 93364;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 45) {
    HEAP32[$1 + 12 >> 2] = 93373;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 46) {
    HEAP32[$1 + 12 >> 2] = 93391;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 47) {
    HEAP32[$1 + 12 >> 2] = 93418;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 48) {
    HEAP32[$1 + 12 >> 2] = 93445;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 49) {
    HEAP32[$1 + 12 >> 2] = 93454;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 29) {
    HEAP32[$1 + 12 >> 2] = 93463;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 31) {
    HEAP32[$1 + 12 >> 2] = 93490;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 50) {
    HEAP32[$1 + 12 >> 2] = 93508;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 33) {
    HEAP32[$1 + 12 >> 2] = 93526;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 34) {
    HEAP32[$1 + 12 >> 2] = 93544;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 51) {
    HEAP32[$1 + 12 >> 2] = 93571;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 52) {
    HEAP32[$1 + 12 >> 2] = 93589;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 53) {
    HEAP32[$1 + 12 >> 2] = 93598;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 20) {
    HEAP32[$1 + 12 >> 2] = 93607;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 54) {
    HEAP32[$1 + 12 >> 2] = 93616;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 55) {
    HEAP32[$1 + 12 >> 2] = 93625;
    break label$1;
   }
  }
  if (HEAP32[$1 + 8 >> 2] == HEAP32[80545]) {
   HEAP32[$1 + 12 >> 2] = 93184;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function tflite__reference_ops__AveragePool_28tflite__PoolParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = Math_fround(0);
 $5 = global$0 - 144 | 0;
 global$0 = $5;
 HEAP32[$5 + 140 >> 2] = $0;
 HEAP32[$5 + 136 >> 2] = $1;
 HEAP32[$5 + 132 >> 2] = $2;
 HEAP32[$5 + 128 >> 2] = $3;
 HEAP32[$5 + 124 >> 2] = $4;
 label$1 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 136 >> 2]) | 0) != 4) {
   break label$1;
  }
 }
 label$2 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 128 >> 2]) | 0) != 4) {
   break label$2;
  }
 }
 HEAP32[$5 + 120 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 136 >> 2], 0, HEAP32[$5 + 128 >> 2], 0);
 HEAP32[$5 + 116 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 136 >> 2], 3, HEAP32[$5 + 128 >> 2], 3);
 HEAP32[$5 + 112 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 136 >> 2], 1);
 HEAP32[$5 + 108 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 136 >> 2], 2);
 HEAP32[$5 + 104 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 128 >> 2], 1);
 HEAP32[$5 + 100 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 128 >> 2], 2);
 HEAP32[$5 + 96 >> 2] = HEAP32[HEAP32[$5 + 140 >> 2] + 12 >> 2];
 HEAP32[$5 + 92 >> 2] = HEAP32[HEAP32[$5 + 140 >> 2] + 16 >> 2];
 HEAP32[$5 + 88 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 88 >> 2] < HEAP32[$5 + 120 >> 2]) {
   HEAP32[$5 + 84 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 84 >> 2] < HEAP32[$5 + 104 >> 2]) {
     HEAP32[$5 + 80 >> 2] = 0;
     while (1) {
      if (HEAP32[$5 + 80 >> 2] < HEAP32[$5 + 100 >> 2]) {
       HEAP32[$5 + 76 >> 2] = 0;
       while (1) {
        if (HEAP32[$5 + 76 >> 2] < HEAP32[$5 + 116 >> 2]) {
         $0 = $5 + 28 | 0;
         $1 = $5 + 40 | 0;
         $2 = $5 + 36 | 0;
         $3 = $5 + 48 | 0;
         HEAP32[$5 + 72 >> 2] = Math_imul(HEAP32[$5 + 80 >> 2], HEAP32[$5 + 92 >> 2]) - HEAP16[HEAP32[$5 + 140 >> 2] + 2 >> 1];
         HEAP32[$5 + 68 >> 2] = Math_imul(HEAP32[$5 + 84 >> 2], HEAP32[$5 + 96 >> 2]) - HEAP16[HEAP32[$5 + 140 >> 2] + 4 >> 1];
         HEAP32[$5 + 60 >> 2] = 0;
         HEAP32[$5 + 56 >> 2] = 0 - HEAP32[$5 + 72 >> 2];
         HEAP32[$5 + 64 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($5 + 60 | 0, $5 + 56 | 0) >> 2];
         $4 = HEAP32[$5 + 140 >> 2] + 24 | 0;
         HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 108 >> 2] - HEAP32[$5 + 72 >> 2];
         HEAP32[$5 + 52 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($4, $3) >> 2];
         HEAP32[$5 + 40 >> 2] = 0;
         HEAP32[$5 + 36 >> 2] = 0 - HEAP32[$5 + 68 >> 2];
         HEAP32[$5 + 44 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($1, $2) >> 2];
         $1 = HEAP32[$5 + 140 >> 2] + 20 | 0;
         HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 112 >> 2] - HEAP32[$5 + 68 >> 2];
         HEAP32[$5 + 32 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($1, $0) >> 2];
         HEAPF32[$5 + 24 >> 2] = 0;
         HEAPF32[$5 + 20 >> 2] = 0;
         HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 44 >> 2];
         while (1) {
          if (HEAP32[$5 + 16 >> 2] < HEAP32[$5 + 32 >> 2]) {
           HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 64 >> 2];
           while (1) {
            if (HEAP32[$5 + 12 >> 2] < HEAP32[$5 + 52 >> 2]) {
             HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 72 >> 2] + HEAP32[$5 + 12 >> 2];
             HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 68 >> 2] + HEAP32[$5 + 16 >> 2];
             $0 = HEAP32[$5 + 132 >> 2];
             $1 = tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$5 + 136 >> 2], HEAP32[$5 + 88 >> 2], HEAP32[$5 + 4 >> 2], HEAP32[$5 + 8 >> 2], HEAP32[$5 + 76 >> 2]);
             HEAPF32[$5 + 24 >> 2] = HEAPF32[$5 + 24 >> 2] + HEAPF32[$0 + ($1 << 2) >> 2];
             HEAPF32[$5 + 20 >> 2] = HEAPF32[$5 + 20 >> 2] + Math_fround(1);
             HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 12 >> 2] + 1;
             continue;
            }
            break;
           }
           HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 16 >> 2] + 1;
           continue;
          }
          break;
         }
         HEAPF32[$5 >> 2] = HEAPF32[$5 + 24 >> 2] / HEAPF32[$5 + 20 >> 2];
         $6 = float_20tflite__ActivationFunctionWithMinMax_float__28float_2c_20float_2c_20float_29(HEAPF32[$5 >> 2], HEAPF32[HEAP32[$5 + 140 >> 2] + 36 >> 2], HEAPF32[HEAP32[$5 + 140 >> 2] + 40 >> 2]);
         HEAPF32[HEAP32[$5 + 124 >> 2] + (tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$5 + 128 >> 2], HEAP32[$5 + 88 >> 2], HEAP32[$5 + 84 >> 2], HEAP32[$5 + 80 >> 2], HEAP32[$5 + 76 >> 2]) << 2) >> 2] = $6;
         HEAP32[$5 + 76 >> 2] = HEAP32[$5 + 76 >> 2] + 1;
         continue;
        }
        break;
       }
       HEAP32[$5 + 80 >> 2] = HEAP32[$5 + 80 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$5 + 84 >> 2] = HEAP32[$5 + 84 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 88 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $5 + 144 | 0;
}
function jsvIterateBufferCallback($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 256 | 0;
 global$0 = $3;
 HEAP32[$3 + 248 >> 2] = $0;
 HEAP32[$3 + 244 >> 2] = $1;
 HEAP32[$3 + 240 >> 2] = $2;
 HEAP8[$3 + 239 | 0] = 1;
 label$1 : {
  label$2 : {
   if (jsvIsNumeric(HEAP32[$3 + 248 >> 2]) & 1) {
    $0 = $3 + 238 | 0;
    HEAP8[$3 + 238 | 0] = jsvGetInteger(HEAP32[$3 + 248 >> 2]);
    FUNCTION_TABLE[HEAP32[$3 + 244 >> 2]]($0, 1, HEAP32[$3 + 240 >> 2]);
    break label$2;
   }
   label$4 : {
    if (jsvIsObject(HEAP32[$3 + 248 >> 2]) & 1) {
     HEAP32[$3 + 232 >> 2] = jsvObjectGetChild(HEAP32[$3 + 248 >> 2], 79245, 0);
     if (jsvIsFunction(HEAP32[$3 + 232 >> 2]) & 1) {
      HEAP32[$3 + 228 >> 2] = jspExecuteFunction(HEAP32[$3 + 232 >> 2], 0, 0, 0);
      jsvUnLock(HEAP32[$3 + 232 >> 2]);
      if (HEAP32[$3 + 228 >> 2]) {
       HEAP8[$3 + 227 | 0] = jsvIterateBufferCallback(HEAP32[$3 + 228 >> 2], HEAP32[$3 + 244 >> 2], HEAP32[$3 + 240 >> 2]) & 1;
       jsvUnLock(HEAP32[$3 + 228 >> 2]);
       HEAP8[$3 + 255 | 0] = HEAP8[$3 + 227 | 0] & 1;
       break label$1;
      }
      HEAP8[$3 + 255 | 0] = 1;
      break label$1;
     }
     jsvUnLock(HEAP32[$3 + 232 >> 2]);
     HEAP32[$3 + 220 >> 2] = jsvObjectGetChild(HEAP32[$3 + 248 >> 2], 79254, 0);
     HEAP32[$3 + 216 >> 2] = jsvObjectGetChild(HEAP32[$3 + 248 >> 2], 79260, 0);
     label$8 : {
      label$9 : {
       if (!HEAP32[$3 + 220 >> 2] | !HEAP32[$3 + 216 >> 2]) {
        break label$9;
       }
       if (!(jsvIsNumeric(HEAP32[$3 + 220 >> 2]) & 1)) {
        break label$9;
       }
       HEAP32[$3 + 212 >> 2] = jsvGetInteger(HEAP32[$3 + 220 >> 2]);
       while (1) {
        if (HEAP8[$3 + 239 | 0] & 1) {
         $0 = HEAP32[$3 + 212 >> 2];
         HEAP32[$3 + 212 >> 2] = $0 + -1;
         $0 = ($0 | 0) > 0;
        } else {
         $0 = 0;
        }
        if ($0) {
         HEAP8[$3 + 239 | 0] = jsvIterateBufferCallback(HEAP32[$3 + 216 >> 2], HEAP32[$3 + 244 >> 2], HEAP32[$3 + 240 >> 2]) & 1;
         continue;
        }
        break;
       }
       break label$8;
      }
      HEAP32[$3 >> 2] = HEAP32[$3 + 248 >> 2];
      jsExceptionHere(3, 79265, $3);
      HEAP8[$3 + 239 | 0] = 0;
     }
     jsvUnLock2(HEAP32[$3 + 220 >> 2], HEAP32[$3 + 216 >> 2]);
     break label$4;
    }
    label$14 : {
     if (jsvIsString(HEAP32[$3 + 248 >> 2]) & 1) {
      jsvStringIteratorNew($3 + 176 | 0, HEAP32[$3 + 248 >> 2], 0);
      while (1) {
       if (jsvStringIteratorHasChar($3 + 176 | 0) & 1) {
        $0 = HEAPU8[$3 + 239 | 0];
       } else {
        $0 = 0;
       }
       if ($0 & 1) {
        jsvStringIteratorGetPtrAndNext($3 + 176 | 0, $3 + 172 | 0, $3 + 168 | 0);
        FUNCTION_TABLE[HEAP32[$3 + 244 >> 2]](HEAP32[$3 + 172 >> 2], HEAP32[$3 + 168 >> 2], HEAP32[$3 + 240 >> 2]);
        continue;
       }
       break;
      }
      jsvStringIteratorFree($3 + 176 | 0);
      break label$14;
     }
     label$20 : {
      if (jsvIsArrayBuffer(HEAP32[$3 + 248 >> 2]) & 1) {
       jsvArrayBufferIteratorNew($3 + 112 | 0, HEAP32[$3 + 248 >> 2], 0);
       label$22 : {
        if (!(HEAPU16[$3 + 148 >> 1] & 16 | (HEAPU16[$3 + 148 >> 1] & 15) != 1)) {
         HEAP32[$3 + 108 >> 2] = $3 + 112;
         HEAP32[$3 + 104 >> 2] = jsvGetArrayBufferLength(HEAP32[$3 + 248 >> 2]);
         while (1) {
          if (HEAP32[$3 + 104 >> 2]) {
           jsvStringIteratorGetPtrAndNext(HEAP32[$3 + 108 >> 2], $3 + 100 | 0, $3 + 96 | 0);
           if (HEAPU32[$3 + 96 >> 2] > HEAPU32[$3 + 104 >> 2]) {
            HEAP32[$3 + 96 >> 2] = HEAP32[$3 + 104 >> 2];
           }
           FUNCTION_TABLE[HEAP32[$3 + 244 >> 2]](HEAP32[$3 + 100 >> 2], HEAP32[$3 + 96 >> 2], HEAP32[$3 + 240 >> 2]);
           HEAP32[$3 + 104 >> 2] = HEAP32[$3 + 104 >> 2] - HEAP32[$3 + 96 >> 2];
           continue;
          }
          break;
         }
         break label$22;
        }
        while (1) {
         if (jsvArrayBufferIteratorHasElement($3 + 112 | 0) & 1) {
          $0 = $3 + 95 | 0;
          $1 = $3 + 112 | 0;
          HEAP8[$3 + 95 | 0] = jsvArrayBufferIteratorGetIntegerValue($1);
          FUNCTION_TABLE[HEAP32[$3 + 244 >> 2]]($0, 1, HEAP32[$3 + 240 >> 2]);
          jsvArrayBufferIteratorNext($1);
          continue;
         }
         break;
        }
       }
       jsvArrayBufferIteratorFree($3 + 112 | 0);
       break label$20;
      }
      label$29 : {
       if (jsvIsIterable(HEAP32[$3 + 248 >> 2]) & 1) {
        jsvIteratorNew($3 + 32 | 0, HEAP32[$3 + 248 >> 2], 1);
        while (1) {
         if (jsvIteratorHasElement($3 + 32 | 0) & 1) {
          $0 = HEAPU8[$3 + 239 | 0];
         } else {
          $0 = 0;
         }
         if ($0 & 1) {
          $0 = $3 + 32 | 0;
          HEAP32[$3 + 28 >> 2] = jsvIteratorGetValue($0);
          HEAP8[$3 + 239 | 0] = jsvIterateBufferCallback(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 244 >> 2], HEAP32[$3 + 240 >> 2]) & 1;
          jsvUnLock(HEAP32[$3 + 28 >> 2]);
          jsvIteratorNext($0);
          continue;
         }
         break;
        }
        jsvIteratorFree($3 + 32 | 0);
        break label$29;
       }
       HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 248 >> 2];
       jsExceptionHere(3, 79365, $3 + 16 | 0);
       HEAP8[$3 + 239 | 0] = 0;
      }
     }
    }
   }
  }
  HEAP8[$3 + 255 | 0] = HEAP8[$3 + 239 | 0] & 1;
 }
 global$0 = $3 + 256 | 0;
 return HEAP8[$3 + 255 | 0] & 1;
}
function jsvGarbageCollect() {
 var $0 = 0, $1 = 0, $2 = 0;
 $0 = global$0 - 48 | 0;
 global$0 = $0;
 label$1 : {
  if (HEAP32[35541]) {
   HEAP32[$0 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[35541] = 2;
  HEAP16[$0 + 42 >> 1] = 1;
  while (1) {
   if (HEAPU16[$0 + 42 >> 1] <= HEAPU32[35415]) {
    HEAP32[$0 + 36 >> 2] = jsvGetAddressOf(HEAPU16[$0 + 42 >> 1]);
    $1 = HEAP32[$0 + 36 >> 2];
    if ((HEAPU8[$1 + 13 | 0] | HEAPU8[$1 + 14 | 0] << 8) & 63) {
     $1 = HEAP32[$0 + 36 >> 2];
     $2 = HEAPU8[$1 + 13 | 0] | HEAPU8[$1 + 14 | 0] << 8 | 128;
     HEAP8[$1 + 13 | 0] = $2;
     HEAP8[$1 + 14 | 0] = $2 >>> 8;
     if (jsvIsFlatString(HEAP32[$0 + 36 >> 2]) & 1) {
      HEAP16[$0 + 42 >> 1] = HEAPU16[$0 + 42 >> 1] + jsvGetFlatStringBlocks(HEAP32[$0 + 36 >> 2]);
     }
    }
    HEAP16[$0 + 42 >> 1] = HEAPU16[$0 + 42 >> 1] + 1;
    continue;
   }
   break;
  }
  HEAP16[$0 + 42 >> 1] = 1;
  while (1) {
   if (HEAPU16[$0 + 42 >> 1] <= HEAPU32[35415]) {
    HEAP32[$0 + 32 >> 2] = jsvGetAddressOf(HEAPU16[$0 + 42 >> 1]);
    $1 = HEAP32[$0 + 32 >> 2];
    label$9 : {
     if (!((HEAPU8[$1 + 13 | 0] | HEAPU8[$1 + 14 | 0] << 8) & 128)) {
      break label$9;
     }
     if ((jsvGetLocks(HEAP32[$0 + 32 >> 2]) & 255) <= 0) {
      break label$9;
     }
     if (!(jsvGarbageCollectMarkUsed(HEAP32[$0 + 32 >> 2]) & 1)) {
      HEAP32[35541] = 0;
      HEAP32[$0 + 44 >> 2] = 0;
      break label$1;
     }
    }
    if (jsvIsFlatString(HEAP32[$0 + 32 >> 2]) & 1) {
     HEAP16[$0 + 42 >> 1] = HEAPU16[$0 + 42 >> 1] + jsvGetFlatStringBlocks(HEAP32[$0 + 32 >> 2]);
    }
    HEAP16[$0 + 42 >> 1] = HEAPU16[$0 + 42 >> 1] + 1;
    continue;
   }
   break;
  }
  HEAP32[$0 + 28 >> 2] = 0;
  HEAP16[71084] = 0;
  HEAP32[$0 + 24 >> 2] = 0;
  HEAP16[$0 + 42 >> 1] = 1;
  while (1) {
   if (HEAPU16[$0 + 42 >> 1] <= HEAPU32[35415]) {
    HEAP32[$0 + 20 >> 2] = jsvGetAddressOf(HEAPU16[$0 + 42 >> 1]);
    $1 = HEAP32[$0 + 20 >> 2];
    label$14 : {
     if ((HEAPU8[$1 + 13 | 0] | HEAPU8[$1 + 14 | 0] << 8) & 128) {
      if (jsvIsFlatString(HEAP32[$0 + 20 >> 2]) & 1) {
       HEAP32[$0 + 16 >> 2] = jsvGetFlatStringBlocks(HEAP32[$0 + 20 >> 2]);
       HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 16 >> 2] + HEAP32[$0 + 28 >> 2];
       $1 = HEAP32[$0 + 20 >> 2];
       HEAP8[$1 + 13 | 0] = 0;
       HEAP8[$1 + 14 | 0] = 0;
       label$17 : {
        if (HEAP32[$0 + 24 >> 2]) {
         jsvSetNextSibling(HEAP32[$0 + 24 >> 2], HEAPU16[$0 + 42 >> 1]);
         break label$17;
        }
        HEAP16[71084] = HEAPU16[$0 + 42 >> 1];
       }
       HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 20 >> 2];
       while (1) {
        label$20 : {
         $1 = HEAP32[$0 + 16 >> 2];
         HEAP32[$0 + 16 >> 2] = $1 + -1;
         if ($1 >>> 0 <= 0) {
          break label$20;
         }
         HEAP16[$0 + 42 >> 1] = HEAPU16[$0 + 42 >> 1] + 1;
         HEAP32[$0 + 20 >> 2] = jsvGetAddressOf(HEAPU16[$0 + 42 >> 1]);
         $1 = HEAP32[$0 + 20 >> 2];
         HEAP8[$1 + 13 | 0] = 0;
         HEAP8[$1 + 14 | 0] = 0;
         label$21 : {
          if (HEAP32[$0 + 24 >> 2]) {
           jsvSetNextSibling(HEAP32[$0 + 24 >> 2], HEAPU16[$0 + 42 >> 1]);
           break label$21;
          }
          HEAP16[71084] = HEAPU16[$0 + 42 >> 1];
         }
         HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 20 >> 2];
         continue;
        }
        break;
       }
       break label$14;
      }
      if (jsvHasSingleChild(HEAP32[$0 + 20 >> 2]) & 1) {
       HEAP16[$0 + 14 >> 1] = jsvGetFirstChild(HEAP32[$0 + 20 >> 2]);
       if (HEAPU16[$0 + 14 >> 1]) {
        HEAP32[$0 + 8 >> 2] = jsvGetAddressOf(HEAPU16[$0 + 14 >> 1]);
        $1 = HEAP32[$0 + 8 >> 2];
        label$25 : {
         if (!(HEAPU8[$1 + 13 | 0] | HEAPU8[$1 + 14 | 0] << 8)) {
          break label$25;
         }
         $1 = HEAP32[$0 + 8 >> 2];
         if ((HEAPU8[$1 + 13 | 0] | HEAPU8[$1 + 14 | 0] << 8) & 128) {
          break label$25;
         }
         jsvUnRef(HEAP32[$0 + 8 >> 2]);
        }
       }
      }
      $1 = HEAP32[$0 + 20 >> 2];
      HEAP8[$1 + 13 | 0] = 0;
      HEAP8[$1 + 14 | 0] = 0;
      label$26 : {
       if (HEAP32[$0 + 24 >> 2]) {
        jsvSetNextSibling(HEAP32[$0 + 24 >> 2], HEAPU16[$0 + 42 >> 1]);
        break label$26;
       }
       HEAP16[71084] = HEAPU16[$0 + 42 >> 1];
      }
      HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 20 >> 2];
      HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 28 >> 2] + 1;
      break label$14;
     }
     label$28 : {
      if (jsvIsFlatString(HEAP32[$0 + 20 >> 2]) & 1) {
       HEAP16[$0 + 42 >> 1] = HEAPU16[$0 + 42 >> 1] + jsvGetFlatStringBlocks(HEAP32[$0 + 20 >> 2]);
       break label$28;
      }
      $1 = HEAP32[$0 + 20 >> 2];
      if (!(HEAPU8[$1 + 13 | 0] | HEAPU8[$1 + 14 | 0] << 8)) {
       label$31 : {
        if (HEAP32[$0 + 24 >> 2]) {
         jsvSetNextSibling(HEAP32[$0 + 24 >> 2], HEAPU16[$0 + 42 >> 1]);
         break label$31;
        }
        HEAP16[71084] = HEAPU16[$0 + 42 >> 1];
       }
       HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 20 >> 2];
      }
     }
    }
    HEAP16[$0 + 42 >> 1] = HEAPU16[$0 + 42 >> 1] + 1;
    continue;
   }
   break;
  }
  if (HEAP32[$0 + 24 >> 2]) {
   jsvSetNextSibling(HEAP32[$0 + 24 >> 2], 0);
  }
  HEAP32[35541] = 0;
  HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 28 >> 2];
 }
 global$0 = $0 + 48 | 0;
 return HEAP32[$0 + 44 >> 2];
}
function tflite__reference_ops__MaxPool_28tflite__PoolParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = Math_fround(0);
 $5 = global$0 - 144 | 0;
 global$0 = $5;
 HEAP32[$5 + 140 >> 2] = $0;
 HEAP32[$5 + 136 >> 2] = $1;
 HEAP32[$5 + 132 >> 2] = $2;
 HEAP32[$5 + 128 >> 2] = $3;
 HEAP32[$5 + 124 >> 2] = $4;
 label$1 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 136 >> 2]) | 0) != 4) {
   break label$1;
  }
 }
 label$2 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 128 >> 2]) | 0) != 4) {
   break label$2;
  }
 }
 HEAP32[$5 + 120 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 136 >> 2], 0, HEAP32[$5 + 128 >> 2], 0);
 HEAP32[$5 + 116 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 136 >> 2], 3, HEAP32[$5 + 128 >> 2], 3);
 HEAP32[$5 + 112 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 136 >> 2], 1);
 HEAP32[$5 + 108 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 136 >> 2], 2);
 HEAP32[$5 + 104 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 128 >> 2], 1);
 HEAP32[$5 + 100 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 128 >> 2], 2);
 HEAP32[$5 + 96 >> 2] = HEAP32[HEAP32[$5 + 140 >> 2] + 12 >> 2];
 HEAP32[$5 + 92 >> 2] = HEAP32[HEAP32[$5 + 140 >> 2] + 16 >> 2];
 HEAP32[$5 + 88 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 88 >> 2] < HEAP32[$5 + 120 >> 2]) {
   HEAP32[$5 + 84 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 84 >> 2] < HEAP32[$5 + 104 >> 2]) {
     HEAP32[$5 + 80 >> 2] = 0;
     while (1) {
      if (HEAP32[$5 + 80 >> 2] < HEAP32[$5 + 100 >> 2]) {
       HEAP32[$5 + 76 >> 2] = 0;
       while (1) {
        if (HEAP32[$5 + 76 >> 2] < HEAP32[$5 + 116 >> 2]) {
         $0 = $5 + 28 | 0;
         $1 = $5 + 40 | 0;
         $2 = $5 + 36 | 0;
         $3 = $5 + 48 | 0;
         HEAP32[$5 + 72 >> 2] = Math_imul(HEAP32[$5 + 80 >> 2], HEAP32[$5 + 92 >> 2]) - HEAP16[HEAP32[$5 + 140 >> 2] + 2 >> 1];
         HEAP32[$5 + 68 >> 2] = Math_imul(HEAP32[$5 + 84 >> 2], HEAP32[$5 + 96 >> 2]) - HEAP16[HEAP32[$5 + 140 >> 2] + 4 >> 1];
         HEAP32[$5 + 60 >> 2] = 0;
         HEAP32[$5 + 56 >> 2] = 0 - HEAP32[$5 + 72 >> 2];
         HEAP32[$5 + 64 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($5 + 60 | 0, $5 + 56 | 0) >> 2];
         $4 = HEAP32[$5 + 140 >> 2] + 24 | 0;
         HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 108 >> 2] - HEAP32[$5 + 72 >> 2];
         HEAP32[$5 + 52 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($4, $3) >> 2];
         HEAP32[$5 + 40 >> 2] = 0;
         HEAP32[$5 + 36 >> 2] = 0 - HEAP32[$5 + 68 >> 2];
         HEAP32[$5 + 44 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($1, $2) >> 2];
         $1 = HEAP32[$5 + 140 >> 2] + 20 | 0;
         HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 112 >> 2] - HEAP32[$5 + 68 >> 2];
         HEAP32[$5 + 32 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($1, $0) >> 2];
         HEAPF32[$5 + 24 >> 2] = -3.4028234663852886e+38;
         HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 44 >> 2];
         while (1) {
          if (HEAP32[$5 + 20 >> 2] < HEAP32[$5 + 32 >> 2]) {
           HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 64 >> 2];
           while (1) {
            if (HEAP32[$5 + 16 >> 2] < HEAP32[$5 + 52 >> 2]) {
             HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 72 >> 2] + HEAP32[$5 + 16 >> 2];
             HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 68 >> 2] + HEAP32[$5 + 20 >> 2];
             HEAPF32[$5 + 24 >> 2] = HEAPF32[float_20const__20std____2__max_float__28float_20const__2c_20float_20const__29($5 + 24 | 0, HEAP32[$5 + 132 >> 2] + (tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$5 + 136 >> 2], HEAP32[$5 + 88 >> 2], HEAP32[$5 + 8 >> 2], HEAP32[$5 + 12 >> 2], HEAP32[$5 + 76 >> 2]) << 2) | 0) >> 2];
             HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 16 >> 2] + 1;
             continue;
            }
            break;
           }
           HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 20 >> 2] + 1;
           continue;
          }
          break;
         }
         $6 = float_20tflite__ActivationFunctionWithMinMax_float__28float_2c_20float_2c_20float_29(HEAPF32[$5 + 24 >> 2], HEAPF32[HEAP32[$5 + 140 >> 2] + 36 >> 2], HEAPF32[HEAP32[$5 + 140 >> 2] + 40 >> 2]);
         HEAPF32[HEAP32[$5 + 124 >> 2] + (tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$5 + 128 >> 2], HEAP32[$5 + 88 >> 2], HEAP32[$5 + 84 >> 2], HEAP32[$5 + 80 >> 2], HEAP32[$5 + 76 >> 2]) << 2) >> 2] = $6;
         HEAP32[$5 + 76 >> 2] = HEAP32[$5 + 76 >> 2] + 1;
         continue;
        }
        break;
       }
       HEAP32[$5 + 80 >> 2] = HEAP32[$5 + 80 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$5 + 84 >> 2] = HEAP32[$5 + 84 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 88 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $5 + 144 | 0;
}
function jswrap_storage_open($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 256 | 0;
 global$0 = $2;
 HEAP32[$2 + 248 >> 2] = $0;
 HEAP32[$2 + 244 >> 2] = $1;
 HEAP8[$2 + 243 | 0] = 0;
 label$1 : {
  label$2 : {
   if (jsvIsStringEqual(HEAP32[$2 + 244 >> 2], 125518) & 1) {
    HEAP8[$2 + 243 | 0] = 114;
    break label$2;
   }
   label$4 : {
    if (jsvIsStringEqual(HEAP32[$2 + 244 >> 2], 125520) & 1) {
     HEAP8[$2 + 243 | 0] = 119;
     break label$4;
    }
    label$6 : {
     if (jsvIsStringEqual(HEAP32[$2 + 244 >> 2], 125522) & 1) {
      HEAP8[$2 + 243 | 0] = 97;
      break label$6;
     }
     HEAP32[$2 + 64 >> 2] = HEAP32[$2 + 244 >> 2];
     jsExceptionHere(1, 125524, $2 - -64 | 0);
     HEAP32[$2 + 252 >> 2] = 0;
     break label$1;
    }
   }
  }
  HEAP32[$2 + 236 >> 2] = jspNewObject(0, 125540);
  if (!HEAP32[$2 + 236 >> 2]) {
   HEAP32[$2 + 252 >> 2] = 0;
   break label$1;
  }
  $0 = $2 + 200 | 0;
  HEAP32[$2 + 232 >> 2] = 1;
  HEAP32[$2 + 228 >> 2] = jsvNewFromStringVar(HEAP32[$2 + 248 >> 2], 0, 28);
  jsfNameFromVar($0, HEAP32[$2 + 228 >> 2]);
  HEAP32[$2 + 196 >> 2] = 27;
  while (1) {
   if (HEAP32[$2 + 196 >> 2] ? !HEAP8[(HEAP32[$2 + 196 >> 2] + $2 | 0) + 199 | 0] : 0) {
    HEAP32[$2 + 196 >> 2] = HEAP32[$2 + 196 >> 2] + -1;
    continue;
   }
   break;
  }
  HEAP8[HEAP32[$2 + 196 >> 2] + ($2 + 200 | 0) | 0] = HEAP32[$2 + 232 >> 2];
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 125552, HEAP32[$2 + 228 >> 2]);
  HEAP32[$2 + 192 >> 2] = 0;
  HEAP32[$2 + 56 >> 2] = HEAP32[$2 + 224 >> 2];
  $0 = HEAP32[$2 + 220 >> 2];
  HEAP32[$2 + 48 >> 2] = HEAP32[$2 + 216 >> 2];
  HEAP32[$2 + 52 >> 2] = $0;
  $0 = HEAP32[$2 + 212 >> 2];
  HEAP32[$2 + 40 >> 2] = HEAP32[$2 + 208 >> 2];
  HEAP32[$2 + 44 >> 2] = $0;
  $0 = HEAP32[$2 + 204 >> 2];
  HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 200 >> 2];
  HEAP32[$2 + 36 >> 2] = $0;
  HEAP32[$2 + 156 >> 2] = jsfFindFile($2 + 32 | 0, $2 + 160 | 0);
  HEAP32[$2 + 152 >> 2] = jsfGetFileSize($2 + 160 | 0);
  if (HEAP8[$2 + 243 | 0] == 119) {
   if (HEAP32[$2 + 156 >> 2]) {
    jswrap_storagefile_erase(HEAP32[$2 + 236 >> 2]);
    HEAP32[$2 + 156 >> 2] = 0;
    HEAP32[$2 + 152 >> 2] = 0;
   }
  }
  if (HEAP8[$2 + 243 | 0] == 97) {
   HEAP8[$2 + 151 | 0] = 255;
   if (HEAP32[$2 + 156 >> 2]) {
    jshFlashRead($2 + 151 | 0, (HEAP32[$2 + 156 >> 2] + jsfGetFileSize($2 + 160 | 0) | 0) - 1 | 0, 1);
   }
   while (1) {
    $0 = 0;
    label$18 : {
     if (!HEAP32[$2 + 156 >> 2]) {
      break label$18;
     }
     $0 = 0;
     if (HEAPU8[$2 + 151 | 0] == 255) {
      break label$18;
     }
     $0 = HEAP32[$2 + 232 >> 2] < 255;
    }
    if ($0) {
     HEAP32[$2 + 232 >> 2] = HEAP32[$2 + 232 >> 2] + 1;
     HEAP8[HEAP32[$2 + 196 >> 2] + ($2 + 200 | 0) | 0] = HEAP32[$2 + 232 >> 2];
     HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 224 >> 2];
     $0 = HEAP32[$2 + 220 >> 2];
     HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 216 >> 2];
     HEAP32[$2 + 20 >> 2] = $0;
     $0 = HEAP32[$2 + 212 >> 2];
     HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 208 >> 2];
     HEAP32[$2 + 12 >> 2] = $0;
     $0 = HEAP32[$2 + 204 >> 2];
     HEAP32[$2 >> 2] = HEAP32[$2 + 200 >> 2];
     HEAP32[$2 + 4 >> 2] = $0;
     HEAP32[$2 + 156 >> 2] = jsfFindFile($2, $2 + 160 | 0);
     HEAP32[$2 + 152 >> 2] = jsfGetFileSize($2 + 160 | 0);
     if (HEAP32[$2 + 156 >> 2]) {
      jshFlashRead($2 + 151 | 0, (HEAP32[$2 + 156 >> 2] + jsfGetFileSize($2 + 160 | 0) | 0) - 1 | 0, 1);
     }
     continue;
    }
    break;
   }
   if (HEAP32[$2 + 156 >> 2]) {
    HEAP8[$2 + 79 | 0] = 0;
    while (1) {
     label$23 : {
      if (!((HEAPU8[$2 + 79 | 0] ^ -1) & 1)) {
       break label$23;
      }
      HEAP32[$2 + 72 >> 2] = HEAP32[$2 + 152 >> 2] - HEAP32[$2 + 192 >> 2];
      if (HEAP32[$2 + 72 >> 2] <= 0) {
       HEAP8[$2 + 79 | 0] = 1;
       break label$23;
      }
      if (HEAP32[$2 + 72 >> 2] > 64) {
       HEAP32[$2 + 72 >> 2] = 64;
      }
      jshFlashRead($2 + 80 | 0, HEAP32[$2 + 156 >> 2] + HEAP32[$2 + 192 >> 2] | 0, HEAP32[$2 + 72 >> 2]);
      HEAP32[$2 + 68 >> 2] = 0;
      while (1) {
       if (HEAP32[$2 + 68 >> 2] < HEAP32[$2 + 72 >> 2]) {
        if (HEAP8[HEAP32[$2 + 68 >> 2] + ($2 + 80 | 0) | 0] == -1) {
         HEAP32[$2 + 72 >> 2] = HEAP32[$2 + 68 >> 2];
         HEAP8[$2 + 79 | 0] = 1;
        } else {
         HEAP32[$2 + 68 >> 2] = HEAP32[$2 + 68 >> 2] + 1;
         continue;
        }
       }
       break;
      }
      HEAP32[$2 + 192 >> 2] = HEAP32[$2 + 72 >> 2] + HEAP32[$2 + 192 >> 2];
      continue;
     }
     break;
    }
   }
  }
  label$30 : {
   if (HEAP8[$2 + 243 | 0] != 114) {
    break label$30;
   }
  }
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 125557, jsvNewFromInteger(HEAP32[$2 + 232 >> 2]));
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 125563, jsvNewFromInteger(HEAP32[$2 + 192 >> 2]));
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 125570, jsvNewFromInteger(HEAP32[$2 + 156 >> 2]));
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 125575, jsvNewFromInteger(HEAP32[$2 + 152 >> 2]));
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 125579, jsvNewFromInteger(HEAP8[$2 + 243 | 0]));
  HEAP32[$2 + 252 >> 2] = HEAP32[$2 + 236 >> 2];
 }
 global$0 = $2 + 256 | 0;
 return HEAP32[$2 + 252 >> 2];
}
function __rem_pio2($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $6 = global$0 - 48 | 0;
 global$0 = $6;
 wasm2js_scratch_store_f64(+$0);
 $5 = wasm2js_scratch_load_i32(1) | 0;
 $9 = wasm2js_scratch_load_i32(0) | 0;
 label$1 : {
  label$2 : {
   $4 = $5;
   $5 = $4;
   $7 = $4 & 2147483647;
   label$3 : {
    if ($7 >>> 0 <= 1074752122) {
     if (($5 & 1048575) == 598523) {
      break label$3;
     }
     if ($7 >>> 0 <= 1073928572) {
      if (($4 | 0) > 0 ? 1 : ($4 | 0) >= 0 ? $9 >>> 0 < 0 ? 0 : 1 : 0) {
       $0 = $0 + -1.5707963267341256;
       $2 = $0 + -6.077100506506192e-11;
       HEAPF64[$1 >> 3] = $2;
       HEAPF64[$1 + 8 >> 3] = $0 - $2 + -6.077100506506192e-11;
       $3 = 1;
       break label$1;
      }
      $0 = $0 + 1.5707963267341256;
      $2 = $0 + 6.077100506506192e-11;
      HEAPF64[$1 >> 3] = $2;
      HEAPF64[$1 + 8 >> 3] = $0 - $2 + 6.077100506506192e-11;
      $3 = -1;
      break label$1;
     }
     if (($4 | 0) > 0 ? 1 : ($4 | 0) >= 0 ? $9 >>> 0 < 0 ? 0 : 1 : 0) {
      $0 = $0 + -3.1415926534682512;
      $2 = $0 + -1.2154201013012384e-10;
      HEAPF64[$1 >> 3] = $2;
      HEAPF64[$1 + 8 >> 3] = $0 - $2 + -1.2154201013012384e-10;
      $3 = 2;
      break label$1;
     }
     $0 = $0 + 3.1415926534682512;
     $2 = $0 + 1.2154201013012384e-10;
     HEAPF64[$1 >> 3] = $2;
     HEAPF64[$1 + 8 >> 3] = $0 - $2 + 1.2154201013012384e-10;
     $3 = -2;
     break label$1;
    }
    if ($7 >>> 0 <= 1075594811) {
     if ($7 >>> 0 <= 1075183036) {
      if (($7 | 0) == 1074977148) {
       break label$3;
      }
      if (($4 | 0) > 0 ? 1 : ($4 | 0) >= 0 ? $9 >>> 0 < 0 ? 0 : 1 : 0) {
       $0 = $0 + -4.712388980202377;
       $2 = $0 + -1.8231301519518578e-10;
       HEAPF64[$1 >> 3] = $2;
       HEAPF64[$1 + 8 >> 3] = $0 - $2 + -1.8231301519518578e-10;
       $3 = 3;
       break label$1;
      }
      $0 = $0 + 4.712388980202377;
      $2 = $0 + 1.8231301519518578e-10;
      HEAPF64[$1 >> 3] = $2;
      HEAPF64[$1 + 8 >> 3] = $0 - $2 + 1.8231301519518578e-10;
      $3 = -3;
      break label$1;
     }
     if (($7 | 0) == 1075388923) {
      break label$3;
     }
     if (($4 | 0) > 0 ? 1 : ($4 | 0) >= 0 ? $9 >>> 0 < 0 ? 0 : 1 : 0) {
      $0 = $0 + -6.2831853069365025;
      $2 = $0 + -2.430840202602477e-10;
      HEAPF64[$1 >> 3] = $2;
      HEAPF64[$1 + 8 >> 3] = $0 - $2 + -2.430840202602477e-10;
      $3 = 4;
      break label$1;
     }
     $0 = $0 + 6.2831853069365025;
     $2 = $0 + 2.430840202602477e-10;
     HEAPF64[$1 >> 3] = $2;
     HEAPF64[$1 + 8 >> 3] = $0 - $2 + 2.430840202602477e-10;
     $3 = -4;
     break label$1;
    }
    if ($7 >>> 0 > 1094263290) {
     break label$2;
    }
   }
   $10 = $0 * .6366197723675814 + 6755399441055744 + -6755399441055744;
   $2 = $0 + $10 * -1.5707963267341256;
   $8 = $10 * 6.077100506506192e-11;
   $0 = $2 - $8;
   HEAPF64[$1 >> 3] = $0;
   $4 = $7 >>> 20;
   wasm2js_scratch_store_f64(+$0);
   $3 = wasm2js_scratch_load_i32(1) | 0;
   wasm2js_scratch_load_i32(0) | 0;
   $9 = ($4 - ($3 >>> 20 & 2047) | 0) < 17;
   if (Math_abs($10) < 2147483648) {
    $3 = ~~$10;
   } else {
    $3 = -2147483648;
   }
   label$14 : {
    if ($9) {
     break label$14;
    }
    $8 = $2;
    $0 = $10 * 6.077100506303966e-11;
    $2 = $2 - $0;
    $8 = $10 * 2.0222662487959506e-21 - ($8 - $2 - $0);
    $0 = $2 - $8;
    HEAPF64[$1 >> 3] = $0;
    $5 = $4;
    wasm2js_scratch_store_f64(+$0);
    $4 = wasm2js_scratch_load_i32(1) | 0;
    wasm2js_scratch_load_i32(0) | 0;
    if (($5 - ($4 >>> 20 & 2047) | 0) < 50) {
     break label$14;
    }
    $8 = $2;
    $0 = $10 * 2.0222662487111665e-21;
    $2 = $2 - $0;
    $8 = $10 * 8.4784276603689e-32 - ($8 - $2 - $0);
    $0 = $2 - $8;
    HEAPF64[$1 >> 3] = $0;
   }
   HEAPF64[$1 + 8 >> 3] = $2 - $0 - $8;
   break label$1;
  }
  if ($7 >>> 0 >= 2146435072) {
   $0 = $0 - $0;
   HEAPF64[$1 >> 3] = $0;
   HEAPF64[$1 + 8 >> 3] = $0;
   break label$1;
  }
  $5 = $4 & 1048575 | 1096810496;
  wasm2js_scratch_store_i32(0, $9 | 0);
  wasm2js_scratch_store_i32(1, $5 | 0);
  $0 = +wasm2js_scratch_load_f64();
  while (1) {
   $5 = ($6 + 16 | 0) + ($3 << 3) | 0;
   if (Math_abs($0) < 2147483648) {
    $11 = ~~$0;
   } else {
    $11 = -2147483648;
   }
   $2 = +($11 | 0);
   HEAPF64[$5 >> 3] = $2;
   $0 = ($0 - $2) * 16777216;
   $3 = $3 + 1 | 0;
   if (($3 | 0) != 2) {
    continue;
   }
   break;
  }
  HEAPF64[$6 + 32 >> 3] = $0;
  label$20 : {
   if ($0 != 0) {
    $3 = 2;
    break label$20;
   }
   $5 = 1;
   while (1) {
    $3 = $5;
    $5 = $3 + -1 | 0;
    if (HEAPF64[($6 + 16 | 0) + ($3 << 3) >> 3] == 0) {
     continue;
    }
    break;
   }
  }
  $3 = __rem_pio2_large($6 + 16 | 0, $6, ($7 >>> 20) + -1046 | 0, $3 + 1 | 0);
  $0 = HEAPF64[$6 >> 3];
  if (($4 | 0) < -1 ? 1 : ($4 | 0) <= -1 ? $9 >>> 0 > 4294967295 ? 0 : 1 : 0) {
   HEAPF64[$1 >> 3] = -$0;
   HEAPF64[$1 + 8 >> 3] = -HEAPF64[$6 + 8 >> 3];
   $3 = 0 - $3 | 0;
   break label$1;
  }
  HEAPF64[$1 >> 3] = $0;
  $4 = HEAP32[$6 + 12 >> 2];
  HEAP32[$1 + 8 >> 2] = HEAP32[$6 + 8 >> 2];
  HEAP32[$1 + 12 >> 2] = $4;
 }
 global$0 = $6 + 48 | 0;
 return $3;
}
function jsvIterateCallback($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 240 | 0;
 global$0 = $3;
 HEAP32[$3 + 232 >> 2] = $0;
 HEAP32[$3 + 228 >> 2] = $1;
 HEAP32[$3 + 224 >> 2] = $2;
 HEAP8[$3 + 223 | 0] = 1;
 label$1 : {
  label$2 : {
   if (jsvIsNumeric(HEAP32[$3 + 232 >> 2]) & 1) {
    $0 = HEAP32[$3 + 228 >> 2];
    FUNCTION_TABLE[$0](jsvGetInteger(HEAP32[$3 + 232 >> 2]), HEAP32[$3 + 224 >> 2]);
    break label$2;
   }
   label$4 : {
    if (jsvIsObject(HEAP32[$3 + 232 >> 2]) & 1) {
     HEAP32[$3 + 216 >> 2] = jsvObjectGetChild(HEAP32[$3 + 232 >> 2], 79245, 0);
     if (jsvIsFunction(HEAP32[$3 + 216 >> 2]) & 1) {
      HEAP32[$3 + 212 >> 2] = jspExecuteFunction(HEAP32[$3 + 216 >> 2], 0, 0, 0);
      jsvUnLock(HEAP32[$3 + 216 >> 2]);
      if (HEAP32[$3 + 212 >> 2]) {
       HEAP8[$3 + 211 | 0] = jsvIterateCallback(HEAP32[$3 + 212 >> 2], HEAP32[$3 + 228 >> 2], HEAP32[$3 + 224 >> 2]) & 1;
       jsvUnLock(HEAP32[$3 + 212 >> 2]);
       HEAP8[$3 + 239 | 0] = HEAP8[$3 + 211 | 0] & 1;
       break label$1;
      }
      HEAP8[$3 + 239 | 0] = 1;
      break label$1;
     }
     jsvUnLock(HEAP32[$3 + 216 >> 2]);
     HEAP32[$3 + 204 >> 2] = jsvObjectGetChild(HEAP32[$3 + 232 >> 2], 79254, 0);
     HEAP32[$3 + 200 >> 2] = jsvObjectGetChild(HEAP32[$3 + 232 >> 2], 79260, 0);
     label$8 : {
      label$9 : {
       if (!HEAP32[$3 + 204 >> 2] | !HEAP32[$3 + 200 >> 2]) {
        break label$9;
       }
       if (!(jsvIsNumeric(HEAP32[$3 + 204 >> 2]) & 1)) {
        break label$9;
       }
       HEAP32[$3 + 196 >> 2] = jsvGetInteger(HEAP32[$3 + 204 >> 2]);
       while (1) {
        if (HEAP8[$3 + 223 | 0] & 1) {
         $0 = HEAP32[$3 + 196 >> 2];
         HEAP32[$3 + 196 >> 2] = $0 + -1;
         $0 = ($0 | 0) > 0;
        } else {
         $0 = 0;
        }
        if ($0) {
         HEAP8[$3 + 223 | 0] = jsvIterateCallback(HEAP32[$3 + 200 >> 2], HEAP32[$3 + 228 >> 2], HEAP32[$3 + 224 >> 2]) & 1;
         continue;
        }
        break;
       }
       break label$8;
      }
      HEAP32[$3 >> 2] = HEAP32[$3 + 232 >> 2];
      jsExceptionHere(3, 79265, $3);
      HEAP8[$3 + 223 | 0] = 0;
     }
     jsvUnLock2(HEAP32[$3 + 204 >> 2], HEAP32[$3 + 200 >> 2]);
     break label$4;
    }
    label$14 : {
     if (jsvIsString(HEAP32[$3 + 232 >> 2]) & 1) {
      jsvStringIteratorNew($3 + 160 | 0, HEAP32[$3 + 232 >> 2], 0);
      while (1) {
       if (jsvStringIteratorHasChar($3 + 160 | 0) & 1) {
        $0 = HEAPU8[$3 + 223 | 0];
       } else {
        $0 = 0;
       }
       if ($0 & 1) {
        HEAP8[$3 + 159 | 0] = jsvStringIteratorGetCharAndNext($3 + 160 | 0);
        FUNCTION_TABLE[HEAP32[$3 + 228 >> 2]](HEAP8[$3 + 159 | 0], HEAP32[$3 + 224 >> 2]);
        continue;
       }
       break;
      }
      jsvStringIteratorFree($3 + 160 | 0);
      break label$14;
     }
     label$20 : {
      if (jsvIsArrayBuffer(HEAP32[$3 + 232 >> 2]) & 1) {
       jsvArrayBufferIteratorNew($3 + 96 | 0, HEAP32[$3 + 232 >> 2], 0);
       label$22 : {
        if (!(HEAPU16[$3 + 132 >> 1] & 16 | (HEAPU16[$3 + 132 >> 1] & 15) != 1)) {
         HEAP32[$3 + 92 >> 2] = $3 + 96;
         HEAP32[$3 + 88 >> 2] = jsvGetArrayBufferLength(HEAP32[$3 + 232 >> 2]);
         while (1) {
          label$25 : {
           $0 = HEAP32[$3 + 88 >> 2];
           HEAP32[$3 + 88 >> 2] = $0 + -1;
           if (!$0) {
            break label$25;
           }
           $0 = HEAP32[$3 + 228 >> 2];
           FUNCTION_TABLE[$0](jsvStringIteratorGetChar(HEAP32[$3 + 92 >> 2]) & 255, HEAP32[$3 + 224 >> 2]);
           jsvStringIteratorNextInline(HEAP32[$3 + 92 >> 2]);
           continue;
          }
          break;
         }
         break label$22;
        }
        while (1) {
         if (jsvArrayBufferIteratorHasElement($3 + 96 | 0) & 1) {
          $0 = HEAP32[$3 + 228 >> 2];
          $1 = $3 + 96 | 0;
          FUNCTION_TABLE[$0](jsvArrayBufferIteratorGetIntegerValue($1), HEAP32[$3 + 224 >> 2]);
          jsvArrayBufferIteratorNext($1);
          continue;
         }
         break;
        }
       }
       jsvArrayBufferIteratorFree($3 + 96 | 0);
       break label$20;
      }
      label$28 : {
       if (jsvIsIterable(HEAP32[$3 + 232 >> 2]) & 1) {
        jsvIteratorNew($3 + 24 | 0, HEAP32[$3 + 232 >> 2], 1);
        while (1) {
         if (jsvIteratorHasElement($3 + 24 | 0) & 1) {
          $0 = HEAPU8[$3 + 223 | 0];
         } else {
          $0 = 0;
         }
         if ($0 & 1) {
          $0 = $3 + 24 | 0;
          HEAP32[$3 + 20 >> 2] = jsvIteratorGetValue($0);
          HEAP8[$3 + 223 | 0] = jsvIterateCallback(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 228 >> 2], HEAP32[$3 + 224 >> 2]) & 1;
          jsvUnLock(HEAP32[$3 + 20 >> 2]);
          jsvIteratorNext($0);
          continue;
         }
         break;
        }
        jsvIteratorFree($3 + 24 | 0);
        break label$28;
       }
       HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 232 >> 2];
       jsExceptionHere(3, 79365, $3 + 16 | 0);
       HEAP8[$3 + 223 | 0] = 0;
      }
     }
    }
   }
  }
  HEAP8[$3 + 239 | 0] = HEAP8[$3 + 223 | 0] & 1;
 }
 global$0 = $3 + 240 | 0;
 return HEAP8[$3 + 239 | 0] & 1;
}
function jswrap_json_parse_internal() {
 var $0 = 0, $1 = 0;
 $0 = global$0 - 112 | 0;
 global$0 = $0;
 label$1 : {
  label$2 : {
   label$3 : {
    label$4 : {
     label$5 : {
      label$6 : {
       label$7 : {
        $1 = HEAP16[HEAP32[35539] + 2 >> 1];
        if (($1 | 0) != 45) {
         if (($1 | 0) == 91) {
          break label$4;
         }
         if (($1 | 0) == 123) {
          break label$3;
         }
         if (($1 | 0) == 129) {
          break label$7;
         }
         if (($1 | 0) == 130) {
          break label$6;
         }
         if (($1 | 0) == 131) {
          break label$5;
         }
         label$9 : {
          label$10 : {
           if (($1 | 0) != 180) {
            if (($1 | 0) == 181) {
             break label$10;
            }
            if (($1 | 0) == 182) {
             break label$9;
            }
            break label$2;
           }
           jslGetNextToken();
           HEAP32[$0 + 108 >> 2] = jsvNewFromBool(1);
           break label$1;
          }
          jslGetNextToken();
          HEAP32[$0 + 108 >> 2] = jsvNewFromBool(0);
          break label$1;
         }
         jslGetNextToken();
         HEAP32[$0 + 108 >> 2] = jsvNewWithFlags(2);
         break label$1;
        }
        jslGetNextToken();
        if (!(HEAP16[HEAP32[35539] + 2 >> 1] == 129 | HEAP16[HEAP32[35539] + 2 >> 1] == 130)) {
         HEAP32[$0 + 108 >> 2] = 0;
         break label$1;
        }
        HEAP32[$0 + 104 >> 2] = jswrap_json_parse_internal();
        HEAP32[$0 + 100 >> 2] = jsvNewFromInteger(0);
        HEAP32[$0 + 96 >> 2] = jsvMathsOp(HEAP32[$0 + 100 >> 2], HEAP32[$0 + 104 >> 2], 45);
        jsvUnLock2(HEAP32[$0 + 104 >> 2], HEAP32[$0 + 100 >> 2]);
        HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 96 >> 2];
        break label$1;
       }
       HEAP32[$0 + 88 >> 2] = stringToInt(jslGetTokenValueAsString());
       HEAP32[$0 + 92 >> 2] = i64toi32_i32$HIGH_BITS;
       jslGetNextToken();
       HEAP32[$0 + 108 >> 2] = jsvNewFromLongInteger(HEAP32[$0 + 88 >> 2], HEAP32[$0 + 92 >> 2]);
       break label$1;
      }
      HEAPF64[$0 + 80 >> 3] = stringToFloat(jslGetTokenValueAsString());
      jslGetNextToken();
      HEAP32[$0 + 108 >> 2] = jsvNewFromFloat(HEAPF64[$0 + 80 >> 3]);
      break label$1;
     }
     HEAP32[$0 + 76 >> 2] = jslGetTokenValueAsVar();
     jslGetNextToken();
     HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 76 >> 2];
     break label$1;
    }
    HEAP32[$0 + 72 >> 2] = jsvNewWithFlags(3);
    if (!HEAP32[$0 + 72 >> 2]) {
     HEAP32[$0 + 108 >> 2] = 0;
     break label$1;
    }
    jslGetNextToken();
    while (1) {
     if (HEAP16[HEAP32[35539] + 2 >> 1] != 93) {
      $1 = jspHasError() ^ -1;
     } else {
      $1 = 0;
     }
     if ($1 & 1) {
      HEAP32[$0 + 68 >> 2] = jswrap_json_parse_internal();
      label$18 : {
       if (HEAP32[$0 + 68 >> 2]) {
        if (HEAP16[HEAP32[35539] + 2 >> 1] == 93) {
         break label$18;
        }
        if (jslMatch(44) & 1) {
         break label$18;
        }
       }
       jsvUnLock2(HEAP32[$0 + 68 >> 2], HEAP32[$0 + 72 >> 2]);
       HEAP32[$0 + 108 >> 2] = 0;
       break label$1;
      }
      jsvArrayPush(HEAP32[$0 + 72 >> 2], HEAP32[$0 + 68 >> 2]);
      jsvUnLock(HEAP32[$0 + 68 >> 2]);
      continue;
     }
     break;
    }
    if (!(jslMatch(93) & 1)) {
     jsvUnLock(HEAP32[$0 + 72 >> 2]);
     HEAP32[$0 + 108 >> 2] = 0;
     break label$1;
    }
    HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 72 >> 2];
    break label$1;
   }
   HEAP32[$0 + 64 >> 2] = jsvNewWithFlags(5);
   if (!HEAP32[$0 + 64 >> 2]) {
    HEAP32[$0 + 108 >> 2] = 0;
    break label$1;
   }
   jslGetNextToken();
   while (1) {
    if (HEAP16[HEAP32[35539] + 2 >> 1] == 131) {
     $1 = jspHasError() ^ -1;
    } else {
     $1 = 0;
    }
    if ($1 & 1) {
     HEAP32[$0 + 60 >> 2] = jsvAsArrayIndexAndUnLock(jslGetTokenValueAsVar());
     jslGetNextToken();
     HEAP32[$0 + 56 >> 2] = 0;
     label$26 : {
      label$27 : {
       if (!(jslMatch(58) & 1)) {
        break label$27;
       }
       $1 = jswrap_json_parse_internal();
       HEAP32[$0 + 56 >> 2] = $1;
       if (!$1) {
        break label$27;
       }
       if (HEAP16[HEAP32[35539] + 2 >> 1] == 125) {
        break label$26;
       }
       if (jslMatch(44) & 1) {
        break label$26;
       }
      }
      jsvUnLock3(HEAP32[$0 + 60 >> 2], HEAP32[$0 + 56 >> 2], HEAP32[$0 + 64 >> 2]);
      HEAP32[$0 + 108 >> 2] = 0;
      break label$1;
     }
     jsvAddName(HEAP32[$0 + 64 >> 2], jsvMakeIntoVariableName(HEAP32[$0 + 60 >> 2], HEAP32[$0 + 56 >> 2]));
     jsvUnLock2(HEAP32[$0 + 56 >> 2], HEAP32[$0 + 60 >> 2]);
     continue;
    }
    break;
   }
   if (!(jslMatch(125) & 1)) {
    jsvUnLock(HEAP32[$0 + 64 >> 2]);
    HEAP32[$0 + 108 >> 2] = 0;
    break label$1;
   }
   HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 64 >> 2];
   break label$1;
  }
  $1 = $0 + 16 | 0;
  jslTokenAsString(HEAP16[HEAP32[35539] + 2 >> 1], $1, 32);
  HEAP32[$0 >> 2] = $1;
  jsExceptionHere(2, 122637, $0);
  HEAP32[$0 + 108 >> 2] = 0;
 }
 global$0 = $0 + 112 | 0;
 return HEAP32[$0 + 108 >> 2];
}
function tflite__ops__micro__quantize__Prepare_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = global$0 - 224 | 0;
 global$0 = $2;
 HEAP32[$2 + 216 >> 2] = $0;
 HEAP32[$2 + 212 >> 2] = $1;
 label$1 : {
  if (!HEAP32[HEAP32[$2 + 212 >> 2] + 8 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$2 + 208 >> 2] = HEAP32[HEAP32[$2 + 212 >> 2] + 8 >> 2];
 label$2 : {
  if ((tflite__NumInputs_28TfLiteNode_20const__29(HEAP32[$2 + 212 >> 2]) | 0) != 1) {
   $0 = HEAP32[HEAP32[$2 + 216 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 216 >> 2];
   $3 = tflite__NumInputs_28TfLiteNode_20const__29(HEAP32[$2 + 212 >> 2]);
   HEAP32[$2 + 20 >> 2] = 1;
   HEAP32[$2 + 16 >> 2] = $3;
   HEAP32[$2 + 12 >> 2] = 135257;
   HEAP32[$2 + 8 >> 2] = 135241;
   HEAP32[$2 + 4 >> 2] = 49;
   HEAP32[$2 >> 2] = 135155;
   FUNCTION_TABLE[$0]($1, 135129, $2);
   HEAP32[$2 + 220 >> 2] = 1;
   break label$2;
  }
  if ((tflite__NumOutputs_28TfLiteNode_20const__29(HEAP32[$2 + 212 >> 2]) | 0) != 1) {
   $0 = HEAP32[HEAP32[$2 + 216 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 216 >> 2];
   $3 = tflite__NumOutputs_28TfLiteNode_20const__29(HEAP32[$2 + 212 >> 2]);
   HEAP32[$2 + 52 >> 2] = 1;
   HEAP32[$2 + 48 >> 2] = $3;
   HEAP32[$2 + 44 >> 2] = 135257;
   HEAP32[$2 + 40 >> 2] = 135259;
   HEAP32[$2 + 36 >> 2] = 50;
   HEAP32[$2 + 32 >> 2] = 135155;
   FUNCTION_TABLE[$0]($1, 135129, $2 + 32 | 0);
   HEAP32[$2 + 220 >> 2] = 1;
   break label$2;
  }
  HEAP32[$2 + 204 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 216 >> 2], HEAP32[$2 + 212 >> 2], 0);
  HEAP32[$2 + 200 >> 2] = tflite__GetOutput_28TfLiteContext__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 216 >> 2], HEAP32[$2 + 212 >> 2]);
  if (HEAP32[HEAP32[$2 + 200 >> 2] >> 2] != 1) {
   $0 = HEAP32[HEAP32[$2 + 216 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 216 >> 2];
   $3 = HEAP32[HEAP32[$2 + 200 >> 2] >> 2];
   HEAP32[$2 + 84 >> 2] = 1;
   HEAP32[$2 + 80 >> 2] = $3;
   HEAP32[$2 + 76 >> 2] = 135302;
   HEAP32[$2 + 72 >> 2] = 135276;
   HEAP32[$2 + 68 >> 2] = 58;
   HEAP32[$2 + 64 >> 2] = 135155;
   FUNCTION_TABLE[$0]($1, 135129, $2 - -64 | 0);
   HEAP32[$2 + 220 >> 2] = 1;
   break label$2;
  }
  HEAP32[$2 + 196 >> 2] = HEAP32[HEAP32[$2 + 200 >> 2] + 4 >> 2];
  if (!HEAP32[$2 + 196 >> 2]) {
   $0 = HEAP32[HEAP32[$2 + 216 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 216 >> 2];
   HEAP32[$2 + 168 >> 2] = 135351;
   HEAP32[$2 + 164 >> 2] = 61;
   HEAP32[$2 + 160 >> 2] = 135155;
   FUNCTION_TABLE[$0]($1, 135328, $2 + 160 | 0);
   HEAP32[$2 + 220 >> 2] = 1;
   break label$2;
  }
  if (!HEAP32[HEAP32[$2 + 196 >> 2] >> 2]) {
   $0 = HEAP32[HEAP32[$2 + 216 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 216 >> 2];
   HEAP32[$2 + 152 >> 2] = 135371;
   HEAP32[$2 + 148 >> 2] = 62;
   HEAP32[$2 + 144 >> 2] = 135155;
   FUNCTION_TABLE[$0]($1, 135328, $2 + 144 | 0);
   HEAP32[$2 + 220 >> 2] = 1;
   break label$2;
  }
  if (HEAP32[HEAP32[HEAP32[$2 + 196 >> 2] >> 2] >> 2] != 1) {
   $0 = HEAP32[HEAP32[$2 + 216 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 216 >> 2];
   HEAP32[$2 + 136 >> 2] = 135398;
   HEAP32[$2 + 132 >> 2] = 63;
   HEAP32[$2 + 128 >> 2] = 135155;
   FUNCTION_TABLE[$0]($1, 135328, $2 + 128 | 0);
   HEAP32[$2 + 220 >> 2] = 1;
   break label$2;
  }
  if (!(HEAP32[HEAP32[$2 + 204 >> 2] + 28 >> 2] == 1 | HEAP32[HEAP32[$2 + 204 >> 2] + 28 >> 2] == 7 | HEAP32[HEAP32[$2 + 204 >> 2] + 28 >> 2] == 9)) {
   $0 = HEAP32[HEAP32[$2 + 216 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 216 >> 2];
   HEAP32[$2 + 120 >> 2] = 135436;
   HEAP32[$2 + 116 >> 2] = 67;
   HEAP32[$2 + 112 >> 2] = 135155;
   FUNCTION_TABLE[$0]($1, 135328, $2 + 112 | 0);
   HEAP32[$2 + 220 >> 2] = 1;
   break label$2;
  }
  if (!(HEAP32[HEAP32[$2 + 200 >> 2] + 28 >> 2] == 3 | HEAP32[HEAP32[$2 + 200 >> 2] + 28 >> 2] == 9 | HEAP32[HEAP32[$2 + 200 >> 2] + 28 >> 2] == 7)) {
   $0 = HEAP32[HEAP32[$2 + 216 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 216 >> 2];
   HEAP32[$2 + 104 >> 2] = 135527;
   HEAP32[$2 + 100 >> 2] = 70;
   HEAP32[$2 + 96 >> 2] = 135155;
   FUNCTION_TABLE[$0]($1, 135328, $2 + 96 | 0);
   HEAP32[$2 + 220 >> 2] = 1;
   break label$2;
  }
  label$11 : {
   if (!(HEAP32[HEAP32[$2 + 200 >> 2] + 28 >> 2] == 9 ? !(HEAP32[HEAP32[$2 + 204 >> 2] + 28 >> 2] != 9 ? HEAP32[HEAP32[$2 + 204 >> 2] + 28 >> 2] != 7 : 0) : 0)) {
    if (HEAP32[HEAP32[$2 + 204 >> 2] + 28 >> 2] != 7 | HEAP32[HEAP32[$2 + 200 >> 2] + 28 >> 2] != 7) {
     break label$11;
    }
   }
   HEAPF64[$2 + 184 >> 3] = Math_fround(HEAPF32[HEAP32[$2 + 204 >> 2] + 8 >> 2] / HEAPF32[HEAP32[$2 + 200 >> 2] + 8 >> 2]);
   tflite__QuantizeMultiplier_28double_2c_20int__2c_20int__29(HEAPF64[$2 + 184 >> 3], HEAP32[$2 + 208 >> 2] + 16 | 0, HEAP32[$2 + 208 >> 2] + 20 | 0);
  }
  HEAP32[HEAP32[$2 + 208 >> 2] >> 2] = HEAP32[HEAP32[$2 + 200 >> 2] + 12 >> 2];
  HEAPF64[HEAP32[$2 + 208 >> 2] + 8 >> 3] = HEAPF32[HEAP32[$2 + 200 >> 2] + 8 >> 2];
  HEAP32[HEAP32[$2 + 208 >> 2] + 24 >> 2] = HEAP32[HEAP32[$2 + 204 >> 2] + 12 >> 2];
  HEAP32[$2 + 220 >> 2] = 0;
 }
 global$0 = $2 + 224 | 0;
 return HEAP32[$2 + 220 >> 2];
}
function matchhere($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 1040 | 0;
 global$0 = $3;
 HEAP32[$3 + 1032 >> 2] = $0;
 HEAP32[$3 + 1028 >> 2] = $1;
 label$1 : {
  if (jspIsInterrupted() & 1) {
   HEAP32[$3 + 1036 >> 2] = 0;
   break label$1;
  }
  if (!(HEAP8[HEAP32[$3 + 1032 >> 2]] != 124 ? HEAP8[HEAP32[$3 + 1032 >> 2]] : 0)) {
   $0 = HEAP32[$3 + 1028 >> 2];
   memcpy($3, $2, 88);
   HEAP32[$3 + 1036 >> 2] = matchfound($0, $3);
   break label$1;
  }
  if (HEAP8[HEAP32[$3 + 1032 >> 2]] == 94) {
   if (jsvStringIteratorGetIndex(HEAP32[$3 + 1028 >> 2])) {
    HEAP32[$3 + 1036 >> 2] = 0;
    break label$1;
   }
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$3 + 1036 >> 2] = 0;
    break label$1;
   }
   $0 = HEAP32[$3 + 1032 >> 2] + 1 | 0;
   $1 = HEAP32[$3 + 1028 >> 2];
   memcpy($3 + 88 | 0, $2, 88);
   HEAP32[$3 + 1036 >> 2] = matchhere($0, $1, $3 + 88 | 0);
   break label$1;
  }
  if (HEAP8[HEAP32[$3 + 1032 >> 2]] == 36) {
   if (!(jsvStringIteratorHasChar(HEAP32[$3 + 1028 >> 2]) & 1)) {
    $0 = HEAP32[$3 + 1032 >> 2] + 1 | 0;
    $1 = HEAP32[$3 + 1028 >> 2];
    memcpy($3 + 264 | 0, $2, 88);
    HEAP32[$3 + 1036 >> 2] = matchhere($0, $1, $3 + 264 | 0);
    break label$1;
   }
   $0 = HEAP32[$3 + 1032 >> 2] + 1 | 0;
   memcpy($3 + 176 | 0, $2, 88);
   HEAP32[$3 + 1036 >> 2] = nomatchfound($0, $3 + 176 | 0);
   break label$1;
  }
  if (HEAP8[HEAP32[$3 + 1032 >> 2]] == 40) {
   $0 = jsvStringIteratorGetIndex(HEAP32[$3 + 1028 >> 2]);
   HEAP32[($2 + 16 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2] = $0;
   HEAP32[($2 + 52 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2] = HEAP32[($2 + 16 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2];
   if (HEAP32[$2 + 12 >> 2] < 9) {
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
   }
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$3 + 1036 >> 2] = 0;
    break label$1;
   }
   $0 = HEAP32[$3 + 1032 >> 2] + 1 | 0;
   $1 = HEAP32[$3 + 1028 >> 2];
   memcpy($3 + 352 | 0, $2, 88);
   HEAP32[$3 + 1036 >> 2] = matchhere($0, $1, $3 + 352 | 0);
   break label$1;
  }
  if (HEAP8[HEAP32[$3 + 1032 >> 2]] == 41) {
   if (HEAP32[$2 + 12 >> 2] > 0) {
    $0 = jsvStringIteratorGetIndex(HEAP32[$3 + 1028 >> 2]);
    HEAP32[((HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) + 48 >> 2] = $0;
   }
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$3 + 1036 >> 2] = 0;
    break label$1;
   }
   $0 = HEAP32[$3 + 1032 >> 2] + 1 | 0;
   $1 = HEAP32[$3 + 1028 >> 2];
   memcpy($3 + 440 | 0, $2, 88);
   HEAP32[$3 + 1036 >> 2] = matchhere($0, $1, $3 + 440 | 0);
   break label$1;
  }
  HEAP8[$3 + 1023 | 0] = matchcharacter(HEAP32[$3 + 1032 >> 2], HEAP32[$3 + 1028 >> 2], $3 + 1024 | 0, $2) & 1;
  if (!(HEAP8[HEAP32[$3 + 1032 >> 2] + HEAP32[$3 + 1024 >> 2] | 0] != 43 ? HEAP8[HEAP32[$3 + 1032 >> 2] + HEAP32[$3 + 1024 >> 2] | 0] != 42 : 0)) {
   HEAP8[$3 + 1022 | 0] = HEAPU8[HEAP32[$3 + 1032 >> 2] + HEAP32[$3 + 1024 >> 2] | 0];
   if (!(HEAP8[$3 + 1023 | 0] & 1 | HEAP8[$3 + 1022 | 0] != 43)) {
    $0 = HEAP32[$3 + 1032 >> 2] + (HEAP32[$3 + 1024 >> 2] + 1 | 0) | 0;
    memcpy($3 + 704 | 0, $2, 88);
    HEAP32[$3 + 1036 >> 2] = nomatchfound($0, $3 + 704 | 0);
    break label$1;
   }
   HEAP32[$3 + 1016 >> 2] = (HEAP32[$3 + 1032 >> 2] + HEAP32[$3 + 1024 >> 2] | 0) + 1;
   jsvStringIteratorClone($3 + 976 | 0, HEAP32[$3 + 1028 >> 2]);
   $0 = HEAP32[$3 + 1016 >> 2];
   memcpy($3 + 616 | 0, $2, 88);
   HEAP32[$3 + 972 >> 2] = matchhere($0, $3 + 976 | 0, $3 + 616 | 0);
   jsvStringIteratorFree($3 + 976 | 0);
   while (1) {
    if (jsvStringIteratorHasChar(HEAP32[$3 + 1028 >> 2]) & 1) {
     $0 = HEAPU8[$3 + 1023 | 0];
    } else {
     $0 = 0;
    }
    if ($0 & 1) {
     $0 = $3 + 976 | 0;
     $1 = $3 + 1024 | 0;
     jsvStringIteratorNext(HEAP32[$3 + 1028 >> 2]);
     HEAP8[$3 + 1023 | 0] = matchcharacter(HEAP32[$3 + 1032 >> 2], HEAP32[$3 + 1028 >> 2], $1, $2) & 1;
     jsvStringIteratorClone($0, HEAP32[$3 + 1028 >> 2]);
     $0 = HEAP32[$3 + 1016 >> 2];
     memcpy($3 + 528 | 0, $2, 88);
     HEAP32[$3 + 968 >> 2] = matchhere($0, $3 + 976 | 0, $3 + 528 | 0);
     jsvStringIteratorFree($3 + 976 | 0);
     if (HEAP32[$3 + 968 >> 2]) {
      jsvUnLock(HEAP32[$3 + 972 >> 2]);
      HEAP32[$3 + 972 >> 2] = HEAP32[$3 + 968 >> 2];
     }
     continue;
    }
    break;
   }
   HEAP32[$3 + 1036 >> 2] = HEAP32[$3 + 972 >> 2];
   break label$1;
  }
  if (!(!(jsvStringIteratorHasChar(HEAP32[$3 + 1028 >> 2]) & 1) | !(HEAP8[$3 + 1023 | 0] & 1))) {
   jsvStringIteratorNext(HEAP32[$3 + 1028 >> 2]);
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$3 + 1036 >> 2] = 0;
    break label$1;
   }
   $0 = HEAP32[$3 + 1032 >> 2] + HEAP32[$3 + 1024 >> 2] | 0;
   $1 = HEAP32[$3 + 1028 >> 2];
   memcpy($3 + 792 | 0, $2, 88);
   HEAP32[$3 + 1036 >> 2] = matchhere($0, $1, $3 + 792 | 0);
   break label$1;
  }
  $0 = HEAP32[$3 + 1032 >> 2] + HEAP32[$3 + 1024 >> 2] | 0;
  memcpy($3 + 880 | 0, $2, 88);
  HEAP32[$3 + 1036 >> 2] = nomatchfound($0, $3 + 880 | 0);
 }
 global$0 = $3 + 1040 | 0;
 return HEAP32[$3 + 1036 >> 2];
}
function jsvDefragment() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $0 = global$0 - 576 | 0;
 global$0 = $0;
 $1 = $0 + 48 | 0;
 jsvGarbageCollect();
 HEAP32[$0 + 572 >> 2] = 256;
 memset($1, 0, 512);
 HEAP32[$0 + 44 >> 2] = 0;
 HEAP32[$0 + 40 >> 2] = 0;
 while (1) {
  if (HEAPU32[$0 + 40 >> 2] < HEAPU32[35415]) {
   HEAP16[$0 + 38 >> 1] = HEAP32[$0 + 40 >> 2] + 1;
   HEAP32[$0 + 32 >> 2] = _jsvGetAddressOf(HEAPU16[$0 + 38 >> 1]);
   $1 = HEAP32[$0 + 32 >> 2];
   if ((HEAPU8[$1 + 13 | 0] | HEAPU8[$1 + 14 | 0] << 8) & 63) {
    label$4 : {
     if (jsvIsFlatString(HEAP32[$0 + 32 >> 2]) & 1) {
      HEAP32[$0 + 40 >> 2] = jsvGetFlatStringBlocks(HEAP32[$0 + 32 >> 2]) + HEAP32[$0 + 40 >> 2];
      break label$4;
     }
     if (!(jsvGetLocks(HEAP32[$0 + 32 >> 2]) & 255)) {
      HEAP16[($0 + 48 | 0) + (HEAP32[$0 + 44 >> 2] << 1) >> 1] = HEAPU16[$0 + 38 >> 1];
      HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 44 >> 2] + 1 & 255;
     }
    }
   }
   HEAP32[$0 + 40 >> 2] = HEAP32[$0 + 40 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 44 >> 2] + -1;
 if (HEAP32[$0 + 44 >> 2] < 0) {
  HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 44 >> 2] + 256;
 }
 while (1) {
  label$9 : {
   if (!HEAPU16[($0 + 48 | 0) + (HEAP32[$0 + 44 >> 2] << 1) >> 1]) {
    break label$9;
   }
   HEAP16[$0 + 30 >> 1] = HEAPU16[($0 + 48 | 0) + (HEAP32[$0 + 44 >> 2] << 1) >> 1];
   HEAP16[$0 + 28 >> 1] = HEAPU16[71084];
   if (!HEAPU16[$0 + 28 >> 1] | HEAPU16[$0 + 30 >> 1] < HEAPU16[$0 + 28 >> 1]) {
    break label$9;
   }
   HEAP32[$0 + 24 >> 2] = _jsvGetAddressOf(HEAPU16[$0 + 30 >> 1]);
   HEAP32[$0 + 20 >> 2] = _jsvGetAddressOf(HEAPU16[$0 + 28 >> 1]);
   HEAP16[71084] = jsvGetNextSibling(HEAP32[$0 + 20 >> 2]);
   $2 = HEAP32[$0 + 24 >> 2];
   $1 = HEAPU8[$2 + 4 | 0] | HEAPU8[$2 + 5 | 0] << 8 | (HEAPU8[$2 + 6 | 0] << 16 | HEAPU8[$2 + 7 | 0] << 24);
   $3 = HEAP32[$0 + 20 >> 2];
   $4 = HEAPU8[$2 | 0] | HEAPU8[$2 + 1 | 0] << 8 | (HEAPU8[$2 + 2 | 0] << 16 | HEAPU8[$2 + 3 | 0] << 24);
   HEAP8[$3 | 0] = $4;
   HEAP8[$3 + 1 | 0] = $4 >>> 8;
   HEAP8[$3 + 2 | 0] = $4 >>> 16;
   HEAP8[$3 + 3 | 0] = $4 >>> 24;
   HEAP8[$3 + 4 | 0] = $1;
   HEAP8[$3 + 5 | 0] = $1 >>> 8;
   HEAP8[$3 + 6 | 0] = $1 >>> 16;
   HEAP8[$3 + 7 | 0] = $1 >>> 24;
   HEAP8[$3 + 14 | 0] = HEAPU8[$2 + 14 | 0];
   $1 = HEAPU8[$2 + 12 | 0] | HEAPU8[$2 + 13 | 0] << 8;
   HEAP8[$3 + 12 | 0] = $1;
   HEAP8[$3 + 13 | 0] = $1 >>> 8;
   $1 = HEAPU8[$2 + 8 | 0] | HEAPU8[$2 + 9 | 0] << 8 | (HEAPU8[$2 + 10 | 0] << 16 | HEAPU8[$2 + 11 | 0] << 24);
   HEAP8[$3 + 8 | 0] = $1;
   HEAP8[$3 + 9 | 0] = $1 >>> 8;
   HEAP8[$3 + 10 | 0] = $1 >>> 16;
   HEAP8[$3 + 11 | 0] = $1 >>> 24;
   $1 = HEAP32[$0 + 24 >> 2];
   HEAP8[$1 + 13 | 0] = 0;
   HEAP8[$1 + 14 | 0] = 0;
   HEAP32[$0 + 16 >> 2] = 0;
   while (1) {
    if (HEAPU32[$0 + 16 >> 2] < HEAPU32[35415]) {
     HEAP16[$0 + 14 >> 1] = HEAP32[$0 + 16 >> 2] + 1;
     HEAP32[$0 + 8 >> 2] = _jsvGetAddressOf(HEAPU16[$0 + 14 >> 1]);
     $1 = HEAP32[$0 + 8 >> 2];
     if ((HEAPU8[$1 + 13 | 0] | HEAPU8[$1 + 14 | 0] << 8) & 63) {
      label$13 : {
       if (jsvIsFlatString(HEAP32[$0 + 8 >> 2]) & 1) {
        HEAP32[$0 + 16 >> 2] = jsvGetFlatStringBlocks(HEAP32[$0 + 8 >> 2]) + HEAP32[$0 + 16 >> 2];
        break label$13;
       }
       if (jsvHasSingleChild(HEAP32[$0 + 8 >> 2]) & 1) {
        if ((jsvGetFirstChild(HEAP32[$0 + 8 >> 2]) & 65535) == HEAPU16[$0 + 30 >> 1]) {
         jsvSetFirstChild(HEAP32[$0 + 8 >> 2], HEAPU16[$0 + 28 >> 1]);
        }
       }
       if (jsvHasCharacterData(HEAP32[$0 + 8 >> 2]) & 1) {
        if ((jsvGetLastChild(HEAP32[$0 + 8 >> 2]) & 65535) == HEAPU16[$0 + 30 >> 1]) {
         jsvSetLastChild(HEAP32[$0 + 8 >> 2], HEAPU16[$0 + 28 >> 1]);
        }
       }
       if (jsvHasChildren(HEAP32[$0 + 8 >> 2]) & 1) {
        if ((jsvGetFirstChild(HEAP32[$0 + 8 >> 2]) & 65535) == HEAPU16[$0 + 30 >> 1]) {
         jsvSetFirstChild(HEAP32[$0 + 8 >> 2], HEAPU16[$0 + 28 >> 1]);
        }
        if ((jsvGetLastChild(HEAP32[$0 + 8 >> 2]) & 65535) == HEAPU16[$0 + 30 >> 1]) {
         jsvSetLastChild(HEAP32[$0 + 8 >> 2], HEAPU16[$0 + 28 >> 1]);
        }
       }
       if (jsvIsName(HEAP32[$0 + 8 >> 2]) & 1) {
        if ((jsvGetNextSibling(HEAP32[$0 + 8 >> 2]) & 65535) == HEAPU16[$0 + 30 >> 1]) {
         jsvSetNextSibling(HEAP32[$0 + 8 >> 2], HEAPU16[$0 + 28 >> 1]);
        }
        if ((jsvGetPrevSibling(HEAP32[$0 + 8 >> 2]) & 65535) == HEAPU16[$0 + 30 >> 1]) {
         jsvSetPrevSibling(HEAP32[$0 + 8 >> 2], HEAPU16[$0 + 28 >> 1]);
        }
       }
      }
     }
     HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 16 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP16[($0 + 48 | 0) + (HEAP32[$0 + 44 >> 2] << 1) >> 1] = 0;
   HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 44 >> 2] + -1;
   if (HEAP32[$0 + 44 >> 2] < 0) {
    HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 44 >> 2] + 256;
   }
   continue;
  }
  break;
 }
 jsvCreateEmptyVarList();
 global$0 = $0 + 576 | 0;
}
function tflite__ops__micro__fully_connected__EvalQuantized_28TfLiteContext__2c_20TfLiteNode__2c_20tflite__ops__micro__fully_connected___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0;
 $7 = global$0 - 304 | 0;
 global$0 = $7;
 HEAP32[$7 + 296 >> 2] = $0;
 HEAP32[$7 + 292 >> 2] = $1;
 HEAP32[$7 + 288 >> 2] = $2;
 HEAP32[$7 + 284 >> 2] = $3;
 HEAP32[$7 + 280 >> 2] = $4;
 HEAP32[$7 + 276 >> 2] = $5;
 HEAP32[$7 + 272 >> 2] = $6;
 HEAP32[$7 + 268 >> 2] = 0 - HEAP32[HEAP32[$7 + 288 >> 2] + 20 >> 2];
 HEAP32[$7 + 264 >> 2] = 0 - HEAP32[HEAP32[$7 + 288 >> 2] + 24 >> 2];
 HEAP32[$7 + 260 >> 2] = HEAP32[HEAP32[$7 + 288 >> 2] + 28 >> 2];
 HEAP32[$7 + 216 >> 2] = HEAP32[$7 + 268 >> 2];
 HEAP32[$7 + 220 >> 2] = HEAP32[$7 + 264 >> 2];
 HEAP32[$7 + 224 >> 2] = HEAP32[$7 + 260 >> 2];
 HEAP32[$7 + 228 >> 2] = HEAP32[HEAP32[$7 + 288 >> 2] >> 2];
 HEAP32[$7 + 232 >> 2] = 0 - HEAP32[HEAP32[$7 + 288 >> 2] + 4 >> 2];
 HEAP32[$7 + 236 >> 2] = HEAP32[HEAP32[$7 + 288 >> 2] + 8 >> 2];
 HEAP32[$7 + 240 >> 2] = HEAP32[HEAP32[$7 + 288 >> 2] + 12 >> 2];
 label$1 : {
  label$2 : {
   label$3 : {
    $0 = HEAP32[HEAP32[$7 + 272 >> 2] + 8 >> 2] + -3 | 0;
    if ($0 >>> 0 > 4) {
     break label$3;
    }
    label$4 : {
     switch ($0 - 1 | 0) {
     default:
      tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 192 | 0, HEAP32[$7 + 284 >> 2]);
      $0 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$7 + 284 >> 2]);
      tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 160 | 0, HEAP32[$7 + 280 >> 2]);
      $1 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$7 + 280 >> 2]);
      tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 136 | 0, HEAP32[$7 + 276 >> 2]);
      $2 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$7 + 276 >> 2]);
      tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 112 | 0, HEAP32[$7 + 272 >> 2]);
      tflite__reference_ops__FullyConnected_28tflite__FullyConnectedParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29($7 + 216 | 0, $7 + 192 | 0, $0, $7 + 160 | 0, $1, $7 + 136 | 0, $2, $7 + 112 | 0, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$7 + 272 >> 2]));
      $0 = $7 + 192 | 0;
      $1 = $7 + 160 | 0;
      $2 = $7 + 136 | 0;
      tflite__RuntimeShape___RuntimeShape_28_29($7 + 112 | 0);
      break label$2;
     case 0:
     case 1:
     case 2:
      break label$3;
     case 3:
      break label$4;
     }
    }
    tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 88 | 0, HEAP32[$7 + 284 >> 2]);
    $0 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$7 + 284 >> 2]);
    tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 - -64 | 0, HEAP32[$7 + 280 >> 2]);
    $1 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$7 + 280 >> 2]);
    tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 40 | 0, HEAP32[$7 + 276 >> 2]);
    $2 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$7 + 276 >> 2]);
    tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 16 | 0, HEAP32[$7 + 272 >> 2]);
    tflite__reference_ops__FullyConnected_28tflite__FullyConnectedParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20short__29($7 + 216 | 0, $7 + 88 | 0, $0, $7 - -64 | 0, $1, $7 + 40 | 0, $2, $7 + 16 | 0, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$7 + 272 >> 2]));
    $0 = $7 + 88 | 0;
    $1 = $7 - -64 | 0;
    $2 = $7 + 40 | 0;
    tflite__RuntimeShape___RuntimeShape_28_29($7 + 16 | 0);
    break label$2;
   }
   $0 = HEAP32[HEAP32[$7 + 296 >> 2] + 20 >> 2];
   $1 = HEAP32[$7 + 296 >> 2];
   $2 = TfLiteTypeGetName(HEAP32[HEAP32[$7 + 272 >> 2] + 8 >> 2]);
   HEAP32[$7 + 4 >> 2] = HEAP32[HEAP32[$7 + 272 >> 2] + 8 >> 2];
   HEAP32[$7 >> 2] = $2;
   FUNCTION_TABLE[$0]($1, 135101, $7);
   HEAP32[$7 + 300 >> 2] = 1;
   break label$1;
  }
  tflite__RuntimeShape___RuntimeShape_28_29($2);
  tflite__RuntimeShape___RuntimeShape_28_29($1);
  tflite__RuntimeShape___RuntimeShape_28_29($0);
  HEAP32[$7 + 300 >> 2] = 0;
 }
 global$0 = $7 + 304 | 0;
 return HEAP32[$7 + 300 >> 2];
}
function utilTimerInsertTask($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 label$1 : {
  if (utilTimerIsFull() & 1) {
   HEAP8[$3 + 31 | 0] = 0;
   break label$1;
  }
  if (HEAP8[324179] & 1) {
   $1 = HEAP32[81047] - jshGetSystemTime() | 0;
   $0 = HEAP32[$3 + 24 >> 2];
   $1 = $1 + (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) | 0;
   HEAP8[$0 | 0] = $1;
   HEAP8[$0 + 1 | 0] = $1 >>> 8;
   HEAP8[$0 + 2 | 0] = $1 >>> 16;
   HEAP8[$0 + 3 | 0] = $1 >>> 24;
  }
  HEAP8[$3 + 23 | 0] = HEAPU8[324178];
  while (1) {
   if (HEAPU8[$3 + 23 | 0] != HEAPU8[324177]) {
    $0 = Math_imul(HEAPU8[$3 + 23 | 0], 25) + 324192 | 0;
    $2 = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
    $0 = HEAP32[$3 + 24 >> 2];
    $0 = ($2 | 0) < (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24));
   } else {
    $0 = 0;
   }
   if ($0) {
    HEAP8[$3 + 23 | 0] = HEAPU8[$3 + 23 | 0] + 1 & 15;
    continue;
   }
   break;
  }
  HEAP8[$3 + 22 | 0] = HEAPU8[$3 + 23 | 0] == HEAPU8[324178];
  HEAP32[$3 + 16 >> 2] = HEAPU8[324177];
  while (1) {
   if (HEAP32[$3 + 16 >> 2] != HEAPU8[$3 + 23 | 0]) {
    HEAP8[$3 + 15 | 0] = HEAP32[$3 + 16 >> 2] + 15 & 15;
    $1 = Math_imul(HEAPU8[$3 + 15 | 0], 25) + 324192 | 0;
    $4 = HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8 | (HEAPU8[$1 + 6 | 0] << 16 | HEAPU8[$1 + 7 | 0] << 24);
    $0 = Math_imul(HEAP32[$3 + 16 >> 2], 25) + 324192 | 0;
    $2 = HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24);
    HEAP8[$0 | 0] = $2;
    HEAP8[$0 + 1 | 0] = $2 >>> 8;
    HEAP8[$0 + 2 | 0] = $2 >>> 16;
    HEAP8[$0 + 3 | 0] = $2 >>> 24;
    HEAP8[$0 + 4 | 0] = $4;
    HEAP8[$0 + 5 | 0] = $4 >>> 8;
    HEAP8[$0 + 6 | 0] = $4 >>> 16;
    HEAP8[$0 + 7 | 0] = $4 >>> 24;
    HEAP8[$0 + 24 | 0] = HEAPU8[$1 + 24 | 0];
    $2 = HEAPU8[$1 + 20 | 0] | HEAPU8[$1 + 21 | 0] << 8 | (HEAPU8[$1 + 22 | 0] << 16 | HEAPU8[$1 + 23 | 0] << 24);
    $4 = HEAPU8[$1 + 16 | 0] | HEAPU8[$1 + 17 | 0] << 8 | (HEAPU8[$1 + 18 | 0] << 16 | HEAPU8[$1 + 19 | 0] << 24);
    HEAP8[$0 + 16 | 0] = $4;
    HEAP8[$0 + 17 | 0] = $4 >>> 8;
    HEAP8[$0 + 18 | 0] = $4 >>> 16;
    HEAP8[$0 + 19 | 0] = $4 >>> 24;
    HEAP8[$0 + 20 | 0] = $2;
    HEAP8[$0 + 21 | 0] = $2 >>> 8;
    HEAP8[$0 + 22 | 0] = $2 >>> 16;
    HEAP8[$0 + 23 | 0] = $2 >>> 24;
    $2 = HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8 | (HEAPU8[$1 + 14 | 0] << 16 | HEAPU8[$1 + 15 | 0] << 24);
    $1 = HEAPU8[$1 + 8 | 0] | HEAPU8[$1 + 9 | 0] << 8 | (HEAPU8[$1 + 10 | 0] << 16 | HEAPU8[$1 + 11 | 0] << 24);
    HEAP8[$0 + 8 | 0] = $1;
    HEAP8[$0 + 9 | 0] = $1 >>> 8;
    HEAP8[$0 + 10 | 0] = $1 >>> 16;
    HEAP8[$0 + 11 | 0] = $1 >>> 24;
    HEAP8[$0 + 12 | 0] = $2;
    HEAP8[$0 + 13 | 0] = $2 >>> 8;
    HEAP8[$0 + 14 | 0] = $2 >>> 16;
    HEAP8[$0 + 15 | 0] = $2 >>> 24;
    HEAP32[$3 + 16 >> 2] = HEAPU8[$3 + 15 | 0];
    continue;
   }
   break;
  }
  $1 = HEAP32[$3 + 24 >> 2];
  $4 = HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8 | (HEAPU8[$1 + 6 | 0] << 16 | HEAPU8[$1 + 7 | 0] << 24);
  $0 = Math_imul(HEAPU8[$3 + 23 | 0], 25) + 324192 | 0;
  $2 = HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24);
  HEAP8[$0 | 0] = $2;
  HEAP8[$0 + 1 | 0] = $2 >>> 8;
  HEAP8[$0 + 2 | 0] = $2 >>> 16;
  HEAP8[$0 + 3 | 0] = $2 >>> 24;
  HEAP8[$0 + 4 | 0] = $4;
  HEAP8[$0 + 5 | 0] = $4 >>> 8;
  HEAP8[$0 + 6 | 0] = $4 >>> 16;
  HEAP8[$0 + 7 | 0] = $4 >>> 24;
  HEAP8[$0 + 24 | 0] = HEAPU8[$1 + 24 | 0];
  $2 = HEAPU8[$1 + 20 | 0] | HEAPU8[$1 + 21 | 0] << 8 | (HEAPU8[$1 + 22 | 0] << 16 | HEAPU8[$1 + 23 | 0] << 24);
  $4 = HEAPU8[$1 + 16 | 0] | HEAPU8[$1 + 17 | 0] << 8 | (HEAPU8[$1 + 18 | 0] << 16 | HEAPU8[$1 + 19 | 0] << 24);
  HEAP8[$0 + 16 | 0] = $4;
  HEAP8[$0 + 17 | 0] = $4 >>> 8;
  HEAP8[$0 + 18 | 0] = $4 >>> 16;
  HEAP8[$0 + 19 | 0] = $4 >>> 24;
  HEAP8[$0 + 20 | 0] = $2;
  HEAP8[$0 + 21 | 0] = $2 >>> 8;
  HEAP8[$0 + 22 | 0] = $2 >>> 16;
  HEAP8[$0 + 23 | 0] = $2 >>> 24;
  $2 = HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8 | (HEAPU8[$1 + 14 | 0] << 16 | HEAPU8[$1 + 15 | 0] << 24);
  $1 = HEAPU8[$1 + 8 | 0] | HEAPU8[$1 + 9 | 0] << 8 | (HEAPU8[$1 + 10 | 0] << 16 | HEAPU8[$1 + 11 | 0] << 24);
  HEAP8[$0 + 8 | 0] = $1;
  HEAP8[$0 + 9 | 0] = $1 >>> 8;
  HEAP8[$0 + 10 | 0] = $1 >>> 16;
  HEAP8[$0 + 11 | 0] = $1 >>> 24;
  HEAP8[$0 + 12 | 0] = $2;
  HEAP8[$0 + 13 | 0] = $2 >>> 8;
  HEAP8[$0 + 14 | 0] = $2 >>> 16;
  HEAP8[$0 + 15 | 0] = $2 >>> 24;
  HEAP8[324177] = HEAPU8[324177] + 1 & 15;
  if (!(HEAP8[$3 + 22 | 0] & 1 ? 0 : HEAP8[324179] & 1)) {
   HEAP8[324179] = 1;
   jstRestartUtilTimer();
  }
  HEAP8[$3 + 31 | 0] = 1;
 }
 global$0 = $3 + 32 | 0;
 return HEAP8[$3 + 31 | 0] & 1;
}
function jswrap_storagefile_read_internal($0, $1) {
 var $2 = 0;
 $2 = global$0 - 192 | 0;
 global$0 = $2;
 HEAP32[$2 + 184 >> 2] = $0;
 HEAP32[$2 + 180 >> 2] = $1;
 HEAP8[$2 + 179 | 0] = HEAP32[$2 + 180 >> 2] < 0;
 HEAP8[$2 + 178 | 0] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$2 + 184 >> 2], 125579, 0));
 label$1 : {
  if (HEAP8[$2 + 178 | 0] != 114) {
   jsExceptionHere(1, 125584, 0);
   HEAP32[$2 + 188 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 172 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$2 + 184 >> 2], 125570, 0));
  if (!HEAP32[$2 + 172 >> 2]) {
   HEAP32[$2 + 188 >> 2] = 0;
   break label$1;
  }
  $0 = $2 + 128 | 0;
  HEAP32[$2 + 168 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$2 + 184 >> 2], 125563, 0));
  HEAP32[$2 + 164 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$2 + 184 >> 2], 125575, 0));
  HEAP32[$2 + 160 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$2 + 184 >> 2], 125557, 0));
  jsfNameFromVarAndUnLock($0, jsvObjectGetChild(HEAP32[$2 + 184 >> 2], 125552, 0));
  HEAP32[$2 + 124 >> 2] = 27;
  while (1) {
   if (HEAP32[$2 + 124 >> 2] ? !HEAP8[(HEAP32[$2 + 124 >> 2] + $2 | 0) + 127 | 0] : 0) {
    HEAP32[$2 + 124 >> 2] = HEAP32[$2 + 124 >> 2] + -1;
    continue;
   }
   break;
  }
  HEAP8[HEAP32[$2 + 124 >> 2] + ($2 + 128 | 0) | 0] = HEAP32[$2 + 160 >> 2];
  HEAP32[$2 + 120 >> 2] = 0;
  if (HEAP8[$2 + 179 | 0] & 1) {
   HEAP32[$2 + 180 >> 2] = 32;
  }
  while (1) {
   label$10 : {
    if (!HEAP32[$2 + 180 >> 2]) {
     break label$10;
    }
    HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 164 >> 2] - HEAP32[$2 + 168 >> 2];
    if (HEAP32[$2 + 76 >> 2] <= 0) {
     HEAP32[$2 + 168 >> 2] = 0;
     label$12 : {
      if (HEAP32[$2 + 160 >> 2] == 255) {
       HEAP32[$2 + 172 >> 2] = 0;
       break label$12;
      }
      HEAP32[$2 + 160 >> 2] = HEAP32[$2 + 160 >> 2] + 1;
      HEAP8[HEAP32[$2 + 124 >> 2] + ($2 + 128 | 0) | 0] = HEAP32[$2 + 160 >> 2];
      HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 152 >> 2];
      $0 = HEAP32[$2 + 148 >> 2];
      HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 144 >> 2];
      HEAP32[$2 + 20 >> 2] = $0;
      $0 = HEAP32[$2 + 140 >> 2];
      HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 136 >> 2];
      HEAP32[$2 + 12 >> 2] = $0;
      $0 = HEAP32[$2 + 132 >> 2];
      HEAP32[$2 >> 2] = HEAP32[$2 + 128 >> 2];
      HEAP32[$2 + 4 >> 2] = $0;
      HEAP32[$2 + 172 >> 2] = jsfFindFile($2, $2 + 40 | 0);
      HEAP32[$2 + 164 >> 2] = jsfGetFileSize($2 + 40 | 0);
      jsvObjectSetChildAndUnLock(HEAP32[$2 + 184 >> 2], 125575, jsvNewFromInteger(HEAP32[$2 + 164 >> 2]));
     }
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 184 >> 2], 125570, jsvNewFromInteger(HEAP32[$2 + 172 >> 2]));
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 184 >> 2], 125563, jsvNewFromInteger(HEAP32[$2 + 168 >> 2]));
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 184 >> 2], 125557, jsvNewFromInteger(HEAP32[$2 + 160 >> 2]));
     HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 164 >> 2];
     if (!HEAP32[$2 + 172 >> 2]) {
      HEAP32[$2 + 188 >> 2] = HEAP32[$2 + 120 >> 2];
      break label$1;
     }
    }
    HEAP32[$2 + 36 >> 2] = HEAP32[$2 + 180 >> 2];
    if (HEAP32[$2 + 36 >> 2] > 32) {
     HEAP32[$2 + 36 >> 2] = 32;
    }
    if (HEAP32[$2 + 36 >> 2] > HEAP32[$2 + 76 >> 2]) {
     HEAP32[$2 + 36 >> 2] = HEAP32[$2 + 76 >> 2];
    }
    jshFlashRead($2 + 80 | 0, HEAP32[$2 + 172 >> 2] + HEAP32[$2 + 168 >> 2] | 0, HEAP32[$2 + 36 >> 2]);
    HEAP32[$2 + 32 >> 2] = 0;
    while (1) {
     label$18 : {
      if (HEAP32[$2 + 32 >> 2] >= HEAP32[$2 + 36 >> 2]) {
       break label$18;
      }
      if (HEAP8[HEAP32[$2 + 32 >> 2] + ($2 + 80 | 0) | 0] == -1) {
       HEAP32[$2 + 36 >> 2] = HEAP32[$2 + 32 >> 2];
       HEAP32[$2 + 180 >> 2] = HEAP32[$2 + 36 >> 2];
       break label$18;
      }
      if (!(HEAP8[$2 + 179 | 0] & 1) | HEAP8[HEAP32[$2 + 32 >> 2] + ($2 + 80 | 0) | 0] != 10) {
       HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 32 >> 2] + 1;
       continue;
      } else {
       HEAP32[$2 + 36 >> 2] = HEAP32[$2 + 32 >> 2] + 1;
       HEAP32[$2 + 180 >> 2] = HEAP32[$2 + 36 >> 2];
       HEAP8[$2 + 179 | 0] = 0;
      }
     }
     break;
    }
    if (!HEAP32[$2 + 36 >> 2]) {
     break label$10;
    }
    if (!HEAP32[$2 + 120 >> 2]) {
     HEAP32[$2 + 120 >> 2] = jsvNewWithFlags(27);
    }
    if (HEAP32[$2 + 120 >> 2]) {
     jsvAppendStringBuf(HEAP32[$2 + 120 >> 2], $2 + 80 | 0, HEAP32[$2 + 36 >> 2]);
    }
    HEAP32[$2 + 180 >> 2] = HEAP32[$2 + 180 >> 2] - HEAP32[$2 + 36 >> 2];
    HEAP32[$2 + 168 >> 2] = HEAP32[$2 + 36 >> 2] + HEAP32[$2 + 168 >> 2];
    if (HEAP8[$2 + 179 | 0] & 1) {
     HEAP32[$2 + 180 >> 2] = 32;
    }
    continue;
   }
   break;
  }
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 184 >> 2], 125563, jsvNewFromInteger(HEAP32[$2 + 168 >> 2]));
  HEAP32[$2 + 188 >> 2] = HEAP32[$2 + 120 >> 2];
 }
 global$0 = $2 + 192 | 0;
 return HEAP32[$2 + 188 >> 2];
}
function FFT($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 128 | 0;
 global$0 = $4;
 HEAP16[$4 + 126 >> 1] = $0;
 HEAP32[$4 + 120 >> 2] = $1;
 HEAP32[$4 + 116 >> 2] = $2;
 HEAP32[$4 + 112 >> 2] = $3;
 HEAP32[$4 + 108 >> 2] = 1;
 HEAP32[$4 + 104 >> 2] = 0;
 while (1) {
  if (HEAP32[$4 + 104 >> 2] < HEAP32[$4 + 120 >> 2]) {
   HEAP32[$4 + 108 >> 2] = HEAP32[$4 + 108 >> 2] << 1;
   HEAP32[$4 + 104 >> 2] = HEAP32[$4 + 104 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[$4 + 88 >> 2] = HEAP32[$4 + 108 >> 2] >> 1;
 HEAP32[$4 + 96 >> 2] = 0;
 HEAP32[$4 + 104 >> 2] = 0;
 while (1) {
  if (HEAP32[$4 + 104 >> 2] < (HEAP32[$4 + 108 >> 2] - 1 | 0)) {
   if (HEAP32[$4 + 104 >> 2] < HEAP32[$4 + 96 >> 2]) {
    HEAPF64[$4 + 48 >> 3] = HEAPF64[HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) >> 3];
    HEAPF64[$4 + 40 >> 3] = HEAPF64[HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) >> 3];
    HEAPF64[HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) >> 3] = HEAPF64[HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 96 >> 2] << 3) >> 3];
    HEAPF64[HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) >> 3] = HEAPF64[HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 96 >> 2] << 3) >> 3];
    HEAPF64[HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 96 >> 2] << 3) >> 3] = HEAPF64[$4 + 48 >> 3];
    HEAPF64[HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 96 >> 2] << 3) >> 3] = HEAPF64[$4 + 40 >> 3];
   }
   HEAP32[$4 + 92 >> 2] = HEAP32[$4 + 88 >> 2];
   while (1) {
    if (HEAP32[$4 + 92 >> 2] <= HEAP32[$4 + 96 >> 2]) {
     HEAP32[$4 + 96 >> 2] = HEAP32[$4 + 96 >> 2] - HEAP32[$4 + 92 >> 2];
     HEAP32[$4 + 92 >> 2] = HEAP32[$4 + 92 >> 2] >> 1;
     continue;
    }
    break;
   }
   HEAP32[$4 + 96 >> 2] = HEAP32[$4 + 92 >> 2] + HEAP32[$4 + 96 >> 2];
   HEAP32[$4 + 104 >> 2] = HEAP32[$4 + 104 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAPF64[$4 + 64 >> 3] = -1;
 HEAPF64[$4 + 56 >> 3] = 0;
 HEAP32[$4 + 76 >> 2] = 1;
 HEAP32[$4 + 84 >> 2] = 0;
 while (1) {
  if (HEAP32[$4 + 84 >> 2] < HEAP32[$4 + 120 >> 2]) {
   HEAP32[$4 + 80 >> 2] = HEAP32[$4 + 76 >> 2];
   HEAP32[$4 + 76 >> 2] = HEAP32[$4 + 76 >> 2] << 1;
   HEAPF64[$4 + 16 >> 3] = 1;
   HEAPF64[$4 + 8 >> 3] = 0;
   HEAP32[$4 + 96 >> 2] = 0;
   while (1) {
    if (HEAP32[$4 + 96 >> 2] < HEAP32[$4 + 80 >> 2]) {
     HEAP32[$4 + 104 >> 2] = HEAP32[$4 + 96 >> 2];
     while (1) {
      if (HEAP32[$4 + 104 >> 2] < HEAP32[$4 + 108 >> 2]) {
       HEAP32[$4 + 100 >> 2] = HEAP32[$4 + 104 >> 2] + HEAP32[$4 + 80 >> 2];
       HEAPF64[$4 + 32 >> 3] = HEAPF64[$4 + 16 >> 3] * HEAPF64[HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 100 >> 2] << 3) >> 3] - HEAPF64[$4 + 8 >> 3] * HEAPF64[HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 100 >> 2] << 3) >> 3];
       HEAPF64[$4 + 24 >> 3] = HEAPF64[$4 + 16 >> 3] * HEAPF64[HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 100 >> 2] << 3) >> 3] + HEAPF64[$4 + 8 >> 3] * HEAPF64[HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 100 >> 2] << 3) >> 3];
       HEAPF64[HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 100 >> 2] << 3) >> 3] = HEAPF64[HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) >> 3] - HEAPF64[$4 + 32 >> 3];
       HEAPF64[HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 100 >> 2] << 3) >> 3] = HEAPF64[HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) >> 3] - HEAPF64[$4 + 24 >> 3];
       $0 = HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) | 0;
       HEAPF64[$0 >> 3] = HEAPF64[$0 >> 3] + HEAPF64[$4 + 32 >> 3];
       $0 = HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) | 0;
       HEAPF64[$0 >> 3] = HEAPF64[$0 >> 3] + HEAPF64[$4 + 24 >> 3];
       HEAP32[$4 + 104 >> 2] = HEAP32[$4 + 76 >> 2] + HEAP32[$4 + 104 >> 2];
       continue;
      }
      break;
     }
     HEAPF64[$4 >> 3] = HEAPF64[$4 + 16 >> 3] * HEAPF64[$4 + 64 >> 3] - HEAPF64[$4 + 8 >> 3] * HEAPF64[$4 + 56 >> 3];
     HEAPF64[$4 + 8 >> 3] = HEAPF64[$4 + 16 >> 3] * HEAPF64[$4 + 56 >> 3] + HEAPF64[$4 + 8 >> 3] * HEAPF64[$4 + 64 >> 3];
     HEAPF64[$4 + 16 >> 3] = HEAPF64[$4 >> 3];
     HEAP32[$4 + 96 >> 2] = HEAP32[$4 + 96 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAPF64[$4 + 56 >> 3] = jswrap_math_sqrt((1 - HEAPF64[$4 + 64 >> 3]) / 2);
   if (HEAP16[$4 + 126 >> 1] == 1) {
    HEAPF64[$4 + 56 >> 3] = -HEAPF64[$4 + 56 >> 3];
   }
   HEAPF64[$4 + 64 >> 3] = jswrap_math_sqrt((1 + HEAPF64[$4 + 64 >> 3]) / 2);
   HEAP32[$4 + 84 >> 2] = HEAP32[$4 + 84 >> 2] + 1;
   continue;
  }
  break;
 }
 if (HEAP16[$4 + 126 >> 1] == 1) {
  HEAP32[$4 + 104 >> 2] = 0;
  while (1) {
   if (HEAP32[$4 + 104 >> 2] < HEAP32[$4 + 108 >> 2]) {
    $0 = HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) | 0;
    HEAPF64[$0 >> 3] = HEAPF64[$0 >> 3] / +HEAP32[$4 + 108 >> 2];
    $0 = HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) | 0;
    HEAPF64[$0 >> 3] = HEAPF64[$0 >> 3] / +HEAP32[$4 + 108 >> 2];
    HEAP32[$4 + 104 >> 2] = HEAP32[$4 + 104 >> 2] + 1;
    continue;
   }
   break;
  }
 }
 global$0 = $4 + 128 | 0;
}
function gemmlowp__FixedPoint_int_2c_200__20gemmlowp__exp_on_interval_between_negative_one_quarter_and_0_excl_int__28gemmlowp__FixedPoint_int_2c_200__29($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0;
 $1 = global$0 - 256 | 0;
 global$0 = $1;
 $5 = $1 + 104 | 0;
 $2 = $1 + 216 | 0;
 $6 = $1 + 8 | 0;
 $4 = $1 + 232 | 0;
 $7 = $1 + 24 | 0;
 $8 = $1 + 40 | 0;
 $3 = $1 + 192 | 0;
 $9 = $1 + 48 | 0;
 $10 = $1 + 224 | 0;
 $11 = $1 + 56 | 0;
 $12 = $1 + 168 | 0;
 $13 = $1 - -64 | 0;
 $14 = $1 + 120 | 0;
 $15 = $1 + 72 | 0;
 $16 = $1 + 144 | 0;
 $17 = $1 + 112 | 0;
 $18 = $1 + 128 | 0;
 $19 = $1 + 136 | 0;
 $20 = $1 + 152 | 0;
 $21 = $1 + 160 | 0;
 $22 = $1 + 176 | 0;
 $23 = $1 + 184 | 0;
 $24 = $1 + 240 | 0;
 $25 = $1 + 208 | 0;
 HEAP32[$1 + 240 >> 2] = $0;
 HEAP32[$1 + 232 >> 2] = gemmlowp__FixedPoint_int_2c_2012___FromScalarRaw_28int_29(gemmlowp__FixedPoint_int_2c_200___ScalarRawType_20gemmlowp__RescaleConstantInitializer_gemmlowp__FixedPoint_int_2c_200__20__28int_29(1895147668));
 HEAP32[$1 + 224 >> 2] = gemmlowp__FixedPoint_int_2c_2012___FromScalarRaw_28int_29(gemmlowp__FixedPoint_int_2c_200___ScalarRawType_20gemmlowp__RescaleConstantInitializer_gemmlowp__FixedPoint_int_2c_200__20__28int_29(715827883));
 HEAP32[$25 >> 2] = HEAP32[$24 >> 2];
 HEAP32[$1 + 200 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__FixedPoint_int_2c_200___ConstantPOT__3__28_29();
 HEAP32[$1 + 216 >> 2] = gemmlowp__FixedPoint_int_2c_2012__20gemmlowp__operator__int_2c_2012__28gemmlowp__FixedPoint_int_2c_2012__2c_20gemmlowp__FixedPoint_int_2c_2012__29(HEAP32[$1 + 208 >> 2], HEAP32[$1 + 200 >> 2]);
 HEAP32[$23 >> 2] = HEAP32[$2 >> 2];
 HEAP32[$22 >> 2] = HEAP32[$2 >> 2];
 HEAP32[$1 + 192 >> 2] = gemmlowp__FixedPoint_int_2c_20_280_29_20__20_280_29__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 184 >> 2], HEAP32[$1 + 176 >> 2]);
 HEAP32[$21 >> 2] = HEAP32[$3 >> 2];
 HEAP32[$20 >> 2] = HEAP32[$2 >> 2];
 HEAP32[$1 + 168 >> 2] = gemmlowp__FixedPoint_int_2c_20_280_29_20__20_280_29__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 160 >> 2], HEAP32[$1 + 152 >> 2]);
 HEAP32[$19 >> 2] = HEAP32[$3 >> 2];
 HEAP32[$18 >> 2] = HEAP32[$3 >> 2];
 HEAP32[$1 + 144 >> 2] = gemmlowp__FixedPoint_int_2c_20_280_29_20__20_280_29__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 136 >> 2], HEAP32[$1 + 128 >> 2]);
 HEAP32[$17 >> 2] = HEAP32[$16 >> 2];
 HEAP32[$1 + 120 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__SaturatingRoundingMultiplyByPOT__2_2c_20int_2c_200__28gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 112 >> 2]);
 HEAP32[$15 >> 2] = HEAP32[$14 >> 2];
 HEAP32[$13 >> 2] = HEAP32[$12 >> 2];
 HEAP32[$1 + 80 >> 2] = gemmlowp__FixedPoint_int_2c_2012__20gemmlowp__operator__int_2c_2012__28gemmlowp__FixedPoint_int_2c_2012__2c_20gemmlowp__FixedPoint_int_2c_2012__29(HEAP32[$1 + 72 >> 2], HEAP32[$1 + 64 >> 2]);
 HEAP32[$11 >> 2] = HEAP32[$10 >> 2];
 HEAP32[$1 + 88 >> 2] = gemmlowp__FixedPoint_int_2c_20_280_29_20__20_280_29__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 80 >> 2], HEAP32[$1 + 56 >> 2]);
 HEAP32[$9 >> 2] = HEAP32[$3 >> 2];
 HEAP32[$1 + 96 >> 2] = gemmlowp__FixedPoint_int_2c_2012__20gemmlowp__operator__int_2c_2012__28gemmlowp__FixedPoint_int_2c_2012__2c_20gemmlowp__FixedPoint_int_2c_2012__29(HEAP32[$1 + 88 >> 2], HEAP32[$1 + 48 >> 2]);
 HEAP32[$1 + 104 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__SaturatingRoundingMultiplyByPOT__1_2c_20int_2c_200__28gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 96 >> 2]);
 HEAP32[$8 >> 2] = HEAP32[$4 >> 2];
 HEAP32[$7 >> 2] = HEAP32[$4 >> 2];
 HEAP32[$6 >> 2] = HEAP32[$2 >> 2];
 HEAP32[$1 >> 2] = HEAP32[$5 >> 2];
 HEAP32[$1 + 16 >> 2] = gemmlowp__FixedPoint_int_2c_2012__20gemmlowp__operator__int_2c_2012__28gemmlowp__FixedPoint_int_2c_2012__2c_20gemmlowp__FixedPoint_int_2c_2012__29(HEAP32[$1 + 8 >> 2], HEAP32[$1 >> 2]);
 HEAP32[$1 + 32 >> 2] = gemmlowp__FixedPoint_int_2c_20_280_29_20__20_280_29__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 24 >> 2], HEAP32[$1 + 16 >> 2]);
 HEAP32[$1 + 248 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__AddSaturatingIf16Bit_int_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 40 >> 2], HEAP32[$1 + 32 >> 2]);
 global$0 = $1 + 256 | 0;
 return HEAP32[$1 + 248 >> 2];
}
function lcdSetPixels_ArrayBuffer($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 $5 = global$0 - 128 | 0;
 global$0 = $5;
 $6 = $5 + 40 | 0;
 HEAP32[$5 + 124 >> 2] = $0;
 HEAP32[$5 + 120 >> 2] = $1;
 HEAP32[$5 + 116 >> 2] = $2;
 HEAP32[$5 + 112 >> 2] = $3;
 HEAP32[$5 + 108 >> 2] = $4;
 $0 = HEAP32[$5 + 124 >> 2];
 HEAP32[$5 + 104 >> 2] = HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24);
 HEAP32[$5 + 100 >> 2] = lcdGetPixelIndex_ArrayBuffer(HEAP32[$5 + 124 >> 2], HEAP32[$5 + 120 >> 2], HEAP32[$5 + 116 >> 2], HEAP32[$5 + 112 >> 2]);
 jsvArrayBufferIteratorNew($6, HEAP32[$5 + 104 >> 2], HEAP32[$5 + 100 >> 2] >>> 3);
 HEAP32[$5 + 36 >> 2] = (1 << HEAPU8[HEAP32[$5 + 124 >> 2] + 16 | 0]) - 1;
 $0 = $5;
 label$1 : {
  if (HEAP32[$5 + 108 >> 2]) {
   $1 = 0;
   if (HEAP32[$5 + 36 >> 2] != (HEAP32[$5 + 108 >> 2] & HEAP32[$5 + 36 >> 2])) {
    break label$1;
   }
  }
  $1 = HEAP32[$5 + 124 >> 2];
  $1 = ((HEAPU8[$1 + 8 | 0] | HEAPU8[$1 + 9 | 0] << 8 | (HEAPU8[$1 + 10 | 0] << 16 | HEAPU8[$1 + 11 | 0] << 24)) & 2) != 0 ^ -1;
 }
 HEAP8[$0 + 35 | 0] = $1 & 1;
 HEAP32[$5 + 28 >> 2] = HEAPU8[HEAP32[$5 + 124 >> 2] + 16 | 0];
 $0 = HEAP32[$5 + 124 >> 2];
 if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 8) {
  HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 28 >> 2] << 1;
  HEAP8[$5 + 35 | 0] = 0;
 }
 while (1) {
  label$5 : {
   $0 = HEAP32[$5 + 112 >> 2];
   HEAP32[$5 + 112 >> 2] = $0 + -1;
   if (!$0) {
    break label$5;
   }
   label$6 : {
    if (HEAPU8[HEAP32[$5 + 124 >> 2] + 16 | 0] & 7) {
     HEAP32[$5 + 100 >> 2] = HEAP32[$5 + 100 >> 2] & 7;
     if (!(HEAP32[$5 + 100 >> 2] | !(HEAP8[$5 + 35 | 0] & 1))) {
      HEAP32[$5 + 24 >> 2] = Math_imul(HEAPU8[HEAP32[$5 + 124 >> 2] + 16 | 0], HEAP32[$5 + 112 >> 2] + 1 | 0) >> 3;
      if (HEAP32[$5 + 24 >> 2]) {
       HEAP8[$5 + 23 | 0] = HEAP32[$5 + 108 >> 2] ? 255 : 0;
       HEAP32[$5 + 112 >> 2] = (HEAP32[$5 + 112 >> 2] + 1 | 0) - ((HEAP32[$5 + 24 >> 2] << 3) / HEAPU8[HEAP32[$5 + 124 >> 2] + 16 | 0] | 0);
       while (1) {
        label$11 : {
         $0 = HEAP32[$5 + 24 >> 2];
         HEAP32[$5 + 24 >> 2] = $0 + -1;
         if (!$0) {
          break label$11;
         }
         $0 = $5 + 40 | 0;
         jsvArrayBufferIteratorSetByteValue($0, HEAP8[$5 + 23 | 0]);
         jsvArrayBufferIteratorNext($0);
         continue;
        }
        break;
       }
       continue;
      }
     }
     HEAP32[$5 + 16 >> 2] = (1 << HEAPU8[HEAP32[$5 + 124 >> 2] + 16 | 0]) - 1;
     HEAP32[$5 + 12 >> 2] = jsvArrayBufferIteratorGetIntegerValue($5 + 40 | 0);
     $0 = $5;
     $1 = HEAP32[$5 + 124 >> 2];
     $2 = 8 - (HEAP32[$5 + 100 >> 2] + HEAPU8[HEAP32[$5 + 124 >> 2] + 16 | 0] | 0) | 0;
     label$12 : {
      if ((HEAPU8[$1 + 8 | 0] | HEAPU8[$1 + 9 | 0] << 8 | (HEAPU8[$1 + 10 | 0] << 16 | HEAPU8[$1 + 11 | 0] << 24)) & 4) {
       break label$12;
      }
      $2 = HEAP32[$5 + 100 >> 2];
     }
     HEAP32[$0 + 8 >> 2] = $2;
     jsvArrayBufferIteratorSetByteValue($5 + 40 | 0, (HEAP32[$5 + 12 >> 2] & (HEAP32[$5 + 16 >> 2] << HEAP32[$5 + 8 >> 2] ^ -1) | (HEAP32[$5 + 108 >> 2] & HEAP32[$5 + 16 >> 2]) << HEAP32[$5 + 8 >> 2]) << 24 >> 24);
     $0 = HEAP32[$5 + 124 >> 2];
     label$14 : {
      if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 2) {
       jsvArrayBufferIteratorNext($5 + 40 | 0);
       break label$14;
      }
      HEAP32[$5 + 100 >> 2] = HEAP32[$5 + 28 >> 2] + HEAP32[$5 + 100 >> 2];
      if (HEAPU32[$5 + 100 >> 2] >= 8) {
       jsvArrayBufferIteratorNext($5 + 40 | 0);
      }
     }
     break label$6;
    }
    $0 = HEAP32[$5 + 124 >> 2];
    label$17 : {
     if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 4) {
      HEAP32[$5 + 4 >> 2] = HEAPU8[HEAP32[$5 + 124 >> 2] + 16 | 0] - 8;
      while (1) {
       if (HEAP32[$5 + 4 >> 2] >= 0) {
        $0 = $5 + 40 | 0;
        jsvArrayBufferIteratorSetByteValue($0, HEAP32[$5 + 108 >> 2] >>> HEAP32[$5 + 4 >> 2] << 24 >> 24);
        jsvArrayBufferIteratorNext($0);
        HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 4 >> 2] - 8;
        continue;
       }
       break;
      }
      break label$17;
     }
     HEAP32[$5 >> 2] = 0;
     while (1) {
      if (HEAP32[$5 >> 2] < HEAPU8[HEAP32[$5 + 124 >> 2] + 16 | 0]) {
       $0 = $5 + 40 | 0;
       jsvArrayBufferIteratorSetByteValue($0, HEAP32[$5 + 108 >> 2] >>> HEAP32[$5 >> 2] << 24 >> 24);
       jsvArrayBufferIteratorNext($0);
       HEAP32[$5 >> 2] = HEAP32[$5 >> 2] + 8;
       continue;
      }
      break;
     }
    }
   }
   continue;
  }
  break;
 }
 jsvArrayBufferIteratorFree($5 + 40 | 0);
 global$0 = $5 + 128 | 0;
}
function jswFindBuiltInFunction($0, $1) {
 var $2 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 label$1 : {
  label$2 : {
   label$3 : {
    if (!HEAP32[$2 + 40 >> 2]) {
     break label$3;
    }
    if (jsvIsRoot(HEAP32[$2 + 40 >> 2]) & 1) {
     break label$3;
    }
    if (jsvIsNativeFunction(HEAP32[$2 + 40 >> 2]) & 1) {
     HEAP32[$2 + 28 >> 2] = jswGetSymbolListForObject(HEAP32[$2 + 40 >> 2]);
     if (HEAP32[$2 + 28 >> 2]) {
      HEAP32[$2 + 32 >> 2] = jswBinarySearch(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
      if (HEAP32[$2 + 32 >> 2]) {
       HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
       break label$1;
      }
     }
    }
    if (jsvIsArray(HEAP32[$2 + 40 >> 2]) & 1) {
     HEAP32[$2 + 32 >> 2] = jswBinarySearch(93238, HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
     if (HEAP32[$2 + 32 >> 2]) {
      HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
      break label$1;
     }
    }
    label$9 : {
     if (!(jsvIsArrayBuffer(HEAP32[$2 + 40 >> 2]) & 1)) {
      break label$9;
     }
     $0 = HEAP32[$2 + 40 >> 2];
     if ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8) != 129) {
      break label$9;
     }
     HEAP32[$2 + 32 >> 2] = jswBinarySearch(93256, HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
     if (HEAP32[$2 + 32 >> 2]) {
      HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
      break label$1;
     }
    }
    label$11 : {
     if (!(jsvIsArrayBuffer(HEAP32[$2 + 40 >> 2]) & 1)) {
      break label$11;
     }
     $0 = HEAP32[$2 + 40 >> 2];
     if ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8) == 129) {
      break label$11;
     }
     HEAP32[$2 + 32 >> 2] = jswBinarySearch(93265, HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
     if (HEAP32[$2 + 32 >> 2]) {
      HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
      break label$1;
     }
    }
    if (jsvIsPin(HEAP32[$2 + 40 >> 2]) & 1) {
     HEAP32[$2 + 32 >> 2] = jswBinarySearch(93382, HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
     if (HEAP32[$2 + 32 >> 2]) {
      HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
      break label$1;
     }
    }
    if (jsvIsNumeric(HEAP32[$2 + 40 >> 2]) & 1) {
     HEAP32[$2 + 32 >> 2] = jswBinarySearch(93400, HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
     if (HEAP32[$2 + 32 >> 2]) {
      HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
      break label$1;
     }
    }
    if (jsvIsFunction(HEAP32[$2 + 40 >> 2]) & 1) {
     HEAP32[$2 + 32 >> 2] = jswBinarySearch(93427, HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
     if (HEAP32[$2 + 32 >> 2]) {
      HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
      break label$1;
     }
    }
    if (jsvIsString(HEAP32[$2 + 40 >> 2]) & 1) {
     HEAP32[$2 + 32 >> 2] = jswBinarySearch(93562, HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
     if (HEAP32[$2 + 32 >> 2]) {
      HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
      break label$1;
     }
    }
    $0 = $2;
    label$21 : {
     if (jsvIsObject(HEAP32[$2 + 40 >> 2]) & 1) {
      $1 = jsvSkipNameAndUnLock(jsvFindChildFromString(HEAP32[$2 + 40 >> 2], 93643, 0));
      break label$21;
     }
     $1 = 0;
    }
    HEAP32[$0 + 24 >> 2] = $1;
    $0 = $2;
    label$23 : {
     if (jsvIsObject(HEAP32[$2 + 24 >> 2]) & 1) {
      $1 = jsvSkipNameAndUnLock(jsvFindChildFromString(HEAP32[$2 + 24 >> 2], 93653, 0));
      break label$23;
     }
     $1 = 0;
    }
    HEAP32[$0 + 20 >> 2] = $1;
    jsvUnLock(HEAP32[$2 + 24 >> 2]);
    label$25 : {
     label$26 : {
      if (!HEAP32[$2 + 20 >> 2]) {
       break label$26;
      }
      if (!(jsvIsNativeFunction(HEAP32[$2 + 20 >> 2]) & 1)) {
       break label$26;
      }
      HEAP32[$2 + 16 >> 2] = jswGetSymbolListForConstructorProto(HEAP32[$2 + 20 >> 2]);
      jsvUnLock(HEAP32[$2 + 20 >> 2]);
      if (HEAP32[$2 + 16 >> 2]) {
       HEAP32[$2 + 32 >> 2] = jswBinarySearch(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
       if (HEAP32[$2 + 32 >> 2]) {
        HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
        break label$1;
       }
      }
      break label$25;
     }
     jsvUnLock(HEAP32[$2 + 20 >> 2]);
    }
    HEAP32[$2 + 32 >> 2] = jswBinarySearch(93409, HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
    if (HEAP32[$2 + 32 >> 2]) {
     HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
     break label$1;
    }
    break label$2;
   }
   HEAP8[$2 + 15 | 0] = jshGetPinFromString(HEAP32[$2 + 36 >> 2]);
   if (HEAPU8[$2 + 15 | 0] != 255) {
    HEAP32[$2 + 44 >> 2] = jsvNewFromPin(HEAPU8[$2 + 15 | 0]);
    break label$1;
   }
   HEAP32[$2 + 44 >> 2] = jswBinarySearch(93184, HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
   break label$1;
  }
  HEAP32[$2 + 44 >> 2] = 0;
 }
 global$0 = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}
function jswrap_graphics_asImage($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 176 | 0;
 global$0 = $2;
 HEAP32[$2 + 168 >> 2] = $0;
 HEAP32[$2 + 164 >> 2] = $1;
 label$1 : {
  if (!(graphicsGetFromVar($2 + 88 | 0, HEAP32[$2 + 168 >> 2]) & 1)) {
   HEAP32[$2 + 172 >> 2] = 0;
   break label$1;
  }
  label$3 : {
   label$4 : {
    if (!(jsvIsUndefined(HEAP32[$2 + 164 >> 2]) & 1)) {
     if (!(jsvIsStringEqual(HEAP32[$2 + 164 >> 2], 127986) & 1)) {
      break label$4;
     }
    }
    HEAP8[$2 + 87 | 0] = 1;
    break label$3;
   }
   label$6 : {
    if (jsvIsStringEqual(HEAP32[$2 + 164 >> 2], 127993) & 1) {
     HEAP8[$2 + 87 | 0] = 0;
     break label$6;
    }
    HEAP32[$2 >> 2] = HEAP32[$2 + 164 >> 2];
    jsExceptionHere(1, 128e3, $2);
    HEAP32[$2 + 172 >> 2] = 0;
    break label$1;
   }
  }
  HEAP32[$2 + 80 >> 2] = jswrap_graphics_getWidthOrHeight(HEAP32[$2 + 168 >> 2], 0);
  HEAP32[$2 + 76 >> 2] = jswrap_graphics_getWidthOrHeight(HEAP32[$2 + 168 >> 2], 1);
  HEAP32[$2 + 72 >> 2] = HEAPU8[$2 + 104 | 0];
  if ((HEAPU8[$2 + 92 | 0] | HEAPU8[$2 + 93 | 0] << 8 | (HEAPU8[$2 + 94 | 0] << 16 | HEAPU8[$2 + 95 | 0] << 24)) == 6) {
   HEAP32[$2 + 72 >> 2] = 3;
  }
  HEAP32[$2 + 68 >> 2] = Math_imul(HEAP32[$2 + 72 >> 2], Math_imul(HEAP32[$2 + 80 >> 2], HEAP32[$2 + 76 >> 2])) + 7 >> 3;
  HEAP32[$2 + 64 >> 2] = 0;
  label$9 : {
   if (HEAP8[$2 + 87 | 0] & 1) {
    HEAP32[$2 + 64 >> 2] = jsvNewWithFlags(5);
    if (!HEAP32[$2 + 64 >> 2]) {
     HEAP32[$2 + 172 >> 2] = 0;
     break label$1;
    }
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 64 >> 2], 127442, jsvNewFromInteger(HEAP32[$2 + 80 >> 2]));
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 64 >> 2], 127448, jsvNewFromInteger(HEAP32[$2 + 76 >> 2]));
    if (HEAP32[$2 + 72 >> 2] != 1) {
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 64 >> 2], 127863, jsvNewFromInteger(HEAP32[$2 + 72 >> 2]));
    }
    if (!(HEAPU8[$2 + 92 | 0] | HEAPU8[$2 + 93 | 0] << 8 | (HEAPU8[$2 + 94 | 0] << 16 | HEAPU8[$2 + 95 | 0] << 24) | (!((HEAPU8[$2 + 96 | 0] | HEAPU8[$2 + 97 | 0] << 8 | (HEAPU8[$2 + 98 | 0] << 16 | HEAPU8[$2 + 99 | 0] << 24)) & 4) | (HEAPU8[$2 + 96 | 0] | HEAPU8[$2 + 97 | 0] << 8 | (HEAPU8[$2 + 98 | 0] << 16 | HEAPU8[$2 + 99 | 0] << 24)) & 11 ? HEAP32[$2 + 72 >> 2] != 8 : 0))) {
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 64 >> 2], 127455, jsvObjectGetChild(HEAPU8[$2 + 88 | 0] | HEAPU8[$2 + 89 | 0] << 8 | (HEAPU8[$2 + 90 | 0] << 16 | HEAPU8[$2 + 91 | 0] << 24), 127455, 0));
     HEAP32[$2 + 172 >> 2] = HEAP32[$2 + 64 >> 2];
     break label$1;
    }
    break label$9;
   }
   HEAP32[$2 + 68 >> 2] = HEAP32[$2 + 68 >> 2] + 3;
  }
  HEAP32[$2 + 60 >> 2] = jsvNewStringOfLength(HEAP32[$2 + 68 >> 2], 0);
  if (!HEAP32[$2 + 60 >> 2]) {
   jsvUnLock(HEAP32[$2 + 64 >> 2]);
   HEAP32[$2 + 172 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 56 >> 2] = 0;
  HEAP32[$2 + 52 >> 2] = 0;
  HEAP32[$2 + 48 >> 2] = 0;
  HEAP32[$2 + 44 >> 2] = 0;
  jsvStringIteratorNew($2 + 8 | 0, HEAP32[$2 + 60 >> 2], 0);
  if (!(HEAP8[$2 + 87 | 0] & 1)) {
   $0 = $2 + 8 | 0;
   jsvStringIteratorSetCharAndNext($0, HEAP32[$2 + 80 >> 2] << 24 >> 24);
   jsvStringIteratorSetCharAndNext($0, HEAP32[$2 + 76 >> 2] << 24 >> 24);
   jsvStringIteratorSetCharAndNext($0, HEAP32[$2 + 72 >> 2] << 24 >> 24);
  }
  while (1) {
   if (jsvStringIteratorHasChar($2 + 8 | 0) & 1) {
    HEAP32[$2 + 4 >> 2] = graphicsGetPixel($2 + 88 | 0, HEAP32[$2 + 56 >> 2], HEAP32[$2 + 52 >> 2]);
    if ((HEAPU8[$2 + 92 | 0] | HEAPU8[$2 + 93 | 0] << 8 | (HEAPU8[$2 + 94 | 0] << 16 | HEAPU8[$2 + 95 | 0] << 24)) == 6) {
     HEAP32[$2 + 4 >> 2] = (HEAP32[$2 + 4 >> 2] & 32768 ? 4 : 0) | (HEAP32[$2 + 4 >> 2] & 1024 ? 2 : 0) | (HEAP32[$2 + 4 >> 2] & 16 ? 1 : 0);
    }
    HEAP32[$2 + 48 >> 2] = HEAP32[$2 + 4 >> 2] | HEAP32[$2 + 48 >> 2] << HEAP32[$2 + 72 >> 2];
    HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 72 >> 2] + HEAP32[$2 + 44 >> 2];
    HEAP32[$2 + 56 >> 2] = HEAP32[$2 + 56 >> 2] + 1;
    if (HEAP32[$2 + 56 >> 2] >= HEAP32[$2 + 80 >> 2]) {
     HEAP32[$2 + 56 >> 2] = 0;
     HEAP32[$2 + 52 >> 2] = HEAP32[$2 + 52 >> 2] + 1;
    }
    while (1) {
     if (HEAPU32[$2 + 44 >> 2] >= 8) {
      jsvStringIteratorSetCharAndNext($2 + 8 | 0, HEAP32[$2 + 48 >> 2] >>> HEAP32[$2 + 44 >> 2] - 8 << 24 >> 24);
      HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 44 >> 2] - 8;
      continue;
     }
     break;
    }
    continue;
   }
   break;
  }
  jsvStringIteratorFree($2 + 8 | 0);
  if (HEAP8[$2 + 87 | 0] & 1) {
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 64 >> 2], 127455, HEAP32[$2 + 60 >> 2]);
   HEAP32[$2 + 172 >> 2] = HEAP32[$2 + 64 >> 2];
   break label$1;
  }
  HEAP32[$2 + 172 >> 2] = HEAP32[$2 + 60 >> 2];
 }
 global$0 = $2 + 176 | 0;
 return HEAP32[$2 + 172 >> 2];
}
function jspeClassDefinition($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 + -64 | 0;
 global$0 = $1;
 HEAP8[$1 + 59 | 0] = $0;
 HEAP32[$1 + 52 >> 2] = 0;
 HEAP32[$1 + 48 >> 2] = 0;
 HEAP32[$1 + 44 >> 2] = 0;
 HEAP8[$1 + 43 | 0] = (HEAP32[80549] & 63) == 1;
 if (HEAP8[$1 + 43 | 0] & 1) {
  HEAP32[$1 + 52 >> 2] = jsvNewWithFlags(7);
  HEAP32[$1 + 36 >> 2] = jspeiGetScopesAsVar();
  if (HEAP32[$1 + 36 >> 2]) {
   jsvUnLock2(jsvAddNamedChild(HEAP32[$1 + 52 >> 2], HEAP32[$1 + 36 >> 2], 79694), HEAP32[$1 + 36 >> 2]);
  }
 }
 if (!(!(HEAP8[$1 + 59 | 0] & 1) | HEAP16[HEAP32[35539] + 2 >> 1] != 128)) {
  if (HEAP32[$1 + 52 >> 2]) {
   HEAP32[$1 + 44 >> 2] = jslGetTokenValueAsVar();
  }
  jslGetNextToken();
 }
 if (HEAP32[$1 + 52 >> 2]) {
  HEAP32[$1 + 32 >> 2] = jsvFindChildFromString(HEAP32[$1 + 52 >> 2], 79516, 1);
  jspEnsureIsPrototype(HEAP32[$1 + 52 >> 2], HEAP32[$1 + 32 >> 2]);
  HEAP32[$1 + 48 >> 2] = jsvSkipName(HEAP32[$1 + 32 >> 2]);
  jsvUnLock(HEAP32[$1 + 32 >> 2]);
 }
 label$6 : {
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 195) {
   jslGetNextToken();
   $0 = $1;
   label$8 : {
    if (HEAP8[$1 + 43 | 0] & 1) {
     $2 = jsvSkipNameAndUnLock(jspGetNamedVariable(jslGetTokenValueAsString()));
     break label$8;
    }
    $2 = 0;
   }
   HEAP32[$0 + 28 >> 2] = $2;
   if (!(jslMatch(128) & 1)) {
    jsvUnLock4(HEAP32[$1 + 28 >> 2], HEAP32[$1 + 52 >> 2], HEAP32[$1 + 44 >> 2], HEAP32[$1 + 48 >> 2]);
    HEAP32[$1 + 60 >> 2] = 0;
    break label$6;
   }
   if (HEAP32[$1 + 48 >> 2]) {
    label$12 : {
     if (jsvIsFunction(HEAP32[$1 + 28 >> 2]) & 1) {
      HEAP32[$1 + 24 >> 2] = jsvObjectGetChild(HEAP32[$1 + 28 >> 2], 79516, 0);
      if (HEAP32[$1 + 24 >> 2]) {
       jsvObjectSetChild(HEAP32[$1 + 48 >> 2], 79526, HEAP32[$1 + 24 >> 2]);
       jsvObjectSetChildAndUnLock(HEAP32[$1 + 52 >> 2], 79689, jsvNewFromString(80221));
       jsvUnLock(HEAP32[$1 + 24 >> 2]);
      }
      break label$12;
     }
     HEAP32[$1 >> 2] = HEAP32[$1 + 28 >> 2];
     jsExceptionHere(2, 80320, $1);
    }
   }
   jsvUnLock(HEAP32[$1 + 28 >> 2]);
  }
  if (!(jslMatch(123) & 1)) {
   jsvUnLock3(HEAP32[$1 + 52 >> 2], HEAP32[$1 + 44 >> 2], HEAP32[$1 + 48 >> 2]);
   HEAP32[$1 + 60 >> 2] = 0;
   break label$6;
  }
  while (1) {
   label$17 : {
    if (HEAP16[HEAP32[35539] + 2 >> 1] != 128) {
     $0 = 0;
     if (HEAP16[HEAP32[35539] + 2 >> 1] != 197) {
      break label$17;
     }
    }
    $0 = jspIsInterrupted() ^ -1;
   }
   if ($0 & 1) {
    HEAP8[$1 + 23 | 0] = HEAP16[HEAP32[35539] + 2 >> 1] == 197;
    if (HEAP8[$1 + 23 | 0] & 1) {
     jslGetNextToken();
    }
    HEAP32[$1 + 16 >> 2] = jslGetTokenValueAsVar();
    if (!(jslMatch(128) & 1)) {
     jsvUnLock4(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 52 >> 2], HEAP32[$1 + 44 >> 2], HEAP32[$1 + 48 >> 2]);
     HEAP32[$1 + 60 >> 2] = 0;
     break label$6;
    }
    HEAP8[$1 + 15 | 0] = 0;
    HEAP8[$1 + 14 | 0] = 0;
    if (HEAP16[HEAP32[35539] + 2 >> 1] == 128) {
     HEAP8[$1 + 15 | 0] = jsvIsStringEqual(HEAP32[$1 + 16 >> 2], 80153) & 1;
     HEAP8[$1 + 14 | 0] = jsvIsStringEqual(HEAP32[$1 + 16 >> 2], 80157) & 1;
     if (!(HEAP8[$1 + 14 | 0] & 1 ? 0 : !(HEAP8[$1 + 15 | 0] & 1))) {
      jsvUnLock(HEAP32[$1 + 16 >> 2]);
      HEAP32[$1 + 16 >> 2] = jslGetTokenValueAsVar();
      jslGetNextToken();
     }
    }
    HEAP32[$1 + 8 >> 2] = jspeFunctionDefinition(0);
    if (!(!HEAP32[$1 + 52 >> 2] | !HEAP32[$1 + 48 >> 2])) {
     $0 = $1;
     if (HEAP8[$1 + 23 | 0] & 1) {
      $2 = HEAP32[$1 + 52 >> 2];
     } else {
      $2 = HEAP32[$1 + 48 >> 2];
     }
     HEAP32[$0 + 4 >> 2] = $2;
     label$28 : {
      if (jsvIsStringEqual(HEAP32[$1 + 16 >> 2], 80199) & 1) {
       jswrap_function_replaceWith(HEAP32[$1 + 52 >> 2], HEAP32[$1 + 8 >> 2]);
       break label$28;
      }
      label$30 : {
       if (!(HEAP8[$1 + 14 | 0] & 1 ? 0 : !(HEAP8[$1 + 15 | 0] & 1))) {
        jsvAddGetterOrSetter(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 16 >> 2], HEAP8[$1 + 15 | 0] & 1, HEAP32[$1 + 8 >> 2]);
        break label$30;
       }
       HEAP32[$1 + 16 >> 2] = jsvMakeIntoVariableName(HEAP32[$1 + 16 >> 2], 0);
       jsvSetValueOfName(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 8 >> 2]);
       jsvAddName(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 16 >> 2]);
      }
     }
    }
    jsvUnLock2(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 16 >> 2]);
    continue;
   }
   break;
  }
  jsvUnLock(HEAP32[$1 + 48 >> 2]);
  if (HEAP32[$1 + 44 >> 2]) {
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 52 >> 2], 79699, HEAP32[$1 + 44 >> 2]);
  }
  if (!(jslMatch(125) & 1)) {
   jsvUnLock(HEAP32[$1 + 52 >> 2]);
   HEAP32[$1 + 60 >> 2] = 0;
   break label$6;
  }
  HEAP32[$1 + 60 >> 2] = HEAP32[$1 + 52 >> 2];
 }
 global$0 = $1 - -64 | 0;
 return HEAP32[$1 + 60 >> 2];
}
function jslLexString() {
 var $0 = 0, $1 = 0, $2 = 0;
 $0 = global$0 + -64 | 0;
 global$0 = $0;
 HEAP8[$0 + 63 | 0] = HEAPU8[HEAP32[35539]];
 $1 = jsvNewWithFlags(27);
 HEAP32[HEAP32[35539] + 76 >> 2] = $1;
 label$1 : {
  if (!HEAP32[HEAP32[35539] + 76 >> 2]) {
   HEAP16[HEAP32[35539] + 2 >> 1] = 0;
   break label$1;
  }
  jsvStringIteratorNew($0 + 24 | 0, HEAP32[HEAP32[35539] + 76 >> 2], 0);
  jslGetNextCh();
  while (1) {
   label$4 : {
    if (!(HEAP8[HEAP32[35539]] ? HEAP8[HEAP32[35539]] != HEAP8[$0 + 63 | 0] : 0)) {
     break label$4;
    }
    label$7 : {
     if (HEAP8[HEAP32[35539]] == 92) {
      jslGetNextCh();
      HEAP8[$0 + 23 | 0] = HEAPU8[HEAP32[35539]];
      label$9 : {
       label$10 : {
        $1 = HEAP8[HEAP32[35539]] + -98 | 0;
        if ($1 >>> 0 > 22) {
         break label$10;
        }
        label$11 : {
         switch ($1 - 1 | 0) {
         case 11:
          HEAP8[$0 + 23 | 0] = 10;
          jslGetNextCh();
          break label$9;
         default:
          HEAP8[$0 + 23 | 0] = 8;
          jslGetNextCh();
          break label$9;
         case 3:
          HEAP8[$0 + 23 | 0] = 12;
          jslGetNextCh();
          break label$9;
         case 15:
          HEAP8[$0 + 23 | 0] = 13;
          jslGetNextCh();
          break label$9;
         case 17:
          HEAP8[$0 + 23 | 0] = 9;
          jslGetNextCh();
          break label$9;
         case 19:
          HEAP8[$0 + 23 | 0] = 11;
          jslGetNextCh();
          break label$9;
         case 0:
         case 1:
         case 2:
         case 4:
         case 5:
         case 6:
         case 7:
         case 8:
         case 9:
         case 10:
         case 12:
         case 13:
         case 14:
         case 16:
         case 20:
          break label$10;
         case 18:
         case 21:
          break label$11;
         }
        }
        HEAP8[$0 + 22 | 0] = HEAPU8[77971];
        $1 = HEAPU8[77967] | HEAPU8[77968] << 8 | (HEAPU8[77969] << 16 | HEAPU8[77970] << 24);
        HEAP8[$0 + 18 | 0] = $1;
        HEAP8[$0 + 19 | 0] = $1 >>> 8;
        HEAP8[$0 + 20 | 0] = $1 >>> 16;
        HEAP8[$0 + 21 | 0] = $1 >>> 24;
        if (HEAP8[HEAP32[35539]] == 117) {
         jslGetNextCh();
         jslGetNextCh();
        }
        $1 = $0 + 18 | 0;
        jslGetNextCh();
        HEAP8[$0 + 20 | 0] = HEAPU8[HEAP32[35539]];
        jslGetNextCh();
        HEAP8[$0 + 21 | 0] = HEAPU8[HEAP32[35539]];
        jslGetNextCh();
        HEAP8[$0 + 23 | 0] = stringToInt($1);
        break label$9;
       }
       label$19 : {
        if (!(HEAP8[HEAP32[35539]] < 48 | HEAP8[HEAP32[35539]] > 55)) {
         HEAP8[$0 + 17 | 0] = HEAPU8[77976];
         $1 = HEAPU8[77972] | HEAPU8[77973] << 8 | (HEAPU8[77974] << 16 | HEAPU8[77975] << 24);
         HEAP8[$0 + 13 | 0] = $1;
         HEAP8[$0 + 14 | 0] = $1 >>> 8;
         HEAP8[$0 + 15 | 0] = $1 >>> 16;
         HEAP8[$0 + 16 | 0] = $1 >>> 24;
         HEAP8[$0 + 14 | 0] = HEAPU8[HEAP32[35539]];
         HEAP32[$0 + 8 >> 2] = 2;
         jslGetNextCh();
         if (!(HEAP8[HEAP32[35539]] < 48 | HEAP8[HEAP32[35539]] > 55)) {
          $1 = HEAPU8[HEAP32[35539]];
          $2 = HEAP32[$0 + 8 >> 2];
          HEAP32[$0 + 8 >> 2] = $2 + 1;
          HEAP8[$2 + ($0 + 13 | 0) | 0] = $1;
          jslGetNextCh();
          if (!(HEAP8[HEAP32[35539]] < 48 | HEAP8[HEAP32[35539]] > 55)) {
           $1 = HEAPU8[HEAP32[35539]];
           $2 = HEAP32[$0 + 8 >> 2];
           HEAP32[$0 + 8 >> 2] = $2 + 1;
           HEAP8[$2 + ($0 + 13 | 0) | 0] = $1;
           jslGetNextCh();
          }
         }
         $1 = $0 + 13 | 0;
         HEAP8[$1 + HEAP32[$0 + 8 >> 2] | 0] = 0;
         HEAP8[$0 + 23 | 0] = stringToInt($1);
         break label$19;
        }
        jslGetNextCh();
       }
      }
      $1 = $0 + 24 | 0;
      jslTokenAppendChar(HEAP8[$0 + 23 | 0]);
      jsvStringIteratorAppend($1, HEAP8[$0 + 23 | 0]);
      break label$7;
     }
     if (!(HEAP8[$0 + 63 | 0] == 96 | HEAP8[HEAP32[35539]] != 10)) {
      break label$4;
     }
     $1 = $0 + 24 | 0;
     jslTokenAppendChar(HEAP8[HEAP32[35539]]);
     jsvStringIteratorAppend($1, HEAP8[HEAP32[35539]]);
     jslGetNextCh();
    }
    continue;
   }
   break;
  }
  jsvStringIteratorFree($0 + 24 | 0);
  label$24 : {
   if (HEAP8[$0 + 63 | 0] == 96) {
    HEAP16[HEAP32[35539] + 2 >> 1] = 133;
    break label$24;
   }
   HEAP16[HEAP32[35539] + 2 >> 1] = 131;
  }
  if (HEAP8[HEAP32[35539]] != HEAP8[$0 + 63 | 0]) {
   $1 = HEAP32[35539];
   HEAP16[$1 + 2 >> 1] = HEAPU16[$1 + 2 >> 1] + 1;
  }
  jslGetNextCh();
 }
 global$0 = $0 - -64 | 0;
}
function jsvMakeIntoVariableName($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 96 | 0;
 global$0 = $2;
 HEAP32[$2 + 88 >> 2] = $0;
 HEAP32[$2 + 84 >> 2] = $1;
 label$1 : {
  if (!HEAP32[$2 + 88 >> 2]) {
   HEAP32[$2 + 92 >> 2] = 0;
   break label$1;
  }
  $0 = HEAP32[$2 + 88 >> 2];
  HEAP16[$2 + 82 >> 1] = (HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63;
  label$3 : {
   if (HEAPU16[$2 + 82 >> 1] == 9) {
    HEAP32[$2 + 76 >> 2] = 14;
    label$5 : {
     if (!(jsvIsInt(HEAP32[$2 + 84 >> 2]) & 1)) {
      if (!(jsvIsBoolean(HEAP32[$2 + 84 >> 2]) & 1)) {
       break label$5;
      }
     }
     if (jsvIsPin(HEAP32[$2 + 84 >> 2]) & 1) {
      break label$5;
     }
     $0 = HEAP32[$2 + 84 >> 2];
     HEAP32[$2 + 72 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
     if (!(HEAP32[$2 + 72 >> 2] < -32768 | HEAP32[$2 + 72 >> 2] > 32767)) {
      HEAP32[$2 + 76 >> 2] = jsvIsInt(HEAP32[$2 + 84 >> 2]) & 1 ? 15 : 16;
      jsvSetFirstChild(HEAP32[$2 + 88 >> 2], HEAP32[$2 + 72 >> 2] & 65535);
      HEAP32[$2 + 84 >> 2] = 0;
     }
    }
    $0 = HEAP32[$2 + 88 >> 2];
    $1 = HEAP32[$2 + 88 >> 2];
    $1 = HEAP32[$2 + 76 >> 2] | (HEAPU8[$1 + 13 | 0] | HEAPU8[$1 + 14 | 0] << 8) & -64;
    HEAP8[$0 + 13 | 0] = $1;
    HEAP8[$0 + 14 | 0] = $1 >>> 8;
    break label$3;
   }
   if (!(HEAPU16[$2 + 82 >> 1] < 17 | HEAPU16[$2 + 82 >> 1] > 40)) {
    if (jsvGetCharactersInVar(HEAP32[$2 + 88 >> 2]) >>> 0 > 4) {
     jsvStringIteratorNew($2 + 32 | 0, HEAP32[$2 + 88 >> 2], 4);
     HEAP32[$2 + 28 >> 2] = jsvNewWithFlags(41);
     HEAP32[$2 + 24 >> 2] = jsvLockAgainSafe(HEAP32[$2 + 28 >> 2]);
     HEAP32[$2 + 20 >> 2] = 0;
     while (1) {
      if (HEAP32[$2 + 24 >> 2]) {
       $0 = jsvStringIteratorHasChar($2 + 32 | 0);
      } else {
       $0 = 0;
      }
      if ($0 & 1) {
       if (HEAPU32[$2 + 20 >> 2] >= 11) {
        jsvSetCharactersInVar(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2]);
        HEAP32[$2 + 16 >> 2] = jsvNewWithFlags(41);
        if (HEAP32[$2 + 16 >> 2]) {
         jsvSetLastChild(HEAP32[$2 + 24 >> 2], jsvGetRef(HEAP32[$2 + 16 >> 2]) & 65535);
        }
        jsvUnLock(HEAP32[$2 + 24 >> 2]);
        HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 16 >> 2];
        HEAP32[$2 + 20 >> 2] = 0;
       }
       $0 = jsvStringIteratorGetCharAndNext($2 + 32 | 0);
       $1 = HEAP32[$2 + 24 >> 2];
       $3 = HEAP32[$2 + 20 >> 2];
       HEAP32[$2 + 20 >> 2] = $3 + 1;
       HEAP8[$1 + $3 | 0] = $0;
       continue;
      }
      break;
     }
     jsvStringIteratorFree($2 + 32 | 0);
     if (HEAP32[$2 + 24 >> 2]) {
      jsvSetCharactersInVar(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2]);
      jsvUnLock(HEAP32[$2 + 24 >> 2]);
     }
     jsvSetCharactersInVar(HEAP32[$2 + 88 >> 2], 4);
     HEAP16[$2 + 14 >> 1] = jsvGetLastChild(HEAP32[$2 + 88 >> 2]);
     while (1) {
      if (HEAPU16[$2 + 14 >> 1]) {
       HEAP32[$2 + 8 >> 2] = jsvGetAddressOf(HEAPU16[$2 + 14 >> 1]);
       HEAP16[$2 + 14 >> 1] = jsvGetLastChild(HEAP32[$2 + 8 >> 2]);
       jsvFreePtrInternal(HEAP32[$2 + 8 >> 2]);
       continue;
      }
      break;
     }
     jsvSetLastChild(HEAP32[$2 + 88 >> 2], jsvGetRef(HEAP32[$2 + 28 >> 2]) & 65535);
     jsvSetNextSibling(HEAP32[$2 + 88 >> 2], 0);
     jsvSetPrevSibling(HEAP32[$2 + 88 >> 2], 0);
     jsvSetFirstChild(HEAP32[$2 + 88 >> 2], 0);
     jsvUnLock(HEAP32[$2 + 28 >> 2]);
    }
    HEAP32[$2 + 4 >> 2] = 22;
    label$19 : {
     label$20 : {
      if (!(jsvIsInt(HEAP32[$2 + 84 >> 2]) & 1)) {
       break label$20;
      }
      if (jsvIsPin(HEAP32[$2 + 84 >> 2]) & 1) {
       break label$20;
      }
      $0 = HEAP32[$2 + 84 >> 2];
      HEAP32[$2 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
      if (!(HEAP32[$2 >> 2] < -32768 | HEAP32[$2 >> 2] > 32767)) {
       HEAP32[$2 + 4 >> 2] = 17;
       jsvSetFirstChild(HEAP32[$2 + 88 >> 2], HEAP32[$2 >> 2] & 65535);
       HEAP32[$2 + 84 >> 2] = 0;
      }
      break label$19;
     }
     jsvSetFirstChild(HEAP32[$2 + 88 >> 2], 0);
    }
    $0 = HEAP32[$2 + 88 >> 2];
    $0 = (HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 65472 | HEAP32[$2 + 4 >> 2] + jsvGetCharactersInVar(HEAP32[$2 + 88 >> 2]);
    $1 = HEAP32[$2 + 88 >> 2];
    HEAP8[$1 + 13 | 0] = $0;
    HEAP8[$1 + 14 | 0] = $0 >>> 8;
   }
  }
  if (HEAP32[$2 + 84 >> 2]) {
   jsvSetFirstChild(HEAP32[$2 + 88 >> 2], jsvGetRef(jsvRef(HEAP32[$2 + 84 >> 2])) & 65535);
  }
  HEAP32[$2 + 92 >> 2] = HEAP32[$2 + 88 >> 2];
 }
 global$0 = $2 + 96 | 0;
 return HEAP32[$2 + 92 >> 2];
}
function graphicsScroll($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 $4 = $3 + 8 | 0;
 $5 = $3 + 4 | 0;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 HEAP32[$3 + 16 >> 2] = 0;
 HEAP32[$3 + 12 >> 2] = 0;
 HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 24 >> 2];
 HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 20 >> 2];
 graphicsToDeviceCoordinates(HEAP32[$3 + 28 >> 2], $3 + 16 | 0, $3 + 12 | 0);
 graphicsToDeviceCoordinates(HEAP32[$3 + 28 >> 2], $4, $5);
 HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 8 >> 2] - HEAP32[$3 + 16 >> 2];
 HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 4 >> 2] - HEAP32[$3 + 12 >> 2];
 HEAP8[$3 + 3 | 0] = 1;
 $0 = HEAP32[$3 + 28 >> 2];
 if (HEAP32[$3 + 24 >> 2] > (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8)) {
  $0 = HEAP32[$3 + 28 >> 2];
  HEAP32[$3 + 24 >> 2] = HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8;
  HEAP8[$3 + 3 | 0] = 0;
 }
 $0 = HEAP32[$3 + 28 >> 2];
 if (HEAP32[$3 + 24 >> 2] < (0 - (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) | 0)) {
  $0 = HEAP32[$3 + 28 >> 2];
  HEAP32[$3 + 24 >> 2] = 0 - (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
  HEAP8[$3 + 3 | 0] = 0;
 }
 $0 = HEAP32[$3 + 28 >> 2];
 if (HEAP32[$3 + 20 >> 2] > (HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8)) {
  $0 = HEAP32[$3 + 28 >> 2];
  HEAP32[$3 + 20 >> 2] = HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8;
  HEAP8[$3 + 3 | 0] = 0;
 }
 $0 = HEAP32[$3 + 28 >> 2];
 if (HEAP32[$3 + 20 >> 2] < (0 - (HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8) | 0)) {
  $0 = HEAP32[$3 + 28 >> 2];
  HEAP32[$3 + 20 >> 2] = 0 - (HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8);
  HEAP8[$3 + 3 | 0] = 0;
 }
 $0 = HEAP32[$3 + 28 >> 2];
 HEAP32[$3 + 16 >> 2] = HEAPU8[$0 + 32 | 0] | HEAPU8[$0 + 33 | 0] << 8;
 $0 = HEAP32[$3 + 28 >> 2];
 HEAP32[$3 + 12 >> 2] = HEAPU8[$0 + 34 | 0] | HEAPU8[$0 + 35 | 0] << 8;
 $0 = HEAP32[$3 + 28 >> 2];
 HEAP32[$3 + 8 >> 2] = HEAPU8[$0 + 36 | 0] | HEAPU8[$0 + 37 | 0] << 8;
 $0 = HEAP32[$3 + 28 >> 2];
 HEAP32[$3 + 4 >> 2] = HEAPU8[$0 + 38 | 0] | HEAPU8[$0 + 39 | 0] << 8;
 if (HEAP8[$3 + 3 | 0] & 1) {
  $0 = HEAP32[$3 + 28 >> 2];
  FUNCTION_TABLE[HEAPU8[$0 + 68 | 0] | HEAPU8[$0 + 69 | 0] << 8 | (HEAPU8[$0 + 70 | 0] << 16 | HEAPU8[$0 + 71 | 0] << 24)](HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 16 >> 2], HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 }
 graphicsSetModified(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 16 >> 2], HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 label$6 : {
  if (HEAP32[$3 + 24 >> 2] > 0) {
   $0 = HEAP32[$3 + 28 >> 2];
   $1 = HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24);
   $0 = HEAP32[$3 + 28 >> 2];
   FUNCTION_TABLE[HEAPU8[$0 + 56 | 0] | HEAPU8[$0 + 57 | 0] << 8 | (HEAPU8[$0 + 58 | 0] << 16 | HEAPU8[$0 + 59 | 0] << 24)](HEAP32[$3 + 28 >> 2], HEAP32[$3 + 16 >> 2], HEAP32[$3 + 12 >> 2], (HEAP32[$3 + 16 >> 2] + HEAP32[$3 + 24 >> 2] | 0) - 1 | 0, HEAP32[$3 + 4 >> 2], $1);
   break label$6;
  }
  if (HEAP32[$3 + 24 >> 2] < 0) {
   $0 = HEAP32[$3 + 28 >> 2];
   $1 = HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24);
   $0 = HEAP32[$3 + 28 >> 2];
   FUNCTION_TABLE[HEAPU8[$0 + 56 | 0] | HEAPU8[$0 + 57 | 0] << 8 | (HEAPU8[$0 + 58 | 0] << 16 | HEAPU8[$0 + 59 | 0] << 24)](HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2] + (HEAP32[$3 + 8 >> 2] + 1 | 0) | 0, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], $1);
  }
 }
 label$9 : {
  if (HEAP32[$3 + 20 >> 2] > 0) {
   $0 = HEAP32[$3 + 28 >> 2];
   $1 = HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24);
   $0 = HEAP32[$3 + 28 >> 2];
   FUNCTION_TABLE[HEAPU8[$0 + 56 | 0] | HEAPU8[$0 + 57 | 0] << 8 | (HEAPU8[$0 + 58 | 0] << 16 | HEAPU8[$0 + 59 | 0] << 24)](HEAP32[$3 + 28 >> 2], HEAP32[$3 + 16 >> 2], HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], (HEAP32[$3 + 12 >> 2] + HEAP32[$3 + 20 >> 2] | 0) - 1 | 0, $1);
   break label$9;
  }
  if (HEAP32[$3 + 20 >> 2] < 0) {
   $0 = HEAP32[$3 + 28 >> 2];
   $1 = HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24);
   $0 = HEAP32[$3 + 28 >> 2];
   FUNCTION_TABLE[HEAPU8[$0 + 56 | 0] | HEAPU8[$0 + 57 | 0] << 8 | (HEAPU8[$0 + 58 | 0] << 16 | HEAPU8[$0 + 59 | 0] << 24)](HEAP32[$3 + 28 >> 2], HEAP32[$3 + 16 >> 2], HEAP32[$3 + 20 >> 2] + (HEAP32[$3 + 4 >> 2] + 1 | 0) | 0, HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], $1);
  }
 }
 global$0 = $3 + 32 | 0;
}
function lcdSetPixels_ArrayBuffer_flat($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 80 | 0;
 global$0 = $5;
 HEAP32[$5 + 76 >> 2] = $0;
 HEAP32[$5 + 72 >> 2] = $1;
 HEAP32[$5 + 68 >> 2] = $2;
 HEAP32[$5 + 64 >> 2] = $3;
 HEAP32[$5 + 60 >> 2] = $4;
 $0 = HEAP32[$5 + 76 >> 2];
 HEAP32[$5 + 56 >> 2] = HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24);
 HEAP32[$5 + 52 >> 2] = lcdGetPixelIndex_ArrayBuffer(HEAP32[$5 + 76 >> 2], HEAP32[$5 + 72 >> 2], HEAP32[$5 + 68 >> 2], HEAP32[$5 + 64 >> 2]);
 HEAP32[$5 + 56 >> 2] = HEAP32[$5 + 56 >> 2] + (HEAP32[$5 + 52 >> 2] >>> 3);
 HEAP32[$5 + 48 >> 2] = (1 << HEAPU8[HEAP32[$5 + 76 >> 2] + 16 | 0]) - 1;
 $0 = $5;
 label$1 : {
  if (HEAP32[$5 + 60 >> 2]) {
   $1 = 0;
   if (HEAP32[$5 + 48 >> 2] != (HEAP32[$5 + 60 >> 2] & HEAP32[$5 + 48 >> 2])) {
    break label$1;
   }
  }
  $1 = HEAP32[$5 + 76 >> 2];
  $1 = ((HEAPU8[$1 + 8 | 0] | HEAPU8[$1 + 9 | 0] << 8 | (HEAPU8[$1 + 10 | 0] << 16 | HEAPU8[$1 + 11 | 0] << 24)) & 2) != 0 ^ -1;
 }
 HEAP8[$0 + 47 | 0] = $1 & 1;
 HEAP32[$5 + 40 >> 2] = HEAPU8[HEAP32[$5 + 76 >> 2] + 16 | 0];
 $0 = HEAP32[$5 + 76 >> 2];
 if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 8) {
  HEAP32[$5 + 40 >> 2] = HEAP32[$5 + 40 >> 2] << 1;
  HEAP8[$5 + 47 | 0] = 0;
 }
 while (1) {
  label$5 : {
   $0 = HEAP32[$5 + 64 >> 2];
   HEAP32[$5 + 64 >> 2] = $0 + -1;
   if (!$0) {
    break label$5;
   }
   label$6 : {
    if (HEAPU8[HEAP32[$5 + 76 >> 2] + 16 | 0] & 7) {
     HEAP32[$5 + 52 >> 2] = HEAP32[$5 + 52 >> 2] & 7;
     if (!(HEAP32[$5 + 52 >> 2] | !(HEAP8[$5 + 47 | 0] & 1))) {
      HEAP32[$5 + 36 >> 2] = Math_imul(HEAPU8[HEAP32[$5 + 76 >> 2] + 16 | 0], HEAP32[$5 + 64 >> 2] + 1 | 0) >> 3;
      if (HEAP32[$5 + 36 >> 2]) {
       HEAP8[$5 + 35 | 0] = HEAP32[$5 + 60 >> 2] ? 255 : 0;
       HEAP32[$5 + 64 >> 2] = (HEAP32[$5 + 64 >> 2] + 1 | 0) - ((HEAP32[$5 + 36 >> 2] << 3) / HEAPU8[HEAP32[$5 + 76 >> 2] + 16 | 0] | 0);
       while (1) {
        $0 = HEAP32[$5 + 36 >> 2];
        HEAP32[$5 + 36 >> 2] = $0 + -1;
        if ($0) {
         HEAP8[HEAP32[$5 + 56 >> 2]] = HEAPU8[$5 + 35 | 0];
         HEAP32[$5 + 56 >> 2] = HEAP32[$5 + 56 >> 2] + 1;
         continue;
        }
        break;
       }
       continue;
      }
     }
     HEAP32[$5 + 28 >> 2] = (1 << HEAPU8[HEAP32[$5 + 76 >> 2] + 16 | 0]) - 1;
     HEAP32[$5 + 24 >> 2] = HEAPU8[HEAP32[$5 + 56 >> 2]];
     $0 = $5;
     $1 = HEAP32[$5 + 76 >> 2];
     $2 = 8 - (HEAP32[$5 + 52 >> 2] + HEAPU8[HEAP32[$5 + 76 >> 2] + 16 | 0] | 0) | 0;
     label$12 : {
      if ((HEAPU8[$1 + 8 | 0] | HEAPU8[$1 + 9 | 0] << 8 | (HEAPU8[$1 + 10 | 0] << 16 | HEAPU8[$1 + 11 | 0] << 24)) & 4) {
       break label$12;
      }
      $2 = HEAP32[$5 + 52 >> 2];
     }
     HEAP32[$0 + 20 >> 2] = $2;
     HEAP8[HEAP32[$5 + 56 >> 2]] = HEAP32[$5 + 24 >> 2] & (HEAP32[$5 + 28 >> 2] << HEAP32[$5 + 20 >> 2] ^ -1) | (HEAP32[$5 + 60 >> 2] & HEAP32[$5 + 28 >> 2]) << HEAP32[$5 + 20 >> 2];
     $0 = HEAP32[$5 + 76 >> 2];
     label$14 : {
      if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 2) {
       HEAP32[$5 + 56 >> 2] = HEAP32[$5 + 56 >> 2] + 1;
       break label$14;
      }
      HEAP32[$5 + 52 >> 2] = HEAP32[$5 + 40 >> 2] + HEAP32[$5 + 52 >> 2];
      if (HEAPU32[$5 + 52 >> 2] >= 8) {
       HEAP32[$5 + 56 >> 2] = HEAP32[$5 + 56 >> 2] + 1;
      }
     }
     break label$6;
    }
    $0 = HEAP32[$5 + 76 >> 2];
    label$17 : {
     if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 4) {
      HEAP32[$5 + 16 >> 2] = HEAPU8[HEAP32[$5 + 76 >> 2] + 16 | 0] - 8;
      while (1) {
       if (HEAP32[$5 + 16 >> 2] >= 0) {
        $0 = HEAP32[$5 + 60 >> 2] >>> HEAP32[$5 + 16 >> 2];
        $1 = HEAP32[$5 + 56 >> 2];
        HEAP32[$5 + 56 >> 2] = $1 + 1;
        HEAP8[$1 | 0] = $0;
        HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 16 >> 2] - 8;
        continue;
       }
       break;
      }
      break label$17;
     }
     HEAP32[$5 + 12 >> 2] = 0;
     while (1) {
      if (HEAP32[$5 + 12 >> 2] < HEAPU8[HEAP32[$5 + 76 >> 2] + 16 | 0]) {
       $0 = HEAP32[$5 + 60 >> 2] >>> HEAP32[$5 + 12 >> 2];
       $1 = HEAP32[$5 + 56 >> 2];
       HEAP32[$5 + 56 >> 2] = $1 + 1;
       HEAP8[$1 | 0] = $0;
       HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 12 >> 2] + 8;
       continue;
      }
      break;
     }
    }
   }
   continue;
  }
  break;
 }
 global$0 = $5 + 80 | 0;
}
function tflite__ParseDepthwiseConv2D_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0, $5 = 0, $6 = 0;
 $4 = global$0 + -64 | 0;
 global$0 = $4;
 $6 = $4 + 32 | 0;
 $5 = $4 + 40 | 0;
 HEAP32[$4 + 56 >> 2] = $0;
 HEAP32[$4 + 52 >> 2] = $1;
 HEAP32[$4 + 48 >> 2] = $2;
 HEAP32[$4 + 44 >> 2] = $3;
 tflite___28anonymous_20namespace_29__CheckParsePointerParams_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29(HEAP32[$4 + 56 >> 2], HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2], HEAP32[$4 + 44 >> 2]);
 tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__SafeBuiltinDataAllocator_28tflite__BuiltinDataAllocator__29($5, HEAP32[$4 + 48 >> 2]);
 std____2__unique_ptr_TfLiteDepthwiseConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__Allocate_TfLiteDepthwiseConvParams__28_29($6, $5);
 label$1 : {
  if (!(bool_20std____2__operator___TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20const__2c_20std__nullptr_t_29($4 + 32 | 0) & 1)) {
   $0 = HEAP32[$4 + 52 >> 2];
   $1 = HEAP32[$4 + 52 >> 2];
   HEAP32[$4 + 8 >> 2] = 136736;
   HEAP32[$4 + 4 >> 2] = 1051;
   HEAP32[$4 >> 2] = 136641;
   tflite__ErrorReporter__ReportError_28void__2c_20char_20const__2c_20____29($0, $1, 136618, $4);
   HEAP32[$4 + 60 >> 2] = 1;
   break label$1;
  }
  HEAP32[$4 + 16 >> 2] = tflite__Operator__builtin_options_as_DepthwiseConv2DOptions_28_29_20const(HEAP32[$4 + 56 >> 2]);
  if (HEAP32[$4 + 16 >> 2]) {
   $0 = tflite___28anonymous_20namespace_29__ConvertPadding_28tflite__Padding_29(tflite__OperatorCode__builtin_code_28_29_20const(HEAP32[$4 + 16 >> 2]));
   HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 32 | 0) >> 2] = $0;
   $0 = tflite__Metadata__buffer_28_29_20const(HEAP32[$4 + 16 >> 2]);
   HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 32 | 0) + 4 >> 2] = $0;
   $0 = tflite__Tensor__buffer_28_29_20const(HEAP32[$4 + 16 >> 2]);
   HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 32 | 0) + 8 >> 2] = $0;
   $0 = tflite__DepthwiseConv2DOptions__depth_multiplier_28_29_20const(HEAP32[$4 + 16 >> 2]);
   HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 32 | 0) + 12 >> 2] = $0;
   $0 = tflite___28anonymous_20namespace_29__ConvertActivation_28tflite__ActivationFunctionType_29(tflite__DepthwiseConv2DOptions__fused_activation_function_28_29_20const(HEAP32[$4 + 16 >> 2]));
   HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 32 | 0) + 16 >> 2] = $0;
   $0 = tflite__Conv2DOptions__dilation_h_factor_28_29_20const(HEAP32[$4 + 16 >> 2]);
   HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 32 | 0) + 20 >> 2] = $0;
   $0 = tflite__DepthwiseConv2DOptions__dilation_h_factor_28_29_20const(HEAP32[$4 + 16 >> 2]);
   HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 32 | 0) + 24 >> 2] = $0;
  }
  $0 = std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___release_28_29($4 + 32 | 0);
  HEAP32[HEAP32[$4 + 44 >> 2] >> 2] = $0;
  HEAP32[$4 + 60 >> 2] = 0;
 }
 HEAP32[$4 + 20 >> 2] = 1;
 std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter____unique_ptr_28_29($4 + 32 | 0);
 global$0 = $4 - -64 | 0;
 return HEAP32[$4 + 60 >> 2];
}
function jspeStatement() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 if (!(!(HEAP32[80549] & 8192) | HEAP16[HEAP32[35539] + 2 >> 1] == 59 | (HEAP32[80549] & 63) != 1)) {
  HEAP32[HEAP32[35539] + 8 >> 2] = HEAP32[HEAP32[35539] + 4 >> 2];
  jsiDebuggerLoop();
 }
 label$2 : {
  label$3 : {
   label$4 : {
    if (HEAP16[HEAP32[35539] + 2 >> 1] == 128 | HEAP16[HEAP32[35539] + 2 >> 1] == 129 | (HEAP16[HEAP32[35539] + 2 >> 1] == 130 | HEAP16[HEAP32[35539] + 2 >> 1] == 131)) {
     break label$4;
    }
    if (HEAP16[HEAP32[35539] + 2 >> 1] == 133 | HEAP16[HEAP32[35539] + 2 >> 1] == 135 | (HEAP16[HEAP32[35539] + 2 >> 1] == 184 | HEAP16[HEAP32[35539] + 2 >> 1] == 182)) {
     break label$4;
    }
    if (HEAP16[HEAP32[35539] + 2 >> 1] == 183 | HEAP16[HEAP32[35539] + 2 >> 1] == 180 | (HEAP16[HEAP32[35539] + 2 >> 1] == 181 | HEAP16[HEAP32[35539] + 2 >> 1] == 175)) {
     break label$4;
    }
    if (HEAP16[HEAP32[35539] + 2 >> 1] == 190 | HEAP16[HEAP32[35539] + 2 >> 1] == 191 | (HEAP16[HEAP32[35539] + 2 >> 1] == 192 | HEAP16[HEAP32[35539] + 2 >> 1] == 196)) {
     break label$4;
    }
    if (HEAP16[HEAP32[35539] + 2 >> 1] == 152 | HEAP16[HEAP32[35539] + 2 >> 1] == 153 | (HEAP16[HEAP32[35539] + 2 >> 1] == 33 | HEAP16[HEAP32[35539] + 2 >> 1] == 45)) {
     break label$4;
    }
    if (HEAP16[HEAP32[35539] + 2 >> 1] == 43 | HEAP16[HEAP32[35539] + 2 >> 1] == 126 | HEAP16[HEAP32[35539] + 2 >> 1] == 91) {
     break label$4;
    }
    if (HEAP16[HEAP32[35539] + 2 >> 1] != 40) {
     break label$3;
    }
   }
   HEAP32[$0 + 12 >> 2] = jspeExpression();
   break label$2;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 123) {
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$0 + 12 >> 2] = 0;
    break label$2;
   }
   jspeBlock();
   HEAP32[$0 + 12 >> 2] = 0;
   break label$2;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 59) {
   jslGetNextToken();
   HEAP32[$0 + 12 >> 2] = 0;
   break label$2;
  }
  if (!(HEAP16[HEAP32[35539] + 2 >> 1] != 174 ? !(HEAP16[HEAP32[35539] + 2 >> 1] == 172 | HEAP16[HEAP32[35539] + 2 >> 1] == 173) : 0)) {
   HEAP32[$0 + 12 >> 2] = jspeStatementVar();
   break label$2;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 163) {
   HEAP32[$0 + 12 >> 2] = jspeStatementIf();
   break label$2;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 165) {
   HEAP32[$0 + 12 >> 2] = jspeStatementDoOrWhile(0);
   break label$2;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 166) {
   HEAP32[$0 + 12 >> 2] = jspeStatementDoOrWhile(1);
   break label$2;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 167) {
   HEAP32[$0 + 12 >> 2] = jspeStatementFor();
   break label$2;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 177) {
   HEAP32[$0 + 12 >> 2] = jspeStatementTry();
   break label$2;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 171) {
   HEAP32[$0 + 12 >> 2] = jspeStatementReturn();
   break label$2;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 176) {
   HEAP32[$0 + 12 >> 2] = jspeStatementThrow();
   break label$2;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 170) {
   HEAP32[$0 + 12 >> 2] = jspeStatementFunctionDecl(0);
   break label$2;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 194) {
   HEAP32[$0 + 12 >> 2] = jspeStatementFunctionDecl(1);
   break label$2;
  }
  label$19 : {
   if (HEAP16[HEAP32[35539] + 2 >> 1] == 169) {
    jslGetNextToken();
    if ((HEAP32[80549] & 63) == 1) {
     label$22 : {
      if (!(HEAP32[80549] & 512)) {
       jsExceptionHere(2, 80779, 0);
       break label$22;
      }
      HEAP32[80549] = HEAP32[80549] & -64 | 4;
     }
    }
    break label$19;
   }
   label$24 : {
    if (HEAP16[HEAP32[35539] + 2 >> 1] == 168) {
     jslGetNextToken();
     if ((HEAP32[80549] & 63) == 1) {
      label$27 : {
       if (!(HEAP32[80549] & 1536)) {
        jsExceptionHere(2, 80827, 0);
        break label$27;
       }
       HEAP32[80549] = HEAP32[80549] & -64 | 2;
      }
     }
     break label$24;
    }
    if (HEAP16[HEAP32[35539] + 2 >> 1] == 187) {
     HEAP32[$0 + 12 >> 2] = jspeStatementSwitch();
     break label$2;
    }
    label$30 : {
     if (HEAP16[HEAP32[35539] + 2 >> 1] == 193) {
      jslGetNextToken();
      if ((HEAP32[80549] & 63) == 1) {
       jsiDebuggerLoop();
      }
      break label$30;
     }
     if (!(jslMatch(0) & 1)) {
      HEAP32[$0 + 12 >> 2] = 0;
      break label$2;
     }
    }
   }
  }
  HEAP32[$0 + 12 >> 2] = 0;
 }
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}
function jspeFunctionDefinitionInternal($0, $1) {
 var $2 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 $2 = global$0 - 96 | 0;
 global$0 = $2;
 HEAP32[$2 + 88 >> 2] = $0;
 HEAP8[$2 + 87 | 0] = $1;
 HEAP8[$2 + 86 | 0] = 0;
 label$1 : {
  label$2 : {
   if (HEAP8[$2 + 87 | 0] & 1) {
    if (HEAP32[$2 + 88 >> 2]) {
     $0 = HEAP32[$2 + 88 >> 2];
     $1 = HEAP32[$2 + 88 >> 2];
     $1 = (HEAPU8[$1 + 13 | 0] | HEAPU8[$1 + 14 | 0] << 8) & -64 | 8;
     HEAP8[$0 + 13 | 0] = $1;
     HEAP8[$0 + 14 | 0] = $1 >>> 8;
    }
    break label$2;
   }
   if (!(jslMatch(123) & 1)) {
    break label$1;
   }
   if (HEAP16[HEAP32[35539] + 2 >> 1] == 131) {
    if (!strcmp(jslGetTokenValueAsString(), 79620)) {
     jsWarn(79629);
    }
    label$7 : {
     if (HEAP16[HEAP32[35539] + 2 >> 1] != 131) {
      break label$7;
     }
     if (strcmp(jslGetTokenValueAsString(), 79685)) {
      break label$7;
     }
     jslGetNextToken();
     HEAP8[$2 + 86 | 0] = 1;
    }
   }
   if (!(!HEAP32[$2 + 88 >> 2] | HEAP16[HEAP32[35539] + 2 >> 1] != 171)) {
    $0 = HEAP32[$2 + 88 >> 2];
    $1 = HEAP32[$2 + 88 >> 2];
    $1 = (HEAPU8[$1 + 13 | 0] | HEAPU8[$1 + 14 | 0] << 8) & -64 | 8;
    HEAP8[$0 + 13 | 0] = $1;
    HEAP8[$0 + 14 | 0] = $1 >>> 8;
    jslGetNextToken();
   }
  }
  $0 = $2 + 40 | 0;
  jslSkipWhiteSpace();
  jslCharPosNew($0, HEAP32[HEAP32[35539] + 84 >> 2], HEAP32[HEAP32[35539] + 4 >> 2]);
  HEAP32[$2 + 36 >> 2] = -1;
  label$9 : {
   if (!(HEAP8[$2 + 87 | 0] & 1)) {
    HEAP32[$2 + 32 >> 2] = 0;
    while (1) {
     if ((HEAP16[HEAP32[35539] + 2 >> 1] ? HEAP32[$2 + 32 >> 2] ? 1 : HEAP16[HEAP32[35539] + 2 >> 1] != 125 : 0) & 1) {
      if (HEAP16[HEAP32[35539] + 2 >> 1] == 123) {
       HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 32 >> 2] + 1;
      }
      if (HEAP16[HEAP32[35539] + 2 >> 1] == 125) {
       HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 32 >> 2] + -1;
      }
      HEAP32[$2 + 36 >> 2] = jsvStringIteratorGetIndex(HEAP32[35539] + 88 | 0) - 1;
      jslGetNextToken();
      continue;
     }
     break;
    }
    break label$9;
   }
   HEAP32[$2 + 28 >> 2] = HEAP32[80549];
   HEAP32[80549] = 0;
   jsvUnLock(__jspeAssignmentExpression(jspeConditionalExpression()));
   HEAP32[80549] = HEAP32[$2 + 28 >> 2];
   HEAP32[$2 + 36 >> 2] = HEAP32[HEAP32[35539] + 4 >> 2];
  }
  if (!(!HEAP32[$2 + 88 >> 2] | HEAP32[$2 + 36 >> 2] <= 0)) {
   label$20 : {
    label$21 : {
     if (HEAP8[$2 + 86 | 0] & 1) {
      break label$21;
     }
     if (!(jsvIsNativeString(HEAP32[HEAP32[35539] + 84 >> 2]) & 1)) {
      break label$21;
     }
     HEAP32[$2 + 20 >> 2] = jsvStringIteratorGetIndex($2 + 40 | 0) - 1;
     $0 = HEAP32[HEAP32[35539] + 84 >> 2];
     HEAP32[$2 + 24 >> 2] = jsvNewNativeString(HEAP32[$2 + 20 >> 2] + (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) | 0, HEAP32[$2 + 36 >> 2] - HEAP32[$2 + 20 >> 2] | 0);
     break label$20;
    }
    label$22 : {
     label$23 : {
      if (HEAP8[$2 + 86 | 0] & 1) {
       break label$23;
      }
      if (!(jsvIsFlashString(HEAP32[HEAP32[35539] + 84 >> 2]) & 1)) {
       break label$23;
      }
      HEAP32[$2 + 16 >> 2] = jsvStringIteratorGetIndex($2 + 40 | 0) - 1;
      $0 = HEAP32[HEAP32[35539] + 84 >> 2];
      HEAP32[$2 + 24 >> 2] = jsvNewFlashString(HEAP32[$2 + 16 >> 2] + (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) | 0, HEAP32[$2 + 36 >> 2] - HEAP32[$2 + 16 >> 2] | 0);
      break label$22;
     }
     label$24 : {
      if (!(wasm2js_i32$0 = 0, wasm2js_i32$1 = !(jsfGetFlag(2) & 1), wasm2js_i32$2 = HEAP8[$2 + 86 | 0] & 1, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1)) {
       HEAP32[$2 + 24 >> 2] = jslNewTokenisedStringFromLexer($2 + 40 | 0, HEAP32[$2 + 36 >> 2]);
       break label$24;
      }
      HEAP32[$2 + 24 >> 2] = jslNewStringFromLexer($2 + 40 | 0, HEAP32[$2 + 36 >> 2]);
     }
    }
   }
   jsvUnLock2(jsvAddNamedChild(HEAP32[$2 + 88 >> 2], HEAP32[$2 + 24 >> 2], 79689), HEAP32[$2 + 24 >> 2]);
   HEAP32[$2 + 12 >> 2] = jspeiGetScopesAsVar();
   if (HEAP32[$2 + 12 >> 2]) {
    jsvUnLock2(jsvAddNamedChild(HEAP32[$2 + 88 >> 2], HEAP32[$2 + 12 >> 2], 79694), HEAP32[$2 + 12 >> 2]);
   }
  }
  jslCharPosFree($2 + 40 | 0);
  if (!(HEAP8[$2 + 87 | 0] & 1)) {
   jslMatch(125);
  }
 }
 HEAP8[$2 + 95 | 0] = 0;
 global$0 = $2 + 96 | 0;
}
function jswrap_espruino_mapInPlace($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 176 | 0;
 global$0 = $4;
 HEAP32[$4 + 172 >> 2] = $0;
 HEAP32[$4 + 168 >> 2] = $1;
 HEAP32[$4 + 164 >> 2] = $2;
 HEAP32[$4 + 160 >> 2] = $3;
 label$1 : {
  label$2 : {
   if (jsvIsArrayBuffer(HEAP32[$4 + 172 >> 2]) & 1) {
    if (jsvIsArrayBuffer(HEAP32[$4 + 168 >> 2]) & 1) {
     break label$2;
    }
   }
   jsExceptionHere(1, 120580, 0);
   break label$1;
  }
  label$4 : {
   if (!HEAP32[$4 + 164 >> 2]) {
    break label$4;
   }
   if (jsvIsArray(HEAP32[$4 + 164 >> 2]) & 1) {
    break label$4;
   }
   if (jsvIsArrayBuffer(HEAP32[$4 + 164 >> 2]) & 1) {
    break label$4;
   }
   if (jsvIsFunction(HEAP32[$4 + 164 >> 2]) & 1) {
    break label$4;
   }
   jsExceptionHere(1, 120622, 0);
   break label$1;
  }
  HEAP8[$4 + 159 | 0] = jsvIsFunction(HEAP32[$4 + 164 >> 2]) & 1;
  $0 = HEAP32[$4 + 172 >> 2];
  HEAP32[$4 + 152 >> 2] = ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8) & 15) << 3;
  HEAP8[$4 + 151 | 0] = 1;
  if (HEAP32[$4 + 160 >> 2] < 0) {
   HEAP32[$4 + 160 >> 2] = 0 - HEAP32[$4 + 160 >> 2];
   HEAP8[$4 + 151 | 0] = 0;
  }
  if (!HEAP32[$4 + 160 >> 2]) {
   HEAP32[$4 + 160 >> 2] = HEAP32[$4 + 152 >> 2];
  }
  $0 = $4 + 32 | 0;
  jsvArrayBufferIteratorNew($4 + 88 | 0, HEAP32[$4 + 172 >> 2], 0);
  HEAP32[$4 + 28 >> 2] = 0;
  HEAP32[$4 + 24 >> 2] = 0;
  jsvArrayBufferIteratorNew($0, HEAP32[$4 + 168 >> 2], 0);
  while (1) {
   label$8 : {
    if (!(jsvArrayBufferIteratorHasElement($4 + 88 | 0) & 1)) {
     $0 = 0;
     if (HEAP32[$4 + 24 >> 2] < HEAP32[$4 + 160 >> 2]) {
      break label$8;
     }
    }
    $0 = jsvArrayBufferIteratorHasElement($4 + 32 | 0);
   }
   if ($0 & 1) {
    $0 = $4;
    label$11 : {
     if (HEAP8[$4 + 159 | 0] & 1) {
      $1 = jsvArrayBufferIteratorGetIndex($4 + 88 | 0);
      break label$11;
     }
     $1 = 0;
    }
    HEAP32[$0 + 20 >> 2] = $1;
    while (1) {
     if (HEAP32[$4 + 24 >> 2] < HEAP32[$4 + 160 >> 2]) {
      label$15 : {
       if (HEAP8[$4 + 151 | 0] & 1) {
        HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 28 >> 2] << HEAP32[$4 + 152 >> 2] | jsvArrayBufferIteratorGetIntegerValue($4 + 88 | 0);
        break label$15;
       }
       HEAP32[$4 + 28 >> 2] = jsvArrayBufferIteratorGetIntegerValue($4 + 88 | 0) << HEAP32[$4 + 24 >> 2] | HEAP32[$4 + 28 >> 2];
      }
      jsvArrayBufferIteratorNext($4 + 88 | 0);
      HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 152 >> 2] + HEAP32[$4 + 24 >> 2];
      continue;
     }
     break;
    }
    label$17 : {
     if (HEAP8[$4 + 151 | 0] & 1) {
      HEAP32[$4 + 16 >> 2] = (1 << HEAP32[$4 + 160 >> 2]) - 1 & HEAP32[$4 + 28 >> 2] >> HEAP32[$4 + 24 >> 2] - HEAP32[$4 + 160 >> 2];
      break label$17;
     }
     HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 28 >> 2] & (1 << HEAP32[$4 + 160 >> 2]) - 1;
     HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 28 >> 2] >> HEAP32[$4 + 160 >> 2];
    }
    HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 24 >> 2] - HEAP32[$4 + 160 >> 2];
    label$19 : {
     if (HEAP32[$4 + 164 >> 2]) {
      HEAP32[$4 + 12 >> 2] = 0;
      label$21 : {
       if (HEAP8[$4 + 159 | 0] & 1) {
        $0 = $4 + 4 | 0;
        HEAP32[$4 + 4 >> 2] = jsvNewFromInteger(HEAP32[$4 + 16 >> 2]);
        HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 20 >> 2];
        HEAP32[$4 + 12 >> 2] = jspeFunctionCall(HEAP32[$4 + 164 >> 2], 0, 0, 0, 2, $0);
        jsvUnLock(HEAP32[$4 + 4 >> 2]);
        break label$21;
       }
       label$23 : {
        if (jsvIsArray(HEAP32[$4 + 164 >> 2]) & 1) {
         HEAP32[$4 + 12 >> 2] = jsvGetArrayItem(HEAP32[$4 + 164 >> 2], HEAP32[$4 + 16 >> 2]);
         break label$23;
        }
        HEAP32[$4 + 12 >> 2] = jsvArrayBufferGet(HEAP32[$4 + 164 >> 2], HEAP32[$4 + 16 >> 2]);
       }
      }
      jsvArrayBufferIteratorSetValue($4 + 32 | 0, HEAP32[$4 + 12 >> 2]);
      jsvUnLock(HEAP32[$4 + 12 >> 2]);
      break label$19;
     }
     jsvArrayBufferIteratorSetIntegerValue($4 + 32 | 0, HEAP32[$4 + 16 >> 2]);
    }
    $0 = $4 + 32 | 0;
    jsvUnLock(HEAP32[$4 + 20 >> 2]);
    jsvArrayBufferIteratorNext($0);
    continue;
   }
   break;
  }
  $0 = $4 + 32 | 0;
  jsvArrayBufferIteratorFree($4 + 88 | 0);
  jsvArrayBufferIteratorFree($0);
 }
 global$0 = $4 + 176 | 0;
}
function jswIsBuiltInObject($0) {
 var $1 = 0, $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93665);
 $1 = 1;
 label$1 : {
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93672);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93674);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93683);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93687);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93697);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93703);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93715);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93731);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93742);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93760);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93770);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93782);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93793);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93805);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93817);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93828);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93841);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93854);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93863);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93868);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93874);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93886);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93896);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93910);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93925);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93934);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93942);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93947);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93955);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93959);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93966);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93973);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93981);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93989);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 93992);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 94e3);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 94008);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 94015);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 94022);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 94034);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 94038);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 94042);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 94049);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = !strcmp(HEAP32[$2 + 12 >> 2], 94058);
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $1 = !strcmp(HEAP32[$2 + 12 >> 2], 94063);
 }
 $0 = $1;
 global$0 = $2 + 16 | 0;
 return $0 & 1;
}
function tflite__MicroInterpreter__AllocateTensors_28_29($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = global$0 + -64 | 0;
 global$0 = $1;
 HEAP32[$1 + 56 >> 2] = $0;
 $0 = HEAP32[$1 + 56 >> 2];
 label$1 : {
  if (tflite__MicroAllocator__StartModelAllocation_28tflite__Model_20const__2c_20tflite__MicroOpResolver_20const__2c_20tflite__NodeAndRegistration___2c_20TfLiteEvalTensor___29(HEAP32[$0 + 104 >> 2], HEAP32[$0 + 4 >> 2], HEAP32[$0 + 8 >> 2], $0, $0 + 120 | 0)) {
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$0 + 12 >> 2], 129153, 0);
   HEAP32[$0 + 112 >> 2] = 1;
   HEAP32[$1 + 60 >> 2] = 1;
   break label$1;
  }
  $3 = HEAP32[$0 + 120 >> 2];
  $2 = global$0 - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0 + 124;
  HEAP32[$2 + 8 >> 2] = $3;
  HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2] = HEAP32[$2 + 8 >> 2];
  HEAP32[$0 + 72 >> 2] = 608;
  HEAP32[$0 + 80 >> 2] = 0;
  HEAP32[$0 + 84 >> 2] = 0;
  HEAP32[$1 + 52 >> 2] = 0;
  while (1) {
   if (HEAPU32[$1 + 52 >> 2] < flatbuffers__Vector_int___size_28_29_20const(tflite__SubGraph__operators_28_29_20const(HEAP32[$0 + 116 >> 2])) >>> 0) {
    tflite__internal__ContextHelper__SetNodeIndex_28int_29($0 + 124 | 0, HEAP32[$1 + 52 >> 2]);
    HEAP32[$1 + 48 >> 2] = HEAP32[$0 >> 2] + Math_imul(HEAP32[$1 + 52 >> 2], 28);
    HEAP32[$1 + 44 >> 2] = HEAP32[(HEAP32[$0 >> 2] + Math_imul(HEAP32[$1 + 52 >> 2], 28) | 0) + 24 >> 2];
    label$5 : {
     if (HEAP32[HEAP32[$1 + 44 >> 2] + 20 >> 2] == 32) {
      HEAP32[$1 + 36 >> 2] = HEAP32[HEAP32[$1 + 48 >> 2] + 16 >> 2];
      HEAP32[$1 + 40 >> 2] = HEAP32[HEAP32[$1 + 48 >> 2] + 20 >> 2];
      break label$5;
     }
     HEAP32[$1 + 36 >> 2] = HEAP32[HEAP32[$1 + 48 >> 2] + 12 >> 2];
     HEAP32[$1 + 40 >> 2] = 0;
    }
    if (HEAP32[HEAP32[$1 + 44 >> 2] >> 2]) {
     $2 = FUNCTION_TABLE[HEAP32[HEAP32[$1 + 44 >> 2] >> 2]]($0 + 16 | 0, HEAP32[$1 + 36 >> 2], HEAP32[$1 + 40 >> 2]) | 0;
     HEAP32[HEAP32[$1 + 48 >> 2] + 8 >> 2] = $2;
    }
    HEAP32[$1 + 52 >> 2] = HEAP32[$1 + 52 >> 2] + 1;
    continue;
   }
   break;
  }
  tflite__internal__ContextHelper__SetNodeIndex_28int_29($0 + 124 | 0, -1);
  HEAP32[$0 + 80 >> 2] = 609;
  HEAP32[$1 + 32 >> 2] = 0;
  while (1) {
   if (HEAPU32[$1 + 32 >> 2] < flatbuffers__Vector_int___size_28_29_20const(tflite__SubGraph__operators_28_29_20const(HEAP32[$0 + 116 >> 2])) >>> 0) {
    tflite__internal__ContextHelper__SetNodeIndex_28int_29($0 + 124 | 0, HEAP32[$1 + 32 >> 2]);
    HEAP32[$1 + 28 >> 2] = HEAP32[$0 >> 2] + Math_imul(HEAP32[$1 + 32 >> 2], 28);
    HEAP32[$1 + 24 >> 2] = HEAP32[(HEAP32[$0 >> 2] + Math_imul(HEAP32[$1 + 32 >> 2], 28) | 0) + 24 >> 2];
    if (HEAP32[HEAP32[$1 + 24 >> 2] + 8 >> 2]) {
     HEAP32[$1 + 20 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$1 + 24 >> 2] + 8 >> 2]]($0 + 16 | 0, HEAP32[$1 + 28 >> 2]);
     if (HEAP32[$1 + 20 >> 2]) {
      $0 = HEAP32[$0 + 12 >> 2];
      $2 = tflite___28anonymous_20namespace_29__OpNameFromRegistration_28TfLiteRegistration_20const__29(HEAP32[$1 + 24 >> 2]);
      $3 = HEAP32[$1 + 32 >> 2];
      HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 20 >> 2];
      HEAP32[$1 + 4 >> 2] = $3;
      HEAP32[$1 >> 2] = $2;
      tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 129188, $1);
      HEAP32[$1 + 60 >> 2] = 1;
      break label$1;
     }
    }
    $2 = HEAP32[$0 + 104 >> 2];
    FUNCTION_TABLE[HEAP32[HEAP32[$2 >> 2] + 8 >> 2]]($2);
    HEAP32[$1 + 32 >> 2] = HEAP32[$1 + 32 >> 2] + 1;
    continue;
   }
   break;
  }
  tflite__internal__ContextHelper__SetNodeIndex_28int_29($0 + 124 | 0, -1);
  HEAP32[$0 + 72 >> 2] = 0;
  HEAP32[$0 + 80 >> 2] = 0;
  HEAP32[$0 + 84 >> 2] = 610;
  HEAP32[$1 + 16 >> 2] = tflite__MicroAllocator__FinishModelAllocation_28tflite__Model_20const__2c_20TfLiteEvalTensor__29(HEAP32[$0 + 104 >> 2], HEAP32[$0 + 4 >> 2], HEAP32[$0 + 120 >> 2]);
  if (HEAP32[$1 + 16 >> 2]) {
   HEAP32[$1 + 60 >> 2] = HEAP32[$1 + 16 >> 2];
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = tflite__MicroInterpreter__ResetVariableTensors_28_29($0);
  if (HEAP32[$1 + 12 >> 2]) {
   HEAP32[$1 + 60 >> 2] = HEAP32[$1 + 12 >> 2];
   break label$1;
  }
  HEAP8[$0 + 108 | 0] = 1;
  HEAP32[$1 + 60 >> 2] = 0;
 }
 global$0 = $1 - -64 | 0;
 return HEAP32[$1 + 60 >> 2];
}
function _jswrap_array_iterate_with_callback($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0;
 $7 = global$0 - 176 | 0;
 global$0 = $7;
 HEAP32[$7 + 168 >> 2] = $0;
 HEAP32[$7 + 164 >> 2] = $1;
 HEAP32[$7 + 160 >> 2] = $2;
 HEAP32[$7 + 156 >> 2] = $3;
 HEAP32[$7 + 152 >> 2] = $4;
 HEAP8[$7 + 151 | 0] = $5;
 HEAP8[$7 + 150 | 0] = $6;
 label$1 : {
  if (!(jsvIsIterable(HEAP32[$7 + 164 >> 2]) & 1)) {
   HEAP32[$7 + 32 >> 2] = HEAP32[$7 + 168 >> 2];
   jsExceptionHere(1, 118875, $7 + 32 | 0);
   HEAP32[$7 + 172 >> 2] = 0;
   break label$1;
  }
  if (!(jsvIsFunction(HEAP32[$7 + 160 >> 2]) & 1)) {
   HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 168 >> 2];
   jsExceptionHere(1, 118925, $7 + 16 | 0);
   HEAP32[$7 + 172 >> 2] = 0;
   break label$1;
  }
  label$4 : {
   if (jsvIsUndefined(HEAP32[$7 + 156 >> 2]) & 1) {
    break label$4;
   }
   if (jsvIsObject(HEAP32[$7 + 156 >> 2]) & 1) {
    break label$4;
   }
   HEAP32[$7 >> 2] = HEAP32[$7 + 168 >> 2];
   jsExceptionHere(1, 119063, $7);
   HEAP32[$7 + 172 >> 2] = 0;
   break label$1;
  }
  HEAP32[$7 + 144 >> 2] = 0;
  if (HEAP32[$7 + 152 >> 2] == 1) {
   HEAP32[$7 + 144 >> 2] = jsvNewWithFlags(3);
  }
  HEAP8[$7 + 143 | 0] = 0;
  if (!(HEAP32[$7 + 152 >> 2] == 1 ? !HEAP32[$7 + 144 >> 2] : 0)) {
   jsvIteratorNew($7 + 80 | 0, HEAP32[$7 + 164 >> 2], 0);
   while (1) {
    if (jsvIteratorHasElement($7 + 80 | 0) & 1) {
     $0 = HEAPU8[$7 + 143 | 0] ^ -1;
    } else {
     $0 = 0;
    }
    if ($0 & 1) {
     HEAP32[$7 + 76 >> 2] = jsvIteratorGetKey($7 + 80 | 0);
     label$12 : {
      if (jsvIsInt(HEAP32[$7 + 76 >> 2]) & 1) {
       $1 = $7 + 56 | 0;
       $0 = $7 + 80 | 0;
       HEAP32[$7 + 72 >> 2] = jsvGetInteger(HEAP32[$7 + 76 >> 2]);
       HEAP32[$7 + 68 >> 2] = jsvIteratorGetValue($0);
       HEAP32[$7 + 56 >> 2] = HEAP32[$7 + 68 >> 2];
       HEAP32[$7 + 60 >> 2] = jsvNewFromInteger(HEAP32[$7 + 72 >> 2]);
       HEAP32[$7 + 64 >> 2] = HEAP32[$7 + 164 >> 2];
       jsvIteratorNext($0);
       HEAP32[$7 + 52 >> 2] = jspeFunctionCall(HEAP32[$7 + 160 >> 2], 0, HEAP32[$7 + 156 >> 2], 0, 3, $1);
       jsvUnLock(HEAP32[$7 + 60 >> 2]);
       if (HEAP32[$7 + 52 >> 2]) {
        if (HEAP8[$7 + 151 | 0] & 1) {
         HEAP8[$7 + 51 | 0] = (jsvGetBool(HEAP32[$7 + 52 >> 2]) & 1) == (HEAP8[$7 + 150 | 0] & 1);
        }
        label$16 : {
         if (HEAP32[$7 + 152 >> 2] == 1) {
          if (HEAP8[$7 + 151 | 0] & 1) {
           if (HEAP8[$7 + 51 | 0] & 1) {
            jsvArrayPush(HEAP32[$7 + 144 >> 2], HEAP32[$7 + 68 >> 2]);
           }
           break label$16;
          }
          HEAP32[$7 + 44 >> 2] = jsvNewFromInteger(HEAP32[$7 + 72 >> 2]);
          if (HEAP32[$7 + 44 >> 2]) {
           jsvMakeIntoVariableName(HEAP32[$7 + 44 >> 2], HEAP32[$7 + 52 >> 2]);
           jsvAddName(HEAP32[$7 + 144 >> 2], HEAP32[$7 + 44 >> 2]);
           jsvUnLock(HEAP32[$7 + 44 >> 2]);
          }
          break label$16;
         }
         if (HEAP8[$7 + 151 | 0] & 1) {
          label$22 : {
           if (!(HEAP32[$7 + 152 >> 2] != 3 ? HEAP32[$7 + 152 >> 2] != 2 : 0)) {
            if (HEAP8[$7 + 51 | 0] & 1) {
             $0 = $7;
             label$26 : {
              if (HEAP32[$7 + 152 >> 2] == 2) {
               $1 = jsvLockAgain(HEAP32[$7 + 68 >> 2]);
               break label$26;
              }
              $1 = jsvNewFromInteger(jsvGetInteger(HEAP32[$7 + 76 >> 2]));
             }
             HEAP32[$0 + 144 >> 2] = $1;
             HEAP8[$7 + 143 | 0] = 1;
            }
            break label$22;
           }
           if (!(HEAP8[$7 + 51 | 0] & 1)) {
            HEAP8[$7 + 143 | 0] = 1;
           }
          }
         }
        }
        jsvUnLock(HEAP32[$7 + 52 >> 2]);
       }
       jsvUnLock(HEAP32[$7 + 68 >> 2]);
       break label$12;
      }
      jsvIteratorNext($7 + 80 | 0);
     }
     jsvUnLock(HEAP32[$7 + 76 >> 2]);
     continue;
    }
    break;
   }
   jsvIteratorFree($7 + 80 | 0);
  }
  if (!(HEAP32[$7 + 152 >> 2] | !(HEAP8[$7 + 151 | 0] & 1))) {
   HEAP32[$7 + 144 >> 2] = jsvNewFromBool((HEAP8[$7 + 143 | 0] & 1) != (HEAP8[$7 + 150 | 0] & 1));
  }
  HEAP32[$7 + 172 >> 2] = HEAP32[$7 + 144 >> 2];
 }
 global$0 = $7 + 176 | 0;
 return HEAP32[$7 + 172 >> 2];
}
function tflite__ParsePool_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0, $5 = 0, $6 = 0;
 $4 = global$0 + -64 | 0;
 global$0 = $4;
 $6 = $4 + 32 | 0;
 $5 = $4 + 40 | 0;
 HEAP32[$4 + 56 >> 2] = $0;
 HEAP32[$4 + 52 >> 2] = $1;
 HEAP32[$4 + 48 >> 2] = $2;
 HEAP32[$4 + 44 >> 2] = $3;
 tflite___28anonymous_20namespace_29__CheckParsePointerParams_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29(HEAP32[$4 + 56 >> 2], HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2], HEAP32[$4 + 44 >> 2]);
 tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__SafeBuiltinDataAllocator_28tflite__BuiltinDataAllocator__29($5, HEAP32[$4 + 48 >> 2]);
 std____2__unique_ptr_TfLitePoolParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__Allocate_TfLitePoolParams__28_29($6, $5);
 label$1 : {
  if (!(bool_20std____2__operator___TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20const__2c_20std__nullptr_t_29($4 + 32 | 0) & 1)) {
   $0 = HEAP32[$4 + 52 >> 2];
   $1 = HEAP32[$4 + 52 >> 2];
   HEAP32[$4 + 8 >> 2] = 136736;
   HEAP32[$4 + 4 >> 2] = 1358;
   HEAP32[$4 >> 2] = 136641;
   tflite__ErrorReporter__ReportError_28void__2c_20char_20const__2c_20____29($0, $1, 136618, $4);
   HEAP32[$4 + 60 >> 2] = 1;
   break label$1;
  }
  HEAP32[$4 + 16 >> 2] = tflite__Operator__builtin_options_as_Pool2DOptions_28_29_20const(HEAP32[$4 + 56 >> 2]);
  if (HEAP32[$4 + 16 >> 2]) {
   $0 = tflite___28anonymous_20namespace_29__ConvertPadding_28tflite__Padding_29(tflite__OperatorCode__builtin_code_28_29_20const(HEAP32[$4 + 16 >> 2]));
   HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 32 | 0) >> 2] = $0;
   $0 = tflite__Metadata__buffer_28_29_20const(HEAP32[$4 + 16 >> 2]);
   HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 32 | 0) + 4 >> 2] = $0;
   $0 = tflite__Tensor__buffer_28_29_20const(HEAP32[$4 + 16 >> 2]);
   HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 32 | 0) + 8 >> 2] = $0;
   $0 = tflite__DepthwiseConv2DOptions__depth_multiplier_28_29_20const(HEAP32[$4 + 16 >> 2]);
   HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 32 | 0) + 12 >> 2] = $0;
   $0 = tflite__Pool2DOptions__filter_height_28_29_20const(HEAP32[$4 + 16 >> 2]);
   HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 32 | 0) + 16 >> 2] = $0;
   $0 = tflite___28anonymous_20namespace_29__ConvertActivation_28tflite__ActivationFunctionType_29(tflite__Pool2DOptions__fused_activation_function_28_29_20const(HEAP32[$4 + 16 >> 2]));
   HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 32 | 0) + 20 >> 2] = $0;
  }
  $0 = std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___release_28_29($4 + 32 | 0);
  HEAP32[HEAP32[$4 + 44 >> 2] >> 2] = $0;
  HEAP32[$4 + 60 >> 2] = 0;
 }
 HEAP32[$4 + 20 >> 2] = 1;
 std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter____unique_ptr_28_29($4 + 32 | 0);
 global$0 = $4 - -64 | 0;
 return HEAP32[$4 + 60 >> 2];
}
function tflite__ParseConv2D_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0, $5 = 0, $6 = 0;
 $4 = global$0 + -64 | 0;
 global$0 = $4;
 $6 = $4 + 32 | 0;
 $5 = $4 + 40 | 0;
 HEAP32[$4 + 56 >> 2] = $0;
 HEAP32[$4 + 52 >> 2] = $1;
 HEAP32[$4 + 48 >> 2] = $2;
 HEAP32[$4 + 44 >> 2] = $3;
 tflite___28anonymous_20namespace_29__CheckParsePointerParams_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29(HEAP32[$4 + 56 >> 2], HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2], HEAP32[$4 + 44 >> 2]);
 tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__SafeBuiltinDataAllocator_28tflite__BuiltinDataAllocator__29($5, HEAP32[$4 + 48 >> 2]);
 std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__Allocate_TfLiteConvParams__28_29($6, $5);
 label$1 : {
  if (!(bool_20std____2__operator___TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20const__2c_20std__nullptr_t_29($4 + 32 | 0) & 1)) {
   $0 = HEAP32[$4 + 52 >> 2];
   $1 = HEAP32[$4 + 52 >> 2];
   HEAP32[$4 + 8 >> 2] = 136736;
   HEAP32[$4 + 4 >> 2] = 1009;
   HEAP32[$4 >> 2] = 136641;
   tflite__ErrorReporter__ReportError_28void__2c_20char_20const__2c_20____29($0, $1, 136618, $4);
   HEAP32[$4 + 60 >> 2] = 1;
   break label$1;
  }
  HEAP32[$4 + 16 >> 2] = tflite__Operator__builtin_options_as_Conv2DOptions_28_29_20const(HEAP32[$4 + 56 >> 2]);
  if (HEAP32[$4 + 16 >> 2]) {
   $0 = tflite___28anonymous_20namespace_29__ConvertPadding_28tflite__Padding_29(tflite__OperatorCode__builtin_code_28_29_20const(HEAP32[$4 + 16 >> 2]));
   HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 32 | 0) >> 2] = $0;
   $0 = tflite__Metadata__buffer_28_29_20const(HEAP32[$4 + 16 >> 2]);
   HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 32 | 0) + 4 >> 2] = $0;
   $0 = tflite__Tensor__buffer_28_29_20const(HEAP32[$4 + 16 >> 2]);
   HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 32 | 0) + 8 >> 2] = $0;
   $0 = tflite___28anonymous_20namespace_29__ConvertActivation_28tflite__ActivationFunctionType_29(tflite__Conv2DOptions__fused_activation_function_28_29_20const(HEAP32[$4 + 16 >> 2]));
   HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 32 | 0) + 12 >> 2] = $0;
   $0 = tflite__Conv2DOptions__dilation_w_factor_28_29_20const(HEAP32[$4 + 16 >> 2]);
   HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 32 | 0) + 16 >> 2] = $0;
   $0 = tflite__Conv2DOptions__dilation_h_factor_28_29_20const(HEAP32[$4 + 16 >> 2]);
   HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 32 | 0) + 20 >> 2] = $0;
  }
  $0 = std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___release_28_29($4 + 32 | 0);
  HEAP32[HEAP32[$4 + 44 >> 2] >> 2] = $0;
  HEAP32[$4 + 60 >> 2] = 0;
 }
 HEAP32[$4 + 20 >> 2] = 1;
 std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter____unique_ptr_28_29($4 + 32 | 0);
 global$0 = $4 - -64 | 0;
 return HEAP32[$4 + 60 >> 2];
}
function tflite__reference_ops__FullyConnected_28tflite__FullyConnectedParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0;
 $9 = global$0 - 112 | 0;
 global$0 = $9;
 HEAP32[$9 + 108 >> 2] = $0;
 HEAP32[$9 + 104 >> 2] = $1;
 HEAP32[$9 + 100 >> 2] = $2;
 HEAP32[$9 + 96 >> 2] = $3;
 HEAP32[$9 + 92 >> 2] = $4;
 HEAP32[$9 + 88 >> 2] = $5;
 HEAP32[$9 + 84 >> 2] = $6;
 HEAP32[$9 + 80 >> 2] = $7;
 HEAP32[$9 + 76 >> 2] = $8;
 HEAP32[$9 + 72 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] >> 2];
 HEAP32[$9 + 68 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 4 >> 2];
 HEAP32[$9 + 64 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 8 >> 2];
 HEAP32[$9 + 60 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 12 >> 2];
 HEAP32[$9 + 56 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 16 >> 2];
 HEAP32[$9 + 52 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 20 >> 2];
 HEAP32[$9 + 48 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 24 >> 2];
 label$1 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 96 >> 2]) | 0) < 2) {
   break label$1;
  }
 }
 label$2 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 80 >> 2]) | 0) < 1) {
   break label$2;
  }
 }
 label$3 : {
  if (HEAP32[$9 + 52 >> 2] > HEAP32[$9 + 48 >> 2]) {
   break label$3;
  }
 }
 HEAP32[$9 + 44 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 80 >> 2]);
 HEAP32[$9 + 40 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 96 >> 2]);
 HEAP32[$9 + 36 >> 2] = tflite__FlatSizeSkipDim_28tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$9 + 80 >> 2], HEAP32[$9 + 44 >> 2] - 1 | 0);
 HEAP32[$9 + 32 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$9 + 96 >> 2], HEAP32[$9 + 40 >> 2] - 2 | 0, HEAP32[$9 + 80 >> 2], HEAP32[$9 + 44 >> 2] - 1 | 0);
 HEAP32[$9 + 28 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 96 >> 2], HEAP32[$9 + 40 >> 2] - 1 | 0);
 HEAP32[$9 + 24 >> 2] = 0;
 while (1) {
  if (HEAP32[$9 + 24 >> 2] < HEAP32[$9 + 36 >> 2]) {
   HEAP32[$9 + 20 >> 2] = 0;
   while (1) {
    if (HEAP32[$9 + 20 >> 2] < HEAP32[$9 + 32 >> 2]) {
     HEAP32[$9 + 16 >> 2] = 0;
     HEAP32[$9 + 12 >> 2] = 0;
     while (1) {
      if (HEAP32[$9 + 12 >> 2] < HEAP32[$9 + 28 >> 2]) {
       HEAP32[$9 + 8 >> 2] = HEAPU8[HEAP32[$9 + 100 >> 2] + (HEAP32[$9 + 12 >> 2] + Math_imul(HEAP32[$9 + 24 >> 2], HEAP32[$9 + 28 >> 2]) | 0) | 0];
       HEAP32[$9 + 4 >> 2] = HEAPU8[HEAP32[$9 + 92 >> 2] + (HEAP32[$9 + 12 >> 2] + Math_imul(HEAP32[$9 + 20 >> 2], HEAP32[$9 + 28 >> 2]) | 0) | 0];
       HEAP32[$9 + 16 >> 2] = HEAP32[$9 + 16 >> 2] + Math_imul(HEAP32[$9 + 4 >> 2] + HEAP32[$9 + 68 >> 2] | 0, HEAP32[$9 + 8 >> 2] + HEAP32[$9 + 72 >> 2] | 0);
       HEAP32[$9 + 12 >> 2] = HEAP32[$9 + 12 >> 2] + 1;
       continue;
      }
      break;
     }
     if (HEAP32[$9 + 84 >> 2]) {
      HEAP32[$9 + 16 >> 2] = HEAP32[HEAP32[$9 + 84 >> 2] + (HEAP32[$9 + 20 >> 2] << 2) >> 2] + HEAP32[$9 + 16 >> 2];
     }
     $0 = $9 + 16 | 0;
     $1 = $9 + 48 | 0;
     $2 = $9 + 52 | 0;
     HEAP32[$9 + 16 >> 2] = tflite__MultiplyByQuantizedMultiplier_28int_2c_20int_2c_20int_29(HEAP32[$9 + 16 >> 2], HEAP32[$9 + 60 >> 2], HEAP32[$9 + 56 >> 2]);
     HEAP32[$9 + 16 >> 2] = HEAP32[$9 + 64 >> 2] + HEAP32[$9 + 16 >> 2];
     HEAP32[$9 + 16 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($0, $2) >> 2];
     HEAP32[$9 + 16 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($0, $1) >> 2];
     HEAP8[HEAP32[$9 + 76 >> 2] + (HEAP32[$9 + 20 >> 2] + Math_imul(HEAP32[$9 + 32 >> 2], HEAP32[$9 + 24 >> 2]) | 0) | 0] = HEAP32[$9 + 16 >> 2];
     HEAP32[$9 + 20 >> 2] = HEAP32[$9 + 20 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$9 + 24 >> 2] = HEAP32[$9 + 24 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $9 + 112 | 0;
}
function jswrap_onewire_search($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 96 | 0;
 global$0 = $2;
 HEAP32[$2 + 88 >> 2] = $0;
 HEAP32[$2 + 84 >> 2] = $1;
 HEAP8[$2 + 83 | 0] = onewire_getpin(HEAP32[$2 + 88 >> 2]);
 label$1 : {
  if (!(jshIsPinValid(HEAPU8[$2 + 83 | 0]) & 1)) {
   HEAP32[$2 + 92 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 76 >> 2] = jsvNewWithFlags(3);
  if (!HEAP32[$2 + 76 >> 2]) {
   HEAP32[$2 + 92 >> 2] = 0;
   break label$1;
  }
  if (!(HEAP32[$2 + 84 >> 2] <= 255 ? HEAP32[$2 + 84 >> 2] > 0 : 0)) {
   HEAP32[$2 + 84 >> 2] = 240;
  }
  HEAP32[$2 + 64 >> 2] = 0;
  HEAP32[$2 + 56 >> 2] = 0;
  HEAP32[$2 + 60 >> 2] = 0;
  HEAP32[$2 + 52 >> 2] = 1;
  while (1) {
   if (HEAP32[$2 + 52 >> 2]) {
    HEAP32[$2 + 48 >> 2] = 1;
    HEAP32[$2 + 44 >> 2] = 0;
    HEAP32[$2 + 40 >> 2] = 0;
    HEAP8[$2 + 37 | 0] = 1;
    HEAP32[$2 + 52 >> 2] = 0;
    if (!HEAP32[$2 + 56 >> 2]) {
     if (!(OneWireReset(HEAPU8[$2 + 83 | 0]) & 1)) {
      HEAP32[$2 + 64 >> 2] = 0;
      HEAP32[$2 + 56 >> 2] = 0;
      HEAP32[$2 + 60 >> 2] = 0;
      HEAP32[$2 + 92 >> 2] = HEAP32[$2 + 76 >> 2];
      break label$1;
     }
     $0 = HEAP32[$2 + 84 >> 2];
     OneWireWrite(HEAPU8[$2 + 83 | 0], 8, $0, $0 >> 31);
     while (1) {
      HEAP8[$2 + 39 | 0] = OneWireRead(HEAPU8[$2 + 83 | 0], 1);
      HEAP8[$2 + 38 | 0] = OneWireRead(HEAPU8[$2 + 83 | 0], 1);
      label$11 : {
       if (!(HEAPU8[$2 + 39 | 0] != 1 | HEAPU8[$2 + 38 | 0] != 1)) {
        break label$11;
       }
       label$13 : {
        if (HEAPU8[$2 + 39 | 0] != HEAPU8[$2 + 38 | 0]) {
         HEAP8[$2 + 36 | 0] = HEAPU8[$2 + 39 | 0];
         break label$13;
        }
        label$15 : {
         if (HEAP32[$2 + 48 >> 2] < HEAP32[$2 + 64 >> 2]) {
          HEAP8[$2 + 36 | 0] = (HEAPU8[HEAP32[$2 + 40 >> 2] + ($2 + 68 | 0) | 0] & HEAPU8[$2 + 37 | 0]) > 0;
          break label$15;
         }
         HEAP8[$2 + 36 | 0] = HEAP32[$2 + 48 >> 2] == HEAP32[$2 + 64 >> 2];
        }
        if (!HEAPU8[$2 + 36 | 0]) {
         HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 48 >> 2];
         if (HEAP32[$2 + 44 >> 2] < 9) {
          HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 44 >> 2];
         }
        }
       }
       label$19 : {
        if (HEAPU8[$2 + 36 | 0] == 1) {
         $0 = HEAP32[$2 + 40 >> 2] + ($2 + 68 | 0) | 0;
         HEAP8[$0 | 0] = HEAPU8[$2 + 37 | 0] | HEAPU8[$0 | 0];
         break label$19;
        }
        $0 = HEAP32[$2 + 40 >> 2] + ($2 + 68 | 0) | 0;
        HEAP8[$0 | 0] = HEAPU8[$0 | 0] & ((HEAPU8[$2 + 37 | 0] ^ -1) & 255);
       }
       OneWireWrite(HEAPU8[$2 + 83 | 0], 1, HEAPU8[$2 + 36 | 0], 0);
       HEAP32[$2 + 48 >> 2] = HEAP32[$2 + 48 >> 2] + 1;
       HEAP8[$2 + 37 | 0] = HEAPU8[$2 + 37 | 0] << 1;
       if (!HEAPU8[$2 + 37 | 0]) {
        HEAP32[$2 + 40 >> 2] = HEAP32[$2 + 40 >> 2] + 1;
        HEAP8[$2 + 37 | 0] = 1;
       }
       if (HEAP32[$2 + 40 >> 2] < 8) {
        continue;
       }
      }
      break;
     }
     if (HEAP32[$2 + 48 >> 2] >= 65) {
      HEAP32[$2 + 64 >> 2] = HEAP32[$2 + 44 >> 2];
      if (!HEAP32[$2 + 64 >> 2]) {
       HEAP32[$2 + 56 >> 2] = 1;
      }
      HEAP32[$2 + 52 >> 2] = 1;
     }
    }
    if (!(HEAPU8[$2 + 68 | 0] ? HEAP32[$2 + 52 >> 2] : 0)) {
     HEAP32[$2 + 64 >> 2] = 0;
     HEAP32[$2 + 56 >> 2] = 0;
     HEAP32[$2 + 60 >> 2] = 0;
     HEAP32[$2 + 52 >> 2] = 0;
    }
    if (HEAP32[$2 + 52 >> 2]) {
     HEAP32[$2 + 32 >> 2] = 0;
     while (1) {
      if (HEAP32[$2 + 32 >> 2] < 8) {
       $0 = $2 + 68 | 0;
       $1 = itoch(HEAPU8[$0 + HEAP32[$2 + 32 >> 2] | 0] >> 4);
       HEAP8[(HEAP32[$2 + 32 >> 2] << 1) + $2 | 0] = $1;
       $0 = itoch(HEAPU8[$0 + HEAP32[$2 + 32 >> 2] | 0] & 15);
       HEAP8[((HEAP32[$2 + 32 >> 2] << 1) + 1 | 0) + $2 | 0] = $0;
       HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 32 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP8[$2 + 16 | 0] = 0;
     jsvArrayPushAndUnLock(HEAP32[$2 + 76 >> 2], jsvNewFromString($2));
    }
    continue;
   }
   break;
  }
  HEAP32[$2 + 92 >> 2] = HEAP32[$2 + 76 >> 2];
 }
 global$0 = $2 + 96 | 0;
 return HEAP32[$2 + 92 >> 2];
}
function jsiDumpHardwareInitialisation($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = global$0 - 96 | 0;
 global$0 = $3;
 HEAP32[$3 + 92 >> 2] = $0;
 HEAP32[$3 + 88 >> 2] = $1;
 HEAP8[$3 + 87 | 0] = $2;
 if (HEAP16[161112] & 1) {
  FUNCTION_TABLE[HEAP32[$3 + 92 >> 2]](81230, HEAP32[$3 + 88 >> 2]);
 }
 if (HEAPU8[141673] != 255) {
  $0 = HEAP32[$3 + 92 >> 2];
  $1 = HEAP32[$3 + 88 >> 2];
  HEAP32[$3 + 64 >> 2] = HEAPU8[141673];
  cbprintf($0, $1, 81239, $3 - -64 | 0);
 }
 if (HEAPU8[141674] != 255) {
  $0 = HEAP32[$3 + 92 >> 2];
  $1 = HEAP32[$3 + 88 >> 2];
  HEAP32[$3 + 48 >> 2] = HEAPU8[141674];
  cbprintf($0, $1, 81262, $3 + 48 | 0);
 }
 if (!(!(HEAP8[$3 + 87 | 0] & 1) | !HEAPU8[142160])) {
  HEAP32[$3 + 80 >> 2] = jsfGetFlags();
  $0 = HEAP32[$3 + 92 >> 2];
  $1 = HEAP32[$3 + 88 >> 2];
  HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 80 >> 2];
  cbprintf($0, $1, 81286, $3 + 32 | 0);
  jsvUnLock(HEAP32[$3 + 80 >> 2]);
 }
 jsiDumpSerialInitialisation(HEAP32[$3 + 92 >> 2], HEAP32[$3 + 88 >> 2], 81303, HEAP8[$3 + 87 | 0] & 1);
 HEAP32[$3 + 76 >> 2] = 0;
 while (1) {
  if (HEAP32[$3 + 76 >> 2] < 1) {
   jsiDumpSerialInitialisation(HEAP32[$3 + 92 >> 2], HEAP32[$3 + 88 >> 2], jshGetDeviceString(HEAP32[$3 + 76 >> 2] + 22 & 255), HEAP8[$3 + 87 | 0] & 1);
   HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 76 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[$3 + 76 >> 2] = 0;
 while (1) {
  if (HEAP32[$3 + 76 >> 2] < 1) {
   jsiDumpDeviceInitialisation(HEAP32[$3 + 92 >> 2], HEAP32[$3 + 88 >> 2], jshGetDeviceString(HEAP32[$3 + 76 >> 2] + 24 & 255));
   HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 76 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[$3 + 76 >> 2] = 0;
 while (1) {
  if (HEAP32[$3 + 76 >> 2] < 1) {
   jsiDumpDeviceInitialisation(HEAP32[$3 + 92 >> 2], HEAP32[$3 + 88 >> 2], jshGetDeviceString(HEAP32[$3 + 76 >> 2] + 25 & 255));
   HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 76 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP8[$3 + 75 | 0] = 0;
 while (1) {
  if (jshIsPinValid(HEAPU8[$3 + 75 | 0]) & 1) {
   $0 = HEAPU8[$3 + 75 | 0] < 48;
  } else {
   $0 = 0;
  }
  if ($0) {
   label$15 : {
    if (HEAPU8[$3 + 75 | 0] == 27 | HEAPU8[$3 + 75 | 0] == 8 | (HEAPU8[$3 + 75 | 0] == 7 | HEAPU8[$3 + 75 | 0] == 6)) {
     break label$15;
    }
    if (HEAPU8[$3 + 75 | 0] == 5 | HEAPU8[$3 + 75 | 0] == 26 | (HEAPU8[$3 + 75 | 0] == 23 | HEAPU8[$3 + 75 | 0] == 3)) {
     break label$15;
    }
    if (HEAPU8[$3 + 75 | 0] == 33 | HEAPU8[$3 + 75 | 0] == 35 | (HEAPU8[$3 + 75 | 0] == 34 | HEAPU8[$3 + 75 | 0] == 36)) {
     break label$15;
    }
    if (HEAPU8[$3 + 75 | 0] == 19) {
     break label$15;
    }
    HEAP8[$3 + 74 | 0] = jshPinGetState(HEAPU8[$3 + 75 | 0]);
    HEAP8[$3 + 73 | 0] = HEAPU8[$3 + 74 | 0] & 15;
    label$17 : {
     label$18 : {
      if (HEAPU8[$3 + 73 | 0] != 1) {
       break label$18;
      }
      if (jshGetPinStateIsManual(HEAPU8[$3 + 75 | 0]) & 1) {
       break label$18;
      }
      HEAP8[$3 + 72 | 0] = (HEAPU8[$3 + 74 | 0] & 16) != 0;
      if (!(HEAP8[$3 + 72 | 0] & 1 | HEAPU8[$3 + 75 | 0] != 8)) {
       break label$15;
      }
      $0 = HEAP32[$3 + 92 >> 2];
      $1 = HEAP32[$3 + 88 >> 2];
      $2 = HEAPU8[$3 + 75 | 0];
      HEAP32[$3 + 20 >> 2] = HEAP8[$3 + 72 | 0] & 1 ? 1 : 0;
      HEAP32[$3 + 16 >> 2] = $2;
      cbprintf($0, $1, 81307, $3 + 16 | 0);
      break label$17;
     }
     if (!(HEAPU8[$3 + 75 | 0] != 17 | HEAPU8[$3 + 73 | 0] != 6)) {
      break label$15;
     }
     if (!(jshIsPinStateDefault(HEAPU8[$3 + 75 | 0], HEAPU8[$3 + 73 | 0]) & 1)) {
      HEAP32[$3 + 68 >> 2] = jswrap_io_getPinMode(HEAPU8[$3 + 75 | 0]);
      if (HEAP32[$3 + 68 >> 2]) {
       $0 = HEAP32[$3 + 92 >> 2];
       $1 = HEAP32[$3 + 88 >> 2];
       $2 = HEAPU8[$3 + 75 | 0];
       $4 = HEAP32[$3 + 68 >> 2];
       HEAP32[$3 + 8 >> 2] = jshGetPinStateIsManual(HEAPU8[$3 + 75 | 0]) & 1 ? 81350 : 81351;
       HEAP32[$3 + 4 >> 2] = $4;
       HEAP32[$3 >> 2] = $2;
       cbprintf($0, $1, 81330, $3);
      }
      jsvUnLock(HEAP32[$3 + 68 >> 2]);
     }
    }
   }
   HEAP8[$3 + 75 | 0] = HEAPU8[$3 + 75 | 0] + 1;
   continue;
  }
  break;
 }
 global$0 = $3 + 96 | 0;
}
function lcdSetCallbacks_ArrayBuffer($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 $2 = $1 + 4 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = jsvObjectGetChild(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 108443, 0);
 HEAP32[$1 + 4 >> 2] = 0;
 HEAP32[$1 >> 2] = jsvGetDataPointer(HEAP32[$1 + 8 >> 2], $2);
 jsvUnLock(HEAP32[$1 + 8 >> 2]);
 label$1 : {
  label$2 : {
   if (!HEAP32[$1 >> 2]) {
    break label$2;
   }
   if (HEAPU32[$1 + 4 >> 2] < graphicsGetMemoryRequired(HEAP32[$1 + 12 >> 2]) >>> 0) {
    break label$2;
   }
   $0 = HEAP32[$1 + 12 >> 2];
   if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 1) {
    break label$2;
   }
   $0 = HEAP32[$1 + 12 >> 2];
   $2 = HEAP32[$1 >> 2];
   HEAP8[$0 + 48 | 0] = $2;
   HEAP8[$0 + 49 | 0] = $2 >>> 8;
   HEAP8[$0 + 50 | 0] = $2 >>> 16;
   HEAP8[$0 + 51 | 0] = $2 >>> 24;
   label$3 : {
    label$4 : {
     if (HEAPU8[HEAP32[$1 + 12 >> 2] + 16 | 0] != 1) {
      break label$4;
     }
     $0 = HEAP32[$1 + 12 >> 2];
     if (!((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 4)) {
      break label$4;
     }
     $0 = HEAP32[$1 + 12 >> 2];
     if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 11) {
      break label$4;
     }
     $0 = HEAP32[$1 + 12 >> 2];
     HEAP8[$0 + 52 | 0] = 536;
     HEAP8[$0 + 53 | 0] = 2;
     HEAP8[$0 + 54 | 0] = 0;
     HEAP8[$0 + 55 | 0] = 0;
     $0 = HEAP32[$1 + 12 >> 2];
     HEAP8[$0 + 60 | 0] = 535;
     HEAP8[$0 + 61 | 0] = 2;
     HEAP8[$0 + 62 | 0] = 0;
     HEAP8[$0 + 63 | 0] = 0;
     $0 = HEAP32[$1 + 12 >> 2];
     HEAP8[$0 + 56 | 0] = 534;
     HEAP8[$0 + 57 | 0] = 2;
     HEAP8[$0 + 58 | 0] = 0;
     HEAP8[$0 + 59 | 0] = 0;
     break label$3;
    }
    label$5 : {
     label$6 : {
      if (HEAPU8[HEAP32[$1 + 12 >> 2] + 16 | 0] != 8) {
       break label$6;
      }
      $0 = HEAP32[$1 + 12 >> 2];
      if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 11) {
       break label$6;
      }
      $0 = HEAP32[$1 + 12 >> 2];
      HEAP8[$0 + 52 | 0] = 540;
      HEAP8[$0 + 53 | 0] = 2;
      HEAP8[$0 + 54 | 0] = 0;
      HEAP8[$0 + 55 | 0] = 0;
      $0 = HEAP32[$1 + 12 >> 2];
      HEAP8[$0 + 60 | 0] = 539;
      HEAP8[$0 + 61 | 0] = 2;
      HEAP8[$0 + 62 | 0] = 0;
      HEAP8[$0 + 63 | 0] = 0;
      $0 = HEAP32[$1 + 12 >> 2];
      HEAP8[$0 + 56 | 0] = 538;
      HEAP8[$0 + 57 | 0] = 2;
      HEAP8[$0 + 58 | 0] = 0;
      HEAP8[$0 + 59 | 0] = 0;
      $0 = HEAP32[$1 + 12 >> 2];
      HEAP8[$0 + 68 | 0] = 537;
      HEAP8[$0 + 69 | 0] = 2;
      HEAP8[$0 + 70 | 0] = 0;
      HEAP8[$0 + 71 | 0] = 0;
      break label$5;
     }
     $0 = HEAP32[$1 + 12 >> 2];
     HEAP8[$0 + 52 | 0] = 542;
     HEAP8[$0 + 53 | 0] = 2;
     HEAP8[$0 + 54 | 0] = 0;
     HEAP8[$0 + 55 | 0] = 0;
     $0 = HEAP32[$1 + 12 >> 2];
     HEAP8[$0 + 60 | 0] = 535;
     HEAP8[$0 + 61 | 0] = 2;
     HEAP8[$0 + 62 | 0] = 0;
     HEAP8[$0 + 63 | 0] = 0;
     $0 = HEAP32[$1 + 12 >> 2];
     HEAP8[$0 + 56 | 0] = 541;
     HEAP8[$0 + 57 | 0] = 2;
     HEAP8[$0 + 58 | 0] = 0;
     HEAP8[$0 + 59 | 0] = 0;
    }
   }
   break label$1;
  }
  if (jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1) {
   $0 = HEAP32[$1 + 12 >> 2];
   $2 = HEAP32[$1 + 8 >> 2];
   HEAP8[$0 + 48 | 0] = $2;
   HEAP8[$0 + 49 | 0] = $2 >>> 8;
   HEAP8[$0 + 50 | 0] = $2 >>> 16;
   HEAP8[$0 + 51 | 0] = $2 >>> 24;
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP8[$0 + 52 | 0] = 545;
   HEAP8[$0 + 53 | 0] = 2;
   HEAP8[$0 + 54 | 0] = 0;
   HEAP8[$0 + 55 | 0] = 0;
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP8[$0 + 60 | 0] = 544;
   HEAP8[$0 + 61 | 0] = 2;
   HEAP8[$0 + 62 | 0] = 0;
   HEAP8[$0 + 63 | 0] = 0;
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP8[$0 + 56 | 0] = 543;
   HEAP8[$0 + 57 | 0] = 2;
   HEAP8[$0 + 58 | 0] = 0;
   HEAP8[$0 + 59 | 0] = 0;
  }
 }
 global$0 = $1 + 16 | 0;
}
function jswrap_graphics_wrapString($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 $3 = global$0 - 272 | 0;
 global$0 = $3;
 HEAP32[$3 + 264 >> 2] = $0;
 HEAP32[$3 + 260 >> 2] = $1;
 HEAP32[$3 + 256 >> 2] = $2;
 label$1 : {
  if (!HEAP32[$3 + 260 >> 2]) {
   HEAP32[$3 + 268 >> 2] = jsvNewWithFlags(3);
   break label$1;
  }
  if (HEAP32[$3 + 256 >> 2] <= 0) {
   HEAP32[$3 + 268 >> 2] = 0;
   break label$1;
  }
  if (!(graphicsGetFromVar($3 + 184 | 0, HEAP32[$3 + 264 >> 2]) & 1)) {
   HEAP32[$3 + 268 >> 2] = 0;
   break label$1;
  }
  $0 = $3 + 104 | 0;
  $1 = $3 + 184 | 0;
  $2 = $3 + 168 | 0;
  _jswrap_graphics_getFontInfo($1, $2);
  HEAP32[$3 + 260 >> 2] = jsvAsString(HEAP32[$3 + 260 >> 2]);
  HEAP32[$3 + 164 >> 2] = jsvNewWithFlags(3);
  HEAP32[$3 + 160 >> 2] = jsvNewWithFlags(27);
  HEAP32[$3 + 156 >> 2] = _jswrap_graphics_getCharWidth($1, $2, 32);
  HEAP32[$3 + 152 >> 2] = 0;
  HEAP32[$3 + 148 >> 2] = 0;
  HEAP32[$3 + 144 >> 2] = 0;
  HEAP8[$3 + 143 | 0] = 0;
  HEAP8[$3 + 142 | 0] = 0;
  jsvStringIteratorNew($0, HEAP32[$3 + 260 >> 2], 0);
  while (1) {
   label$6 : {
    if (jsvStringIteratorHasChar($3 + 104 | 0) & 1) {
     $0 = 1;
    } else {
     $0 = HEAPU8[$3 + 143 | 0];
    }
    if (!($0 & 1)) {
     break label$6;
    }
    HEAP8[$3 + 103 | 0] = jsvStringIteratorGetCharAndNext($3 + 104 | 0);
    if (!(HEAP8[$3 + 103 | 0] != 32 ? !(HEAP8[$3 + 143 | 0] & 1 | HEAP8[$3 + 103 | 0] == 10) : 0)) {
     HEAP32[$3 + 96 >> 2] = jsvStringIteratorGetIndex($3 + 104 | 0);
     label$11 : {
      if (!(HEAP8[$3 + 142 | 0] & 1 | (HEAP32[$3 + 152 >> 2] + (HEAP32[$3 + 148 >> 2] + HEAP32[$3 + 156 >> 2] | 0) | 0) > HEAP32[$3 + 256 >> 2])) {
       if (HEAP32[$3 + 148 >> 2]) {
        jsvAppendString(HEAP32[$3 + 160 >> 2], 127809);
        HEAP32[$3 + 148 >> 2] = HEAP32[$3 + 156 >> 2] + HEAP32[$3 + 148 >> 2];
       }
       jsvAppendStringVar(HEAP32[$3 + 160 >> 2], HEAP32[$3 + 260 >> 2], HEAP32[$3 + 144 >> 2], HEAP32[$3 + 96 >> 2] - (HEAP32[$3 + 144 >> 2] + 1 | 0) | 0);
       HEAP32[$3 + 148 >> 2] = HEAP32[$3 + 152 >> 2] + HEAP32[$3 + 148 >> 2];
       break label$11;
      }
      HEAP32[$3 + 148 >> 2] = HEAP32[$3 + 152 >> 2];
      if (!(wasm2js_i32$0 = 0, wasm2js_i32$1 = !jsvGetStringLength(HEAP32[$3 + 160 >> 2]), wasm2js_i32$2 = HEAP8[$3 + 142 | 0] & 1, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1)) {
       jsvArrayPush(HEAP32[$3 + 164 >> 2], HEAP32[$3 + 160 >> 2]);
      }
      jsvUnLock(HEAP32[$3 + 160 >> 2]);
      HEAP32[$3 + 160 >> 2] = jsvNewFromStringVar(HEAP32[$3 + 260 >> 2], HEAP32[$3 + 144 >> 2], HEAP32[$3 + 96 >> 2] - (HEAP32[$3 + 144 >> 2] + 1 | 0) | 0);
     }
     HEAP32[$3 + 152 >> 2] = 0;
     HEAP32[$3 + 144 >> 2] = HEAP32[$3 + 96 >> 2];
     HEAP8[$3 + 142 | 0] = HEAP8[$3 + 103 | 0] == 10;
     if (HEAP8[$3 + 143 | 0] & 1) {
      break label$6;
     }
     continue;
    }
    if (!HEAP8[$3 + 103 | 0]) {
     $0 = $3 + 184 | 0;
     $1 = $3 + 8 | 0;
     HEAP32[$3 + 4 >> 2] = jsvStringIteratorGetIndex($3 + 104 | 0);
     if (_jswrap_graphics_parseImage($0, HEAP32[$3 + 260 >> 2], HEAP32[$3 + 4 >> 2], $1) & 1) {
      $0 = $3 + 8 | 0;
      jsvStringIteratorGoto($3 + 104 | 0, HEAP32[$3 + 260 >> 2], HEAPU16[$3 + 58 >> 1] + (HEAP32[$3 + 4 >> 2] + HEAPU16[$3 + 56 >> 1] | 0) | 0);
      _jswrap_graphics_freeImageInfo($0);
      HEAP32[$3 + 152 >> 2] = HEAP32[$3 + 8 >> 2] + HEAP32[$3 + 152 >> 2];
     }
     continue;
    }
    $0 = $3 + 104 | 0;
    HEAP32[$3 + 152 >> 2] = _jswrap_graphics_getCharWidth($3 + 184 | 0, $3 + 168 | 0, HEAP8[$3 + 103 | 0]) + HEAP32[$3 + 152 >> 2];
    if (!(jsvStringIteratorHasChar($0) & 1)) {
     HEAP8[$3 + 143 | 0] = 1;
    }
    continue;
   }
   break;
  }
  jsvStringIteratorFree($3 + 104 | 0);
  if (jsvGetStringLength(HEAP32[$3 + 160 >> 2])) {
   jsvArrayPush(HEAP32[$3 + 164 >> 2], HEAP32[$3 + 160 >> 2]);
  }
  jsvUnLock2(HEAP32[$3 + 260 >> 2], HEAP32[$3 + 160 >> 2]);
  HEAP32[$3 + 268 >> 2] = HEAP32[$3 + 164 >> 2];
 }
 global$0 = $3 + 272 | 0;
 return HEAP32[$3 + 268 >> 2];
}
function jswrap_graphics_blit($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 224 | 0;
 global$0 = $2;
 HEAP32[$2 + 216 >> 2] = $0;
 HEAP32[$2 + 212 >> 2] = $1;
 label$1 : {
  if (!(graphicsGetFromVar($2 + 136 | 0, HEAP32[$2 + 216 >> 2]) & 1)) {
   HEAP32[$2 + 220 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 132 >> 2] = HEAPU8[$2 + 148 | 0] | HEAPU8[$2 + 149 | 0] << 8;
  HEAP32[$2 + 128 >> 2] = HEAPU8[$2 + 150 | 0] | HEAPU8[$2 + 151 | 0] << 8;
  HEAP32[$2 + 124 >> 2] = 0;
  HEAP32[$2 + 120 >> 2] = 0;
  HEAP32[$2 + 116 >> 2] = 0;
  HEAP32[$2 + 112 >> 2] = 0;
  HEAP32[$2 + 108 >> 2] = 0;
  HEAP32[$2 + 104 >> 2] = 0;
  HEAP8[$2 + 103 | 0] = 0;
  HEAP32[$2 + 16 >> 2] = 127466;
  HEAP16[$2 + 20 >> 1] = 9;
  HEAP32[$2 + 24 >> 2] = $2 + 124;
  HEAP32[$2 + 28 >> 2] = 127469;
  HEAP16[$2 + 32 >> 1] = 9;
  HEAP32[$2 + 36 >> 2] = $2 + 120;
  HEAP32[$2 + 40 >> 2] = 127478;
  HEAP16[$2 + 44 >> 1] = 9;
  HEAP32[$2 + 48 >> 2] = $2 + 116;
  HEAP32[$2 + 52 >> 2] = 127480;
  HEAP16[$2 + 56 >> 1] = 9;
  HEAP32[$2 + 60 >> 2] = $2 + 112;
  HEAP32[$2 + 64 >> 2] = 127472;
  HEAP16[$2 + 68 >> 1] = 9;
  HEAP32[$2 + 72 >> 2] = $2 + 108;
  HEAP32[$2 + 76 >> 2] = 127475;
  HEAP16[$2 + 80 >> 1] = 9;
  HEAP32[$2 + 84 >> 2] = $2 + 104;
  HEAP32[$2 + 88 >> 2] = 128022;
  HEAP16[$2 + 92 >> 1] = 11;
  HEAP32[$2 + 96 >> 2] = $2 + 103;
  label$3 : {
   if (jsvIsObject(HEAP32[$2 + 212 >> 2]) & 1) {
    if (jsvReadConfigObject(HEAP32[$2 + 212 >> 2], $2 + 16 | 0, 7) & 1) {
     break label$3;
    }
   }
   jsExceptionHere(1, 128034, 0);
   HEAP32[$2 + 220 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$2 + 124 >> 2] < 0) {
   HEAP32[$2 + 108 >> 2] = HEAP32[$2 + 108 >> 2] - HEAP32[$2 + 124 >> 2];
   HEAP32[$2 + 116 >> 2] = HEAP32[$2 + 124 >> 2] + HEAP32[$2 + 116 >> 2];
   HEAP32[$2 + 124 >> 2] = 0;
  }
  if (HEAP32[$2 + 120 >> 2] < 0) {
   HEAP32[$2 + 104 >> 2] = HEAP32[$2 + 104 >> 2] - HEAP32[$2 + 120 >> 2];
   HEAP32[$2 + 112 >> 2] = HEAP32[$2 + 120 >> 2] + HEAP32[$2 + 112 >> 2];
   HEAP32[$2 + 120 >> 2] = 0;
  }
  HEAP32[$2 + 12 >> 2] = (HEAP32[$2 + 124 >> 2] + HEAP32[$2 + 116 >> 2] | 0) - HEAP32[$2 + 132 >> 2];
  if (HEAP32[$2 + 12 >> 2] > 0) {
   HEAP32[$2 + 116 >> 2] = HEAP32[$2 + 116 >> 2] - HEAP32[$2 + 12 >> 2];
  }
  HEAP32[$2 + 12 >> 2] = (HEAP32[$2 + 120 >> 2] + HEAP32[$2 + 112 >> 2] | 0) - HEAP32[$2 + 128 >> 2];
  if (HEAP32[$2 + 12 >> 2] > 0) {
   HEAP32[$2 + 112 >> 2] = HEAP32[$2 + 112 >> 2] - HEAP32[$2 + 12 >> 2];
  }
  if (HEAP32[$2 + 108 >> 2] < 0) {
   HEAP32[$2 + 124 >> 2] = HEAP32[$2 + 124 >> 2] - HEAP32[$2 + 108 >> 2];
   HEAP32[$2 + 116 >> 2] = HEAP32[$2 + 108 >> 2] + HEAP32[$2 + 116 >> 2];
   HEAP32[$2 + 108 >> 2] = 0;
  }
  if (HEAP32[$2 + 104 >> 2] < 0) {
   HEAP32[$2 + 120 >> 2] = HEAP32[$2 + 120 >> 2] - HEAP32[$2 + 104 >> 2];
   HEAP32[$2 + 112 >> 2] = HEAP32[$2 + 104 >> 2] + HEAP32[$2 + 112 >> 2];
   HEAP32[$2 + 104 >> 2] = 0;
  }
  HEAP32[$2 + 12 >> 2] = (HEAP32[$2 + 108 >> 2] + HEAP32[$2 + 116 >> 2] | 0) - HEAP32[$2 + 132 >> 2];
  if (HEAP32[$2 + 12 >> 2] > 0) {
   HEAP32[$2 + 116 >> 2] = HEAP32[$2 + 116 >> 2] - HEAP32[$2 + 12 >> 2];
  }
  HEAP32[$2 + 12 >> 2] = (HEAP32[$2 + 104 >> 2] + HEAP32[$2 + 112 >> 2] | 0) - HEAP32[$2 + 128 >> 2];
  if (HEAP32[$2 + 12 >> 2] > 0) {
   HEAP32[$2 + 112 >> 2] = HEAP32[$2 + 112 >> 2] - HEAP32[$2 + 12 >> 2];
  }
  if (!(HEAP32[$2 + 112 >> 2] <= 0 ? HEAP32[$2 + 116 >> 2] <= 0 : 0)) {
   FUNCTION_TABLE[HEAPU8[$2 + 200 | 0] | HEAPU8[$2 + 201 | 0] << 8 | (HEAPU8[$2 + 202 | 0] << 16 | HEAPU8[$2 + 203 | 0] << 24)]($2 + 136 | 0, HEAP32[$2 + 124 >> 2], HEAP32[$2 + 120 >> 2], HEAP32[$2 + 116 >> 2], HEAP32[$2 + 112 >> 2], HEAP32[$2 + 108 >> 2], HEAP32[$2 + 104 >> 2]);
   if (HEAP8[$2 + 103 | 0] & 1) {
    $0 = $2 + 136 | 0;
    graphicsSetModified($0, HEAP32[$2 + 108 >> 2], HEAP32[$2 + 104 >> 2], HEAP32[$2 + 108 >> 2] + HEAP32[$2 + 116 >> 2] | 0, HEAP32[$2 + 104 >> 2] + HEAP32[$2 + 112 >> 2] | 0);
    graphicsSetVar($0);
   }
  }
  HEAP32[$2 + 220 >> 2] = jsvLockAgain(HEAP32[$2 + 216 >> 2]);
 }
 global$0 = $2 + 224 | 0;
 return HEAP32[$2 + 220 >> 2];
}
function tflite__ops__micro__conv__CalculateOpData_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteConvParams_20const__2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20TfLiteType_2c_20tflite__ops__micro__conv__OpData__29($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10) {
 var $11 = 0;
 $11 = global$0 - 144 | 0;
 global$0 = $11;
 HEAP32[$11 + 136 >> 2] = $0;
 HEAP32[$11 + 132 >> 2] = $1;
 HEAP32[$11 + 128 >> 2] = $2;
 HEAP32[$11 + 124 >> 2] = $3;
 HEAP32[$11 + 120 >> 2] = $4;
 HEAP32[$11 + 116 >> 2] = $5;
 HEAP32[$11 + 112 >> 2] = $6;
 HEAP32[$11 + 108 >> 2] = $7;
 HEAP32[$11 + 104 >> 2] = $8;
 HEAP32[$11 + 100 >> 2] = $9;
 HEAP32[$11 + 96 >> 2] = $10;
 HEAP8[$11 + 95 | 0] = HEAP32[HEAP32[HEAP32[$11 + 132 >> 2] >> 2] >> 2] == 3;
 label$1 : {
  if (!(HEAP8[$11 + 95 | 0] & 1 | HEAP32[HEAP32[HEAP32[$11 + 132 >> 2] >> 2] >> 2] == 2)) {
   $0 = HEAP32[HEAP32[$11 + 136 >> 2] + 20 >> 2];
   $1 = HEAP32[$11 + 136 >> 2];
   HEAP32[$11 + 40 >> 2] = 133918;
   HEAP32[$11 + 36 >> 2] = 86;
   HEAP32[$11 + 32 >> 2] = 133836;
   FUNCTION_TABLE[$0]($1, 133813, $11 + 32 | 0);
   HEAP32[$11 + 140 >> 2] = 1;
   break label$1;
  }
  if (HEAP32[HEAP32[HEAP32[$11 + 132 >> 2] + 4 >> 2] >> 2] != 1) {
   $0 = HEAP32[HEAP32[$11 + 136 >> 2] + 20 >> 2];
   $1 = HEAP32[$11 + 136 >> 2];
   $2 = HEAP32[HEAP32[HEAP32[$11 + 132 >> 2] + 4 >> 2] >> 2];
   HEAP32[$11 + 20 >> 2] = 1;
   HEAP32[$11 + 16 >> 2] = $2;
   HEAP32[$11 + 12 >> 2] = 134e3;
   HEAP32[$11 + 8 >> 2] = 133980;
   HEAP32[$11 + 4 >> 2] = 87;
   HEAP32[$11 >> 2] = 133836;
   FUNCTION_TABLE[$0]($1, 133954, $11);
   HEAP32[$11 + 140 >> 2] = 1;
   break label$1;
  }
  HEAP32[$11 + 88 >> 2] = HEAP32[HEAP32[$11 + 128 >> 2] >> 2];
  $0 = $11 + 72 | 0;
  tflite__ComputePaddingHeightWidth_28int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20TfLitePadding_2c_20int__2c_20int__29($0, HEAP32[HEAP32[$11 + 128 >> 2] + 8 >> 2], HEAP32[HEAP32[$11 + 128 >> 2] + 4 >> 2], HEAP32[HEAP32[$11 + 128 >> 2] + 20 >> 2], HEAP32[HEAP32[$11 + 128 >> 2] + 16 >> 2], HEAP32[$11 + 120 >> 2], HEAP32[$11 + 124 >> 2], HEAP32[$11 + 112 >> 2], HEAP32[$11 + 116 >> 2], HEAP32[$11 + 88 >> 2], $11 + 104 | 0, $11 + 108 | 0);
  $2 = HEAP32[$0 + 4 >> 2];
  $1 = HEAP32[$11 + 96 >> 2];
  HEAP32[$1 >> 2] = HEAP32[$0 >> 2];
  HEAP32[$1 + 4 >> 2] = $2;
  $2 = HEAP32[$0 + 12 >> 2];
  HEAP32[$1 + 8 >> 2] = HEAP32[$0 + 8 >> 2];
  HEAP32[$1 + 12 >> 2] = $2;
  if (HEAP32[$11 + 100 >> 2] != 1) {
   HEAP32[$11 + 68 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$11 + 136 >> 2], HEAP32[$11 + 132 >> 2], 0);
   HEAP32[$11 + 64 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$11 + 136 >> 2], HEAP32[$11 + 132 >> 2], 1);
   HEAP32[$11 + 60 >> 2] = tflite__GetOptionalInputTensor_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$11 + 136 >> 2], HEAP32[$11 + 132 >> 2]);
   HEAP32[$11 + 56 >> 2] = tflite__GetOutput_28TfLiteContext__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$11 + 136 >> 2], HEAP32[$11 + 132 >> 2]);
   HEAP32[$11 + 52 >> 2] = HEAP32[HEAP32[HEAP32[$11 + 64 >> 2] + 20 >> 2] + 4 >> 2];
   HEAP32[$11 + 48 >> 2] = tflite__PopulateConvolutionQuantizationParams_28TfLiteContext__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor__2c_20TfLiteFusedActivation_20const__2c_20int__2c_20int__2c_20int__2c_20int__2c_20int__2c_20int__2c_20int_29(HEAP32[$11 + 136 >> 2], HEAP32[$11 + 68 >> 2], HEAP32[$11 + 64 >> 2], HEAP32[$11 + 60 >> 2], HEAP32[$11 + 56 >> 2], HEAP32[$11 + 128 >> 2] + 12 | 0, HEAP32[$11 + 96 >> 2] + 28 | 0, HEAP32[$11 + 96 >> 2] + 32 | 0, HEAP32[$11 + 96 >> 2] + 44 | 0, HEAP32[$11 + 96 >> 2] + 48 | 0, HEAP32[HEAP32[$11 + 96 >> 2] + 36 >> 2], HEAP32[HEAP32[$11 + 96 >> 2] + 40 >> 2], HEAP32[$11 + 52 >> 2]);
   if (HEAP32[$11 + 48 >> 2]) {
    HEAP32[$11 + 140 >> 2] = HEAP32[$11 + 48 >> 2];
    break label$1;
   }
  }
  HEAP32[$11 + 140 >> 2] = 0;
 }
 global$0 = $11 + 144 | 0;
 return HEAP32[$11 + 140 >> 2];
}
function tflite__ParseFullyConnected_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0, $5 = 0, $6 = 0;
 $4 = global$0 + -64 | 0;
 global$0 = $4;
 $6 = $4 + 32 | 0;
 $5 = $4 + 40 | 0;
 HEAP32[$4 + 56 >> 2] = $0;
 HEAP32[$4 + 52 >> 2] = $1;
 HEAP32[$4 + 48 >> 2] = $2;
 HEAP32[$4 + 44 >> 2] = $3;
 tflite___28anonymous_20namespace_29__CheckParsePointerParams_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29(HEAP32[$4 + 56 >> 2], HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2], HEAP32[$4 + 44 >> 2]);
 tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__SafeBuiltinDataAllocator_28tflite__BuiltinDataAllocator__29($5, HEAP32[$4 + 48 >> 2]);
 std____2__unique_ptr_TfLiteFullyConnectedParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__Allocate_TfLiteFullyConnectedParams__28_29($6, $5);
 label$1 : {
  if (!(bool_20std____2__operator___TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20const__2c_20std__nullptr_t_29($4 + 32 | 0) & 1)) {
   $0 = HEAP32[$4 + 52 >> 2];
   $1 = HEAP32[$4 + 52 >> 2];
   HEAP32[$4 + 8 >> 2] = 136736;
   HEAP32[$4 + 4 >> 2] = 1111;
   HEAP32[$4 >> 2] = 136641;
   tflite__ErrorReporter__ReportError_28void__2c_20char_20const__2c_20____29($0, $1, 136618, $4);
   HEAP32[$4 + 60 >> 2] = 1;
   break label$1;
  }
  HEAP32[$4 + 16 >> 2] = tflite__Operator__builtin_options_as_FullyConnectedOptions_28_29_20const(HEAP32[$4 + 56 >> 2]);
  if (HEAP32[$4 + 16 >> 2]) {
   $0 = tflite___28anonymous_20namespace_29__ConvertActivation_28tflite__ActivationFunctionType_29(tflite__OperatorCode__builtin_code_28_29_20const(HEAP32[$4 + 16 >> 2]));
   HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 32 | 0) >> 2] = $0;
   $0 = tflite__FullyConnectedOptions__keep_num_dims_28_29_20const(HEAP32[$4 + 16 >> 2]);
   HEAP8[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 32 | 0) + 8 | 0] = $0 & 1;
   $0 = tflite__FullyConnectedOptions__asymmetric_quantize_inputs_28_29_20const(HEAP32[$4 + 16 >> 2]);
   HEAP8[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 32 | 0) + 9 | 0] = $0 & 1;
   $0 = tflite__Tensor__type_28_29_20const(HEAP32[$4 + 16 >> 2]);
   $1 = $0;
   label$4 : {
    if ($0 >>> 0 <= 1) {
     if ($1 - 1) {
      HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 32 | 0) + 4 >> 2] = 0;
      break label$4;
     }
     HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 32 | 0) + 4 >> 2] = 1;
     break label$4;
    }
    tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$4 + 52 >> 2], 136754, 0);
    HEAP32[$4 + 60 >> 2] = 1;
    break label$1;
   }
  }
  $0 = std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___release_28_29($4 + 32 | 0);
  HEAP32[HEAP32[$4 + 44 >> 2] >> 2] = $0;
  HEAP32[$4 + 60 >> 2] = 0;
 }
 HEAP32[$4 + 20 >> 2] = 1;
 std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter____unique_ptr_28_29($4 + 32 | 0);
 global$0 = $4 - -64 | 0;
 return HEAP32[$4 + 60 >> 2];
}
function tflite__reference_integer_ops__FullyConnected_28tflite__FullyConnectedParams_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0;
 $9 = global$0 - 112 | 0;
 global$0 = $9;
 HEAP32[$9 + 108 >> 2] = $0;
 HEAP32[$9 + 104 >> 2] = $1;
 HEAP32[$9 + 100 >> 2] = $2;
 HEAP32[$9 + 96 >> 2] = $3;
 HEAP32[$9 + 92 >> 2] = $4;
 HEAP32[$9 + 88 >> 2] = $5;
 HEAP32[$9 + 84 >> 2] = $6;
 HEAP32[$9 + 80 >> 2] = $7;
 HEAP32[$9 + 76 >> 2] = $8;
 HEAP32[$9 + 72 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] >> 2];
 HEAP32[$9 + 68 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 4 >> 2];
 HEAP32[$9 + 64 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 8 >> 2];
 HEAP32[$9 + 60 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 12 >> 2];
 HEAP32[$9 + 56 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 16 >> 2];
 HEAP32[$9 + 52 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 20 >> 2];
 HEAP32[$9 + 48 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 24 >> 2];
 label$1 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 96 >> 2]) | 0) < 2) {
   break label$1;
  }
 }
 label$2 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 80 >> 2]) | 0) != 2) {
   break label$2;
  }
 }
 label$3 : {
  if (HEAP32[$9 + 52 >> 2] > HEAP32[$9 + 48 >> 2]) {
   break label$3;
  }
 }
 HEAP32[$9 + 44 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 96 >> 2]);
 HEAP32[$9 + 40 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 80 >> 2], 0);
 HEAP32[$9 + 36 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 80 >> 2], 1);
 label$4 : {
  if (HEAP32[$9 + 36 >> 2] > (tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 96 >> 2], HEAP32[$9 + 44 >> 2] - 2 | 0) | 0)) {
   break label$4;
  }
 }
 HEAP32[$9 + 32 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 96 >> 2], HEAP32[$9 + 44 >> 2] - 1 | 0);
 HEAP32[$9 + 28 >> 2] = 0;
 while (1) {
  if (HEAP32[$9 + 28 >> 2] < HEAP32[$9 + 40 >> 2]) {
   HEAP32[$9 + 24 >> 2] = 0;
   while (1) {
    if (HEAP32[$9 + 24 >> 2] < HEAP32[$9 + 36 >> 2]) {
     HEAP32[$9 + 20 >> 2] = 0;
     HEAP32[$9 + 16 >> 2] = 0;
     while (1) {
      if (HEAP32[$9 + 16 >> 2] < HEAP32[$9 + 32 >> 2]) {
       HEAP32[$9 + 12 >> 2] = HEAP8[HEAP32[$9 + 100 >> 2] + (HEAP32[$9 + 16 >> 2] + Math_imul(HEAP32[$9 + 28 >> 2], HEAP32[$9 + 32 >> 2]) | 0) | 0];
       HEAP32[$9 + 8 >> 2] = HEAP8[HEAP32[$9 + 92 >> 2] + (HEAP32[$9 + 16 >> 2] + Math_imul(HEAP32[$9 + 24 >> 2], HEAP32[$9 + 32 >> 2]) | 0) | 0];
       HEAP32[$9 + 20 >> 2] = HEAP32[$9 + 20 >> 2] + Math_imul(HEAP32[$9 + 8 >> 2] + HEAP32[$9 + 68 >> 2] | 0, HEAP32[$9 + 12 >> 2] + HEAP32[$9 + 72 >> 2] | 0);
       HEAP32[$9 + 16 >> 2] = HEAP32[$9 + 16 >> 2] + 1;
       continue;
      }
      break;
     }
     if (HEAP32[$9 + 84 >> 2]) {
      HEAP32[$9 + 20 >> 2] = HEAP32[HEAP32[$9 + 84 >> 2] + (HEAP32[$9 + 24 >> 2] << 2) >> 2] + HEAP32[$9 + 20 >> 2];
     }
     $0 = $9 + 20 | 0;
     $1 = $9 + 48 | 0;
     $2 = $9 + 52 | 0;
     HEAP32[$9 + 20 >> 2] = tflite__MultiplyByQuantizedMultiplier_28int_2c_20int_2c_20int_29(HEAP32[$9 + 20 >> 2], HEAP32[$9 + 60 >> 2], HEAP32[$9 + 56 >> 2]);
     HEAP32[$9 + 20 >> 2] = HEAP32[$9 + 64 >> 2] + HEAP32[$9 + 20 >> 2];
     HEAP32[$9 + 20 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($0, $2) >> 2];
     HEAP32[$9 + 20 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($0, $1) >> 2];
     HEAP8[HEAP32[$9 + 76 >> 2] + (HEAP32[$9 + 24 >> 2] + Math_imul(HEAP32[$9 + 36 >> 2], HEAP32[$9 + 28 >> 2]) | 0) | 0] = HEAP32[$9 + 20 >> 2];
     HEAP32[$9 + 24 >> 2] = HEAP32[$9 + 24 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$9 + 28 >> 2] = HEAP32[$9 + 28 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $9 + 112 | 0;
}
function jswrap_array_splice($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 96 | 0;
 global$0 = $4;
 HEAP32[$4 + 88 >> 2] = $0;
 HEAP32[$4 + 84 >> 2] = $1;
 HEAP32[$4 + 80 >> 2] = $2;
 HEAP32[$4 + 76 >> 2] = $3;
 label$1 : {
  if (!(jsvIsArray(HEAP32[$4 + 88 >> 2]) & 1)) {
   HEAP32[$4 + 92 >> 2] = 0;
   break label$1;
  }
  HEAP32[$4 + 72 >> 2] = jsvGetArrayLength(HEAP32[$4 + 88 >> 2]);
  if (HEAP32[$4 + 84 >> 2] < 0) {
   HEAP32[$4 + 84 >> 2] = HEAP32[$4 + 72 >> 2] + HEAP32[$4 + 84 >> 2];
  }
  if (HEAP32[$4 + 84 >> 2] < 0) {
   HEAP32[$4 + 84 >> 2] = 0;
  }
  if (HEAP32[$4 + 84 >> 2] > HEAP32[$4 + 72 >> 2]) {
   HEAP32[$4 + 84 >> 2] = HEAP32[$4 + 72 >> 2];
  }
  HEAP32[$4 + 68 >> 2] = HEAP32[$4 + 72 >> 2];
  if (jsvIsInt(HEAP32[$4 + 80 >> 2]) & 1) {
   HEAP32[$4 + 68 >> 2] = jsvGetInteger(HEAP32[$4 + 80 >> 2]);
  }
  if (HEAP32[$4 + 68 >> 2] > (HEAP32[$4 + 72 >> 2] - HEAP32[$4 + 84 >> 2] | 0)) {
   HEAP32[$4 + 68 >> 2] = HEAP32[$4 + 72 >> 2] - HEAP32[$4 + 84 >> 2];
  }
  $0 = $4 + 48 | 0;
  HEAP32[$4 + 64 >> 2] = jsvGetArrayLength(HEAP32[$4 + 76 >> 2]);
  HEAP32[$4 + 60 >> 2] = HEAP32[$4 + 64 >> 2] - HEAP32[$4 + 68 >> 2];
  HEAP8[$4 + 59 | 0] = 0;
  HEAP32[$4 + 52 >> 2] = jsvNewWithFlags(3);
  jsvObjectIteratorNew($0, HEAP32[$4 + 88 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue($4 + 48 | 0) & 1) {
    $0 = HEAPU8[$4 + 59 | 0] ^ -1;
   } else {
    $0 = 0;
   }
   if ($0 & 1) {
    HEAP8[$4 + 47 | 0] = 1;
    HEAP32[$4 + 40 >> 2] = jsvObjectIteratorGetKey($4 + 48 | 0);
    label$12 : {
     if (!HEAP32[$4 + 40 >> 2]) {
      break label$12;
     }
     if (!(jsvIsInt(HEAP32[$4 + 40 >> 2]) & 1)) {
      break label$12;
     }
     HEAP32[$4 + 36 >> 2] = jsvGetInteger(HEAP32[$4 + 40 >> 2]);
     if (HEAP32[$4 + 36 >> 2] >= HEAP32[$4 + 84 >> 2]) {
      label$14 : {
       if (HEAP32[$4 + 36 >> 2] < (HEAP32[$4 + 84 >> 2] + HEAP32[$4 + 68 >> 2] | 0)) {
        if (HEAP32[$4 + 52 >> 2]) {
         HEAP32[$4 + 32 >> 2] = jsvObjectIteratorGetValue($4 + 48 | 0);
         jsvArrayPushAndUnLock(HEAP32[$4 + 52 >> 2], HEAP32[$4 + 32 >> 2]);
        }
        HEAP8[$4 + 47 | 0] = 0;
        $0 = $4 + 48 | 0;
        HEAP32[$4 + 28 >> 2] = jsvObjectIteratorGetKey($0);
        jsvObjectIteratorNext($0);
        jsvRemoveChild(HEAP32[$4 + 88 >> 2], HEAP32[$4 + 28 >> 2]);
        jsvUnLock(HEAP32[$4 + 28 >> 2]);
        break label$14;
       }
       HEAP8[$4 + 59 | 0] = 1;
       HEAP8[$4 + 47 | 0] = 0;
      }
     }
    }
    jsvUnLock(HEAP32[$4 + 40 >> 2]);
    if (HEAP8[$4 + 47 | 0] & 1) {
     jsvObjectIteratorNext($4 + 48 | 0);
    }
    continue;
   }
   break;
  }
  $0 = $4 + 16 | 0;
  HEAP32[$4 + 24 >> 2] = jsvObjectIteratorGetKey($4 + 48 | 0);
  jsvObjectIteratorNew($0, HEAP32[$4 + 76 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue($4 + 16 | 0) & 1) {
    $0 = $4 + 16 | 0;
    HEAP32[$4 + 12 >> 2] = jsvObjectIteratorGetValue($0);
    jsvArrayInsertBefore(HEAP32[$4 + 88 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 12 >> 2]);
    jsvUnLock(HEAP32[$4 + 12 >> 2]);
    jsvObjectIteratorNext($0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree($4 + 16 | 0);
  jsvUnLock(HEAP32[$4 + 24 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue($4 + 48 | 0) & 1) {
    HEAP32[$4 + 8 >> 2] = jsvObjectIteratorGetKey($4 + 48 | 0);
    label$22 : {
     if (!HEAP32[$4 + 8 >> 2]) {
      break label$22;
     }
     if (!(jsvIsInt(HEAP32[$4 + 8 >> 2]) & 1)) {
      break label$22;
     }
     jsvSetInteger(HEAP32[$4 + 8 >> 2], jsvGetInteger(HEAP32[$4 + 8 >> 2]) + HEAP32[$4 + 60 >> 2] | 0);
    }
    $0 = $4 + 48 | 0;
    jsvUnLock(HEAP32[$4 + 8 >> 2]);
    jsvObjectIteratorNext($0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree($4 + 48 | 0);
  jsvSetArrayLength(HEAP32[$4 + 88 >> 2], HEAP32[$4 + 72 >> 2] + HEAP32[$4 + 60 >> 2] | 0);
  HEAP32[$4 + 92 >> 2] = HEAP32[$4 + 52 >> 2];
 }
 global$0 = $4 + 96 | 0;
 return HEAP32[$4 + 92 >> 2];
}
function jswrap_object_keys_or_property_names_cb($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 144 | 0;
 global$0 = $5;
 HEAP32[$5 + 140 >> 2] = $0;
 HEAP8[$5 + 139 | 0] = $1;
 HEAP8[$5 + 138 | 0] = $2;
 HEAP32[$5 + 132 >> 2] = $3;
 HEAP32[$5 + 128 >> 2] = $4;
 if (jsvIsIterable(HEAP32[$5 + 140 >> 2]) & 1) {
  $0 = $5 - -64 | 0;
  HEAP32[$5 + 124 >> 2] = jsvGetInternalFunctionCheckerFor(HEAP32[$5 + 140 >> 2]);
  jsvIteratorNew($0, HEAP32[$5 + 140 >> 2], 0);
  while (1) {
   if (jsvIteratorHasElement($5 - -64 | 0) & 1) {
    HEAP32[$5 + 60 >> 2] = jsvIteratorGetKey($5 - -64 | 0);
    label$4 : {
     label$5 : {
      if (!HEAP32[$5 + 124 >> 2]) {
       break label$5;
      }
      if (!(FUNCTION_TABLE[HEAP32[$5 + 124 >> 2]](HEAP32[$5 + 60 >> 2]) & 1)) {
       break label$5;
      }
      if (!(jsvIsStringEqual(HEAP32[$5 + 60 >> 2], 123232) & 1)) {
       break label$4;
      }
     }
     HEAP32[$5 + 56 >> 2] = jsvAsArrayIndexAndUnLock(jsvCopyNameOnly(HEAP32[$5 + 60 >> 2], 0, 0));
     if (HEAP32[$5 + 56 >> 2]) {
      FUNCTION_TABLE[HEAP32[$5 + 132 >> 2]](HEAP32[$5 + 128 >> 2], HEAP32[$5 + 56 >> 2]);
      jsvUnLock(HEAP32[$5 + 56 >> 2]);
     }
    }
    $0 = $5 - -64 | 0;
    jsvUnLock(HEAP32[$5 + 60 >> 2]);
    jsvIteratorNext($0);
    continue;
   }
   break;
  }
  jsvIteratorFree($5 - -64 | 0);
 }
 if (HEAP8[$5 + 139 | 0] & 1) {
  HEAP32[$5 + 52 >> 2] = jswGetSymbolListForObjectProto(0);
  HEAP32[$5 + 48 >> 2] = jspGetPrototypeOwner(HEAP32[$5 + 140 >> 2]);
  label$8 : {
   if (HEAP32[$5 + 48 >> 2]) {
    HEAP32[$5 + 44 >> 2] = jswGetSymbolListForObjectProto(HEAP32[$5 + 48 >> 2]);
    jsvUnLock(HEAP32[$5 + 48 >> 2]);
    _jswrap_object_keys_or_property_names_iterator(HEAP32[$5 + 44 >> 2], HEAP32[$5 + 132 >> 2], HEAP32[$5 + 128 >> 2]);
    break label$8;
   }
   label$10 : {
    if (jsvIsObject(HEAP32[$5 + 140 >> 2]) & 1) {
     if (!(jsvIsRoot(HEAP32[$5 + 140 >> 2]) & 1)) {
      break label$10;
     }
    }
    HEAP32[$5 + 40 >> 2] = jswGetSymbolListForObject(HEAP32[$5 + 140 >> 2]);
    _jswrap_object_keys_or_property_names_iterator(HEAP32[$5 + 40 >> 2], HEAP32[$5 + 132 >> 2], HEAP32[$5 + 128 >> 2]);
   }
  }
  if (HEAP8[$5 + 138 | 0] & 1) {
   HEAP32[$5 + 36 >> 2] = 0;
   label$13 : {
    if (!(jsvIsObject(HEAP32[$5 + 140 >> 2]) & 1)) {
     if (!(jsvIsFunction(HEAP32[$5 + 140 >> 2]) & 1)) {
      break label$13;
     }
    }
    HEAP32[$5 + 36 >> 2] = jsvObjectGetChild(HEAP32[$5 + 140 >> 2], 123244, 0);
   }
   label$15 : {
    if (jsvIsObject(HEAP32[$5 + 36 >> 2]) & 1) {
     jswrap_object_keys_or_property_names_cb(HEAP32[$5 + 36 >> 2], HEAP8[$5 + 139 | 0] & 1, HEAP8[$5 + 138 | 0] & 1, HEAP32[$5 + 132 >> 2], HEAP32[$5 + 128 >> 2]);
     break label$15;
    }
    HEAP32[$5 + 32 >> 2] = jswGetSymbolListForObjectProto(HEAP32[$5 + 140 >> 2]);
    _jswrap_object_keys_or_property_names_iterator(HEAP32[$5 + 32 >> 2], HEAP32[$5 + 132 >> 2], HEAP32[$5 + 128 >> 2]);
    if (HEAP32[$5 + 52 >> 2] != HEAP32[$5 + 32 >> 2]) {
     _jswrap_object_keys_or_property_names_iterator(HEAP32[$5 + 52 >> 2], HEAP32[$5 + 132 >> 2], HEAP32[$5 + 128 >> 2]);
    }
   }
   jsvUnLock(HEAP32[$5 + 36 >> 2]);
  }
  label$18 : {
   if (!(jsvIsArray(HEAP32[$5 + 140 >> 2]) & 1)) {
    if (!(jsvIsString(HEAP32[$5 + 140 >> 2]) & 1)) {
     break label$18;
    }
   }
   HEAP32[$5 + 28 >> 2] = jsvNewFromString(123254);
   FUNCTION_TABLE[HEAP32[$5 + 132 >> 2]](HEAP32[$5 + 128 >> 2], HEAP32[$5 + 28 >> 2]);
   jsvUnLock(HEAP32[$5 + 28 >> 2]);
  }
 }
 if (jsvIsRoot(HEAP32[$5 + 140 >> 2]) & 1) {
  HEAP32[$5 + 24 >> 2] = 0;
  while (1) {
   if (HEAP32[$5 + 24 >> 2] < 48) {
    $0 = $5 + 14 | 0;
    jshGetPinString($0, HEAP32[$5 + 24 >> 2] & 255);
    HEAP32[$5 + 8 >> 2] = jsvNewFromString($0);
    FUNCTION_TABLE[HEAP32[$5 + 132 >> 2]](HEAP32[$5 + 128 >> 2], HEAP32[$5 + 8 >> 2]);
    jsvUnLock(HEAP32[$5 + 8 >> 2]);
    HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 24 >> 2] + 1;
    continue;
   }
   break;
  }
 }
 global$0 = $5 + 144 | 0;
}
function gemmlowp__FixedPoint_int_2c_200__20gemmlowp__one_over_one_plus_x_for_x_in_0_1_int__28gemmlowp__FixedPoint_int_2c_200__29($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $1 = global$0 - 208 | 0;
 global$0 = $1;
 $2 = $1 + 152 | 0;
 $3 = $1 + 112 | 0;
 $4 = $1 + 184 | 0;
 $5 = $1 + 120 | 0;
 $6 = $1 + 160 | 0;
 $7 = $1 + 136 | 0;
 HEAP32[$1 + 192 >> 2] = $0;
 HEAP32[$1 + 176 >> 2] = HEAP32[$1 + 192 >> 2];
 HEAP32[$1 + 168 >> 2] = gemmlowp__FixedPoint_int_2c_200___One_28_29();
 HEAP32[$1 + 184 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__RoundingHalfSum_int_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 176 >> 2], HEAP32[$1 + 168 >> 2]);
 HEAP32[$1 + 160 >> 2] = gemmlowp__FixedPoint_int_2c_2012___FromScalarRaw_28int_29(gemmlowp__FixedPoint_int_2c_200___ScalarRawType_20gemmlowp__RescaleConstantInitializer_gemmlowp__FixedPoint_int_2c_200__20__28int_29(1515870810));
 HEAP32[$1 + 152 >> 2] = gemmlowp__FixedPoint_int_2c_2012___FromScalarRaw_28int_29(gemmlowp__FixedPoint_int_2c_200___ScalarRawType_20gemmlowp__RescaleConstantInitializer_gemmlowp__FixedPoint_int_2c_200__20__28int_29(-1010580540));
 HEAP32[$7 >> 2] = HEAP32[$6 >> 2];
 HEAP32[$5 >> 2] = HEAP32[$4 >> 2];
 HEAP32[$3 >> 2] = HEAP32[$2 >> 2];
 HEAP32[$1 + 128 >> 2] = gemmlowp__FixedPoint_int_2c_20_280_29_20__20_280_29__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 120 >> 2], HEAP32[$1 + 112 >> 2]);
 HEAP32[$1 + 144 >> 2] = gemmlowp__FixedPoint_int_2c_2012__20gemmlowp__operator__int_2c_2012__28gemmlowp__FixedPoint_int_2c_2012__2c_20gemmlowp__FixedPoint_int_2c_2012__29(HEAP32[$1 + 136 >> 2], HEAP32[$1 + 128 >> 2]);
 HEAP32[$1 + 108 >> 2] = 0;
 while (1) {
  if (HEAP32[$1 + 108 >> 2] < 3) {
   $2 = $1 + 56 | 0;
   $3 = $1 + 80 | 0;
   $4 = $1 + 16 | 0;
   $5 = $1 + 24 | 0;
   $6 = $1 + 48 | 0;
   $7 = $1 + 104 | 0;
   $8 = $1 - -64 | 0;
   HEAP32[$1 + 96 >> 2] = HEAP32[$1 + 184 >> 2];
   $0 = $1 + 144 | 0;
   HEAP32[$1 + 88 >> 2] = HEAP32[$0 >> 2];
   HEAP32[$1 + 104 >> 2] = gemmlowp__FixedPoint_int_2c_20_280_29_20__20_280_29__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 96 >> 2], HEAP32[$1 + 88 >> 2]);
   HEAP32[$1 + 72 >> 2] = gemmlowp__FixedPoint_int_2c_202___One_28_29();
   HEAP32[$8 >> 2] = HEAP32[$7 >> 2];
   HEAP32[$1 + 80 >> 2] = gemmlowp__FixedPoint_int_2c_205__20gemmlowp__operator__int_2c_205__28gemmlowp__FixedPoint_int_2c_205__2c_20gemmlowp__FixedPoint_int_2c_205__29(HEAP32[$1 + 72 >> 2], HEAP32[$1 + 64 >> 2]);
   HEAP32[$6 >> 2] = HEAP32[$0 >> 2];
   HEAP32[$5 >> 2] = HEAP32[$0 >> 2];
   HEAP32[$4 >> 2] = HEAP32[$3 >> 2];
   HEAP32[$1 + 32 >> 2] = gemmlowp__FixedPoint_int_2c_20_280_29_20__20_280_29__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 24 >> 2], HEAP32[$1 + 16 >> 2]);
   HEAP32[$1 + 40 >> 2] = gemmlowp__FixedPoint_int_2c_202__20gemmlowp__Rescale_2_2c_20int_2c_204__28gemmlowp__FixedPoint_int_2c_204__29(HEAP32[$1 + 32 >> 2]);
   HEAP32[$1 + 56 >> 2] = gemmlowp__FixedPoint_int_2c_2012__20gemmlowp__operator__int_2c_2012__28gemmlowp__FixedPoint_int_2c_2012__2c_20gemmlowp__FixedPoint_int_2c_2012__29(HEAP32[$1 + 48 >> 2], HEAP32[$1 + 40 >> 2]);
   HEAP32[$0 >> 2] = HEAP32[$2 >> 2];
   HEAP32[$1 + 108 >> 2] = HEAP32[$1 + 108 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[$1 >> 2] = HEAP32[$1 + 144 >> 2];
 HEAP32[$1 + 8 >> 2] = gemmlowp__FixedPoint_int_2c_20_28_1_29_20__20_282_29__20gemmlowp__ExactMulByPot__1_2c_20int_2c_202__28gemmlowp__FixedPoint_int_2c_202__29(HEAP32[$1 >> 2]);
 HEAP32[$1 + 200 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__Rescale_0_2c_20int_2c_201__28gemmlowp__FixedPoint_int_2c_201__29(HEAP32[$1 + 8 >> 2]);
 global$0 = $1 + 208 | 0;
 return HEAP32[$1 + 200 >> 2];
}
function __jspeAssignmentExpression($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 label$1 : {
  label$2 : {
   if (HEAP16[HEAP32[35539] + 2 >> 1] == 61 | HEAP16[HEAP32[35539] + 2 >> 1] == 150 | (HEAP16[HEAP32[35539] + 2 >> 1] == 151 | HEAP16[HEAP32[35539] + 2 >> 1] == 154)) {
    break label$2;
   }
   if (HEAP16[HEAP32[35539] + 2 >> 1] == 155 | HEAP16[HEAP32[35539] + 2 >> 1] == 156 | (HEAP16[HEAP32[35539] + 2 >> 1] == 157 | HEAP16[HEAP32[35539] + 2 >> 1] == 159)) {
    break label$2;
   }
   if (HEAP16[HEAP32[35539] + 2 >> 1] == 161 | HEAP16[HEAP32[35539] + 2 >> 1] == 148 | HEAP16[HEAP32[35539] + 2 >> 1] == 144) {
    break label$2;
   }
   if (HEAP16[HEAP32[35539] + 2 >> 1] != 149) {
    break label$1;
   }
  }
  HEAP32[$1 + 20 >> 2] = HEAP16[HEAP32[35539] + 2 >> 1];
  jslGetNextToken();
  HEAP32[$1 + 24 >> 2] = __jspeAssignmentExpression(jspeConditionalExpression());
  HEAP32[$1 + 24 >> 2] = jsvSkipNameAndUnLock(HEAP32[$1 + 24 >> 2]);
  if (!(!HEAP32[$1 + 28 >> 2] | (HEAP32[80549] & 63) != 1)) {
   label$4 : {
    if (HEAP32[$1 + 20 >> 2] == 61) {
     jsvReplaceWithOrAddToRoot(HEAP32[$1 + 28 >> 2], HEAP32[$1 + 24 >> 2]);
     break label$4;
    }
    label$6 : {
     if (HEAP32[$1 + 20 >> 2] == 150) {
      HEAP32[$1 + 20 >> 2] = 43;
      break label$6;
     }
     label$8 : {
      if (HEAP32[$1 + 20 >> 2] == 151) {
       HEAP32[$1 + 20 >> 2] = 45;
       break label$8;
      }
      label$10 : {
       if (HEAP32[$1 + 20 >> 2] == 154) {
        HEAP32[$1 + 20 >> 2] = 42;
        break label$10;
       }
       label$12 : {
        if (HEAP32[$1 + 20 >> 2] == 155) {
         HEAP32[$1 + 20 >> 2] = 47;
         break label$12;
        }
        label$14 : {
         if (HEAP32[$1 + 20 >> 2] == 156) {
          HEAP32[$1 + 20 >> 2] = 37;
          break label$14;
         }
         label$16 : {
          if (HEAP32[$1 + 20 >> 2] == 157) {
           HEAP32[$1 + 20 >> 2] = 38;
           break label$16;
          }
          label$18 : {
           if (HEAP32[$1 + 20 >> 2] == 159) {
            HEAP32[$1 + 20 >> 2] = 124;
            break label$18;
           }
           label$20 : {
            if (HEAP32[$1 + 20 >> 2] == 161) {
             HEAP32[$1 + 20 >> 2] = 94;
             break label$20;
            }
            label$22 : {
             if (HEAP32[$1 + 20 >> 2] == 148) {
              HEAP32[$1 + 20 >> 2] = 146;
              break label$22;
             }
             label$24 : {
              if (HEAP32[$1 + 20 >> 2] == 144) {
               HEAP32[$1 + 20 >> 2] = 143;
               break label$24;
              }
              if (HEAP32[$1 + 20 >> 2] == 149) {
               HEAP32[$1 + 20 >> 2] = 147;
              }
             }
            }
           }
          }
         }
        }
       }
      }
     }
    }
    label$27 : {
     if (HEAP32[$1 + 20 >> 2] != 43) {
      break label$27;
     }
     if (!(jsvIsName(HEAP32[$1 + 28 >> 2]) & 1)) {
      break label$27;
     }
     HEAP32[$1 + 16 >> 2] = jsvSkipName(HEAP32[$1 + 28 >> 2]);
     label$28 : {
      if (!(jsvIsBasicString(HEAP32[$1 + 16 >> 2]) & 1)) {
       break label$28;
      }
      if ((jsvGetRefs(HEAP32[$1 + 16 >> 2]) & 255) != 1 | HEAP32[$1 + 24 >> 2] == HEAP32[$1 + 16 >> 2]) {
       break label$28;
      }
      HEAP32[$1 + 12 >> 2] = jsvAsString(HEAP32[$1 + 24 >> 2]);
      jsvAppendStringVarComplete(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 12 >> 2]);
      jsvUnLock(HEAP32[$1 + 12 >> 2]);
      HEAP32[$1 + 20 >> 2] = 0;
     }
     jsvUnLock(HEAP32[$1 + 16 >> 2]);
    }
    if (HEAP32[$1 + 20 >> 2]) {
     HEAP32[$1 + 8 >> 2] = jsvMathsOpSkipNames(HEAP32[$1 + 28 >> 2], HEAP32[$1 + 24 >> 2], HEAP32[$1 + 20 >> 2]);
     jsvReplaceWith(HEAP32[$1 + 28 >> 2], HEAP32[$1 + 8 >> 2]);
     jsvUnLock(HEAP32[$1 + 8 >> 2]);
    }
   }
  }
  jsvUnLock(HEAP32[$1 + 24 >> 2]);
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function jsserialPopulateUSARTInfo($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $3 = global$0 - 176 | 0;
 global$0 = $3;
 $4 = $3 + 156 | 0;
 $5 = $3 + 160 | 0;
 $6 = $3 + 148 | 0;
 $7 = $3 + 152 | 0;
 HEAP32[$3 + 172 >> 2] = $0;
 HEAP32[$3 + 168 >> 2] = $1;
 HEAP32[$3 + 164 >> 2] = $2;
 jshUSARTInitInfo(HEAP32[$3 + 172 >> 2]);
 HEAP32[$3 + 160 >> 2] = 0;
 HEAP32[$3 + 156 >> 2] = 0;
 HEAP32[$3 + 152 >> 2] = HEAPU8[HEAP32[$3 + 172 >> 2] + 8 | 0];
 HEAP32[$3 + 148 >> 2] = HEAPU8[HEAP32[$3 + 172 >> 2] + 10 | 0];
 HEAP32[$3 + 32 >> 2] = 83389;
 HEAP16[$3 + 36 >> 1] = 12;
 HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 172 >> 2] + 4;
 HEAP32[$3 + 44 >> 2] = 83392;
 HEAP16[$3 + 48 >> 1] = 12;
 HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 172 >> 2] + 5;
 HEAP32[$3 + 56 >> 2] = 83395;
 HEAP16[$3 + 60 >> 1] = 12;
 HEAP32[$3 + 64 >> 2] = HEAP32[$3 + 172 >> 2] + 6;
 HEAP32[$3 + 68 >> 2] = 83398;
 HEAP16[$3 + 72 >> 1] = 12;
 HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 172 >> 2] + 7;
 HEAP32[$3 + 80 >> 2] = 83402;
 HEAP16[$3 + 84 >> 1] = 9;
 HEAP32[$3 + 88 >> 2] = $7;
 HEAP32[$3 + 92 >> 2] = 83411;
 HEAP16[$3 + 96 >> 1] = 9;
 HEAP32[$3 + 100 >> 2] = $6;
 HEAP32[$3 + 104 >> 2] = 83420;
 HEAP16[$3 + 108 >> 1] = 5;
 HEAP32[$3 + 112 >> 2] = $5;
 HEAP32[$3 + 116 >> 2] = 83427;
 HEAP16[$3 + 120 >> 1] = 5;
 HEAP32[$3 + 124 >> 2] = $4;
 HEAP32[$3 + 128 >> 2] = 83432;
 HEAP16[$3 + 132 >> 1] = 11;
 HEAP32[$3 + 136 >> 2] = HEAP32[$3 + 172 >> 2] + 12;
 if (!(jsvIsUndefined(HEAP32[$3 + 168 >> 2]) & 1)) {
  HEAP32[$3 + 28 >> 2] = jsvGetInteger(HEAP32[$3 + 168 >> 2]);
  label$2 : {
   if (!(HEAP32[$3 + 28 >> 2] <= 1e7 ? HEAP32[$3 + 28 >> 2] > 100 : 0)) {
    jsExceptionHere(1, 83439, 0);
    break label$2;
   }
   $0 = HEAP32[$3 + 172 >> 2];
   $1 = HEAP32[$3 + 28 >> 2];
   HEAP8[$0 | 0] = $1;
   HEAP8[$0 + 1 | 0] = $1 >>> 8;
   HEAP8[$0 + 2 | 0] = $1 >>> 16;
   HEAP8[$0 + 3 | 0] = $1 >>> 24;
  }
 }
 HEAP8[$3 + 27 | 0] = 1;
 if (jsvReadConfigObject(HEAP32[$3 + 164 >> 2], $3 + 32 | 0, 9) & 1) {
  HEAP8[HEAP32[$3 + 172 >> 2] + 8 | 0] = HEAP32[$3 + 152 >> 2];
  HEAP8[HEAP32[$3 + 172 >> 2] + 10 | 0] = HEAP32[$3 + 148 >> 2];
  HEAP8[HEAP32[$3 + 172 >> 2] + 9 | 0] = 0;
  label$6 : {
   if (jsvIsString(HEAP32[$3 + 160 >> 2]) & 1) {
    label$8 : {
     if (!(jsvIsStringEqual(HEAP32[$3 + 160 >> 2], 83467) & 1)) {
      if (!(jsvIsStringEqual(HEAP32[$3 + 160 >> 2], 83469) & 1)) {
       break label$8;
      }
     }
     HEAP8[HEAP32[$3 + 172 >> 2] + 9 | 0] = 1;
     break label$6;
    }
    label$10 : {
     if (!(jsvIsStringEqual(HEAP32[$3 + 160 >> 2], 83473) & 1)) {
      if (!(jsvIsStringEqual(HEAP32[$3 + 160 >> 2], 83475) & 1)) {
       break label$10;
      }
     }
     HEAP8[HEAP32[$3 + 172 >> 2] + 9 | 0] = 2;
    }
    break label$6;
   }
   if (jsvIsInt(HEAP32[$3 + 160 >> 2]) & 1) {
    $0 = jsvGetInteger(HEAP32[$3 + 160 >> 2]);
    HEAP8[HEAP32[$3 + 172 >> 2] + 9 | 0] = $0;
   }
  }
  if (HEAPU8[HEAP32[$3 + 172 >> 2] + 9 | 0] > 2) {
   HEAP32[$3 + 16 >> 2] = HEAPU8[HEAP32[$3 + 172 >> 2] + 9 | 0];
   jsExceptionHere(1, 83480, $3 + 16 | 0);
   HEAP8[$3 + 27 | 0] = 0;
  }
  if (HEAP8[$3 + 27 | 0] & 1) {
   label$15 : {
    label$16 : {
     label$17 : {
      if (jsvIsUndefined(HEAP32[$3 + 156 >> 2]) & 1) {
       break label$17;
      }
      if (jsvIsNull(HEAP32[$3 + 156 >> 2]) & 1) {
       break label$17;
      }
      if (!(jsvIsStringEqual(HEAP32[$3 + 156 >> 2], 83498) & 1)) {
       break label$16;
      }
     }
     HEAP8[HEAP32[$3 + 172 >> 2] + 11 | 0] = 0;
     break label$15;
    }
    label$18 : {
     if (jsvIsStringEqual(HEAP32[$3 + 156 >> 2], 83503) & 1) {
      HEAP8[HEAP32[$3 + 172 >> 2] + 11 | 0] = 1;
      break label$18;
     }
     HEAP32[$3 >> 2] = HEAP32[$3 + 156 >> 2];
     jsExceptionHere(1, 83507, $3);
     HEAP8[$3 + 27 | 0] = 0;
    }
   }
  }
 }
 jsvUnLock(HEAP32[$3 + 160 >> 2]);
 jsvUnLock(HEAP32[$3 + 156 >> 2]);
 global$0 = $3 + 176 | 0;
 return HEAP8[$3 + 27 | 0] & 1;
}
function tflite__reference_ops__FullyConnected_28tflite__FullyConnectedParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20short__29($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0;
 $9 = global$0 - 112 | 0;
 global$0 = $9;
 HEAP32[$9 + 108 >> 2] = $0;
 HEAP32[$9 + 104 >> 2] = $1;
 HEAP32[$9 + 100 >> 2] = $2;
 HEAP32[$9 + 96 >> 2] = $3;
 HEAP32[$9 + 92 >> 2] = $4;
 HEAP32[$9 + 88 >> 2] = $5;
 HEAP32[$9 + 84 >> 2] = $6;
 HEAP32[$9 + 80 >> 2] = $7;
 HEAP32[$9 + 76 >> 2] = $8;
 HEAP32[$9 + 72 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] >> 2];
 HEAP32[$9 + 68 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 4 >> 2];
 HEAP32[$9 + 64 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 8 >> 2];
 HEAP32[$9 + 60 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 12 >> 2];
 HEAP32[$9 + 56 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 16 >> 2];
 HEAP32[$9 + 52 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 20 >> 2];
 HEAP32[$9 + 48 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 24 >> 2];
 label$1 : {
  if (HEAP32[$9 + 52 >> 2] > HEAP32[$9 + 48 >> 2]) {
   break label$1;
  }
 }
 label$2 : {
  if (HEAP32[$9 + 64 >> 2]) {
   break label$2;
  }
 }
 HEAP32[$9 + 44 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 80 >> 2]);
 HEAP32[$9 + 40 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 96 >> 2]);
 HEAP32[$9 + 36 >> 2] = tflite__FlatSizeSkipDim_28tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$9 + 80 >> 2], HEAP32[$9 + 44 >> 2] - 1 | 0);
 HEAP32[$9 + 32 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$9 + 96 >> 2], HEAP32[$9 + 40 >> 2] - 2 | 0, HEAP32[$9 + 80 >> 2], HEAP32[$9 + 44 >> 2] - 1 | 0);
 HEAP32[$9 + 28 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 96 >> 2], HEAP32[$9 + 40 >> 2] - 1 | 0);
 HEAP32[$9 + 24 >> 2] = 0;
 while (1) {
  if (HEAP32[$9 + 24 >> 2] < HEAP32[$9 + 36 >> 2]) {
   HEAP32[$9 + 20 >> 2] = 0;
   while (1) {
    if (HEAP32[$9 + 20 >> 2] < HEAP32[$9 + 32 >> 2]) {
     HEAP32[$9 + 16 >> 2] = HEAP32[HEAP32[$9 + 84 >> 2] + (HEAP32[$9 + 20 >> 2] << 2) >> 2];
     HEAP32[$9 + 12 >> 2] = 0;
     while (1) {
      if (HEAP32[$9 + 12 >> 2] < HEAP32[$9 + 28 >> 2]) {
       HEAP16[$9 + 10 >> 1] = HEAPU8[HEAP32[$9 + 100 >> 2] + (HEAP32[$9 + 12 >> 2] + Math_imul(HEAP32[$9 + 24 >> 2], HEAP32[$9 + 28 >> 2]) | 0) | 0] + HEAP32[$9 + 72 >> 2];
       HEAP16[$9 + 8 >> 1] = HEAPU8[HEAP32[$9 + 92 >> 2] + (HEAP32[$9 + 12 >> 2] + Math_imul(HEAP32[$9 + 20 >> 2], HEAP32[$9 + 28 >> 2]) | 0) | 0] + HEAP32[$9 + 68 >> 2];
       HEAP32[$9 + 16 >> 2] = HEAP32[$9 + 16 >> 2] + Math_imul(HEAP16[$9 + 8 >> 1], HEAP16[$9 + 10 >> 1]);
       HEAP32[$9 + 12 >> 2] = HEAP32[$9 + 12 >> 2] + 1;
       continue;
      }
      break;
     }
     $0 = $9 + 16 | 0;
     $1 = $9 + 4 | 0;
     HEAP32[$9 + 16 >> 2] = tflite__MultiplyByQuantizedMultiplier_28int_2c_20int_2c_20int_29(HEAP32[$9 + 16 >> 2], HEAP32[$9 + 60 >> 2], HEAP32[$9 + 56 >> 2]);
     HEAP32[$9 + 4 >> 2] = HEAP32[$9 + 52 >> 2] - HEAP32[$9 + 64 >> 2];
     HEAP32[$9 + 16 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($0, $1) >> 2];
     HEAP32[$9 >> 2] = HEAP32[$9 + 48 >> 2] - HEAP32[$9 + 64 >> 2];
     HEAP32[$9 + 16 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($0, $9) >> 2];
     HEAP32[$9 + 16 >> 2] = HEAP32[$9 + 64 >> 2] + HEAP32[$9 + 16 >> 2];
     HEAP16[HEAP32[$9 + 76 >> 2] + (HEAP32[$9 + 20 >> 2] + Math_imul(HEAP32[$9 + 32 >> 2], HEAP32[$9 + 24 >> 2]) << 1) >> 1] = HEAP32[$9 + 16 >> 2];
     HEAP32[$9 + 20 >> 2] = HEAP32[$9 + 20 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$9 + 24 >> 2] = HEAP32[$9 + 24 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $9 + 112 | 0;
}
function jswrap_function_bind($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 80 | 0;
 global$0 = $3;
 HEAP32[$3 + 72 >> 2] = $0;
 HEAP32[$3 + 68 >> 2] = $1;
 HEAP32[$3 + 64 >> 2] = $2;
 label$1 : {
  if (!(jsvIsFunction(HEAP32[$3 + 72 >> 2]) & 1)) {
   HEAP32[$3 >> 2] = HEAP32[$3 + 72 >> 2];
   jsExceptionHere(3, 124250, $3);
   HEAP32[$3 + 76 >> 2] = 0;
   break label$1;
  }
  label$3 : {
   if (jsvIsNativeFunction(HEAP32[$3 + 72 >> 2]) & 1) {
    $0 = HEAP32[$3 + 72 >> 2];
    $1 = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
    $0 = HEAP32[$3 + 72 >> 2];
    HEAP32[$3 + 60 >> 2] = jsvNewNativeFunction($1, HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8);
    break label$3;
   }
   HEAP32[$3 + 60 >> 2] = jsvNewWithFlags((jsvIsFunctionReturn(HEAP32[$3 + 72 >> 2]) & 1 ? 8 : 7) & 65535);
  }
  if (!HEAP32[$3 + 60 >> 2]) {
   HEAP32[$3 + 76 >> 2] = 0;
   break label$1;
  }
  jsvObjectIteratorNew($3 + 56 | 0, HEAP32[$3 + 72 >> 2]);
  while (1) {
   label$7 : {
    if (!(jsvObjectIteratorHasValue($3 + 56 | 0) & 1)) {
     break label$7;
    }
    $0 = $3 + 56 | 0;
    HEAP32[$3 + 52 >> 2] = jsvObjectIteratorGetKey($0);
    HEAP32[$3 + 48 >> 2] = jsvObjectIteratorGetValue($0);
    $1 = jsvIsFunctionParameter(HEAP32[$3 + 52 >> 2]) & 1;
    HEAP8[$3 + 47 | 0] = $1 ? HEAP32[$3 + 48 >> 2] != 0 : 0;
    if (HEAP8[$3 + 47 | 0] & 1) {
     HEAP32[$3 + 40 >> 2] = jsvCopy(HEAP32[$3 + 52 >> 2], 1);
     if (HEAP32[$3 + 40 >> 2]) {
      jsvAddName(HEAP32[$3 + 60 >> 2], HEAP32[$3 + 40 >> 2]);
      jsvUnLock(HEAP32[$3 + 40 >> 2]);
     }
    }
    jsvUnLock2(HEAP32[$3 + 52 >> 2], HEAP32[$3 + 48 >> 2]);
    if (!(HEAP8[$3 + 47 | 0] & 1)) {
     break label$7;
    }
    jsvObjectIteratorNext($3 + 56 | 0);
    continue;
   }
   break;
  }
  if (HEAP32[$3 + 64 >> 2]) {
   jsvObjectIteratorNew($3 + 32 | 0, HEAP32[$3 + 64 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue($3 + 32 | 0) & 1) {
     HEAP32[$3 + 28 >> 2] = jsvObjectIteratorGetValue($3 + 32 | 0);
     HEAP8[$3 + 27 | 0] = 0;
     while (1) {
      label$16 : {
       if (HEAP8[$3 + 27 | 0] & 1) {
        $0 = 0;
       } else {
        $0 = jsvObjectIteratorHasValue($3 + 56 | 0);
       }
       if (!($0 & 1)) {
        break label$16;
       }
       HEAP32[$3 + 20 >> 2] = jsvObjectIteratorGetKey($3 + 56 | 0);
       if (!(jsvIsFunctionParameter(HEAP32[$3 + 20 >> 2]) & 1)) {
        jsvUnLock(HEAP32[$3 + 20 >> 2]);
        break label$16;
       }
       $0 = $3 + 56 | 0;
       HEAP32[$3 + 16 >> 2] = jsvCopyNameOnly(HEAP32[$3 + 20 >> 2], 0, 1);
       jsvSetValueOfName(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 28 >> 2]);
       jsvAddName(HEAP32[$3 + 60 >> 2], HEAP32[$3 + 16 >> 2]);
       HEAP8[$3 + 27 | 0] = 1;
       jsvUnLock2(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 16 >> 2]);
       jsvObjectIteratorNext($0);
       continue;
      }
      break;
     }
     if (!(HEAP8[$3 + 27 | 0] & 1)) {
      jsvAddFunctionParameter(HEAP32[$3 + 60 >> 2], 0, HEAP32[$3 + 28 >> 2]);
     }
     $0 = $3 + 32 | 0;
     jsvUnLock(HEAP32[$3 + 28 >> 2]);
     jsvObjectIteratorNext($0);
     continue;
    }
    break;
   }
   jsvObjectIteratorFree($3 + 32 | 0);
  }
  while (1) {
   if (jsvObjectIteratorHasValue($3 + 56 | 0) & 1) {
    HEAP32[$3 + 12 >> 2] = jsvObjectIteratorGetKey($3 + 56 | 0);
    HEAP32[$3 + 8 >> 2] = jsvCopyNameOnly(HEAP32[$3 + 12 >> 2], 1, 1);
    if (HEAP32[$3 + 8 >> 2]) {
     jsvAddName(HEAP32[$3 + 60 >> 2], HEAP32[$3 + 8 >> 2]);
     jsvUnLock(HEAP32[$3 + 8 >> 2]);
    }
    $0 = $3 + 56 | 0;
    jsvUnLock(HEAP32[$3 + 12 >> 2]);
    jsvObjectIteratorNext($0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree($3 + 56 | 0);
  jsvObjectSetChild(HEAP32[$3 + 60 >> 2], 124305, HEAP32[$3 + 68 >> 2]);
  HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 60 >> 2];
 }
 global$0 = $3 + 80 | 0;
 return HEAP32[$3 + 76 >> 2];
}
function jsfWriteFile($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 $6 = global$0 - 128 | 0;
 $5 = $6;
 global$0 = $5;
 HEAP32[$5 + 120 >> 2] = $1;
 HEAP32[$5 + 116 >> 2] = $2;
 HEAP32[$5 + 112 >> 2] = $3;
 HEAP32[$5 + 108 >> 2] = $4;
 label$1 : {
  if (!(HEAP32[$5 + 108 >> 2] >= 0 ? HEAP32[$5 + 112 >> 2] >= 0 : 0)) {
   HEAP8[$5 + 127 | 0] = 0;
   break label$1;
  }
  HEAP32[$5 + 104 >> 2] = HEAP32[$5 + 108 >> 2];
  HEAP32[$5 + 100 >> 2] = 0;
  HEAP32[$5 + 96 >> 2] = jsvGetDataPointer(HEAP32[$5 + 120 >> 2], $5 + 100 | 0);
  if (!(HEAP32[$5 + 96 >> 2] | !HEAP32[$5 + 120 >> 2])) {
   HEAP32[$5 + 100 >> 2] = jsvIterateCallbackCount(HEAP32[$5 + 120 >> 2]);
   label$5 : {
    if (HEAP32[$5 + 100 >> 2] + 256 >>> 0 > 1e6) {
     jsExceptionHere(1, 78043, 0);
     break label$5;
    }
    $1 = $6 - (HEAP32[$5 + 100 >> 2] + 15 & -16) | 0;
    global$0 = $1;
    HEAP32[$5 + 96 >> 2] = $1;
    jsvIterateCallbackToBytes(HEAP32[$5 + 120 >> 2], HEAP32[$5 + 96 >> 2], HEAP32[$5 + 100 >> 2]);
   }
  }
  if (!HEAP32[$5 + 96 >> 2]) {
   HEAP8[$5 + 127 | 0] = 0;
   break label$1;
  }
  if (!HEAP32[$5 + 104 >> 2]) {
   HEAP32[$5 + 104 >> 2] = HEAP32[$5 + 100 >> 2];
  }
  HEAP32[$5 + 56 >> 2] = HEAP32[$0 + 24 >> 2];
  $2 = HEAP32[$0 + 20 >> 2];
  HEAP32[$5 + 48 >> 2] = HEAP32[$0 + 16 >> 2];
  HEAP32[$5 + 52 >> 2] = $2;
  $2 = HEAP32[$0 + 12 >> 2];
  HEAP32[$5 + 40 >> 2] = HEAP32[$0 + 8 >> 2];
  HEAP32[$5 + 44 >> 2] = $2;
  $2 = HEAP32[$0 + 4 >> 2];
  HEAP32[$5 + 32 >> 2] = HEAP32[$0 >> 2];
  HEAP32[$5 + 36 >> 2] = $2;
  HEAP32[$5 + 60 >> 2] = jsfFindFile($5 + 32 | 0, $5 - -64 | 0);
  label$9 : {
   label$10 : {
    if (HEAP32[$5 + 112 >> 2] ? 0 : !HEAP32[$5 + 60 >> 2]) {
     break label$10;
    }
    if (HEAP32[$5 + 112 >> 2] | !HEAP32[$5 + 60 >> 2]) {
     break label$9;
    }
    if (HEAP32[$5 + 116 >> 2] != (jsfGetFileFlags($5 - -64 | 0) | 0)) {
     break label$10;
    }
    if (HEAP32[$5 + 104 >> 2] != (jsfGetFileSize($5 - -64 | 0) | 0)) {
     break label$10;
    }
    if (jsfIsErased(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 104 >> 2]) & 1) {
     break label$9;
    }
   }
   label$12 : {
    if (HEAP32[$5 + 112 >> 2] | !HEAP32[$5 + 60 >> 2]) {
     break label$12;
    }
    if (HEAP32[$5 + 104 >> 2] != (jsfGetFileSize($5 - -64 | 0) | 0)) {
     break label$12;
    }
    if (HEAP32[$5 + 116 >> 2] != (jsfGetFileFlags($5 - -64 | 0) | 0) | HEAP32[$5 + 100 >> 2] != HEAP32[$5 + 104 >> 2]) {
     break label$12;
    }
    if (!(jsfIsEqual(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 96 >> 2], HEAP32[$5 + 100 >> 2]) & 1)) {
     break label$12;
    }
    HEAP8[$5 + 127 | 0] = 1;
    break label$1;
   }
   if (HEAP32[$5 + 60 >> 2]) {
    jsfEraseFileInternal(HEAP32[$5 + 60 >> 2], $5 - -64 | 0);
   }
   $1 = HEAP32[$5 + 104 >> 2];
   $2 = HEAP32[$5 + 116 >> 2];
   HEAP32[$5 + 24 >> 2] = HEAP32[$0 + 24 >> 2];
   $3 = HEAP32[$0 + 20 >> 2];
   HEAP32[$5 + 16 >> 2] = HEAP32[$0 + 16 >> 2];
   HEAP32[$5 + 20 >> 2] = $3;
   $3 = HEAP32[$0 + 12 >> 2];
   HEAP32[$5 + 8 >> 2] = HEAP32[$0 + 8 >> 2];
   HEAP32[$5 + 12 >> 2] = $3;
   $3 = HEAP32[$0 + 4 >> 2];
   HEAP32[$5 >> 2] = HEAP32[$0 >> 2];
   HEAP32[$5 + 4 >> 2] = $3;
   HEAP32[$5 + 60 >> 2] = jsfCreateFile($5, $1, $2, $5 - -64 | 0);
  }
  if (!HEAP32[$5 + 60 >> 2]) {
   jsExceptionHere(1, 78082, 0);
   HEAP8[$5 + 127 | 0] = 0;
   break label$1;
  }
  if (HEAP32[$5 + 112 >> 2] + HEAP32[$5 + 100 >> 2] >>> 0 > jsfGetFileSize($5 - -64 | 0) >>> 0) {
   jsExceptionHere(1, 78112, 0);
   HEAP8[$5 + 127 | 0] = 0;
   break label$1;
  }
  HEAP32[$5 + 60 >> 2] = HEAP32[$5 + 112 >> 2] + HEAP32[$5 + 60 >> 2];
  if (!(jsfIsErased(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 100 >> 2]) & 1)) {
   jsExceptionHere(1, 78140, 0);
   HEAP8[$5 + 127 | 0] = 0;
   break label$1;
  }
  jshFlashWriteAligned(HEAP32[$5 + 96 >> 2], HEAP32[$5 + 60 >> 2], HEAP32[$5 + 100 >> 2]);
  HEAP8[$5 + 127 | 0] = 1;
 }
 global$0 = $5 + 128 | 0;
 return HEAP8[$5 + 127 | 0] & 1;
}
function _ZN17compiler_builtins3int4udiv10divmod_u6417h6026910b5ed08e40E($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0;
 label$1 : {
  label$2 : {
   label$3 : {
    label$4 : {
     label$5 : {
      label$6 : {
       label$7 : {
        label$8 : {
         label$9 : {
          label$11 : {
           $6 = $1;
           if ($6) {
            $4 = $2;
            if (!$4) {
             break label$11;
            }
            $5 = $3;
            if (!$5) {
             break label$9;
            }
            $4 = Math_clz32($5) - Math_clz32($6) | 0;
            if ($4 >>> 0 <= 31) {
             break label$8;
            }
            break label$2;
           }
           if (($3 | 0) == 1 & $2 >>> 0 >= 0 | $3 >>> 0 > 1) {
            break label$2;
           }
           $1 = ($0 >>> 0) / ($2 >>> 0) | 0;
           legalfunc$wasm2js_scratch_store_i64($0 - Math_imul($1, $2) | 0, 0);
           i64toi32_i32$HIGH_BITS = 0;
           return $1;
          }
          $4 = $3;
          if (!$0) {
           break label$7;
          }
          if (!$4) {
           break label$6;
          }
          $5 = $4 + -1 | 0;
          if ($5 & $4) {
           break label$6;
          }
          legalfunc$wasm2js_scratch_store_i64($0, $6 & $5);
          $0 = $6 >>> (__wasm_ctz_i32($4) & 31);
          i64toi32_i32$HIGH_BITS = 0;
          return $0;
         }
         $5 = $4 + -1 | 0;
         if (!($5 & $4)) {
          break label$5;
         }
         $8 = (Math_clz32($4) + 33 | 0) - Math_clz32($6) | 0;
         $9 = 0 - $8 | 0;
         break label$3;
        }
        $8 = $4 + 1 | 0;
        $9 = 63 - $4 | 0;
        break label$3;
       }
       $0 = ($6 >>> 0) / ($4 >>> 0) | 0;
       legalfunc$wasm2js_scratch_store_i64(0, $6 - Math_imul($0, $4) | 0);
       i64toi32_i32$HIGH_BITS = 0;
       return $0;
      }
      $4 = Math_clz32($4) - Math_clz32($6) | 0;
      if ($4 >>> 0 < 31) {
       break label$4;
      }
      break label$2;
     }
     legalfunc$wasm2js_scratch_store_i64($0 & $5, 0);
     if (($4 | 0) == 1) {
      break label$1;
     }
     $2 = __wasm_ctz_i32($4);
     $3 = $0;
     $0 = $2 & 31;
     if (32 <= ($2 & 63) >>> 0) {
      $4 = 0;
      $0 = $1 >>> $0;
     } else {
      $4 = $1 >>> $0;
      $0 = ((1 << $0) - 1 & $1) << 32 - $0 | $3 >>> $0;
     }
     i64toi32_i32$HIGH_BITS = $4;
     return $0;
    }
    $8 = $4 + 1 | 0;
    $9 = 63 - $4 | 0;
   }
   $5 = $1;
   $12 = $0;
   $4 = $8 & 63;
   $6 = $4 & 31;
   if (32 <= ($4 & 63) >>> 0) {
    $4 = 0;
    $7 = $5 >>> $6;
   } else {
    $4 = $5 >>> $6;
    $7 = ((1 << $6) - 1 & $5) << 32 - $6 | $12 >>> $6;
   }
   $5 = $4;
   $6 = $0;
   $4 = $9 & 63;
   $0 = $4 & 31;
   if (32 <= ($4 & 63) >>> 0) {
    $4 = $6 << $0;
    $0 = 0;
   } else {
    $4 = (1 << $0) - 1 & $6 >>> 32 - $0 | $1 << $0;
    $0 = $6 << $0;
   }
   $1 = $4;
   if ($8) {
    $4 = $3 + -1 | 0;
    $6 = $2 + -1 | 0;
    if ($6 >>> 0 < 4294967295) {
     $4 = $4 + 1 | 0;
    }
    $9 = $4;
    while (1) {
     $4 = $5 << 1 | $7 >>> 31;
     $5 = $7 << 1;
     $12 = $4;
     $5 = $1 >>> 31 | $5;
     $11 = $5;
     $7 = $9 - (($6 >>> 0 < $5 >>> 0) + $4 | 0) | 0;
     $4 = $7 >> 31;
     $10 = $7 >> 31;
     $5 = $2 & $10;
     $7 = $11 - $5 | 0;
     $5 = $12 - (($3 & $4) + ($11 >>> 0 < $5 >>> 0) | 0) | 0;
     $4 = $1 << 1 | $0 >>> 31;
     $0 = $13 | $0 << 1;
     $1 = $4 | $14;
     $11 = 0;
     $10 = $10 & 1;
     $13 = $10;
     $8 = $8 + -1 | 0;
     if ($8) {
      continue;
     }
     break;
    }
   }
   legalfunc$wasm2js_scratch_store_i64($7, $5);
   $4 = $1 << 1 | $0 >>> 31;
   $0 = $10 | $0 << 1;
   i64toi32_i32$HIGH_BITS = $4 | $11;
   return $0;
  }
  legalfunc$wasm2js_scratch_store_i64($0, $1);
  $0 = 0;
  $1 = 0;
 }
 i64toi32_i32$HIGH_BITS = $1;
 return $0;
}
function jswrap_string_split($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = global$0 + -64 | 0;
 global$0 = $2;
 HEAP32[$2 + 56 >> 2] = $0;
 HEAP32[$2 + 52 >> 2] = $1;
 label$1 : {
  if (!(jsvIsString(HEAP32[$2 + 56 >> 2]) & 1)) {
   HEAP32[$2 + 60 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 48 >> 2] = jsvNewWithFlags(3);
  if (!HEAP32[$2 + 48 >> 2]) {
   HEAP32[$2 + 60 >> 2] = 0;
   break label$1;
  }
  if (jsvIsUndefined(HEAP32[$2 + 52 >> 2]) & 1) {
   jsvArrayPush(HEAP32[$2 + 48 >> 2], HEAP32[$2 + 56 >> 2]);
   HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 48 >> 2];
   break label$1;
  }
  if (jsvIsInstanceOf(HEAP32[$2 + 52 >> 2], 126e3) & 1) {
   HEAP32[$2 + 44 >> 2] = 0;
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 52 >> 2], 126007, jsvNewFromInteger(0));
   HEAP32[$2 + 40 >> 2] = jswrap_regexp_exec(HEAP32[$2 + 52 >> 2], HEAP32[$2 + 56 >> 2]);
   while (1) {
    if (HEAP32[$2 + 40 >> 2]) {
     $0 = jsvIsNull(HEAP32[$2 + 40 >> 2]) ^ -1;
    } else {
     $0 = 0;
    }
    if ($0 & 1) {
     HEAP32[$2 + 36 >> 2] = jsvGetArrayItem(HEAP32[$2 + 40 >> 2], 0);
     HEAP32[$2 + 32 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$2 + 40 >> 2], 126017, 0));
     HEAP32[$2 + 28 >> 2] = jsvGetStringLength(HEAP32[$2 + 36 >> 2]);
     jsvUnLock(HEAP32[$2 + 36 >> 2]);
     jsvArrayPushAndUnLock(HEAP32[$2 + 48 >> 2], jsvNewFromStringVar(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 44 >> 2], HEAP32[$2 + 32 >> 2] - HEAP32[$2 + 44 >> 2] | 0));
     HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2] + HEAP32[$2 + 28 >> 2];
     jsvUnLock(HEAP32[$2 + 40 >> 2]);
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 52 >> 2], 126007, jsvNewFromInteger(HEAP32[$2 + 44 >> 2]));
     HEAP32[$2 + 40 >> 2] = jswrap_regexp_exec(HEAP32[$2 + 52 >> 2], HEAP32[$2 + 56 >> 2]);
     continue;
    }
    break;
   }
   jsvUnLock(HEAP32[$2 + 40 >> 2]);
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 52 >> 2], 126007, jsvNewFromInteger(0));
   if (HEAP32[$2 + 44 >> 2] <= (jsvGetStringLength(HEAP32[$2 + 56 >> 2]) | 0)) {
    jsvArrayPushAndUnLock(HEAP32[$2 + 48 >> 2], jsvNewFromStringVar(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 44 >> 2], 2147483647));
   }
   HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 48 >> 2];
   break label$1;
  }
  HEAP32[$2 + 52 >> 2] = jsvAsString(HEAP32[$2 + 52 >> 2]);
  HEAP32[$2 + 20 >> 2] = 0;
  $1 = $2;
  $0 = jsvIsUndefined(HEAP32[$2 + 52 >> 2]) & 1;
  $3 = 0;
  label$11 : {
   if ($0) {
    break label$11;
   }
   $3 = jsvGetStringLength(HEAP32[$2 + 52 >> 2]);
  }
  HEAP32[$1 + 16 >> 2] = $3;
  HEAP32[$2 + 12 >> 2] = (jsvGetStringLength(HEAP32[$2 + 56 >> 2]) + 1 | 0) - HEAP32[$2 + 16 >> 2];
  HEAP32[$2 + 24 >> 2] = 0;
  while (1) {
   label$13 : {
    if (HEAP32[$2 + 24 >> 2] > HEAP32[$2 + 12 >> 2]) {
     break label$13;
    }
    if (HEAP32[$2 + 16 >> 2] | HEAP32[$2 + 24 >> 2]) {
     label$16 : {
      if (!(!HEAP32[$2 + 16 >> 2] | HEAP32[$2 + 24 >> 2] == HEAP32[$2 + 12 >> 2])) {
       if (jsvCompareString(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 52 >> 2], HEAP32[$2 + 24 >> 2], 1)) {
        break label$16;
       }
      }
      if (HEAP32[$2 + 24 >> 2] == HEAP32[$2 + 12 >> 2]) {
       HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 12 >> 2] + HEAP32[$2 + 16 >> 2];
       if (!HEAP32[$2 + 16 >> 2]) {
        break label$13;
       }
      }
      HEAP32[$2 + 8 >> 2] = jsvNewFromStringVar(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 24 >> 2] - HEAP32[$2 + 20 >> 2] | 0);
      if (!HEAP32[$2 + 8 >> 2]) {
       break label$13;
      }
      jsvArrayPush(HEAP32[$2 + 48 >> 2], HEAP32[$2 + 8 >> 2]);
      jsvUnLock(HEAP32[$2 + 8 >> 2]);
      HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 24 >> 2] + HEAP32[$2 + 16 >> 2];
     }
    }
    HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 24 >> 2] + 1;
    continue;
   }
   break;
  }
  jsvUnLock(HEAP32[$2 + 52 >> 2]);
  HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 48 >> 2];
 }
 global$0 = $2 - -64 | 0;
 return HEAP32[$2 + 60 >> 2];
}
function jsvAsString($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = global$0 - 112 | 0;
 global$0 = $1;
 HEAP32[$1 + 108 >> 2] = $0;
 HEAP32[$1 + 104 >> 2] = 0;
 label$1 : {
  label$2 : {
   if (!(jsvHasCharacterData(HEAP32[$1 + 108 >> 2]) & 1)) {
    break label$2;
   }
   if (!(jsvIsName(HEAP32[$1 + 108 >> 2]) & 1)) {
    break label$2;
   }
   HEAP32[$1 + 104 >> 2] = jsvNewFromStringVar(HEAP32[$1 + 108 >> 2], 0, 2147483647);
   break label$1;
  }
  label$3 : {
   if (jsvIsString(HEAP32[$1 + 108 >> 2]) & 1) {
    HEAP32[$1 + 104 >> 2] = jsvLockAgain(HEAP32[$1 + 108 >> 2]);
    break label$3;
   }
   label$5 : {
    if (jsvIsObject(HEAP32[$1 + 108 >> 2]) & 1) {
     HEAP32[$1 + 100 >> 2] = jspGetNamedField(HEAP32[$1 + 108 >> 2], 78484, 0);
     label$7 : {
      label$8 : {
       if (!HEAP32[$1 + 100 >> 2]) {
        break label$8;
       }
       $0 = HEAP32[$1 + 100 >> 2];
       if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 1) {
        break label$8;
       }
       HEAP32[$1 + 96 >> 2] = jspExecuteFunction(HEAP32[$1 + 100 >> 2], HEAP32[$1 + 108 >> 2], 0, 0);
       jsvUnLock(HEAP32[$1 + 100 >> 2]);
       HEAP32[$1 + 104 >> 2] = jsvAsStringAndUnLock(HEAP32[$1 + 96 >> 2]);
       break label$7;
      }
      jsvUnLock(HEAP32[$1 + 100 >> 2]);
      HEAP32[$1 + 104 >> 2] = jsvNewFromString(78493);
     }
     break label$5;
    }
    HEAP32[$1 + 92 >> 2] = jsvGetConstString(HEAP32[$1 + 108 >> 2]);
    label$9 : {
     if (HEAP32[$1 + 92 >> 2]) {
      HEAP32[$1 + 104 >> 2] = jsvNewFromString(HEAP32[$1 + 92 >> 2]);
      break label$9;
     }
     label$11 : {
      if (jsvIsPin(HEAP32[$1 + 108 >> 2]) & 1) {
       $2 = $1 + 16 | 0;
       $0 = HEAP32[$1 + 108 >> 2];
       jshGetPinString($2, (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) & 255);
       HEAP32[$1 + 104 >> 2] = jsvNewFromString($2);
       break label$11;
      }
      label$13 : {
       if (jsvIsInt(HEAP32[$1 + 108 >> 2]) & 1) {
        $0 = HEAP32[$1 + 108 >> 2];
        $2 = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
        $0 = $1 + 16 | 0;
        itostr($2, $0, 10);
        HEAP32[$1 + 104 >> 2] = jsvNewFromString($0);
        break label$13;
       }
       label$15 : {
        if (jsvIsFloat(HEAP32[$1 + 108 >> 2]) & 1) {
         $0 = HEAP32[$1 + 108 >> 2];
         $2 = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
         $0 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
         wasm2js_scratch_store_i32(0, $2 | 0);
         wasm2js_scratch_store_i32(1, $0 | 0);
         $3 = +wasm2js_scratch_load_f64();
         $0 = $1 + 16 | 0;
         ftoa_bounded($3, $0, 70);
         HEAP32[$1 + 104 >> 2] = jsvNewFromString($0);
         break label$15;
        }
        label$17 : {
         label$18 : {
          if (!(jsvIsArray(HEAP32[$1 + 108 >> 2]) & 1)) {
           if (!(jsvIsArrayBuffer(HEAP32[$1 + 108 >> 2]) & 1)) {
            break label$18;
           }
          }
          HEAP32[$1 + 12 >> 2] = jsvNewFromString(78509);
          HEAP32[$1 + 104 >> 2] = jsvArrayJoin(HEAP32[$1 + 108 >> 2], HEAP32[$1 + 12 >> 2]);
          jsvUnLock(HEAP32[$1 + 12 >> 2]);
          break label$17;
         }
         label$20 : {
          if (jsvIsFunction(HEAP32[$1 + 108 >> 2]) & 1) {
           HEAP32[$1 + 104 >> 2] = jsvNewWithFlags(27);
           if (HEAP32[$1 + 104 >> 2]) {
            jsfGetJSON(HEAP32[$1 + 108 >> 2], HEAP32[$1 + 104 >> 2], 0);
           }
           break label$20;
          }
          jsExceptionHere(4, 78440, 0);
         }
        }
       }
      }
     }
    }
   }
  }
 }
 global$0 = $1 + 112 | 0;
 return HEAP32[$1 + 104 >> 2];
}
function mbedtls_sha256_finish($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 12 >> 2] = HEAP32[HEAP32[$2 + 28 >> 2] + 4 >> 2] << 3 | HEAP32[HEAP32[$2 + 28 >> 2] >> 2] >>> 29;
 HEAP32[$2 + 8 >> 2] = HEAP32[HEAP32[$2 + 28 >> 2] >> 2] << 3;
 HEAP8[$2 | 0] = HEAP32[$2 + 12 >> 2] >>> 24;
 HEAP8[$2 + 1 | 0] = HEAP32[$2 + 12 >> 2] >>> 16;
 HEAP8[$2 + 2 | 0] = HEAP32[$2 + 12 >> 2] >>> 8;
 HEAP8[$2 + 3 | 0] = HEAP32[$2 + 12 >> 2];
 HEAP8[$2 + 4 | 0] = HEAP32[$2 + 8 >> 2] >>> 24;
 HEAP8[$2 + 5 | 0] = HEAP32[$2 + 8 >> 2] >>> 16;
 HEAP8[$2 + 6 | 0] = HEAP32[$2 + 8 >> 2] >>> 8;
 HEAP8[$2 + 7 | 0] = HEAP32[$2 + 8 >> 2];
 HEAP32[$2 + 20 >> 2] = HEAP32[HEAP32[$2 + 28 >> 2] >> 2] & 63;
 $0 = $2;
 if (HEAPU32[$2 + 20 >> 2] < 56) {
  $1 = 56 - HEAP32[$2 + 20 >> 2] | 0;
 } else {
  $1 = 120 - HEAP32[$2 + 20 >> 2] | 0;
 }
 HEAP32[$0 + 16 >> 2] = $1;
 mbedtls_sha256_update(HEAP32[$2 + 28 >> 2], 108736, HEAP32[$2 + 16 >> 2]);
 mbedtls_sha256_update(HEAP32[$2 + 28 >> 2], $2, 8);
 HEAP8[HEAP32[$2 + 24 >> 2]] = HEAP32[HEAP32[$2 + 28 >> 2] + 8 >> 2] >>> 24;
 HEAP8[HEAP32[$2 + 24 >> 2] + 1 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 8 >> 2] >>> 16;
 HEAP8[HEAP32[$2 + 24 >> 2] + 2 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 8 >> 2] >>> 8;
 HEAP8[HEAP32[$2 + 24 >> 2] + 3 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 8 >> 2];
 HEAP8[HEAP32[$2 + 24 >> 2] + 4 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 12 >> 2] >>> 24;
 HEAP8[HEAP32[$2 + 24 >> 2] + 5 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 12 >> 2] >>> 16;
 HEAP8[HEAP32[$2 + 24 >> 2] + 6 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 12 >> 2] >>> 8;
 HEAP8[HEAP32[$2 + 24 >> 2] + 7 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 12 >> 2];
 HEAP8[HEAP32[$2 + 24 >> 2] + 8 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 16 >> 2] >>> 24;
 HEAP8[HEAP32[$2 + 24 >> 2] + 9 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 16 >> 2] >>> 16;
 HEAP8[HEAP32[$2 + 24 >> 2] + 10 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 16 >> 2] >>> 8;
 HEAP8[HEAP32[$2 + 24 >> 2] + 11 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 16 >> 2];
 HEAP8[HEAP32[$2 + 24 >> 2] + 12 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 20 >> 2] >>> 24;
 HEAP8[HEAP32[$2 + 24 >> 2] + 13 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 20 >> 2] >>> 16;
 HEAP8[HEAP32[$2 + 24 >> 2] + 14 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 20 >> 2] >>> 8;
 HEAP8[HEAP32[$2 + 24 >> 2] + 15 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 20 >> 2];
 HEAP8[HEAP32[$2 + 24 >> 2] + 16 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 24 >> 2] >>> 24;
 HEAP8[HEAP32[$2 + 24 >> 2] + 17 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 24 >> 2] >>> 16;
 HEAP8[HEAP32[$2 + 24 >> 2] + 18 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 24 >> 2] >>> 8;
 HEAP8[HEAP32[$2 + 24 >> 2] + 19 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 24 >> 2];
 HEAP8[HEAP32[$2 + 24 >> 2] + 20 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 28 >> 2] >>> 24;
 HEAP8[HEAP32[$2 + 24 >> 2] + 21 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 28 >> 2] >>> 16;
 HEAP8[HEAP32[$2 + 24 >> 2] + 22 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 28 >> 2] >>> 8;
 HEAP8[HEAP32[$2 + 24 >> 2] + 23 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 28 >> 2];
 HEAP8[HEAP32[$2 + 24 >> 2] + 24 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 32 >> 2] >>> 24;
 HEAP8[HEAP32[$2 + 24 >> 2] + 25 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 32 >> 2] >>> 16;
 HEAP8[HEAP32[$2 + 24 >> 2] + 26 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 32 >> 2] >>> 8;
 HEAP8[HEAP32[$2 + 24 >> 2] + 27 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 32 >> 2];
 if (!HEAP32[HEAP32[$2 + 28 >> 2] + 104 >> 2]) {
  HEAP8[HEAP32[$2 + 24 >> 2] + 28 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 36 >> 2] >>> 24;
  HEAP8[HEAP32[$2 + 24 >> 2] + 29 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 36 >> 2] >>> 16;
  HEAP8[HEAP32[$2 + 24 >> 2] + 30 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 36 >> 2] >>> 8;
  HEAP8[HEAP32[$2 + 24 >> 2] + 31 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 36 >> 2];
 }
 global$0 = $2 + 32 | 0;
}
function jsvIsBasicVarEqual($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 96 | 0;
 global$0 = $2;
 HEAP32[$2 + 88 >> 2] = $0;
 HEAP32[$2 + 84 >> 2] = $1;
 label$1 : {
  if (HEAP32[$2 + 88 >> 2] == HEAP32[$2 + 84 >> 2]) {
   HEAP8[$2 + 95 | 0] = 1;
   break label$1;
  }
  if (!(HEAP32[$2 + 84 >> 2] ? HEAP32[$2 + 88 >> 2] : 0)) {
   HEAP8[$2 + 95 | 0] = 0;
   break label$1;
  }
  label$5 : {
   if (!(jsvIsNumeric(HEAP32[$2 + 88 >> 2]) & 1)) {
    break label$5;
   }
   if (!(jsvIsNumeric(HEAP32[$2 + 84 >> 2]) & 1)) {
    break label$5;
   }
   if (jsvIsIntegerish(HEAP32[$2 + 88 >> 2]) & 1) {
    if (jsvIsIntegerish(HEAP32[$2 + 84 >> 2]) & 1) {
     $0 = HEAP32[$2 + 88 >> 2];
     $1 = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
     $0 = HEAP32[$2 + 84 >> 2];
     HEAP8[$2 + 95 | 0] = ($1 | 0) == (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24));
     break label$1;
    }
    $0 = HEAP32[$2 + 88 >> 2];
    $3 = +(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24));
    $0 = HEAP32[$2 + 84 >> 2];
    $1 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
    wasm2js_scratch_store_i32(0, HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24));
    wasm2js_scratch_store_i32(1, $1 | 0);
    HEAP8[$2 + 95 | 0] = $3 == +wasm2js_scratch_load_f64();
    break label$1;
   }
   if (jsvIsIntegerish(HEAP32[$2 + 84 >> 2]) & 1) {
    $0 = HEAP32[$2 + 88 >> 2];
    $1 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
    wasm2js_scratch_store_i32(0, HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24));
    wasm2js_scratch_store_i32(1, $1 | 0);
    $3 = +wasm2js_scratch_load_f64();
    $0 = HEAP32[$2 + 84 >> 2];
    HEAP8[$2 + 95 | 0] = $3 == +(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24));
    break label$1;
   }
   $0 = HEAP32[$2 + 88 >> 2];
   $1 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
   wasm2js_scratch_store_i32(0, HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24));
   wasm2js_scratch_store_i32(1, $1 | 0);
   $3 = +wasm2js_scratch_load_f64();
   $0 = HEAP32[$2 + 84 >> 2];
   $1 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
   wasm2js_scratch_store_i32(0, HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24));
   wasm2js_scratch_store_i32(1, $1 | 0);
   HEAP8[$2 + 95 | 0] = $3 == +wasm2js_scratch_load_f64();
   break label$1;
  }
  label$9 : {
   if (!(jsvIsString(HEAP32[$2 + 88 >> 2]) & 1)) {
    break label$9;
   }
   if (!(jsvIsString(HEAP32[$2 + 84 >> 2]) & 1)) {
    break label$9;
   }
   $0 = $2 + 8 | 0;
   jsvStringIteratorNew($2 + 48 | 0, HEAP32[$2 + 88 >> 2], 0);
   jsvStringIteratorNew($0, HEAP32[$2 + 84 >> 2], 0);
   while (1) {
    $0 = $2 + 8 | 0;
    HEAP8[$2 + 7 | 0] = jsvStringIteratorGetCharAndNext($2 + 48 | 0);
    HEAP8[$2 + 6 | 0] = jsvStringIteratorGetCharAndNext($0);
    if (HEAP8[$2 + 7 | 0] != HEAP8[$2 + 6 | 0]) {
     $0 = $2 + 8 | 0;
     jsvStringIteratorFree($2 + 48 | 0);
     jsvStringIteratorFree($0);
     HEAP8[$2 + 95 | 0] = 0;
     break label$1;
    }
    if (HEAPU8[$2 + 7 | 0]) {
     continue;
    }
    break;
   }
   $0 = $2 + 8 | 0;
   jsvStringIteratorFree($2 + 48 | 0);
   jsvStringIteratorFree($0);
   HEAP8[$2 + 95 | 0] = 1;
   break label$1;
  }
  HEAP8[$2 + 95 | 0] = 0;
 }
 global$0 = $2 + 96 | 0;
 return HEAP8[$2 + 95 | 0] & 1;
}
function stringToFloatWithRadix($0, $1) {
 var $2 = 0;
 $2 = global$0 + -64 | 0;
 global$0 = $2;
 HEAP32[$2 + 52 >> 2] = $0;
 HEAP32[$2 + 48 >> 2] = 0;
 HEAP32[$2 + 44 >> 2] = $1;
 while (1) {
  if (isWhitespace(HEAP8[HEAP32[$2 + 52 >> 2]]) & 1) {
   HEAP32[$2 + 52 >> 2] = HEAP32[$2 + 52 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP8[$2 + 43 | 0] = 0;
 label$3 : {
  if (HEAP8[HEAP32[$2 + 52 >> 2]] == 45) {
   HEAP8[$2 + 43 | 0] = 1;
   HEAP32[$2 + 52 >> 2] = HEAP32[$2 + 52 >> 2] + 1;
   break label$3;
  }
  if (HEAP8[HEAP32[$2 + 52 >> 2]] == 43) {
   HEAP32[$2 + 52 >> 2] = HEAP32[$2 + 52 >> 2] + 1;
  }
 }
 HEAP32[$2 + 36 >> 2] = HEAP32[$2 + 52 >> 2];
 if (HEAP32[$2 + 44 >> 2]) {
  HEAP32[HEAP32[$2 + 44 >> 2] >> 2] = HEAP32[$2 + 52 >> 2];
 }
 $0 = $2;
 if (HEAP32[$2 + 48 >> 2]) {
  $1 = HEAP32[$2 + 48 >> 2];
 } else {
  $1 = getRadix($2 + 52 | 0, 0);
 }
 HEAP32[$0 + 32 >> 2] = $1;
 label$9 : {
  if (!HEAP32[$2 + 32 >> 2]) {
   HEAPF64[$2 + 56 >> 3] = nan;
   break label$9;
  }
  HEAPF64[$2 + 24 >> 3] = 0;
  HEAPF64[$2 + 16 >> 3] = .1;
  while (1) {
   label$12 : {
    if (!HEAPU8[HEAP32[$2 + 52 >> 2]]) {
     break label$12;
    }
    HEAP32[$2 + 12 >> 2] = chtod(HEAP8[HEAP32[$2 + 52 >> 2]]);
    if (HEAP32[$2 + 12 >> 2] < 0 | HEAP32[$2 + 12 >> 2] >= HEAP32[$2 + 32 >> 2]) {
     break label$12;
    }
    HEAPF64[$2 + 24 >> 3] = HEAPF64[$2 + 24 >> 3] * +HEAP32[$2 + 32 >> 2] + +HEAP32[$2 + 12 >> 2];
    HEAP32[$2 + 52 >> 2] = HEAP32[$2 + 52 >> 2] + 1;
    continue;
   }
   break;
  }
  if (HEAP32[$2 + 32 >> 2] == 10) {
   if (HEAP8[HEAP32[$2 + 52 >> 2]] == 46) {
    HEAP32[$2 + 52 >> 2] = HEAP32[$2 + 52 >> 2] + 1;
    while (1) {
     if (!(!HEAPU8[HEAP32[$2 + 52 >> 2]] | HEAP8[HEAP32[$2 + 52 >> 2]] < 48 | HEAP8[HEAP32[$2 + 52 >> 2]] > 57)) {
      HEAPF64[$2 + 24 >> 3] = HEAPF64[$2 + 24 >> 3] + HEAPF64[$2 + 16 >> 3] * +(HEAP8[HEAP32[$2 + 52 >> 2]] - 48 | 0);
      HEAPF64[$2 + 16 >> 3] = HEAPF64[$2 + 16 >> 3] / 10;
      HEAP32[$2 + 52 >> 2] = HEAP32[$2 + 52 >> 2] + 1;
      continue;
     }
     break;
    }
   }
   if (!(HEAP8[HEAP32[$2 + 52 >> 2]] != 69 ? HEAP8[HEAP32[$2 + 52 >> 2]] != 101 : 0)) {
    HEAP32[$2 + 52 >> 2] = HEAP32[$2 + 52 >> 2] + 1;
    HEAP8[$2 + 11 | 0] = 0;
    if (!(HEAP8[HEAP32[$2 + 52 >> 2]] != 43 ? HEAP8[HEAP32[$2 + 52 >> 2]] != 45 : 0)) {
     HEAP8[$2 + 11 | 0] = HEAP8[HEAP32[$2 + 52 >> 2]] == 45;
     HEAP32[$2 + 52 >> 2] = HEAP32[$2 + 52 >> 2] + 1;
    }
    HEAP32[$2 + 4 >> 2] = 0;
    while (1) {
     if (!(!HEAPU8[HEAP32[$2 + 52 >> 2]] | HEAP8[HEAP32[$2 + 52 >> 2]] < 48 | HEAP8[HEAP32[$2 + 52 >> 2]] > 57)) {
      HEAP32[$2 + 4 >> 2] = (HEAP8[HEAP32[$2 + 52 >> 2]] - 48 | 0) + Math_imul(HEAP32[$2 + 4 >> 2], 10);
      HEAP32[$2 + 52 >> 2] = HEAP32[$2 + 52 >> 2] + 1;
      continue;
     }
     break;
    }
    if (HEAP8[$2 + 11 | 0] & 1) {
     HEAP32[$2 + 4 >> 2] = 0 - HEAP32[$2 + 4 >> 2];
    }
    while (1) {
     if (HEAP32[$2 + 4 >> 2] > 0) {
      HEAPF64[$2 + 24 >> 3] = HEAPF64[$2 + 24 >> 3] * 10;
      HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + -1;
      continue;
     }
     break;
    }
    while (1) {
     if (HEAP32[$2 + 4 >> 2] < 0) {
      HEAPF64[$2 + 24 >> 3] = HEAPF64[$2 + 24 >> 3] / 10;
      HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + 1;
      continue;
     }
     break;
    }
   }
  }
  if (HEAP32[$2 + 44 >> 2]) {
   HEAP32[HEAP32[$2 + 44 >> 2] >> 2] = HEAP32[$2 + 52 >> 2];
  }
  if (!(HEAP8[HEAP32[$2 + 36 >> 2]] != 46 | HEAP32[$2 + 52 >> 2] != (HEAP32[$2 + 36 >> 2] + 1 | 0) ? HEAP32[$2 + 36 >> 2] != HEAP32[$2 + 52 >> 2] : 0)) {
   HEAPF64[$2 + 56 >> 3] = nan;
   break label$9;
  }
  if (HEAP8[$2 + 43 | 0] & 1) {
   HEAPF64[$2 + 56 >> 3] = -HEAPF64[$2 + 24 >> 3];
   break label$9;
  }
  HEAPF64[$2 + 56 >> 3] = HEAPF64[$2 + 24 >> 3];
 }
 global$0 = $2 - -64 | 0;
 return HEAPF64[$2 + 56 >> 3];
}
function jsfCreateFile($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 112 | 0;
 global$0 = $4;
 HEAP32[$4 + 104 >> 2] = $1;
 HEAP32[$4 + 100 >> 2] = $2;
 HEAP32[$4 + 96 >> 2] = $3;
 HEAP32[$4 + 24 >> 2] = HEAP32[$0 + 24 >> 2];
 $2 = HEAP32[$0 + 20 >> 2];
 HEAP32[$4 + 16 >> 2] = HEAP32[$0 + 16 >> 2];
 HEAP32[$4 + 20 >> 2] = $2;
 $2 = HEAP32[$0 + 12 >> 2];
 HEAP32[$4 + 8 >> 2] = HEAP32[$0 + 8 >> 2];
 HEAP32[$4 + 12 >> 2] = $2;
 $2 = HEAP32[$0 + 4 >> 2];
 HEAP32[$4 >> 2] = HEAP32[$0 >> 2];
 HEAP32[$4 + 4 >> 2] = $2;
 $2 = $4 + 88 | 0;
 $3 = $4 + 84 | 0;
 HEAP8[$4 + 95 | 0] = jsfStripDriveFromName($0);
 jsfGetDriveBankAddress(HEAP8[$4 + 95 | 0], $2, $3);
 HEAP32[$4 + 80 >> 2] = jsfAlignAddress(HEAP32[$4 + 104 >> 2]) + 32;
 HEAP8[$4 + 79 | 0] = 0;
 HEAP32[$4 + 72 >> 2] = 0;
 HEAP32[$4 + 36 >> 2] = 0;
 label$1 : {
  while (1) {
   if ((HEAP32[$4 + 36 >> 2] != 0 ^ -1) & 1) {
    HEAP32[$4 + 72 >> 2] = HEAP32[$4 + 88 >> 2];
    HEAP32[$4 + 36 >> 2] = 0;
    while (1) {
     if (jsfGetFileHeader(HEAP32[$4 + 72 >> 2], $4 + 40 | 0, 0) & 1) {
      while (1) {
       if (jsfGetNextFileHeader($4 + 72 | 0, $4 + 40 | 0, 0) & 1) {
        continue;
       }
       break;
      }
     }
     label$7 : {
      if (jsfGetSpaceLeftInPage(HEAP32[$4 + 72 >> 2]) >>> 0 < HEAPU32[$4 + 80 >> 2]) {
       HEAP32[$4 + 72 >> 2] = jsfGetAddressOfNextPage(HEAP32[$4 + 72 >> 2]);
       break label$7;
      }
      HEAP32[$4 + 36 >> 2] = HEAP32[$4 + 72 >> 2];
     }
     if ((HEAP32[$4 + 72 >> 2] ? HEAP32[$4 + 36 >> 2] != 0 ^ -1 : 0) & 1) {
      continue;
     }
     break;
    }
    if (!HEAP32[$4 + 36 >> 2]) {
     label$12 : {
      if (!(HEAP8[$4 + 79 | 0] & 1)) {
       HEAP8[$4 + 79 | 0] = 1;
       if (!(jsfCompact() & 1)) {
        HEAP32[$4 + 108 >> 2] = 0;
        break label$1;
       }
       HEAP32[$4 + 72 >> 2] = HEAP32[$4 + 88 >> 2];
       break label$12;
      }
      HEAP32[$4 + 108 >> 2] = 0;
      break label$1;
     }
    }
    continue;
   }
   break;
  }
  HEAP32[$4 + 72 >> 2] = HEAP32[$4 + 36 >> 2];
  HEAP32[$4 + 32 >> 2] = jsfGetSpaceLeftInPage(HEAP32[$4 + 72 >> 2]);
  HEAP32[$4 + 28 >> 2] = jsfGetAddressOfNextPage(HEAP32[$4 + 72 >> 2]);
  label$15 : {
   if (!HEAP32[$4 + 28 >> 2] | HEAP32[$4 + 28 >> 2] - HEAP32[$4 + 72 >> 2] >>> 0 >= HEAPU32[$4 + 80 >> 2] | (HEAPU32[$4 + 32 >> 2] <= (HEAP32[$4 + 104 >> 2] + HEAP32[$4 + 28 >> 2] | 0) - HEAP32[$4 + 72 >> 2] >>> 0 | HEAPU32[$4 + 80 >> 2] >= 512)) {
    break label$15;
   }
   if (jsfGetFileHeader(HEAP32[$4 + 28 >> 2], $4 + 40 | 0, 0) & 1) {
    break label$15;
   }
   HEAP32[$4 + 72 >> 2] = HEAP32[$4 + 28 >> 2];
  }
  HEAP32[$4 + 40 >> 2] = HEAP32[$4 + 104 >> 2] | HEAP32[$4 + 100 >> 2] << 24;
  $1 = HEAP32[$0 + 4 >> 2];
  HEAP32[$4 + 44 >> 2] = HEAP32[$0 >> 2];
  HEAP32[$4 + 48 >> 2] = $1;
  HEAP32[$4 + 68 >> 2] = HEAP32[$0 + 24 >> 2];
  $1 = HEAP32[$0 + 20 >> 2];
  HEAP32[$4 + 60 >> 2] = HEAP32[$0 + 16 >> 2];
  HEAP32[$4 + 64 >> 2] = $1;
  $1 = HEAP32[$0 + 12 >> 2];
  HEAP32[$4 + 52 >> 2] = HEAP32[$0 + 8 >> 2];
  HEAP32[$4 + 56 >> 2] = $1;
  jshFlashWrite($4 + 40 | 0, HEAP32[$4 + 72 >> 2], 32);
  if (HEAP32[$4 + 96 >> 2]) {
   $2 = HEAP32[$4 + 44 >> 2];
   $0 = HEAP32[$4 + 96 >> 2];
   HEAP32[$0 >> 2] = HEAP32[$4 + 40 >> 2];
   HEAP32[$0 + 4 >> 2] = $2;
   $1 = HEAP32[$4 + 68 >> 2];
   HEAP32[$0 + 24 >> 2] = HEAP32[$4 + 64 >> 2];
   HEAP32[$0 + 28 >> 2] = $1;
   $1 = HEAP32[$4 + 60 >> 2];
   HEAP32[$0 + 16 >> 2] = HEAP32[$4 + 56 >> 2];
   HEAP32[$0 + 20 >> 2] = $1;
   $1 = HEAP32[$4 + 52 >> 2];
   HEAP32[$0 + 8 >> 2] = HEAP32[$4 + 48 >> 2];
   HEAP32[$0 + 12 >> 2] = $1;
  }
  HEAP32[$4 + 72 >> 2] = HEAP32[$4 + 72 >> 2] + 32;
  jsfCachePut($4 + 40 | 0, HEAP32[$4 + 72 >> 2]);
  HEAP32[$4 + 108 >> 2] = HEAP32[$4 + 72 >> 2];
 }
 global$0 = $4 + 112 | 0;
 return HEAP32[$4 + 108 >> 2];
}
function _jswrap_drawImageLayerInit($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = global$0 - 48 | 0;
 global$0 = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 HEAP32[HEAP32[$1 + 44 >> 2] + 156 >> 2] = HEAP32[HEAP32[$1 + 44 >> 2] + 36 >> 2] << 8;
 HEAP32[HEAP32[$1 + 44 >> 2] + 160 >> 2] = HEAP32[HEAP32[$1 + 44 >> 2] + 40 >> 2] << 8;
 HEAPF64[$1 + 32 >> 3] = cos(HEAPF64[HEAP32[$1 + 44 >> 2] + 16 >> 3]);
 HEAPF64[$1 + 24 >> 3] = sin(HEAPF64[HEAP32[$1 + 44 >> 2] + 16 >> 3]);
 $0 = HEAP32[$1 + 44 >> 2];
 $2 = HEAPF64[$1 + 32 >> 3] / HEAPF64[HEAP32[$1 + 44 >> 2] + 24 >> 3] * 256 + .5;
 label$1 : {
  if (Math_abs($2) < 2147483648) {
   $3 = ~~$2;
   break label$1;
  }
  $3 = -2147483648;
 }
 HEAP32[$0 + 164 >> 2] = $3;
 $0 = HEAP32[$1 + 44 >> 2];
 $2 = HEAPF64[$1 + 24 >> 3] / HEAPF64[HEAP32[$1 + 44 >> 2] + 24 >> 3] * 256 + .5;
 label$3 : {
  if (Math_abs($2) < 2147483648) {
   $3 = ~~$2;
   break label$3;
  }
  $3 = -2147483648;
 }
 HEAP32[$0 + 168 >> 2] = $3;
 $0 = $1;
 $2 = .5 + HEAPF64[HEAP32[$1 + 44 >> 2] + 24 >> 3] * (+HEAP32[HEAP32[$1 + 44 >> 2] + 36 >> 2] * Math_abs(HEAPF64[$1 + 32 >> 3]) + +HEAP32[HEAP32[$1 + 44 >> 2] + 40 >> 2] * Math_abs(HEAPF64[$1 + 24 >> 3]));
 label$5 : {
  if (Math_abs($2) < 2147483648) {
   $3 = ~~$2;
   break label$5;
  }
  $3 = -2147483648;
 }
 HEAP32[$0 + 20 >> 2] = $3;
 $0 = $1;
 $2 = .5 + HEAPF64[HEAP32[$1 + 44 >> 2] + 24 >> 3] * (+HEAP32[HEAP32[$1 + 44 >> 2] + 36 >> 2] * Math_abs(HEAPF64[$1 + 24 >> 3]) + +HEAP32[HEAP32[$1 + 44 >> 2] + 40 >> 2] * Math_abs(HEAPF64[$1 + 32 >> 3]));
 label$7 : {
  if (Math_abs($2) < 2147483648) {
   $3 = ~~$2;
   break label$7;
  }
  $3 = -2147483648;
 }
 HEAP32[$0 + 16 >> 2] = $3;
 if (HEAP8[HEAP32[$1 + 44 >> 2] + 32 | 0] & 1) {
  $0 = HEAP32[$1 + 44 >> 2];
  HEAP32[$0 >> 2] = HEAP32[$0 >> 2] - (HEAP32[$1 + 20 >> 2] / 2 | 0);
  $0 = HEAP32[$1 + 44 >> 2];
  HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] - (HEAP32[$1 + 16 >> 2] / 2 | 0);
 }
 HEAP32[HEAP32[$1 + 44 >> 2] + 8 >> 2] = HEAP32[HEAP32[$1 + 44 >> 2] >> 2] + HEAP32[$1 + 20 >> 2];
 HEAP32[HEAP32[$1 + 44 >> 2] + 12 >> 2] = HEAP32[HEAP32[$1 + 44 >> 2] + 4 >> 2] + HEAP32[$1 + 16 >> 2];
 HEAP32[$1 + 12 >> 2] = HEAP32[HEAP32[$1 + 44 >> 2] + 36 >> 2] << 7;
 HEAP32[$1 + 8 >> 2] = HEAP32[HEAP32[$1 + 44 >> 2] + 40 >> 2] << 7;
 HEAP32[HEAP32[$1 + 44 >> 2] + 172 >> 2] = HEAP32[$1 + 12 >> 2] - (((Math_imul(HEAP32[HEAP32[$1 + 44 >> 2] + 164 >> 2], HEAP32[$1 + 20 >> 2]) + 1 | 0) + Math_imul(HEAP32[HEAP32[$1 + 44 >> 2] + 168 >> 2], HEAP32[$1 + 16 >> 2]) | 0) / 2 | 0);
 HEAP32[HEAP32[$1 + 44 >> 2] + 176 >> 2] = HEAP32[$1 + 8 >> 2] - (((Math_imul(HEAP32[HEAP32[$1 + 44 >> 2] + 164 >> 2], HEAP32[$1 + 16 >> 2]) + 1 | 0) - Math_imul(HEAP32[HEAP32[$1 + 44 >> 2] + 168 >> 2], HEAP32[$1 + 20 >> 2]) | 0) / 2 | 0);
 if (HEAP8[HEAP32[$1 + 44 >> 2] + 33 | 0] & 1) {
  while (1) {
   if (HEAP32[HEAP32[$1 + 44 >> 2] + 172 >> 2] < 0) {
    $0 = HEAP32[$1 + 44 >> 2];
    HEAP32[$0 + 172 >> 2] = HEAP32[HEAP32[$1 + 44 >> 2] + 156 >> 2] + HEAP32[$0 + 172 >> 2];
    continue;
   }
   break;
  }
  while (1) {
   if (HEAP32[HEAP32[$1 + 44 >> 2] + 172 >> 2] >= HEAP32[HEAP32[$1 + 44 >> 2] + 156 >> 2]) {
    $0 = HEAP32[$1 + 44 >> 2];
    HEAP32[$0 + 172 >> 2] = HEAP32[$0 + 172 >> 2] - HEAP32[HEAP32[$1 + 44 >> 2] + 156 >> 2];
    continue;
   }
   break;
  }
  while (1) {
   if (HEAP32[HEAP32[$1 + 44 >> 2] + 176 >> 2] < 0) {
    $0 = HEAP32[$1 + 44 >> 2];
    HEAP32[$0 + 176 >> 2] = HEAP32[HEAP32[$1 + 44 >> 2] + 160 >> 2] + HEAP32[$0 + 176 >> 2];
    continue;
   }
   break;
  }
  while (1) {
   if (HEAP32[HEAP32[$1 + 44 >> 2] + 176 >> 2] >= HEAP32[HEAP32[$1 + 44 >> 2] + 160 >> 2]) {
    $0 = HEAP32[$1 + 44 >> 2];
    HEAP32[$0 + 176 >> 2] = HEAP32[$0 + 176 >> 2] - HEAP32[HEAP32[$1 + 44 >> 2] + 160 >> 2];
    continue;
   }
   break;
  }
 }
 global$0 = $1 + 48 | 0;
}
function graphicsDrawEllipse($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0;
 $5 = global$0 + -64 | 0;
 global$0 = $5;
 $6 = $5 + 48 | 0;
 $7 = $5 + 44 | 0;
 HEAP32[$5 + 60 >> 2] = $0;
 HEAP32[$5 + 56 >> 2] = $1;
 HEAP32[$5 + 52 >> 2] = $2;
 HEAP32[$5 + 48 >> 2] = $3;
 HEAP32[$5 + 44 >> 2] = $4;
 graphicsToDeviceCoordinates(HEAP32[$5 + 60 >> 2], $5 + 56 | 0, $5 + 52 | 0);
 graphicsToDeviceCoordinates(HEAP32[$5 + 60 >> 2], $6, $7);
 HEAP32[$5 + 40 >> 2] = (HEAP32[$5 + 56 >> 2] + HEAP32[$5 + 48 >> 2] | 0) / 2;
 HEAP32[$5 + 36 >> 2] = (HEAP32[$5 + 52 >> 2] + HEAP32[$5 + 44 >> 2] | 0) / 2;
 HEAP32[$5 + 32 >> 2] = (HEAP32[$5 + 48 >> 2] - HEAP32[$5 + 56 >> 2] | 0) / 2;
 HEAP32[$5 + 28 >> 2] = (HEAP32[$5 + 44 >> 2] - HEAP32[$5 + 52 >> 2] | 0) / 2;
 HEAP32[$5 + 24 >> 2] = 0;
 HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 28 >> 2];
 HEAP32[$5 + 16 >> 2] = Math_imul(HEAP32[$5 + 32 >> 2], HEAP32[$5 + 32 >> 2]);
 HEAP32[$5 + 12 >> 2] = Math_imul(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 28 >> 2]);
 HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 12 >> 2] - Math_imul(HEAP32[$5 + 16 >> 2], (HEAP32[$5 + 28 >> 2] << 1) - 1 | 0);
 HEAP8[$5 + 3 | 0] = 0;
 while (1) {
  HEAP8[$5 + 3 | 0] = 0;
  $0 = HEAP32[$5 + 60 >> 2];
  graphicsSetPixelDevice(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 40 >> 2] + HEAP32[$5 + 24 >> 2] | 0, HEAP32[$5 + 36 >> 2] + HEAP32[$5 + 20 >> 2] | 0, HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
  $0 = HEAP32[$5 + 60 >> 2];
  graphicsSetPixelDevice(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 40 >> 2] - HEAP32[$5 + 24 >> 2] | 0, HEAP32[$5 + 36 >> 2] + HEAP32[$5 + 20 >> 2] | 0, HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
  $0 = HEAP32[$5 + 60 >> 2];
  graphicsSetPixelDevice(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 40 >> 2] + HEAP32[$5 + 24 >> 2] | 0, HEAP32[$5 + 36 >> 2] - HEAP32[$5 + 20 >> 2] | 0, HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
  $0 = HEAP32[$5 + 60 >> 2];
  graphicsSetPixelDevice(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 40 >> 2] - HEAP32[$5 + 24 >> 2] | 0, HEAP32[$5 + 36 >> 2] - HEAP32[$5 + 20 >> 2] | 0, HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
  HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 8 >> 2] << 1;
  if (HEAP32[$5 + 4 >> 2] < (Math_imul(HEAP32[$5 + 12 >> 2], (HEAP32[$5 + 24 >> 2] << 1) + 1 | 0) | 0)) {
   HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 24 >> 2] + 1;
   HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 8 >> 2] + Math_imul(HEAP32[$5 + 12 >> 2], (HEAP32[$5 + 24 >> 2] << 1) + 1 | 0);
   HEAP8[$5 + 3 | 0] = 1;
  }
  if (HEAP32[$5 + 4 >> 2] > (Math_imul(HEAP32[$5 + 16 >> 2], 0 - ((HEAP32[$5 + 20 >> 2] << 1) - 1 | 0) | 0) | 0)) {
   HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 20 >> 2] + -1;
   HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 8 >> 2] - Math_imul(HEAP32[$5 + 16 >> 2], (HEAP32[$5 + 20 >> 2] << 1) - 1 | 0);
   HEAP8[$5 + 3 | 0] = 1;
  }
  if (HEAP8[$5 + 3 | 0] & 1 ? HEAP32[$5 + 20 >> 2] >= 0 : 0) {
   continue;
  }
  break;
 }
 while (1) {
  label$7 : {
   $0 = HEAP32[$5 + 24 >> 2];
   HEAP32[$5 + 24 >> 2] = $0 + 1;
   if (($0 | 0) >= HEAP32[$5 + 32 >> 2]) {
    break label$7;
   }
   $0 = HEAP32[$5 + 60 >> 2];
   graphicsSetPixelDevice(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 40 >> 2] + HEAP32[$5 + 24 >> 2] | 0, HEAP32[$5 + 36 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
   $0 = HEAP32[$5 + 60 >> 2];
   graphicsSetPixelDevice(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 40 >> 2] - HEAP32[$5 + 24 >> 2] | 0, HEAP32[$5 + 36 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
   continue;
  }
  break;
 }
 global$0 = $5 - -64 | 0;
}
function tflite__ops__micro__depthwise_conv___28anonymous_20namespace_29__CalculateOpData_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteDepthwiseConvParams__2c_20int_2c_20int_2c_20int_2c_20int_2c_20TfLiteType_2c_20tflite__ops__micro__depthwise_conv___28anonymous_20namespace_29__OpData__29($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0;
 $9 = global$0 - 144 | 0;
 global$0 = $9;
 HEAP32[$9 + 136 >> 2] = $0;
 HEAP32[$9 + 132 >> 2] = $1;
 HEAP32[$9 + 128 >> 2] = $2;
 HEAP32[$9 + 124 >> 2] = $3;
 HEAP32[$9 + 120 >> 2] = $4;
 HEAP32[$9 + 116 >> 2] = $5;
 HEAP32[$9 + 112 >> 2] = $6;
 HEAP32[$9 + 108 >> 2] = $7;
 HEAP32[$9 + 104 >> 2] = $8;
 HEAP8[$9 + 103 | 0] = HEAP32[HEAP32[HEAP32[$9 + 132 >> 2] >> 2] >> 2] == 3;
 label$1 : {
  if (!(HEAP8[$9 + 103 | 0] & 1 | HEAP32[HEAP32[HEAP32[$9 + 132 >> 2] >> 2] >> 2] == 2)) {
   $0 = HEAP32[HEAP32[$9 + 136 >> 2] + 20 >> 2];
   $1 = HEAP32[$9 + 136 >> 2];
   HEAP32[$9 + 40 >> 2] = 133755;
   HEAP32[$9 + 36 >> 2] = 72;
   HEAP32[$9 + 32 >> 2] = 133280;
   FUNCTION_TABLE[$0]($1, 133424, $9 + 32 | 0);
   HEAP32[$9 + 140 >> 2] = 1;
   break label$1;
  }
  if (HEAP32[HEAP32[HEAP32[$9 + 132 >> 2] + 4 >> 2] >> 2] != 1) {
   $0 = HEAP32[HEAP32[$9 + 136 >> 2] + 20 >> 2];
   $1 = HEAP32[$9 + 136 >> 2];
   $2 = HEAP32[HEAP32[HEAP32[$9 + 132 >> 2] + 4 >> 2] >> 2];
   HEAP32[$9 + 20 >> 2] = 1;
   HEAP32[$9 + 16 >> 2] = $2;
   HEAP32[$9 + 12 >> 2] = 133811;
   HEAP32[$9 + 8 >> 2] = 133791;
   HEAP32[$9 + 4 >> 2] = 73;
   HEAP32[$9 >> 2] = 133280;
   FUNCTION_TABLE[$0]($1, 133254, $9);
   HEAP32[$9 + 140 >> 2] = 1;
   break label$1;
  }
  $0 = $9 + 72 | 0;
  tflite__ComputePaddingHeightWidth_28int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20TfLitePadding_2c_20int__2c_20int__29($0, HEAP32[HEAP32[$9 + 128 >> 2] + 8 >> 2], HEAP32[HEAP32[$9 + 128 >> 2] + 4 >> 2], 1, 1, HEAP32[$9 + 120 >> 2], HEAP32[$9 + 124 >> 2], HEAP32[$9 + 112 >> 2], HEAP32[$9 + 116 >> 2], HEAP32[HEAP32[$9 + 128 >> 2] >> 2], $9 + 96 | 0, $9 + 92 | 0);
  $2 = HEAP32[$0 + 4 >> 2];
  $1 = HEAP32[$9 + 104 >> 2];
  HEAP32[$1 >> 2] = HEAP32[$0 >> 2];
  HEAP32[$1 + 4 >> 2] = $2;
  $2 = HEAP32[$0 + 12 >> 2];
  HEAP32[$1 + 8 >> 2] = HEAP32[$0 + 8 >> 2];
  HEAP32[$1 + 12 >> 2] = $2;
  if (HEAP32[$9 + 108 >> 2] != 1) {
   HEAP32[$9 + 68 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$9 + 136 >> 2], HEAP32[$9 + 132 >> 2], 0);
   HEAP32[$9 + 64 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$9 + 136 >> 2], HEAP32[$9 + 132 >> 2], 1);
   HEAP32[$9 + 60 >> 2] = tflite__GetOptionalInputTensor_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$9 + 136 >> 2], HEAP32[$9 + 132 >> 2]);
   HEAP32[$9 + 56 >> 2] = tflite__GetOutput_28TfLiteContext__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$9 + 136 >> 2], HEAP32[$9 + 132 >> 2]);
   HEAP32[$9 + 52 >> 2] = HEAP32[HEAP32[HEAP32[$9 + 64 >> 2] + 20 >> 2] + 16 >> 2];
   HEAP32[$9 + 140 >> 2] = tflite__PopulateConvolutionQuantizationParams_28TfLiteContext__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor__2c_20TfLiteFusedActivation_20const__2c_20int__2c_20int__2c_20int__2c_20int__2c_20int__2c_20int__2c_20int_29(HEAP32[$9 + 136 >> 2], HEAP32[$9 + 68 >> 2], HEAP32[$9 + 64 >> 2], HEAP32[$9 + 60 >> 2], HEAP32[$9 + 56 >> 2], HEAP32[$9 + 128 >> 2] + 16 | 0, HEAP32[$9 + 104 >> 2] + 28 | 0, HEAP32[$9 + 104 >> 2] + 32 | 0, HEAP32[$9 + 104 >> 2] + 44 | 0, HEAP32[$9 + 104 >> 2] + 48 | 0, HEAP32[HEAP32[$9 + 104 >> 2] + 36 >> 2], HEAP32[HEAP32[$9 + 104 >> 2] + 40 >> 2], HEAP32[$9 + 52 >> 2]);
   break label$1;
  }
  HEAP32[$9 + 140 >> 2] = 0;
 }
 global$0 = $9 + 144 | 0;
 return HEAP32[$9 + 140 >> 2];
}
function jswrap_graphics_setFont($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 80 | 0;
 global$0 = $3;
 HEAP32[$3 + 72 >> 2] = $0;
 HEAP32[$3 + 68 >> 2] = $1;
 HEAP32[$3 + 64 >> 2] = $2;
 label$1 : {
  if (!(jsvIsString(HEAP32[$3 + 68 >> 2]) & 1)) {
   HEAP32[$3 + 76 >> 2] = 0;
   break label$1;
  }
  HEAP8[$3 + 63 | 0] = 0;
  HEAP32[$3 + 56 >> 2] = -1;
  if (jsvIsStringEqualOrStartsWith(HEAP32[$3 + 68 >> 2], 127697, 1) & 1) {
   if (jsvGetStringLength(HEAP32[$3 + 68 >> 2]) >>> 0 > 6) {
    HEAP32[$3 + 56 >> 2] = 6;
   }
   HEAP8[$3 + 63 | 0] = 1;
  }
  HEAP32[$3 + 52 >> 2] = jsvGetStringIndexOf(HEAP32[$3 + 68 >> 2], 58);
  if (HEAP32[$3 + 52 >> 2] >= 0) {
   HEAP32[$3 + 56 >> 2] = HEAP32[$3 + 52 >> 2] + 1;
  }
  label$6 : {
   if (HEAP32[$3 + 56 >> 2] >= 0) {
    HEAP32[$3 + 44 >> 2] = jsvNewFromStringVar(HEAP32[$3 + 68 >> 2], HEAP32[$3 + 56 >> 2], 2147483647);
    HEAP32[$3 + 40 >> 2] = jsvGetStringIndexOf(HEAP32[$3 + 44 >> 2], 120);
    label$8 : {
     if (HEAP32[$3 + 40 >> 2] >= 0) {
      HEAP32[$3 + 36 >> 2] = jsvGetIntegerAndUnLock(jsvNewFromStringVar(HEAP32[$3 + 44 >> 2], 0, HEAP32[$3 + 40 >> 2]));
      HEAP32[$3 + 32 >> 2] = jsvGetIntegerAndUnLock(jsvNewFromStringVar(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 40 >> 2] + 1 | 0, 2147483647));
      if (HEAP32[$3 + 36 >> 2] < 0) {
       HEAP32[$3 + 36 >> 2] = 0;
      }
      if (HEAP32[$3 + 32 >> 2] < 0) {
       HEAP32[$3 + 32 >> 2] = 0;
      }
      if (HEAP32[$3 + 36 >> 2] > 63) {
       HEAP32[$3 + 36 >> 2] = 63;
      }
      if (HEAP32[$3 + 32 >> 2] > 63) {
       HEAP32[$3 + 32 >> 2] = 63;
      }
      HEAP32[$3 + 64 >> 2] = HEAP32[$3 + 36 >> 2] | HEAP32[$3 + 32 >> 2] << 6 | 4096;
      break label$8;
     }
     HEAP32[$3 + 64 >> 2] = jsvGetInteger(HEAP32[$3 + 44 >> 2]);
    }
    jsvUnLock(HEAP32[$3 + 44 >> 2]);
    $0 = $3;
    $1 = HEAP32[$3 + 68 >> 2];
    if (HEAP32[$3 + 56 >> 2] > 0) {
     $2 = HEAP32[$3 + 56 >> 2] - 1 | 0;
    } else {
     $2 = 0;
    }
    HEAP32[$0 + 48 >> 2] = jsvNewFromStringVar($1, 0, $2);
    break label$6;
   }
   HEAP32[$3 + 48 >> 2] = jsvLockAgain(HEAP32[$3 + 68 >> 2]);
  }
  if (HEAP32[$3 + 64 >> 2] < 1) {
   HEAP32[$3 + 64 >> 2] = 1;
  }
  if (HEAP32[$3 + 64 >> 2] > 8191) {
   HEAP32[$3 + 64 >> 2] = 8191;
  }
  HEAP16[$3 + 30 >> 1] = 65535;
  label$18 : {
   if (HEAP8[$3 + 63 | 0] & 1) {
    HEAP16[$3 + 30 >> 1] = HEAP32[$3 + 64 >> 2];
    break label$18;
   }
   label$20 : {
    label$21 : {
     if (jsvIsUndefined(HEAP32[$3 + 48 >> 2]) & 1) {
      break label$21;
     }
     if (!jsvGetStringLength(HEAP32[$3 + 48 >> 2])) {
      break label$21;
     }
     if (!(jsvIsStringEqual(HEAP32[$3 + 48 >> 2], 127704) & 1)) {
      break label$20;
     }
    }
    HEAP16[$3 + 30 >> 1] = HEAP32[$3 + 64 >> 2] - -8192;
   }
  }
  if (jsvIsStringEqual(HEAP32[$3 + 48 >> 2], 127708) & 1) {
   HEAP16[$3 + 30 >> 1] = HEAP32[$3 + 64 >> 2] + 16384;
  }
  if (HEAPU16[$3 + 30 >> 1] == 65535) {
   HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 48 >> 2];
   HEAP32[$3 + 24 >> 2] = jsvVarPrintf(127712, $3 + 16 | 0);
   HEAP32[$3 + 20 >> 2] = jspGetVarNamedField(HEAP32[$3 + 72 >> 2], HEAP32[$3 + 24 >> 2], 0);
   if (HEAP32[$3 + 20 >> 2]) {
    jsvUnLock(jspExecuteFunction(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 72 >> 2], 0, 0));
    HEAP16[$3 + 30 >> 1] = HEAP32[$3 + 64 >> 2] + 32768;
   }
   jsvUnLock2(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 24 >> 2]);
  }
  if (HEAPU16[$3 + 30 >> 1] == 65535) {
   HEAP32[$3 >> 2] = HEAP32[$3 + 48 >> 2];
   jsExceptionHere(1, 127722, $3);
  }
  jsvUnLock(HEAP32[$3 + 48 >> 2]);
  HEAP32[$3 + 76 >> 2] = jswrap_graphics_setFontSizeX(HEAP32[$3 + 72 >> 2], HEAPU16[$3 + 30 >> 1], HEAP8[$3 + 63 | 0] & 1);
 }
 global$0 = $3 + 80 | 0;
 return HEAP32[$3 + 76 >> 2];
}
function jswGetBasicObjectName($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (jsvIsFunction(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 93925;
   break label$1;
  }
  label$3 : {
   if (!(jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1)) {
    break label$3;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8) != 20) {
    break label$3;
   }
   HEAP32[$1 + 12 >> 2] = 93817;
   break label$1;
  }
  label$4 : {
   if (!(jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1)) {
    break label$4;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8) != 65) {
    break label$4;
   }
   HEAP32[$1 + 12 >> 2] = 93742;
   break label$1;
  }
  label$5 : {
   if (!(jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1)) {
    break label$5;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8) != 4) {
    break label$5;
   }
   HEAP32[$1 + 12 >> 2] = 93805;
   break label$1;
  }
  if (jsvIsPin(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 93955;
   break label$1;
  }
  label$7 : {
   if (!(jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1)) {
    break label$7;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8) != 129) {
    break label$7;
   }
   HEAP32[$1 + 12 >> 2] = 93703;
   break label$1;
  }
  if (jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 93966;
   break label$1;
  }
  label$9 : {
   if (!(jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1)) {
    break label$9;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8) != 1) {
    break label$9;
   }
   HEAP32[$1 + 12 >> 2] = 93731;
   break label$1;
  }
  label$10 : {
   if (!(jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1)) {
    break label$10;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8) != 2) {
    break label$10;
   }
   HEAP32[$1 + 12 >> 2] = 93770;
   break label$1;
  }
  label$11 : {
   if (!(jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1)) {
    break label$11;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8) != 40) {
    break label$11;
   }
   HEAP32[$1 + 12 >> 2] = 93841;
   break label$1;
  }
  if (jsvIsNumeric(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 93959;
   break label$1;
  }
  label$13 : {
   if (!(jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1)) {
    break label$13;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8) != 17) {
    break label$13;
   }
   HEAP32[$1 + 12 >> 2] = 93760;
   break label$1;
  }
  if (jsvIsArray(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 93697;
   break label$1;
  }
  label$15 : {
   if (!(jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1)) {
    break label$15;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8) != 18) {
    break label$15;
   }
   HEAP32[$1 + 12 >> 2] = 93782;
   break label$1;
  }
  label$16 : {
   if (!(jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1)) {
    break label$16;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8) != 36) {
    break label$16;
   }
   HEAP32[$1 + 12 >> 2] = 93828;
   break label$1;
  }
  label$17 : {
   if (!(jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1)) {
    break label$17;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8) != 3) {
    break label$17;
   }
   HEAP32[$1 + 12 >> 2] = 93793;
   break label$1;
  }
  if (jsvIsString(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 94042;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jswrap_graphics_transformVertices($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $3 = global$0 - 320 | 0;
 global$0 = $3;
 HEAP32[$3 + 312 >> 2] = $0;
 HEAP32[$3 + 308 >> 2] = $1;
 HEAP32[$3 + 304 >> 2] = $2;
 HEAP32[$3 + 300 >> 2] = jsvNewWithFlags(3);
 label$1 : {
  if (!HEAP32[$3 + 300 >> 2]) {
   HEAP32[$3 + 316 >> 2] = 0;
   break label$1;
  }
  if (!(jsvIsIterable(HEAP32[$3 + 308 >> 2]) & 1)) {
   HEAP32[$3 + 316 >> 2] = HEAP32[$3 + 300 >> 2];
   break label$1;
  }
  label$4 : {
   if (jsvIsObject(HEAP32[$3 + 304 >> 2]) & 1) {
    HEAPF64[$3 + 232 >> 3] = 0;
    HEAPF64[$3 + 224 >> 3] = 0;
    HEAPF64[$3 + 216 >> 3] = 1;
    HEAPF64[$3 + 208 >> 3] = 0;
    HEAP32[$3 + 160 >> 2] = 127462;
    HEAP16[$3 + 164 >> 1] = 10;
    HEAP32[$3 + 168 >> 2] = $3 + 232;
    HEAP32[$3 + 172 >> 2] = 127464;
    HEAP16[$3 + 176 >> 1] = 10;
    HEAP32[$3 + 180 >> 2] = $3 + 224;
    HEAP32[$3 + 184 >> 2] = 127892;
    HEAP16[$3 + 188 >> 1] = 10;
    HEAP32[$3 + 192 >> 2] = $3 + 216;
    HEAP32[$3 + 196 >> 2] = 127898;
    HEAP16[$3 + 200 >> 1] = 10;
    HEAP32[$3 + 204 >> 2] = $3 + 208;
    if (!(jsvReadConfigObject(HEAP32[$3 + 304 >> 2], $3 + 160 | 0, 4) & 1)) {
     HEAP32[$3 + 316 >> 2] = HEAP32[$3 + 300 >> 2];
     break label$1;
    }
    HEAPF64[$3 + 152 >> 3] = 1;
    HEAPF64[$3 + 144 >> 3] = 0;
    if (HEAPF64[$3 + 208 >> 3] != 0) {
     HEAPF64[$3 + 152 >> 3] = cos(HEAPF64[$3 + 208 >> 3]);
     HEAPF64[$3 + 144 >> 3] = sin(HEAPF64[$3 + 208 >> 3]);
    }
    HEAPF64[$3 + 240 >> 3] = HEAPF64[$3 + 152 >> 3] * HEAPF64[$3 + 216 >> 3];
    HEAPF64[$3 + 256 >> 3] = -HEAPF64[$3 + 144 >> 3] * HEAPF64[$3 + 216 >> 3];
    HEAPF64[$3 + 272 >> 3] = HEAPF64[$3 + 232 >> 3];
    HEAPF64[$3 + 248 >> 3] = HEAPF64[$3 + 144 >> 3] * HEAPF64[$3 + 216 >> 3];
    HEAPF64[$3 + 264 >> 3] = HEAPF64[$3 + 152 >> 3] * HEAPF64[$3 + 216 >> 3];
    HEAPF64[$3 + 280 >> 3] = HEAPF64[$3 + 224 >> 3];
    break label$4;
   }
   label$8 : {
    label$9 : {
     if (!(jsvIsIterable(HEAP32[$3 + 304 >> 2]) & 1)) {
      break label$9;
     }
     if ((jsvGetLength(HEAP32[$3 + 304 >> 2]) | 0) != 6) {
      break label$9;
     }
     jsvIteratorNew($3 + 80 | 0, HEAP32[$3 + 304 >> 2], 1);
     HEAP32[$3 + 76 >> 2] = 0;
     while (1) {
      if (HEAP32[$3 + 76 >> 2] < 6) {
       $0 = $3 + 240 | 0;
       $1 = $3 + 80 | 0;
       $4 = jsvIteratorGetFloatValue($1);
       HEAPF64[$0 + (HEAP32[$3 + 76 >> 2] << 3) >> 3] = $4;
       jsvIteratorNext($1);
       HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 76 >> 2] + 1;
       continue;
      }
      break;
     }
     jsvIteratorFree($3 + 80 | 0);
     break label$8;
    }
    jsExceptionHere(3, 128083, 0);
    HEAP32[$3 + 316 >> 2] = 0;
    break label$1;
   }
  }
  jsvIteratorNew($3 + 16 | 0, HEAP32[$3 + 308 >> 2], 1);
  while (1) {
   label$13 : {
    if (!(jsvIteratorHasElement($3 + 16 | 0) & 1)) {
     break label$13;
    }
    $0 = $3 + 16 | 0;
    HEAPF64[$3 + 8 >> 3] = jsvIteratorGetFloatValue($0);
    jsvIteratorNext($0);
    if (!(jsvIteratorHasElement($0) & 1)) {
     break label$13;
    }
    $0 = $3 + 16 | 0;
    HEAPF64[$3 >> 3] = jsvIteratorGetFloatValue($0);
    jsvIteratorNext($0);
    jsvArrayPushAndUnLock(HEAP32[$3 + 300 >> 2], jsvNewFromFloat(HEAPF64[$3 + 240 >> 3] * HEAPF64[$3 + 8 >> 3] + HEAPF64[$3 + 256 >> 3] * HEAPF64[$3 >> 3] + HEAPF64[$3 + 272 >> 3]));
    jsvArrayPushAndUnLock(HEAP32[$3 + 300 >> 2], jsvNewFromFloat(HEAPF64[$3 + 248 >> 3] * HEAPF64[$3 + 8 >> 3] + HEAPF64[$3 + 264 >> 3] * HEAPF64[$3 >> 3] + HEAPF64[$3 + 280 >> 3]));
    continue;
   }
   break;
  }
  jsvIteratorFree($3 + 16 | 0);
  HEAP32[$3 + 316 >> 2] = HEAP32[$3 + 300 >> 2];
 }
 global$0 = $3 + 320 | 0;
 return HEAP32[$3 + 316 >> 2];
}
function jswrap_espruino_HSBtoRGB_int($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = global$0 - 80 | 0;
 HEAPF64[$3 + 64 >> 3] = $0;
 HEAPF64[$3 + 56 >> 3] = $1;
 HEAPF64[$3 + 48 >> 3] = $2;
 label$1 : {
  if (HEAPF64[$3 + 48 >> 3] == 0) {
   HEAP32[$3 + 76 >> 2] = 0;
   break label$1;
  }
  if (HEAPF64[$3 + 56 >> 3] == 0) {
   $5 = $3;
   $0 = HEAPF64[$3 + 48 >> 3] * 255;
   label$4 : {
    if (Math_abs($0) < 2147483648) {
     $4 = ~~$0;
     break label$4;
    }
    $4 = -2147483648;
   }
   HEAP32[$5 + 44 >> 2] = $4;
   HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 44 >> 2] | (HEAP32[$3 + 44 >> 2] << 16 | HEAP32[$3 + 44 >> 2] << 8);
   break label$1;
  }
  HEAPF64[$3 + 64 >> 3] = (HEAPF64[$3 + 64 >> 3] - Math_floor(HEAPF64[$3 + 64 >> 3])) * 6;
  $5 = $3;
  $0 = HEAPF64[$3 + 64 >> 3];
  label$6 : {
   if (Math_abs($0) < 2147483648) {
    $4 = ~~$0;
    break label$6;
   }
   $4 = -2147483648;
  }
  HEAP32[$5 + 32 >> 2] = $4;
  HEAPF64[$3 + 8 >> 3] = HEAPF64[$3 + 64 >> 3] - +HEAP32[$3 + 32 >> 2];
  HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 32 >> 2] % 6;
  HEAPF64[$3 + 48 >> 3] = HEAPF64[$3 + 48 >> 3] * 255;
  $5 = $3;
  $0 = HEAPF64[$3 + 48 >> 3];
  label$8 : {
   if (Math_abs($0) < 2147483648) {
    $4 = ~~$0;
    break label$8;
   }
   $4 = -2147483648;
  }
  HEAP32[$5 + 28 >> 2] = $4;
  $5 = $3;
  $0 = (1 - HEAPF64[$3 + 56 >> 3]) * HEAPF64[$3 + 48 >> 3];
  label$10 : {
   if (Math_abs($0) < 2147483648) {
    $4 = ~~$0;
    break label$10;
   }
   $4 = -2147483648;
  }
  HEAP32[$5 + 24 >> 2] = $4;
  $5 = $3;
  $0 = (1 - HEAPF64[$3 + 56 >> 3] * HEAPF64[$3 + 8 >> 3]) * HEAPF64[$3 + 48 >> 3];
  label$12 : {
   if (Math_abs($0) < 2147483648) {
    $4 = ~~$0;
    break label$12;
   }
   $4 = -2147483648;
  }
  HEAP32[$5 + 20 >> 2] = $4;
  $5 = $3;
  $0 = (1 - HEAPF64[$3 + 56 >> 3] * (1 - HEAPF64[$3 + 8 >> 3])) * HEAPF64[$3 + 48 >> 3];
  label$14 : {
   if (Math_abs($0) < 2147483648) {
    $4 = ~~$0;
    break label$14;
   }
   $4 = -2147483648;
  }
  HEAP32[$5 + 16 >> 2] = $4;
  label$16 : {
   if (!HEAP32[$3 + 32 >> 2]) {
    HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 28 >> 2];
    HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 16 >> 2];
    HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 24 >> 2];
    break label$16;
   }
   label$18 : {
    if (HEAP32[$3 + 32 >> 2] == 1) {
     HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 20 >> 2];
     HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 28 >> 2];
     HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 24 >> 2];
     break label$18;
    }
    label$20 : {
     if (HEAP32[$3 + 32 >> 2] == 2) {
      HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 24 >> 2];
      HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 28 >> 2];
      HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 16 >> 2];
      break label$20;
     }
     label$22 : {
      if (HEAP32[$3 + 32 >> 2] == 3) {
       HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 24 >> 2];
       HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 20 >> 2];
       HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 28 >> 2];
       break label$22;
      }
      label$24 : {
       if (HEAP32[$3 + 32 >> 2] == 4) {
        HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 16 >> 2];
        HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 24 >> 2];
        HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 28 >> 2];
        break label$24;
       }
       label$26 : {
        if (HEAP32[$3 + 32 >> 2] == 5) {
         HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 28 >> 2];
         HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 24 >> 2];
         HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 20 >> 2];
         break label$26;
        }
        HEAP32[$3 + 44 >> 2] = 0;
        HEAP32[$3 + 40 >> 2] = 0;
        HEAP32[$3 + 36 >> 2] = 0;
       }
      }
     }
    }
   }
  }
  HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 44 >> 2] | (HEAP32[$3 + 36 >> 2] << 16 | HEAP32[$3 + 40 >> 2] << 8);
 }
 return HEAP32[$3 + 76 >> 2];
}
function jshPinFunctionToString($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP16[$3 + 46 >> 1] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP32[$3 + 36 >> 2] = $2;
 HEAP32[$3 + 32 >> 2] = 16;
 HEAP32[$3 + 28 >> 2] = 80920;
 HEAP16[$3 + 26 >> 1] = HEAPU16[$3 + 46 >> 1] & 61440;
 HEAP16[$3 + 24 >> 1] = 0;
 HEAP32[$3 + 20 >> 2] = 0;
 HEAP8[HEAP32[$3 + 36 >> 2]] = 0;
 label$1 : {
  if (!((HEAPU16[$3 + 46 >> 1] & 4080) < 768 | (HEAPU16[$3 + 46 >> 1] & 4080) > 848)) {
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 40 >> 2] & 16 ? 80921 : 80928;
   HEAP16[$3 + 24 >> 1] = 768;
   label$3 : {
    if (!HEAPU16[$3 + 26 >> 1]) {
     HEAP32[$3 + 20 >> 2] = 80934;
     break label$3;
    }
    label$5 : {
     if (HEAPU16[$3 + 26 >> 1] == 4096) {
      HEAP32[$3 + 20 >> 2] = 80937;
      break label$5;
     }
     if (HEAPU16[$3 + 26 >> 1] == 8192) {
      HEAP32[$3 + 20 >> 2] = 80940;
     }
    }
   }
   break label$1;
  }
  label$8 : {
   if (!((HEAPU16[$3 + 46 >> 1] & 4080) < 512 | (HEAPU16[$3 + 46 >> 1] & 4080) > 544)) {
    HEAP32[$3 + 28 >> 2] = 80943;
    HEAP16[$3 + 24 >> 1] = 512;
    label$10 : {
     if (!HEAPU16[$3 + 26 >> 1]) {
      HEAP32[$3 + 20 >> 2] = 80947;
      break label$10;
     }
     label$12 : {
      if (HEAPU16[$3 + 26 >> 1] == 4096) {
       HEAP32[$3 + 20 >> 2] = 80952;
       break label$12;
      }
      if (HEAPU16[$3 + 26 >> 1] == 8192) {
       HEAP32[$3 + 20 >> 2] = 80957;
      }
     }
    }
    break label$8;
   }
   label$15 : {
    if (!((HEAPU16[$3 + 46 >> 1] & 4080) < 640 | (HEAPU16[$3 + 46 >> 1] & 4080) > 688)) {
     HEAP32[$3 + 28 >> 2] = 80961;
     HEAP16[$3 + 24 >> 1] = 640;
     label$17 : {
      if (!HEAPU16[$3 + 26 >> 1]) {
       HEAP32[$3 + 20 >> 2] = 80965;
       break label$17;
      }
      if (HEAPU16[$3 + 26 >> 1] == 4096) {
       HEAP32[$3 + 20 >> 2] = 80969;
      }
     }
     break label$15;
    }
    label$20 : {
     if ((HEAPU16[$3 + 46 >> 1] & 4080) == 384) {
      HEAP32[$3 + 28 >> 2] = 80973;
      HEAP16[$3 + 24 >> 1] = 384;
      label$22 : {
       if (!HEAPU16[$3 + 26 >> 1]) {
        HEAP32[$3 + 20 >> 2] = 80977;
        break label$22;
       }
       if (HEAPU16[$3 + 26 >> 1] == 4096) {
        HEAP32[$3 + 20 >> 2] = 80981;
       }
      }
      break label$20;
     }
     if (!((HEAPU16[$3 + 46 >> 1] & 4080) < 16 | (HEAPU16[$3 + 46 >> 1] & 4080) > 288)) {
      HEAP32[$3 + 28 >> 2] = 80985;
      HEAP16[$3 + 24 >> 1] = 16;
      HEAP32[$3 + 20 >> 2] = $3 + 15;
      HEAP8[$3 + 15 | 0] = 67;
      HEAP8[$3 + 16 | 0] = 72;
      HEAP8[$3 + 17 | 0] = ((HEAPU16[$3 + 26 >> 1] & 28672) >> 12) + 49;
      label$26 : {
       if (HEAPU16[$3 + 26 >> 1] & 32768) {
        HEAP8[$3 + 18 | 0] = 78;
        HEAP8[$3 + 19 | 0] = 0;
        break label$26;
       }
       HEAP8[$3 + 18 | 0] = 0;
      }
     }
    }
   }
  }
 }
 HEAP32[$3 + 8 >> 2] = ((HEAPU16[$3 + 46 >> 1] & 4080) - HEAPU16[$3 + 24 >> 1] >> 4) + 1;
 label$28 : {
  if (!HEAP32[$3 + 28 >> 2]) {
   HEAP32[$3 >> 2] = HEAPU16[$3 + 46 >> 1];
   jsiConsolePrintf(80989, $3);
   break label$28;
  }
  if (HEAP32[$3 + 40 >> 2] & 1) {
   strncat(HEAP32[$3 + 36 >> 2], HEAP32[$3 + 28 >> 2], HEAP32[$3 + 32 >> 2] - 1 | 0);
  }
  if (HEAP32[$3 + 40 >> 2] & 2) {
   itostr(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 36 >> 2] + strlen(HEAP32[$3 + 36 >> 2]) | 0, 10);
  }
  if (HEAP32[$3 + 40 >> 2] & 4) {
   strncat(HEAP32[$3 + 36 >> 2], 81023, HEAP32[$3 + 32 >> 2] - (strlen(HEAP32[$3 + 36 >> 2]) + 1 | 0) | 0);
  }
  if (!HEAP32[$3 + 20 >> 2] | !(HEAP32[$3 + 40 >> 2] & 8)) {
   break label$28;
  }
  strncat(HEAP32[$3 + 36 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 32 >> 2] - (strlen(HEAP32[$3 + 36 >> 2]) + 1 | 0) | 0);
 }
 global$0 = $3 + 48 | 0;
}
function tflite__ops__micro__depthwise_conv__Eval_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 label$1 : {
  if (!HEAP32[HEAP32[$2 + 36 >> 2] + 8 >> 2]) {
   break label$1;
  }
 }
 label$2 : {
  if (!HEAP32[HEAP32[$2 + 36 >> 2] + 12 >> 2]) {
   break label$2;
  }
 }
 HEAP32[$2 + 32 >> 2] = HEAP32[HEAP32[$2 + 36 >> 2] + 12 >> 2];
 HEAP32[$2 + 28 >> 2] = HEAP32[HEAP32[$2 + 36 >> 2] + 8 >> 2];
 HEAP32[$2 + 24 >> 2] = tflite__micro__GetEvalOutput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
 HEAP32[$2 + 20 >> 2] = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], 0);
 HEAP32[$2 + 16 >> 2] = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], 1);
 $0 = $2;
 label$3 : {
  if ((tflite__NumInputs_28TfLiteNode_20const__29(HEAP32[$2 + 36 >> 2]) | 0) == 3) {
   $1 = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], 2);
   break label$3;
  }
  $1 = 0;
 }
 HEAP32[$0 + 12 >> 2] = $1;
 label$5 : {
  label$6 : {
   label$7 : {
    $0 = HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2] + -1 | 0;
    if ($0 >>> 0 > 8) {
     break label$7;
    }
    label$8 : {
     switch ($0 - 1 | 0) {
     default:
      tflite__ops__micro__depthwise_conv__EvalFloat_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteDepthwiseConvParams__2c_20tflite__ops__micro__depthwise_conv___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], HEAP32[$2 + 32 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 24 >> 2]);
      break label$6;
     case 7:
      tflite__ops__micro__depthwise_conv__EvalQuantizedPerChannel_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteDepthwiseConvParams__2c_20tflite__ops__micro__depthwise_conv___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], HEAP32[$2 + 32 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 24 >> 2]);
      break label$6;
     case 0:
     case 2:
     case 3:
     case 4:
     case 5:
     case 6:
      break label$7;
     case 1:
      break label$8;
     }
    }
    tflite__ops__micro__depthwise_conv__EvalQuantized_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteDepthwiseConvParams__2c_20tflite__ops__micro__depthwise_conv___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], HEAP32[$2 + 32 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 24 >> 2]);
    break label$6;
   }
   $0 = HEAP32[HEAP32[$2 + 40 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 40 >> 2];
   $3 = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2]);
   HEAP32[$2 + 4 >> 2] = HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2];
   HEAP32[$2 >> 2] = $3;
   FUNCTION_TABLE[$0]($1, 133727, $2);
   HEAP32[$2 + 44 >> 2] = 1;
   break label$5;
  }
  HEAP32[$2 + 44 >> 2] = 0;
 }
 global$0 = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}
function tflite__ops__micro__conv__EvalQuantized_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteConvParams__2c_20tflite__ops__micro__conv__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__2c_20TfLiteEvalTensor__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0, $9 = 0;
 $8 = global$0 - 240 | 0;
 global$0 = $8;
 $9 = $8 + 104 | 0;
 HEAP32[$8 + 236 >> 2] = $0;
 HEAP32[$8 + 232 >> 2] = $1;
 HEAP32[$8 + 228 >> 2] = $2;
 HEAP32[$8 + 224 >> 2] = $3;
 HEAP32[$8 + 220 >> 2] = $4;
 HEAP32[$8 + 216 >> 2] = $5;
 HEAP32[$8 + 212 >> 2] = $6;
 HEAP32[$8 + 208 >> 2] = 0;
 HEAP32[$8 + 204 >> 2] = 0;
 HEAP32[$8 + 200 >> 2] = $7;
 HEAP32[$8 + 196 >> 2] = 0 - HEAP32[HEAP32[$8 + 224 >> 2] + 16 >> 2];
 HEAP32[$8 + 192 >> 2] = 0 - HEAP32[HEAP32[$8 + 224 >> 2] + 20 >> 2];
 HEAP32[$8 + 188 >> 2] = HEAP32[HEAP32[$8 + 224 >> 2] + 24 >> 2];
 HEAP8[$8 + 128 | 0] = tflite__ops__micro__conv__RuntimePaddingType_28TfLitePadding_29(HEAP32[HEAP32[$8 + 228 >> 2] >> 2]);
 HEAP16[$8 + 130 >> 1] = HEAP32[HEAP32[$8 + 224 >> 2] >> 2];
 HEAP16[$8 + 132 >> 1] = HEAP32[HEAP32[$8 + 224 >> 2] + 4 >> 2];
 HEAP16[$8 + 138 >> 1] = HEAP32[HEAP32[$8 + 228 >> 2] + 4 >> 2];
 HEAP16[$8 + 140 >> 1] = HEAP32[HEAP32[$8 + 228 >> 2] + 8 >> 2];
 HEAP16[$8 + 142 >> 1] = HEAP32[HEAP32[$8 + 228 >> 2] + 16 >> 2];
 HEAP16[$8 + 144 >> 1] = HEAP32[HEAP32[$8 + 228 >> 2] + 20 >> 2];
 HEAP32[$8 + 148 >> 2] = HEAP32[$8 + 196 >> 2];
 HEAP32[$8 + 152 >> 2] = HEAP32[$8 + 192 >> 2];
 HEAP32[$8 + 156 >> 2] = HEAP32[$8 + 188 >> 2];
 HEAP32[$8 + 160 >> 2] = HEAP32[HEAP32[$8 + 224 >> 2] + 28 >> 2];
 HEAP32[$8 + 164 >> 2] = 0 - HEAP32[HEAP32[$8 + 224 >> 2] + 32 >> 2];
 HEAP32[$8 + 168 >> 2] = HEAP32[HEAP32[$8 + 224 >> 2] + 44 >> 2];
 HEAP32[$8 + 172 >> 2] = HEAP32[HEAP32[$8 + 224 >> 2] + 48 >> 2];
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($9, HEAP32[$8 + 220 >> 2]);
 $0 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$8 + 220 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 72 | 0, HEAP32[$8 + 216 >> 2]);
 $1 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$8 + 216 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 48 | 0, HEAP32[$8 + 212 >> 2]);
 $2 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$8 + 212 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 24 | 0, HEAP32[$8 + 200 >> 2]);
 $3 = float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$8 + 200 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8, HEAP32[$8 + 208 >> 2]);
 tflite__reference_ops__Conv_28tflite__ConvParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__2c_20void__29($8 + 128 | 0, $8 + 104 | 0, $0, $8 + 72 | 0, $1, $8 + 48 | 0, $2, $8 + 24 | 0, $3, $8, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$8 + 208 >> 2]));
 $0 = $8 + 104 | 0;
 $1 = $8 + 72 | 0;
 $2 = $8 + 48 | 0;
 $3 = $8 + 24 | 0;
 tflite__RuntimeShape___RuntimeShape_28_29($8);
 tflite__RuntimeShape___RuntimeShape_28_29($3);
 tflite__RuntimeShape___RuntimeShape_28_29($2);
 tflite__RuntimeShape___RuntimeShape_28_29($1);
 tflite__RuntimeShape___RuntimeShape_28_29($0);
 global$0 = $8 + 240 | 0;
}
function jslNewTokenisedStringFromLexer($0, $1) {
 var $2 = 0;
 $2 = global$0 - 240 | 0;
 global$0 = $2;
 HEAP32[$2 + 236 >> 2] = $0;
 HEAP32[$2 + 232 >> 2] = $1;
 HEAP32[$2 + 228 >> 2] = HEAP32[35539];
 HEAP32[35539] = $2 + 104;
 HEAP32[$2 + 100 >> 2] = 0;
 jslInit(HEAP32[HEAP32[$2 + 228 >> 2] + 84 >> 2]);
 jslSeekToP(HEAP32[$2 + 236 >> 2]);
 HEAP32[$2 + 96 >> 2] = 0;
 while (1) {
  if (HEAP16[HEAP32[35539] + 2 >> 1]) {
   $0 = jsvStringIteratorGetIndex(HEAP32[35539] + 88 | 0) >>> 0 <= HEAP32[$2 + 232 >> 2] + 1 >>> 0;
  } else {
   $0 = 0;
  }
  if ($0) {
   if (jslPreserveSpaceBetweenTokens(HEAP32[$2 + 96 >> 2], HEAP16[HEAP32[35539] + 2 >> 1]) & 1) {
    HEAP32[$2 + 100 >> 2] = HEAP32[$2 + 100 >> 2] + 1;
   }
   label$6 : {
    label$7 : {
     label$8 : {
      if (HEAP16[HEAP32[35539] + 2 >> 1] == 128 | HEAP16[HEAP32[35539] + 2 >> 1] == 129 | (HEAP16[HEAP32[35539] + 2 >> 1] == 130 | HEAP16[HEAP32[35539] + 2 >> 1] == 131)) {
       break label$8;
      }
      if (HEAP16[HEAP32[35539] + 2 >> 1] == 133) {
       break label$8;
      }
      if (HEAP16[HEAP32[35539] + 2 >> 1] != 135) {
       break label$7;
      }
     }
     HEAP32[$2 + 100 >> 2] = (jsvStringIteratorGetIndex(HEAP32[35539] + 88 | 0) - (HEAP32[HEAP32[35539] + 4 >> 2] + 1 | 0) | 0) + HEAP32[$2 + 100 >> 2];
     break label$6;
    }
    HEAP32[$2 + 100 >> 2] = HEAP32[$2 + 100 >> 2] + 1;
   }
   HEAP32[$2 + 96 >> 2] = HEAP16[HEAP32[35539] + 2 >> 1];
   jslGetNextToken();
   continue;
  }
  break;
 }
 HEAP32[$2 + 92 >> 2] = jsvNewStringOfLength(HEAP32[$2 + 100 >> 2], 0);
 if (HEAP32[$2 + 92 >> 2]) {
  $0 = $2 + 16 | 0;
  jsvStringIteratorNew($2 + 56 | 0, HEAP32[$2 + 92 >> 2], 0);
  jslSeekToP(HEAP32[$2 + 236 >> 2]);
  HEAP8[$2 + 15 | 0] = HEAPU8[HEAP32[$2 + 236 >> 2] + 36 | 0];
  jsvStringIteratorClone($0, HEAP32[$2 + 236 >> 2]);
  HEAP32[$2 + 96 >> 2] = 0;
  while (1) {
   if (HEAP16[HEAP32[35539] + 2 >> 1]) {
    $0 = jsvStringIteratorGetIndex(HEAP32[35539] + 88 | 0) >>> 0 <= HEAP32[$2 + 232 >> 2] + 1 >>> 0;
   } else {
    $0 = 0;
   }
   if ($0) {
    if (jslPreserveSpaceBetweenTokens(HEAP32[$2 + 96 >> 2], HEAP16[HEAP32[35539] + 2 >> 1]) & 1) {
     jsvStringIteratorSetCharAndNext($2 + 56 | 0, 32);
    }
    label$15 : {
     label$16 : {
      label$17 : {
       if (HEAP16[HEAP32[35539] + 2 >> 1] == 128 | HEAP16[HEAP32[35539] + 2 >> 1] == 129 | (HEAP16[HEAP32[35539] + 2 >> 1] == 130 | HEAP16[HEAP32[35539] + 2 >> 1] == 131)) {
        break label$17;
       }
       if (HEAP16[HEAP32[35539] + 2 >> 1] == 133) {
        break label$17;
       }
       if (HEAP16[HEAP32[35539] + 2 >> 1] != 135) {
        break label$16;
       }
      }
      jsvStringIteratorSetCharAndNext($2 + 56 | 0, HEAP8[$2 + 15 | 0]);
      while (1) {
       if (jsvStringIteratorGetIndex($2 + 16 | 0) + 1 >>> 0 < jsvStringIteratorGetIndex(HEAP32[35539] + 88 | 0) >>> 0) {
        jsvStringIteratorSetCharAndNext($2 + 56 | 0, jsvStringIteratorGetCharAndNext($2 + 16 | 0) << 24 >> 24);
        continue;
       }
       break;
      }
      break label$15;
     }
     jsvStringIteratorSetCharAndNext($2 + 56 | 0, HEAPU16[HEAP32[35539] + 2 >> 1] << 24 >> 24);
    }
    $0 = $2 + 16 | 0;
    HEAP32[$2 + 96 >> 2] = HEAP16[HEAP32[35539] + 2 >> 1];
    jslSkipWhiteSpace();
    jsvStringIteratorFree($0);
    jsvStringIteratorClone($0, HEAP32[35539] + 88 | 0);
    HEAP8[$2 + 15 | 0] = HEAPU8[HEAP32[35539]];
    jslGetNextToken();
    continue;
   }
   break;
  }
  $0 = $2 + 56 | 0;
  jsvStringIteratorFree($2 + 16 | 0);
  jsvStringIteratorFree($0);
 }
 jslKill();
 HEAP32[35539] = HEAP32[$2 + 228 >> 2];
 global$0 = $2 + 240 | 0;
 return HEAP32[$2 + 92 >> 2];
}
function jspeStatementSwitch() {
 var $0 = 0, $1 = 0;
 $0 = global$0 - 32 | 0;
 global$0 = $0;
 jslGetNextToken();
 label$1 : {
  if (!(jslMatch(40) & 1)) {
   break label$1;
  }
  HEAP32[$0 + 24 >> 2] = jspeExpression();
  HEAP32[$0 + 20 >> 2] = HEAP32[80549];
  HEAP8[$0 + 19 | 0] = (HEAP32[80549] & 63) == 1;
  if (!(jslMatch(41) & 1)) {
   jsvUnLock(HEAP32[$0 + 24 >> 2]);
   break label$1;
  }
  if (!(HEAP8[$0 + 19 | 0] & 1)) {
   jsvUnLock(HEAP32[$0 + 24 >> 2]);
   jspeBlock();
   break label$1;
  }
  if (!(jslMatch(123) & 1)) {
   jsvUnLock(HEAP32[$0 + 24 >> 2]);
   break label$1;
  }
  HEAP8[$0 + 18 | 0] = 1;
  if (HEAP8[$0 + 19 | 0] & 1) {
   HEAP32[80549] = 1024;
  }
  while (1) {
   if (HEAP16[HEAP32[35539] + 2 >> 1] == 188) {
    if (!(jslMatch(188) & 1)) {
     jsvUnLock(HEAP32[$0 + 24 >> 2]);
     break label$1;
    }
    HEAP32[$0 + 12 >> 2] = HEAP32[80549];
    if (HEAP8[$0 + 19 | 0] & 1) {
     HEAP32[80549] = 1025;
    }
    HEAP32[$0 + 8 >> 2] = __jspeAssignmentExpression(jspeConditionalExpression());
    HEAP32[80549] = HEAP32[$0 + 12 >> 2] | 1024;
    if (!(jslMatch(58) & 1)) {
     jsvUnLock2(HEAP32[$0 + 24 >> 2], HEAP32[$0 + 8 >> 2]);
     break label$1;
    }
    HEAP8[$0 + 7 | 0] = 0;
    if (HEAP8[$0 + 19 | 0] & 1) {
     HEAP8[$0 + 7 | 0] = jsvGetBoolAndUnLock(jsvMathsOpSkipNames(HEAP32[$0 + 24 >> 2], HEAP32[$0 + 8 >> 2], 139)) & 1;
    }
    if (HEAP8[$0 + 7 | 0] & 1) {
     HEAP8[$0 + 18 | 0] = 0;
    }
    jsvUnLock(HEAP32[$0 + 8 >> 2]);
    if (!(!(HEAP8[$0 + 7 | 0] & 1) | HEAP32[80549] & 63)) {
     HEAP32[80549] = 1025;
    }
    while (1) {
     $1 = 0;
     label$15 : {
      if (HEAP32[80549] & 80) {
       break label$15;
      }
      $1 = 0;
      if (!HEAP16[HEAP32[35539] + 2 >> 1]) {
       break label$15;
      }
      $1 = 0;
      if (HEAP16[HEAP32[35539] + 2 >> 1] == 188) {
       break label$15;
      }
      $1 = 0;
      if (HEAP16[HEAP32[35539] + 2 >> 1] == 189) {
       break label$15;
      }
      $1 = HEAP16[HEAP32[35539] + 2 >> 1] != 125;
     }
     if ($1) {
      jsvUnLock(jspeBlockOrStatement());
      continue;
     }
     break;
    }
    HEAP32[$0 + 20 >> 2] = HEAP32[$0 + 20 >> 2] | HEAP32[80549] & 120;
    continue;
   }
   break;
  }
  jsvUnLock(HEAP32[$0 + 24 >> 2]);
  label$17 : {
   if (!(!(HEAP8[$0 + 19 | 0] & 1) | (HEAP32[80549] & 63) != 2)) {
    HEAP32[80549] = 1025;
    break label$17;
   }
   HEAP8[$0 + 18 | 0] = 1;
  }
  HEAP32[80549] = HEAP32[80549] & -1664 | HEAP32[$0 + 20 >> 2] & 1663;
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 189) {
   jslGetNextToken();
   if (!(jslMatch(58) & 1)) {
    break label$1;
   }
   HEAP32[$0 >> 2] = HEAP32[80549];
   label$20 : {
    if (!(HEAP8[$0 + 18 | 0] & 1)) {
     jspSetNoExecute();
     break label$20;
    }
    HEAP32[80549] = HEAP32[80549] | 1024;
   }
   while (1) {
    $1 = 0;
    label$23 : {
     if (HEAP32[80549] & 80) {
      break label$23;
     }
     $1 = 0;
     if (!HEAP16[HEAP32[35539] + 2 >> 1]) {
      break label$23;
     }
     $1 = 0;
     if (HEAP16[HEAP32[35539] + 2 >> 1] == 125) {
      break label$23;
     }
     $1 = HEAP16[HEAP32[35539] + 2 >> 1] != 188;
    }
    if ($1) {
     jsvUnLock(jspeBlockOrStatement());
     continue;
    }
    break;
   }
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2] | HEAP32[80549] & 120;
   HEAP32[80549] = HEAP32[80549] & -3;
   HEAP32[80549] = HEAP32[80549] & -1664 | HEAP32[$0 >> 2] & 1663;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 188) {
   jsExceptionHere(2, 80565, 0);
   break label$1;
  }
  jslMatch(125);
 }
 HEAP32[$0 + 28 >> 2] = 0;
 global$0 = $0 + 32 | 0;
 return HEAP32[$0 + 28 >> 2];
}
function jsiTabComplete() {
 var $0 = 0, $1 = 0;
 $0 = global$0 - 320 | 0;
 global$0 = $0;
 label$1 : {
  if (!(jsvIsString(HEAP32[80557]) & 1)) {
   break label$1;
  }
  HEAP32[$0 + 316 >> 2] = 0;
  HEAP32[$0 + 300 >> 2] = 0;
  HEAP32[$0 + 292 >> 2] = 0;
  HEAP32[$0 + 164 >> 2] = jslSetLex($0 + 168 | 0);
  jslInit(HEAP32[80557]);
  while (1) {
   if (HEAP16[$0 + 170 >> 1] ? HEAP32[$0 + 172 >> 2] + 1 >>> 0 <= HEAPU32[80559] : 0) {
    label$6 : {
     if (HEAP16[$0 + 170 >> 1] == 46) {
      jsvUnLock(HEAP32[$0 + 316 >> 2]);
      HEAP32[$0 + 316 >> 2] = HEAP32[$0 + 300 >> 2];
      HEAP32[$0 + 300 >> 2] = 0;
      break label$6;
     }
     label$8 : {
      if (HEAP16[$0 + 170 >> 1] == 128) {
       jsvUnLock(HEAP32[$0 + 300 >> 2]);
       HEAP32[$0 + 300 >> 2] = jslGetTokenValueAsVar();
       HEAP32[$0 + 292 >> 2] = HEAP32[$0 + 172 >> 2] + 1;
       break label$8;
      }
      jsvUnLock(HEAP32[$0 + 316 >> 2]);
      HEAP32[$0 + 316 >> 2] = 0;
      jsvUnLock(HEAP32[$0 + 300 >> 2]);
      HEAP32[$0 + 300 >> 2] = 0;
     }
    }
    jslGetNextToken();
    continue;
   }
   break;
  }
  jslKill();
  jslSetLex(HEAP32[$0 + 164 >> 2]);
  if (!(HEAP32[$0 + 316 >> 2] | HEAP32[$0 + 300 >> 2])) {
   break label$1;
  }
  label$11 : {
   if (HEAP32[$0 + 300 >> 2]) {
    HEAP32[$0 + 296 >> 2] = jsvGetStringLength(HEAP32[$0 + 300 >> 2]);
    HEAP32[$0 + 160 >> 2] = (HEAP32[80559] + 1 | 0) - HEAP32[$0 + 292 >> 2];
    if (HEAPU32[$0 + 160 >> 2] > HEAPU32[$0 + 296 >> 2]) {
     jsvUnLock2(HEAP32[$0 + 316 >> 2], HEAP32[$0 + 300 >> 2]);
     break label$1;
    }
    if (HEAPU32[$0 + 160 >> 2] < HEAPU32[$0 + 296 >> 2]) {
     HEAP32[$0 + 156 >> 2] = jsvNewFromStringVar(HEAP32[$0 + 300 >> 2], 0, HEAP32[$0 + 160 >> 2]);
     jsvUnLock(HEAP32[$0 + 300 >> 2]);
     HEAP32[$0 + 300 >> 2] = HEAP32[$0 + 156 >> 2];
     HEAP32[$0 + 296 >> 2] = HEAP32[$0 + 160 >> 2];
    }
    break label$11;
   }
   HEAP32[$0 + 300 >> 2] = jsvNewWithFlags(27);
   HEAP32[$0 + 296 >> 2] = 0;
  }
  if (HEAP32[$0 + 316 >> 2]) {
   $1 = $0 + 80 | 0;
   jsvGetString(HEAP32[$0 + 316 >> 2], $1, 64);
   HEAP32[$0 + 76 >> 2] = jspGetNamedVariable($1);
   label$16 : {
    if (jsvIsVariableDefined(HEAP32[$0 + 76 >> 2]) & 1) {
     HEAP32[$0 + 76 >> 2] = jsvSkipNameAndUnLock(HEAP32[$0 + 76 >> 2]);
     break label$16;
    }
    jsvUnLock(HEAP32[$0 + 76 >> 2]);
    HEAP32[$0 + 76 >> 2] = 0;
   }
   jsvUnLock(HEAP32[$0 + 316 >> 2]);
   HEAP32[$0 + 316 >> 2] = HEAP32[$0 + 76 >> 2];
   if (!HEAP32[$0 + 76 >> 2]) {
    jsvUnLock(HEAP32[$0 + 300 >> 2]);
    break label$1;
   }
  }
  if (!HEAP32[$0 + 316 >> 2]) {
   HEAP32[$0 + 316 >> 2] = jsvLockAgain(HEAP32[80545]);
  }
  HEAP32[$0 + 304 >> 2] = 0;
  HEAP32[$0 + 308 >> 2] = 0;
  jswrap_object_keys_or_property_names_cb(HEAP32[$0 + 316 >> 2], 1, 1, 10, $0 + 296 | 0);
  if (HEAP32[$0 + 308 >> 2] > 1) {
   $1 = $0 + 296 | 0;
   jsiMoveCursorChar(HEAP32[80557], HEAP32[80559], HEAP32[35419]);
   HEAP8[322232] = 1;
   jsiConsolePrintString(81737);
   HEAP32[$0 + 312 >> 2] = 0;
   jswrap_object_keys_or_property_names_cb(HEAP32[$0 + 316 >> 2], 1, 1, 11, $1);
   if (HEAP32[$0 + 312 >> 2]) {
    jsiConsolePrintString(81553);
   }
   jsiConsolePrintString(81553);
   jsiConsoleReturnInputLine();
  }
  jsvUnLock2(HEAP32[$0 + 316 >> 2], HEAP32[$0 + 300 >> 2]);
  if (!HEAP32[$0 + 304 >> 2]) {
   break label$1;
  }
  jsvGetString(HEAP32[$0 + 304 >> 2], $0, 64);
  if (HEAPU32[$0 + 296 >> 2] < strlen($0) >>> 0) {
   jsiAppendStringToInputLine(HEAP32[$0 + 296 >> 2] + $0 | 0);
  }
  jsvUnLock(HEAP32[$0 + 304 >> 2]);
 }
 global$0 = $0 + 320 | 0;
}
function mbedtls_sha256_process($0, $1) {
 var $2 = 0;
 $2 = global$0 - 320 | 0;
 global$0 = $2;
 HEAP32[$2 + 316 >> 2] = $0;
 HEAP32[$2 + 312 >> 2] = $1;
 HEAP32[$2 + 12 >> 2] = 0;
 while (1) {
  if (HEAPU32[$2 + 12 >> 2] < 8) {
   HEAP32[($2 + 16 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2] = HEAP32[(HEAP32[$2 + 316 >> 2] + 8 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2];
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[$2 + 12 >> 2] = 0;
 while (1) {
  if (HEAPU32[$2 + 12 >> 2] < 64) {
   label$5 : {
    if (HEAPU32[$2 + 12 >> 2] < 16) {
     HEAP32[($2 + 48 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2] = HEAPU8[HEAP32[$2 + 312 >> 2] + ((HEAP32[$2 + 12 >> 2] << 2) + 3 | 0) | 0] | (HEAPU8[HEAP32[$2 + 312 >> 2] + (HEAP32[$2 + 12 >> 2] << 2) | 0] << 24 | HEAPU8[HEAP32[$2 + 312 >> 2] + ((HEAP32[$2 + 12 >> 2] << 2) + 1 | 0) | 0] << 16 | HEAPU8[HEAP32[$2 + 312 >> 2] + ((HEAP32[$2 + 12 >> 2] << 2) + 2 | 0) | 0] << 8);
     break label$5;
    }
    $0 = $2 + 48 | 0;
    HEAP32[$0 + (HEAP32[$2 + 12 >> 2] << 2) >> 2] = HEAP32[$0 + (HEAP32[$2 + 12 >> 2] - 16 << 2) >> 2] + ((HEAP32[$0 + (HEAP32[$2 + 12 >> 2] - 7 << 2) >> 2] + ((HEAP32[$0 + (HEAP32[$2 + 12 >> 2] - 2 << 2) >> 2] << 15 | HEAP32[$0 + (HEAP32[$2 + 12 >> 2] - 2 << 2) >> 2] >>> 17) ^ (HEAP32[$0 + (HEAP32[$2 + 12 >> 2] - 2 << 2) >> 2] << 13 | HEAP32[$0 + (HEAP32[$2 + 12 >> 2] - 2 << 2) >> 2] >>> 19) ^ HEAP32[$0 + (HEAP32[$2 + 12 >> 2] - 2 << 2) >> 2] >>> 10) | 0) + ((HEAP32[$0 + (HEAP32[$2 + 12 >> 2] - 15 << 2) >> 2] << 25 | HEAP32[$0 + (HEAP32[$2 + 12 >> 2] - 15 << 2) >> 2] >>> 7) ^ (HEAP32[$0 + (HEAP32[$2 + 12 >> 2] - 15 << 2) >> 2] << 14 | HEAP32[$0 + (HEAP32[$2 + 12 >> 2] - 15 << 2) >> 2] >>> 18) ^ HEAP32[$0 + (HEAP32[$2 + 12 >> 2] - 15 << 2) >> 2] >>> 3) | 0);
   }
   HEAP32[$2 + 308 >> 2] = HEAP32[($2 + 48 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2] + (HEAP32[(HEAP32[$2 + 12 >> 2] << 2) + 108480 >> 2] + ((HEAP32[$2 + 44 >> 2] + ((HEAP32[$2 + 32 >> 2] << 7 | HEAP32[$2 + 32 >> 2] >>> 25) ^ ((HEAP32[$2 + 32 >> 2] << 26 | HEAP32[$2 + 32 >> 2] >>> 6) ^ (HEAP32[$2 + 32 >> 2] << 21 | HEAP32[$2 + 32 >> 2] >>> 11))) | 0) + (HEAP32[$2 + 40 >> 2] ^ HEAP32[$2 + 32 >> 2] & (HEAP32[$2 + 36 >> 2] ^ HEAP32[$2 + 40 >> 2])) | 0) | 0);
   HEAP32[$2 + 304 >> 2] = (HEAP32[$2 + 16 >> 2] & HEAP32[$2 + 20 >> 2] | HEAP32[$2 + 24 >> 2] & (HEAP32[$2 + 16 >> 2] | HEAP32[$2 + 20 >> 2])) + ((HEAP32[$2 + 16 >> 2] << 10 | HEAP32[$2 + 16 >> 2] >>> 22) ^ ((HEAP32[$2 + 16 >> 2] << 30 | HEAP32[$2 + 16 >> 2] >>> 2) ^ (HEAP32[$2 + 16 >> 2] << 19 | HEAP32[$2 + 16 >> 2] >>> 13)));
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 308 >> 2] + HEAP32[$2 + 28 >> 2];
   HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 308 >> 2] + HEAP32[$2 + 304 >> 2];
   HEAP32[$2 + 308 >> 2] = HEAP32[$2 + 44 >> 2];
   HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 40 >> 2];
   HEAP32[$2 + 40 >> 2] = HEAP32[$2 + 36 >> 2];
   HEAP32[$2 + 36 >> 2] = HEAP32[$2 + 32 >> 2];
   HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 28 >> 2];
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 24 >> 2];
   HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 20 >> 2];
   HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 16 >> 2];
   HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 308 >> 2];
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[$2 + 12 >> 2] = 0;
 while (1) {
  if (HEAPU32[$2 + 12 >> 2] < 8) {
   $0 = (HEAP32[$2 + 316 >> 2] + 8 | 0) + (HEAP32[$2 + 12 >> 2] << 2) | 0;
   HEAP32[$0 >> 2] = HEAP32[($2 + 16 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2] + HEAP32[$0 >> 2];
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $2 + 320 | 0;
}
function jspeFactorMember($0, $1) {
 var $2 = 0;
 $2 = global$0 - 80 | 0;
 global$0 = $2;
 HEAP32[$2 + 72 >> 2] = $0;
 HEAP32[$2 + 68 >> 2] = $1;
 HEAP32[$2 + 64 >> 2] = 0;
 label$1 : {
  while (1) {
   if (HEAP16[HEAP32[35539] + 2 >> 1] != 46 ? HEAP16[HEAP32[35539] + 2 >> 1] == 91 : 1) {
    if (HEAP16[HEAP32[35539] + 2 >> 1] == 46) {
     jslGetNextToken();
     label$7 : {
      if (jslIsIDOrReservedWord() & 1) {
       if ((HEAP32[80549] & 63) == 1) {
        HEAP32[$2 + 60 >> 2] = jslGetTokenValueAsString();
        HEAP32[$2 + 56 >> 2] = jsvSkipNameWithParent(HEAP32[$2 + 72 >> 2], 1, HEAP32[$2 + 64 >> 2]);
        HEAP32[$2 + 52 >> 2] = 0;
        if (HEAP32[$2 + 56 >> 2]) {
         HEAP32[$2 + 52 >> 2] = jspGetNamedField(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 60 >> 2], 1);
        }
        if (!HEAP32[$2 + 52 >> 2]) {
         label$12 : {
          if (!(jsvIsUndefined(HEAP32[$2 + 56 >> 2]) & 1)) {
           HEAP32[$2 + 48 >> 2] = jslGetTokenValueAsVar();
           HEAP32[$2 + 52 >> 2] = jsvCreateNewChild(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 48 >> 2], 0);
           jsvUnLock(HEAP32[$2 + 48 >> 2]);
           break label$12;
          }
          HEAP32[$2 >> 2] = HEAP32[$2 + 60 >> 2];
          jsExceptionHere(1, 79962, $2);
         }
        }
        jsvUnLock(HEAP32[$2 + 64 >> 2]);
        HEAP32[$2 + 64 >> 2] = HEAP32[$2 + 56 >> 2];
        jsvUnLock(HEAP32[$2 + 72 >> 2]);
        HEAP32[$2 + 72 >> 2] = HEAP32[$2 + 52 >> 2];
       }
       jslGetNextToken();
       break label$7;
      }
      if (!(jslMatch(128) & 1)) {
       HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 72 >> 2];
       break label$1;
      }
     }
     continue;
    }
    if (HEAP16[HEAP32[35539] + 2 >> 1] == 91) {
     jslGetNextToken();
     if (!(jspCheckStackPosition() & 1)) {
      HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 64 >> 2];
      break label$1;
     }
     HEAP32[$2 + 44 >> 2] = jsvSkipNameAndUnLock(__jspeAssignmentExpression(jspeConditionalExpression()));
     if (!(jslMatch(93) & 1)) {
      jsvUnLock2(HEAP32[$2 + 64 >> 2], HEAP32[$2 + 44 >> 2]);
      HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 72 >> 2];
      break label$1;
     }
     if ((HEAP32[80549] & 63) == 1) {
      HEAP32[$2 + 44 >> 2] = jsvAsArrayIndexAndUnLock(HEAP32[$2 + 44 >> 2]);
      HEAP32[$2 + 40 >> 2] = jsvSkipNameWithParent(HEAP32[$2 + 72 >> 2], 1, HEAP32[$2 + 64 >> 2]);
      HEAP32[$2 + 36 >> 2] = 0;
      if (HEAP32[$2 + 40 >> 2]) {
       HEAP32[$2 + 36 >> 2] = jspGetVarNamedField(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 44 >> 2], 1);
      }
      if (!HEAP32[$2 + 36 >> 2]) {
       label$21 : {
        if (jsvHasChildren(HEAP32[$2 + 40 >> 2]) & 1) {
         HEAP32[$2 + 36 >> 2] = jsvCreateNewChild(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 44 >> 2], 0);
         break label$21;
        }
        $0 = HEAP32[$2 + 44 >> 2];
        HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 40 >> 2];
        HEAP32[$2 + 16 >> 2] = $0;
        jsExceptionHere(1, 80001, $2 + 16 | 0);
       }
      }
      jsvUnLock(HEAP32[$2 + 64 >> 2]);
      HEAP32[$2 + 64 >> 2] = jsvLockAgainSafe(HEAP32[$2 + 40 >> 2]);
      jsvUnLock(HEAP32[$2 + 72 >> 2]);
      HEAP32[$2 + 72 >> 2] = HEAP32[$2 + 36 >> 2];
      jsvUnLock(HEAP32[$2 + 40 >> 2]);
     }
     jsvUnLock(HEAP32[$2 + 44 >> 2]);
    }
    continue;
   }
   break;
  }
  label$23 : {
   if (HEAP32[$2 + 68 >> 2]) {
    HEAP32[HEAP32[$2 + 68 >> 2] >> 2] = HEAP32[$2 + 64 >> 2];
    break label$23;
   }
   jsvUnLock(HEAP32[$2 + 64 >> 2]);
  }
  HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 72 >> 2];
 }
 global$0 = $2 + 80 | 0;
 return HEAP32[$2 + 76 >> 2];
}
function tflite__ops__micro__conv__Eval_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 HEAP32[$2 + 32 >> 2] = HEAP32[HEAP32[$2 + 36 >> 2] + 12 >> 2];
 HEAP32[$2 + 28 >> 2] = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], 0);
 HEAP32[$2 + 24 >> 2] = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], 1);
 $0 = $2;
 label$1 : {
  if ((tflite__NumInputs_28TfLiteNode_20const__29(HEAP32[$2 + 36 >> 2]) | 0) == 3) {
   $1 = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], 2);
   break label$1;
  }
  $1 = 0;
 }
 HEAP32[$0 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = tflite__micro__GetEvalOutput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
 label$3 : {
  if (!HEAP32[HEAP32[$2 + 36 >> 2] + 8 >> 2]) {
   break label$3;
  }
 }
 HEAP32[$2 + 12 >> 2] = HEAP32[HEAP32[$2 + 36 >> 2] + 8 >> 2];
 label$4 : {
  label$5 : {
   label$6 : {
    $0 = HEAP32[HEAP32[$2 + 28 >> 2] + 8 >> 2] + -1 | 0;
    if ($0 >>> 0 > 8) {
     break label$6;
    }
    label$7 : {
     switch ($0 - 1 | 0) {
     default:
      tflite__ops__micro__conv__EvalFloat_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteConvParams__2c_20tflite__ops__micro__conv__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__2c_20TfLiteEvalTensor__2c_20TfLiteEvalTensor__29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], HEAP32[$2 + 32 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2]);
      break label$5;
     case 7:
      tflite__ops__micro__conv__EvalQuantizedPerChannel_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteConvParams__2c_20tflite__ops__micro__conv__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__2c_20TfLiteEvalTensor__29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], HEAP32[$2 + 32 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2]);
      break label$5;
     case 0:
     case 2:
     case 3:
     case 4:
     case 5:
     case 6:
      break label$6;
     case 1:
      break label$7;
     }
    }
    tflite__ops__micro__conv__EvalQuantized_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteConvParams__2c_20tflite__ops__micro__conv__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__2c_20TfLiteEvalTensor__2c_20TfLiteEvalTensor__29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], HEAP32[$2 + 32 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2]);
    break label$5;
   }
   $0 = HEAP32[HEAP32[$2 + 40 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 40 >> 2];
   $3 = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 28 >> 2] + 8 >> 2]);
   HEAP32[$2 + 4 >> 2] = HEAP32[HEAP32[$2 + 28 >> 2] + 8 >> 2];
   HEAP32[$2 >> 2] = $3;
   FUNCTION_TABLE[$0]($1, 134325, $2);
   HEAP32[$2 + 44 >> 2] = 1;
   break label$4;
  }
  HEAP32[$2 + 44 >> 2] = 0;
 }
 global$0 = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}
function _jswrap_banglejs_setOptions($0, $1) {
 var $2 = 0;
 $2 = global$0 - 272 | 0;
 global$0 = $2;
 HEAP32[$2 + 264 >> 2] = $0;
 HEAP8[$2 + 263 | 0] = $1;
 HEAP8[$2 + 262 | 0] = (HEAP32[84152] & 2) != 0;
 HEAP8[$2 + 261 | 0] = (HEAP32[84152] & 4) != 0;
 HEAP8[$2 + 260 | 0] = (HEAP32[84152] & 8) != 0;
 HEAP8[$2 + 259 | 0] = (HEAP32[84152] & 1) != 0;
 HEAP8[$2 + 258 | 0] = (HEAP32[84152] & 16) != 0;
 HEAP8[$2 + 257 | 0] = (HEAP32[84152] & 32) != 0;
 HEAP8[$2 + 256 | 0] = (HEAP32[84152] & 1024) != 0;
 HEAP32[$2 + 244 >> 2] = Math_imul(HEAPU16[70843], HEAPU16[70843]);
 HEAP32[$2 + 240 >> 2] = Math_imul(HEAPU16[70844], HEAPU16[70844]);
 HEAP32[$2 >> 2] = 110097;
 HEAP16[$2 + 4 >> 1] = 9;
 HEAP32[$2 + 8 >> 2] = $2 + 244;
 HEAP32[$2 + 12 >> 2] = 110116;
 HEAP16[$2 + 16 >> 1] = 9;
 HEAP32[$2 + 20 >> 2] = $2 + 240;
 HEAP32[$2 + 24 >> 2] = 110133;
 HEAP16[$2 + 28 >> 1] = 9;
 HEAP32[$2 + 32 >> 2] = 141692;
 HEAP32[$2 + 36 >> 2] = 110154;
 HEAP16[$2 + 40 >> 1] = 9;
 HEAP32[$2 + 44 >> 2] = 141696;
 HEAP32[$2 + 48 >> 2] = 110171;
 HEAP16[$2 + 52 >> 1] = 9;
 HEAP32[$2 + 56 >> 2] = $2 + 252;
 HEAP32[$2 + 60 >> 2] = 110195;
 HEAP16[$2 + 64 >> 1] = 9;
 HEAP32[$2 + 68 >> 2] = $2 + 248;
 HEAP32[$2 + 72 >> 2] = 110220;
 HEAP16[$2 + 76 >> 1] = 9;
 HEAP32[$2 + 80 >> 2] = 141700;
 HEAP32[$2 + 84 >> 2] = 110235;
 HEAP16[$2 + 88 >> 1] = 9;
 HEAP32[$2 + 92 >> 2] = 141708;
 HEAP32[$2 + 96 >> 2] = 110248;
 HEAP16[$2 + 100 >> 1] = 9;
 HEAP32[$2 + 104 >> 2] = 141704;
 HEAP32[$2 + 108 >> 2] = 110258;
 HEAP16[$2 + 112 >> 1] = 11;
 HEAP32[$2 + 116 >> 2] = $2 + 262;
 HEAP32[$2 + 120 >> 2] = 110269;
 HEAP16[$2 + 124 >> 1] = 11;
 HEAP32[$2 + 128 >> 2] = $2 + 261;
 HEAP32[$2 + 132 >> 2] = 110280;
 HEAP16[$2 + 136 >> 1] = 11;
 HEAP32[$2 + 140 >> 2] = $2 + 260;
 HEAP32[$2 + 144 >> 2] = 110291;
 HEAP16[$2 + 148 >> 1] = 11;
 HEAP32[$2 + 152 >> 2] = $2 + 259;
 HEAP32[$2 + 156 >> 2] = 110304;
 HEAP16[$2 + 160 >> 1] = 11;
 HEAP32[$2 + 164 >> 2] = $2 + 258;
 HEAP32[$2 + 168 >> 2] = 110316;
 HEAP16[$2 + 172 >> 1] = 11;
 HEAP32[$2 + 176 >> 2] = $2 + 257;
 HEAP32[$2 + 180 >> 2] = 110328;
 HEAP16[$2 + 184 >> 1] = 11;
 HEAP32[$2 + 188 >> 2] = $2 + 256;
 HEAP32[$2 + 192 >> 2] = 110338;
 HEAP16[$2 + 196 >> 1] = 9;
 HEAP32[$2 + 200 >> 2] = 336624;
 HEAP32[$2 + 204 >> 2] = 110350;
 HEAP16[$2 + 208 >> 1] = 9;
 HEAP32[$2 + 212 >> 2] = 336616;
 HEAP32[$2 + 216 >> 2] = 110366;
 HEAP16[$2 + 220 >> 1] = 9;
 HEAP32[$2 + 224 >> 2] = 336620;
 label$1 : {
  if (HEAP8[$2 + 263 | 0] & 1) {
   HEAP32[$2 + 268 >> 2] = jsvCreateConfigObject($2);
   break label$1;
  }
  if (jsvReadConfigObject(HEAP32[$2 + 264 >> 2], $2, 19) & 1) {
   HEAP32[84152] = HEAP32[84152] & -3 | (HEAP8[$2 + 262 | 0] & 1 ? 2 : 0);
   HEAP32[84152] = HEAP32[84152] & -5 | (HEAP8[$2 + 261 | 0] & 1 ? 4 : 0);
   HEAP32[84152] = HEAP32[84152] & -9 | (HEAP8[$2 + 260 | 0] & 1 ? 8 : 0);
   HEAP32[84152] = HEAP32[84152] & -2 | (HEAP8[$2 + 259 | 0] & 1 ? 1 : 0);
   HEAP32[84152] = HEAP32[84152] & -17 | (HEAP8[$2 + 258 | 0] & 1 ? 16 : 0);
   HEAP32[84152] = HEAP32[84152] & -33 | (HEAP8[$2 + 257 | 0] & 1 ? 32 : 0);
   HEAP32[84152] = HEAP32[84152] & -1025 | (HEAP8[$2 + 256 | 0] & 1 ? 1024 : 0);
   if (HEAP32[84156] < 0) {
    HEAP32[84156] = 0;
   }
   if (HEAP32[84154] < 0) {
    HEAP32[84154] = 0;
   }
   if (HEAP32[84155] < 0) {
    HEAP32[84155] = 0;
   }
   HEAP16[70843] = int_sqrt32(HEAP32[$2 + 244 >> 2]);
   HEAP16[70844] = int_sqrt32(HEAP32[$2 + 240 >> 2]);
  }
  HEAP32[$2 + 268 >> 2] = 0;
 }
 global$0 = $2 + 272 | 0;
 return HEAP32[$2 + 268 >> 2];
}
function jsfGetJSONForObjectItWithCallback($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0;
 $7 = global$0 - 128 | 0;
 global$0 = $7;
 HEAP32[$7 + 124 >> 2] = $0;
 HEAP32[$7 + 120 >> 2] = $1;
 HEAP32[$7 + 116 >> 2] = $2;
 HEAP32[$7 + 112 >> 2] = $3;
 HEAP32[$7 + 108 >> 2] = $4;
 HEAP32[$7 + 104 >> 2] = $5;
 HEAP8[$7 + 103 | 0] = $6;
 HEAP8[$7 + 102 | 0] = 0;
 HEAP32[$7 + 96 >> 2] = 0;
 while (1) {
  if (jsvObjectIteratorHasValue(HEAP32[$7 + 124 >> 2]) & 1) {
   $0 = jspIsInterrupted() ^ -1;
  } else {
   $0 = 0;
  }
  if ($0 & 1) {
   HEAP32[$7 + 92 >> 2] = jsvObjectIteratorGetKey(HEAP32[$7 + 124 >> 2]);
   HEAP32[$7 + 88 >> 2] = jsvGetValueOfName(HEAP32[$7 + 92 >> 2]);
   $2 = jsvIsInternalObjectKey(HEAP32[$7 + 92 >> 2]);
   $0 = $7;
   $1 = 1;
   label$5 : {
    if ($2 & 1) {
     break label$5;
    }
    if (HEAP32[$7 + 120 >> 2] & 16) {
     $2 = jsvIsFunction(HEAP32[$7 + 88 >> 2]) & 1;
     $1 = 1;
     if ($2) {
      break label$5;
     }
    }
    if (HEAP32[$7 + 120 >> 2] & 64) {
     $2 = jsvIsUndefined(HEAP32[$7 + 88 >> 2]) & 1;
     $1 = 1;
     if ($2) {
      break label$5;
     }
    }
    $1 = jsvIsGetterOrSetter(HEAP32[$7 + 88 >> 2]);
   }
   HEAP8[$0 + 87 | 0] = $1 & 1;
   if (!(HEAP8[$7 + 87 | 0] & 1)) {
    HEAP32[$7 + 96 >> 2] = HEAP32[$7 + 96 >> 2] + 1;
    if (!(HEAP8[$7 + 103 | 0] & 1)) {
     cbprintf(HEAP32[$7 + 108 >> 2], HEAP32[$7 + 104 >> 2], HEAP32[$7 + 120 >> 2] & 4 ? 122750 : 122671, 0);
    }
    $0 = $7;
    if (HEAP32[$7 + 120 >> 2] & 1) {
     $1 = jsonNeedsNewLine(HEAP32[$7 + 88 >> 2]);
    } else {
     $1 = 0;
    }
    HEAP8[$0 + 86 | 0] = $1 & 1;
    if (!(!(HEAP32[$7 + 120 >> 2] & 1) | HEAPU32[$7 + 96 >> 2] <= 4)) {
     HEAP8[$7 + 102 | 0] = 1;
    }
    if (HEAP32[$7 + 120 >> 2] & 2) {
     HEAP8[$7 + 102 | 0] = 1;
     HEAP8[$7 + 86 | 0] = 1;
    }
    if (!(HEAP8[$7 + 86 | 0] & 1 ? 0 : !(HEAP8[$7 + 102 | 0] & 1))) {
     jsonNewLine(HEAP32[$7 + 112 >> 2], HEAP32[$7 + 116 >> 2], HEAP32[$7 + 108 >> 2], HEAP32[$7 + 104 >> 2]);
     HEAP8[$7 + 102 | 0] = 0;
     HEAP32[$7 + 96 >> 2] = 0;
    }
    HEAP8[$7 + 85 | 0] = 1;
    if (HEAP32[$7 + 120 >> 2] & 512) {
     label$17 : {
      if (jsvIsIntegerish(HEAP32[$7 + 92 >> 2]) & 1) {
       HEAP8[$7 + 85 | 0] = 0;
       break label$17;
      }
      label$19 : {
       if (!(jsvIsString(HEAP32[$7 + 92 >> 2]) & 1)) {
        break label$19;
       }
       if (jsvGetStringLength(HEAP32[$7 + 92 >> 2]) >>> 0 >= 63) {
        break label$19;
       }
       $0 = $7 + 16 | 0;
       jsvGetString(HEAP32[$7 + 92 >> 2], $0, 64);
       if (isIDString($0) & 1) {
        HEAP8[$7 + 85 | 0] = 0;
       }
      }
     }
    }
    $1 = HEAP32[$7 + 108 >> 2];
    $2 = HEAP32[$7 + 104 >> 2];
    if (HEAP8[$7 + 85 | 0] & 1) {
     $0 = HEAP32[$7 + 120 >> 2] & 1024 ? 122892 : 122897;
    } else {
     $0 = 122902;
    }
    $3 = HEAP32[$7 + 92 >> 2];
    HEAP32[$7 + 4 >> 2] = HEAP32[$7 + 120 >> 2] & 4 ? 122907 : 122910;
    HEAP32[$7 >> 2] = $3;
    cbprintf($1, $2, $0, $7);
    if (HEAP8[$7 + 103 | 0] & 1) {
     HEAP8[$7 + 103 | 0] = 0;
    }
    jsfGetJSONWithCallback(HEAP32[$7 + 88 >> 2], HEAP32[$7 + 92 >> 2], HEAP32[$7 + 112 >> 2], HEAP32[$7 + 116 >> 2], HEAP32[$7 + 108 >> 2], HEAP32[$7 + 104 >> 2]);
    HEAP8[$7 + 102 | 0] = HEAP8[$7 + 86 | 0] & 1;
   }
   jsvUnLock2(HEAP32[$7 + 92 >> 2], HEAP32[$7 + 88 >> 2]);
   jsvObjectIteratorNext(HEAP32[$7 + 124 >> 2]);
   continue;
  }
  break;
 }
 global$0 = $7 + 128 | 0;
 return HEAP8[$7 + 102 | 0] & 1;
}
function jswrap_storagefile_getLength($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = global$0 - 240 | 0;
 global$0 = $1;
 $2 = $1 + 200 | 0;
 HEAP32[$1 + 236 >> 2] = $0;
 HEAP32[$1 + 232 >> 2] = jsvObjectGetChild(HEAP32[$1 + 236 >> 2], 125552, 0);
 jsfNameFromVar($2, HEAP32[$1 + 232 >> 2]);
 jsvUnLock(HEAP32[$1 + 232 >> 2]);
 HEAP32[$1 + 196 >> 2] = 27;
 while (1) {
  if (HEAP32[$1 + 196 >> 2] ? !HEAP8[(HEAP32[$1 + 196 >> 2] + $1 | 0) + 199 | 0] : 0) {
   HEAP32[$1 + 196 >> 2] = HEAP32[$1 + 196 >> 2] + -1;
   continue;
  }
  break;
 }
 HEAP32[$1 + 192 >> 2] = 1;
 HEAP8[HEAP32[$1 + 196 >> 2] + ($1 + 200 | 0) | 0] = HEAP32[$1 + 192 >> 2];
 HEAP32[$1 + 188 >> 2] = 0;
 HEAP32[$1 + 184 >> 2] = 0;
 HEAP32[$1 + 64 >> 2] = HEAP32[$1 + 224 >> 2];
 $0 = HEAP32[$1 + 220 >> 2];
 HEAP32[$1 + 56 >> 2] = HEAP32[$1 + 216 >> 2];
 HEAP32[$1 + 60 >> 2] = $0;
 $0 = HEAP32[$1 + 212 >> 2];
 HEAP32[$1 + 48 >> 2] = HEAP32[$1 + 208 >> 2];
 HEAP32[$1 + 52 >> 2] = $0;
 $0 = HEAP32[$1 + 204 >> 2];
 HEAP32[$1 + 40 >> 2] = HEAP32[$1 + 200 >> 2];
 HEAP32[$1 + 44 >> 2] = $0;
 HEAP32[$1 + 148 >> 2] = jsfFindFile($1 + 40 | 0, $1 + 152 | 0);
 HEAP8[$1 + 147 | 0] = 255;
 if (HEAP32[$1 + 148 >> 2]) {
  jshFlashRead($1 + 147 | 0, (HEAP32[$1 + 148 >> 2] + jsfGetFileSize($1 + 152 | 0) | 0) - 1 | 0, 1);
 }
 while (1) {
  $0 = 0;
  label$7 : {
   if (!HEAP32[$1 + 148 >> 2]) {
    break label$7;
   }
   $0 = 0;
   if (HEAPU8[$1 + 147 | 0] == 255) {
    break label$7;
   }
   $0 = HEAP32[$1 + 192 >> 2] < 255;
  }
  if ($0) {
   $0 = $1 + 200 | 0;
   HEAP32[$1 + 188 >> 2] = jsfGetFileSize($1 + 152 | 0) + HEAP32[$1 + 188 >> 2];
   HEAP32[$1 + 192 >> 2] = HEAP32[$1 + 192 >> 2] + 1;
   HEAP8[$0 + HEAP32[$1 + 196 >> 2] | 0] = HEAP32[$1 + 192 >> 2];
   HEAP32[$1 + 32 >> 2] = HEAP32[$1 + 224 >> 2];
   $0 = HEAP32[$1 + 220 >> 2];
   HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 216 >> 2];
   HEAP32[$1 + 28 >> 2] = $0;
   $0 = HEAP32[$1 + 212 >> 2];
   HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 208 >> 2];
   HEAP32[$1 + 20 >> 2] = $0;
   $0 = HEAP32[$1 + 204 >> 2];
   HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 200 >> 2];
   HEAP32[$1 + 12 >> 2] = $0;
   HEAP32[$1 + 148 >> 2] = jsfFindFile($1 + 8 | 0, $1 + 152 | 0);
   if (HEAP32[$1 + 148 >> 2]) {
    jshFlashRead($1 + 147 | 0, (HEAP32[$1 + 148 >> 2] + jsfGetFileSize($1 + 152 | 0) | 0) - 1 | 0, 1);
   }
   continue;
  }
  break;
 }
 if (HEAP32[$1 + 148 >> 2]) {
  HEAP8[$1 + 79 | 0] = 0;
  while (1) {
   label$12 : {
    if (!((HEAPU8[$1 + 79 | 0] ^ -1) & 1)) {
     break label$12;
    }
    HEAP32[$1 + 72 >> 2] = jsfGetFileSize($1 + 152 | 0) - HEAP32[$1 + 184 >> 2];
    if (HEAP32[$1 + 72 >> 2] <= 0) {
     HEAP8[$1 + 79 | 0] = 1;
     break label$12;
    }
    if (HEAPU32[$1 + 72 >> 2] > 64) {
     HEAP32[$1 + 72 >> 2] = 64;
    }
    jshFlashRead($1 + 80 | 0, HEAP32[$1 + 148 >> 2] + HEAP32[$1 + 184 >> 2] | 0, HEAP32[$1 + 72 >> 2]);
    HEAP32[$1 + 68 >> 2] = 0;
    while (1) {
     if (HEAP32[$1 + 68 >> 2] < HEAP32[$1 + 72 >> 2]) {
      if (HEAP8[HEAP32[$1 + 68 >> 2] + ($1 + 80 | 0) | 0] == -1) {
       HEAP32[$1 + 72 >> 2] = HEAP32[$1 + 68 >> 2];
       HEAP8[$1 + 79 | 0] = 1;
      } else {
       HEAP32[$1 + 68 >> 2] = HEAP32[$1 + 68 >> 2] + 1;
       continue;
      }
     }
     break;
    }
    HEAP32[$1 + 184 >> 2] = HEAP32[$1 + 72 >> 2] + HEAP32[$1 + 184 >> 2];
    continue;
   }
   break;
  }
 }
 HEAP32[$1 + 188 >> 2] = HEAP32[$1 + 184 >> 2] + HEAP32[$1 + 188 >> 2];
 global$0 = $1 + 240 | 0;
 return HEAP32[$1 + 188 >> 2];
}
function jswrap_espruino_decodeUTF8($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 160 | 0;
 global$0 = $3;
 HEAP32[$3 + 152 >> 2] = $0;
 HEAP32[$3 + 148 >> 2] = $1;
 HEAP32[$3 + 144 >> 2] = $2;
 label$1 : {
  if (!(jsvIsString(HEAP32[$3 + 152 >> 2]) & 1)) {
   HEAP32[$3 >> 2] = HEAP32[$3 + 152 >> 2];
   jsExceptionHere(1, 121047, $3);
   HEAP32[$3 + 156 >> 2] = 0;
   break label$1;
  }
  $0 = $3 - -64 | 0;
  $1 = $3 + 104 | 0;
  HEAP32[$3 + 60 >> 2] = jsvNewWithFlags(27);
  jsvStringIteratorNew($1, HEAP32[$3 + 152 >> 2], 0);
  jsvStringIteratorNew($0, HEAP32[$3 + 60 >> 2], 0);
  while (1) {
   if (jsvStringIteratorHasChar($3 + 104 | 0) & 1) {
    HEAP8[$3 + 59 | 0] = jsvStringIteratorGetCharAndNext($3 + 104 | 0);
    HEAP32[$3 + 52 >> 2] = HEAPU8[$3 + 59 | 0];
    HEAP32[$3 + 48 >> 2] = 0;
    if (HEAPU8[$3 + 59 | 0] > 127) {
     label$6 : {
      if ((HEAPU8[$3 + 59 | 0] & 224) == 192) {
       HEAP32[$3 + 52 >> 2] = HEAPU8[$3 + 59 | 0] & 31;
       HEAP32[$3 + 48 >> 2] = 1;
       break label$6;
      }
      label$8 : {
       if ((HEAPU8[$3 + 59 | 0] & 240) == 224) {
        HEAP32[$3 + 52 >> 2] = HEAPU8[$3 + 59 | 0] & 15;
        HEAP32[$3 + 48 >> 2] = 2;
        break label$8;
       }
       if ((HEAPU8[$3 + 59 | 0] & 248) == 240) {
        HEAP32[$3 + 52 >> 2] = HEAPU8[$3 + 59 | 0] & 7;
        HEAP32[$3 + 48 >> 2] = 3;
       }
      }
     }
     while (1) {
      label$12 : {
       $0 = HEAP32[$3 + 48 >> 2];
       HEAP32[$3 + 48 >> 2] = $0 + -1;
       if (!$0) {
        break label$12;
       }
       HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 52 >> 2] << 6 | jsvStringIteratorGetCharAndNext($3 + 104 | 0) & 63;
       continue;
      }
      break;
     }
    }
    label$13 : {
     if (HEAP32[$3 + 52 >> 2] <= 255) {
      jsvStringIteratorAppend($3 - -64 | 0, HEAP32[$3 + 52 >> 2] << 24 >> 24);
      break label$13;
     }
     HEAP32[$3 + 44 >> 2] = 0;
     label$15 : {
      if (jsvIsArray(HEAP32[$3 + 148 >> 2]) & 1) {
       HEAP32[$3 + 44 >> 2] = jsvGetArrayItem(HEAP32[$3 + 148 >> 2], HEAP32[$3 + 52 >> 2]);
       break label$15;
      }
      if (jsvIsObject(HEAP32[$3 + 148 >> 2]) & 1) {
       $0 = $3 + 16 | 0;
       itostr(HEAP32[$3 + 52 >> 2], $0, 16);
       HEAP32[$3 + 44 >> 2] = jsvObjectGetChild(HEAP32[$3 + 148 >> 2], $0, 0);
      }
     }
     label$18 : {
      if (HEAP32[$3 + 44 >> 2]) {
       break label$18;
      }
      if (!(jsvIsFunction(HEAP32[$3 + 144 >> 2]) & 1)) {
       break label$18;
      }
      $0 = $3 + 12 | 0;
      HEAP32[$3 + 12 >> 2] = jsvNewFromInteger(HEAP32[$3 + 52 >> 2]);
      HEAP32[$3 + 44 >> 2] = jspExecuteFunction(HEAP32[$3 + 144 >> 2], 0, 1, $0);
      jsvUnLock(HEAP32[$3 + 12 >> 2]);
     }
     label$19 : {
      if (HEAP32[$3 + 44 >> 2]) {
       break label$19;
      }
      if (!(jsvIsString(HEAP32[$3 + 144 >> 2]) & 1)) {
       break label$19;
      }
      HEAP32[$3 + 44 >> 2] = jsvLockAgain(HEAP32[$3 + 144 >> 2]);
     }
     if (HEAP32[$3 + 44 >> 2]) {
      $0 = $3 - -64 | 0;
      HEAP32[$3 + 44 >> 2] = jsvAsStringAndUnLock(HEAP32[$3 + 44 >> 2]);
      jsvStringIteratorAppendString($0, HEAP32[$3 + 44 >> 2], 0, 2147483647);
      jsvUnLock(HEAP32[$3 + 44 >> 2]);
     }
    }
    continue;
   }
   break;
  }
  $0 = $3 - -64 | 0;
  jsvStringIteratorFree($3 + 104 | 0);
  jsvStringIteratorFree($0);
  HEAP32[$3 + 156 >> 2] = HEAP32[$3 + 60 >> 2];
 }
 global$0 = $3 + 160 | 0;
 return HEAP32[$3 + 156 >> 2];
}
function jspeStatementDoOrWhile($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = global$0 - 160 | 0;
 global$0 = $1;
 HEAP8[$1 + 155 | 0] = $0;
 HEAP8[$1 + 147 | 0] = 1;
 HEAP8[$1 + 146 | 0] = 0;
 HEAP8[$1 + 103 | 0] = (HEAP32[80549] & 512) != 0;
 label$1 : {
  label$2 : {
   if (HEAP8[$1 + 155 | 0] & 1) {
    $0 = $1 + 104 | 0;
    jslGetNextToken();
    jslCharPosFromLex($0);
    if (!(jslMatch(40) & 1)) {
     jslCharPosFree($1 + 104 | 0);
     break label$1;
    }
    HEAP32[$1 + 148 >> 2] = jspeExpression();
    $0 = 0;
    if ((HEAP32[80549] & 63) == 1) {
     $0 = jsvGetBoolAndUnLock(jsvSkipName(HEAP32[$1 + 148 >> 2]));
    }
    $2 = $1 + 56 | 0;
    HEAP8[$1 + 147 | 0] = $0 & 1;
    jsvUnLock(HEAP32[$1 + 148 >> 2]);
    jslCharPosFromLex($2);
    if (!(jslMatch(41) & 1)) {
     $0 = $1 + 104 | 0;
     jslCharPosFree($1 + 56 | 0);
     jslCharPosFree($0);
     break label$1;
    }
    break label$2;
   }
   jslCharPosFromLex($1 + 56 | 0);
   if (!(jslMatch(165) & 1)) {
    jslCharPosFree($1 + 56 | 0);
    break label$1;
   }
  }
  HEAP32[$1 + 52 >> 2] = HEAP32[80549];
  if (!(HEAP8[$1 + 147 | 0] & 1)) {
   jspSetNoExecute();
  }
  HEAP32[80549] = HEAP32[80549] | 512;
  jsvUnLock(jspeBlockOrStatement());
  if (!(HEAP8[$1 + 103 | 0] & 1)) {
   HEAP32[80549] = HEAP32[80549] & -513;
  }
  HEAP8[$1 + 146 | 0] = (jspeCheckBreakContinue() & 1 | HEAP8[$1 + 146 | 0] & 1) != 0;
  if (!(HEAP8[$1 + 147 | 0] & 1)) {
   HEAP32[80549] = HEAP32[80549] & -1664 | HEAP32[$1 + 52 >> 2] & 1663;
  }
  if (!(HEAP8[$1 + 155 | 0] & 1)) {
   if (!(jslMatch(166) & 1)) {
    jslCharPosFree($1 + 56 | 0);
    break label$1;
   }
   jslCharPosFromLex($1 + 104 | 0);
   if (!(jslMatch(40) & 1)) {
    $0 = $1 + 104 | 0;
    jslCharPosFree($1 + 56 | 0);
    jslCharPosFree($0);
    break label$1;
   }
   HEAP32[$1 + 148 >> 2] = jspeExpression();
   $0 = $1;
   if ((HEAP32[80549] & 63) == 1) {
    $2 = jsvGetBoolAndUnLock(jsvSkipName(HEAP32[$1 + 148 >> 2]));
   } else {
    $2 = 0;
   }
   HEAP8[$0 + 147 | 0] = $2 & 1;
   jsvUnLock(HEAP32[$1 + 148 >> 2]);
   if (!(jslMatch(41) & 1)) {
    $0 = $1 + 104 | 0;
    jslCharPosFree($1 + 56 | 0);
    jslCharPosFree($0);
    break label$1;
   }
  }
  jslCharPosNew($1 + 8 | 0, HEAP32[HEAP32[35539] + 84 >> 2], HEAP32[HEAP32[35539] + 4 >> 2]);
  HEAP32[$1 + 4 >> 2] = 0;
  while (1) {
   if ((HEAP8[$1 + 146 | 0] & 1 ? 0 : HEAPU8[$1 + 147 | 0]) & 1) {
    if (!(HEAP32[$1 + 4 >> 2] ? 0 : !(HEAP8[$1 + 155 | 0] & 1))) {
     jslSeekToP($1 + 104 | 0);
     HEAP32[$1 + 148 >> 2] = jspeExpression();
     $0 = $1;
     if ((HEAP32[80549] & 63) == 1) {
      $2 = jsvGetBoolAndUnLock(jsvSkipName(HEAP32[$1 + 148 >> 2]));
     } else {
      $2 = 0;
     }
     HEAP8[$0 + 147 | 0] = $2 & 1;
     jsvUnLock(HEAP32[$1 + 148 >> 2]);
    }
    if (HEAP8[$1 + 147 | 0] & 1) {
     jslSeekToP($1 + 56 | 0);
     HEAP32[80549] = HEAP32[80549] | 512;
     jspDebuggerLoopIfCtrlC();
     jsvUnLock(jspeBlockOrStatement());
     if (!(HEAP8[$1 + 103 | 0] & 1)) {
      HEAP32[80549] = HEAP32[80549] & -513;
     }
     HEAP8[$1 + 146 | 0] = (jspeCheckBreakContinue() & 1 | HEAP8[$1 + 146 | 0] & 1) != 0;
    }
    HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + 1;
    continue;
   }
   break;
  }
  $0 = $1 + 56 | 0;
  $2 = $1 + 104 | 0;
  $3 = $1 + 8 | 0;
  jslSeekToP($3);
  jslCharPosFree($2);
  jslCharPosFree($0);
  jslCharPosFree($3);
 }
 HEAP32[$1 + 156 >> 2] = 0;
 global$0 = $1 + 160 | 0;
 return HEAP32[$1 + 156 >> 2];
}
function jswrap_date_parse($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = global$0 - 208 | 0;
 global$0 = $1;
 HEAP32[$1 + 196 >> 2] = $0;
 label$1 : {
  if (!(jsvIsString(HEAP32[$1 + 196 >> 2]) & 1)) {
   HEAPF64[$1 + 200 >> 3] = 0;
   break label$1;
  }
  $0 = $1 + 16 | 0;
  HEAP32[$1 + 168 >> 2] = 0;
  HEAP32[$1 + 184 >> 2] = 0;
  HEAP32[$1 + 180 >> 2] = 0;
  HEAP32[$1 + 176 >> 2] = 0;
  HEAP32[$1 + 172 >> 2] = 0;
  HEAP32[$1 + 188 >> 2] = 0;
  getCalendarDate($1 + 144 | 0, 0);
  HEAP32[$1 + 12 >> 2] = jslSetLex($0);
  jslInit(HEAP32[$1 + 196 >> 2]);
  label$3 : {
   if (HEAP16[$1 + 18 >> 1] == 128) {
    HEAP32[$1 + 152 >> 2] = getMonth(jslGetTokenValueAsString());
    HEAP32[$1 + 160 >> 2] = getDay(jslGetTokenValueAsString());
    label$5 : {
     if (HEAP32[$1 + 152 >> 2] >= 0) {
      HEAP32[$1 + 188 >> 2] = jsdGetTimeZone();
      jslGetNextToken();
      if (HEAP16[$1 + 18 >> 1] == 129) {
       HEAP32[$1 + 148 >> 2] = _parse_int();
       jslGetNextToken();
       if (HEAP16[$1 + 18 >> 1] == 44) {
        jslGetNextToken();
        if (HEAP16[$1 + 18 >> 1] == 129) {
         HEAP32[$1 + 156 >> 2] = _parse_int();
         jslGetNextToken();
         if (HEAP16[$1 + 18 >> 1] == 129) {
          _parse_time($1 + 168 | 0, 0);
         }
        }
       }
      }
      break label$5;
     }
     label$11 : {
      if (HEAP32[$1 + 160 >> 2] >= 0) {
       HEAP32[$1 + 188 >> 2] = jsdGetTimeZone();
       HEAP32[$1 + 152 >> 2] = 0;
       jslGetNextToken();
       if (HEAP16[$1 + 18 >> 1] == 44) {
        jslGetNextToken();
        if (HEAP16[$1 + 18 >> 1] == 129) {
         HEAP32[$1 + 148 >> 2] = _parse_int();
         jslGetNextToken();
         label$15 : {
          if (HEAP16[$1 + 18 >> 1] != 128) {
           break label$15;
          }
          if ((getMonth(jslGetTokenValueAsString()) | 0) < 0) {
           break label$15;
          }
          HEAP32[$1 + 152 >> 2] = getMonth(jslGetTokenValueAsString());
          jslGetNextToken();
          if (HEAP16[$1 + 18 >> 1] == 129) {
           HEAP32[$1 + 156 >> 2] = _parse_int();
           jslGetNextToken();
           if (HEAP16[$1 + 18 >> 1] == 129) {
            _parse_time($1 + 168 | 0, 0);
           }
          }
         }
        }
       }
       break label$11;
      }
      HEAP32[$1 + 160 >> 2] = 0;
      HEAP32[$1 + 152 >> 2] = 0;
     }
    }
    break label$3;
   }
   if (HEAP16[$1 + 18 >> 1] == 129) {
    HEAP32[$1 + 156 >> 2] = _parse_int();
    jslGetNextToken();
    if (HEAP16[$1 + 18 >> 1] == 45) {
     jslGetNextToken();
     if (HEAP16[$1 + 18 >> 1] == 129) {
      HEAP32[$1 + 152 >> 2] = _parse_int() - 1;
      jslGetNextToken();
      if (HEAP16[$1 + 18 >> 1] == 45) {
       jslGetNextToken();
       if (HEAP16[$1 + 18 >> 1] == 129) {
        HEAP32[$1 + 148 >> 2] = _parse_int();
        jslGetNextToken();
        label$23 : {
         if (HEAP16[$1 + 18 >> 1] != 128) {
          break label$23;
         }
         if (HEAP8[jslGetTokenValueAsString() | 0] != 84) {
          break label$23;
         }
         $0 = $1 + 168 | 0;
         HEAP32[$1 + 188 >> 2] = jsdGetTimeZone();
         _parse_time($0, 1);
        }
       }
      }
     }
    }
   }
  }
  $0 = $1 + 168 | 0;
  $2 = $1 + 144 | 0;
  jslKill();
  jslSetLex(HEAP32[$1 + 12 >> 2]);
  HEAP32[$1 + 168 >> 2] = fromCalenderDate($2);
  HEAPF64[$1 + 200 >> 3] = fromTimeInDay($0);
 }
 global$0 = $1 + 208 | 0;
 return +HEAPF64[$1 + 200 >> 3];
}
function jsfCompactInternal($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = global$0 - 96 | 0;
 global$0 = $3;
 HEAP32[$3 + 88 >> 2] = $0;
 HEAP32[$3 + 84 >> 2] = $1;
 HEAP32[$3 + 80 >> 2] = $2;
 HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 88 >> 2];
 HEAP32[$3 + 72 >> 2] = 0;
 HEAP32[$3 + 68 >> 2] = 0;
 HEAP32[$3 + 64 >> 2] = 0;
 $0 = $3 + 32 | 0;
 HEAP32[$0 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 88 >> 2];
 label$1 : {
  if (jsfGetFileHeader(HEAP32[$3 + 28 >> 2], $0, 1) & 1) {
   while (1) {
    if (HEAP32[$3 + 36 >> 2]) {
     HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 76 >> 2] + HEAP32[$3 + 64 >> 2];
     if (HEAP32[$3 + 28 >> 2] != HEAP32[$3 + 24 >> 2]) {
      jsvUpdateMemoryAddress(HEAP32[$3 + 28 >> 2], jsfGetFileSize($3 + 32 | 0) + 32 | 0, HEAP32[$3 + 24 >> 2]);
     }
     $0 = $3 + 76 | 0;
     $1 = $3 - -64 | 0;
     $2 = $3 + 68 | 0;
     $4 = $3 + 32 | 0;
     memcpy_circular(HEAP32[$3 + 84 >> 2], $3 + 72 | 0, HEAP32[$3 + 80 >> 2], $4);
     HEAP32[$3 + 64 >> 2] = HEAP32[$3 + 64 >> 2] + 32;
     HEAP32[$3 + 20 >> 2] = jsfAlignAddress(jsfGetFileSize($4));
     HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 28 >> 2] + 32;
     jsfCompactWriteBuffer($0, HEAP32[$3 + 16 >> 2], HEAP32[$3 + 84 >> 2], HEAP32[$3 + 80 >> 2], $1, $2);
     while (1) {
      if (HEAP32[$3 + 20 >> 2]) {
       HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 80 >> 2] - HEAP32[$3 + 64 >> 2];
       if (HEAPU32[$3 + 12 >> 2] > HEAP32[$3 + 80 >> 2] - HEAP32[$3 + 72 >> 2] >>> 0) {
        HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 80 >> 2] - HEAP32[$3 + 72 >> 2];
       }
       if (!(HEAPU32[$3 + 68 >> 2] <= HEAPU32[$3 + 72 >> 2] | HEAPU32[$3 + 12 >> 2] <= HEAP32[$3 + 68 >> 2] - HEAP32[$3 + 72 >> 2] >>> 0)) {
        HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 68 >> 2] - HEAP32[$3 + 72 >> 2];
       }
       if (!HEAP32[$3 + 12 >> 2]) {
        HEAP8[$3 + 95 | 0] = 0;
        break label$1;
       }
       if (HEAPU32[$3 + 12 >> 2] > HEAPU32[$3 + 20 >> 2]) {
        HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 20 >> 2];
       }
       $0 = $3 + 76 | 0;
       $1 = $3 - -64 | 0;
       $2 = $3 + 68 | 0;
       jshFlashRead(HEAP32[$3 + 84 >> 2] + HEAP32[$3 + 72 >> 2] | 0, HEAP32[$3 + 16 >> 2], HEAP32[$3 + 12 >> 2]);
       HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] - HEAP32[$3 + 12 >> 2];
       HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 12 >> 2] + HEAP32[$3 + 16 >> 2];
       HEAP32[$3 + 64 >> 2] = HEAP32[$3 + 12 >> 2] + HEAP32[$3 + 64 >> 2];
       HEAP32[$3 + 72 >> 2] = (HEAP32[$3 + 72 >> 2] + HEAP32[$3 + 12 >> 2] >>> 0) % HEAPU32[$3 + 80 >> 2];
       jsfCompactWriteBuffer($0, HEAP32[$3 + 16 >> 2], HEAP32[$3 + 84 >> 2], HEAP32[$3 + 80 >> 2], $1, $2);
       continue;
      }
      break;
     }
    }
    if (jsfGetNextFileHeader($3 + 28 | 0, $3 + 32 | 0, 1) & 1) {
     continue;
    }
    break;
   }
  }
  $0 = $3 - -64 | 0;
  $1 = $3 + 68 | 0;
  jsfCompactWriteBuffer($3 + 76 | 0, jsfGetBankEndAddress(HEAP32[$3 + 76 >> 2]), HEAP32[$3 + 84 >> 2], HEAP32[$3 + 80 >> 2], $0, $1);
  if (HEAP32[$3 + 76 >> 2] != HEAP32[$3 + 88 >> 2]) {
   HEAP32[$3 + 76 >> 2] = jsfGetAddressOfNextPage(HEAP32[$3 + 76 >> 2] - 1 | 0);
  }
  if (HEAP32[$3 + 76 >> 2]) {
   jsfEraseArea(HEAP32[$3 + 76 >> 2], HEAP32[$3 + 28 >> 2]);
  }
  HEAP8[$3 + 95 | 0] = 1;
 }
 global$0 = $3 + 96 | 0;
 return HEAP8[$3 + 95 | 0] & 1;
}
function tflite__ops__micro__reshape__ReshapeOutput_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 144 | 0;
 global$0 = $2;
 HEAP32[$2 + 136 >> 2] = $0;
 HEAP32[$2 + 132 >> 2] = $1;
 HEAP32[$2 + 128 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 136 >> 2], HEAP32[$2 + 132 >> 2], 0);
 HEAP32[$2 + 124 >> 2] = tflite__GetOutput_28TfLiteContext__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 136 >> 2], HEAP32[$2 + 132 >> 2]);
 HEAP32[$2 + 120 >> 2] = tflite__NumElements_28TfLiteTensor_20const__29(HEAP32[$2 + 128 >> 2]);
 HEAP32[$2 + 116 >> 2] = HEAP32[HEAP32[$2 + 124 >> 2] + 20 >> 2];
 if (!((tflite__NumInputs_28TfLiteNode_20const__29(HEAP32[$2 + 132 >> 2]) | 0) != 1 | HEAP32[HEAP32[$2 + 116 >> 2] >> 2] != 1 | HEAP32[HEAP32[$2 + 116 >> 2] + 4 >> 2])) {
  HEAP32[HEAP32[$2 + 116 >> 2] >> 2] = 0;
 }
 HEAP32[$2 + 112 >> 2] = 1;
 HEAP32[$2 + 108 >> 2] = -1;
 HEAP32[$2 + 104 >> 2] = 0;
 label$2 : {
  while (1) {
   if (HEAP32[$2 + 104 >> 2] < HEAP32[HEAP32[$2 + 116 >> 2] >> 2]) {
    HEAP32[$2 + 100 >> 2] = HEAP32[(HEAP32[$2 + 116 >> 2] + 4 | 0) + (HEAP32[$2 + 104 >> 2] << 2) >> 2];
    label$5 : {
     if (HEAP32[$2 + 100 >> 2] == -1) {
      if (HEAP32[$2 + 108 >> 2] != -1) {
       $0 = HEAP32[HEAP32[$2 + 136 >> 2] + 20 >> 2];
       $1 = HEAP32[$2 + 136 >> 2];
       $3 = HEAP32[$2 + 108 >> 2];
       HEAP32[$2 + 20 >> 2] = -1;
       HEAP32[$2 + 16 >> 2] = $3;
       HEAP32[$2 + 12 >> 2] = 136227;
       HEAP32[$2 + 8 >> 2] = 136215;
       HEAP32[$2 + 4 >> 2] = 56;
       HEAP32[$2 >> 2] = 136130;
       FUNCTION_TABLE[$0]($1, 136104, $2);
       HEAP32[$2 + 140 >> 2] = 1;
       break label$2;
      }
      HEAP32[$2 + 108 >> 2] = HEAP32[$2 + 104 >> 2];
      break label$5;
     }
     HEAP32[$2 + 112 >> 2] = Math_imul(HEAP32[$2 + 100 >> 2], HEAP32[$2 + 112 >> 2]);
    }
    HEAP32[$2 + 104 >> 2] = HEAP32[$2 + 104 >> 2] + 1;
    continue;
   }
   break;
  }
  if (HEAP32[$2 + 108 >> 2] != -1) {
   HEAP32[(HEAP32[$2 + 116 >> 2] + 4 | 0) + (HEAP32[$2 + 108 >> 2] << 2) >> 2] = HEAP32[$2 + 120 >> 2] / HEAP32[$2 + 112 >> 2];
   HEAP32[$2 + 112 >> 2] = Math_imul(HEAP32[(HEAP32[$2 + 116 >> 2] + 4 | 0) + (HEAP32[$2 + 108 >> 2] << 2) >> 2], HEAP32[$2 + 112 >> 2]);
  }
  if (HEAP32[HEAP32[$2 + 128 >> 2] + 28 >> 2] != HEAP32[HEAP32[$2 + 124 >> 2] + 28 >> 2]) {
   $0 = HEAP32[HEAP32[$2 + 136 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 136 >> 2];
   $3 = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 128 >> 2] + 28 >> 2]);
   HEAP32[$2 + 52 >> 2] = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 124 >> 2] + 28 >> 2]);
   HEAP32[$2 + 48 >> 2] = $3;
   HEAP32[$2 + 44 >> 2] = 136268;
   HEAP32[$2 + 40 >> 2] = 136256;
   HEAP32[$2 + 36 >> 2] = 67;
   HEAP32[$2 + 32 >> 2] = 136130;
   FUNCTION_TABLE[$0]($1, 136230, $2 + 32 | 0);
   HEAP32[$2 + 140 >> 2] = 1;
   break label$2;
  }
  if (HEAP32[$2 + 120 >> 2] != HEAP32[$2 + 112 >> 2]) {
   $0 = HEAP32[HEAP32[$2 + 136 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 136 >> 2];
   $3 = HEAP32[$2 + 120 >> 2];
   HEAP32[$2 + 84 >> 2] = HEAP32[$2 + 112 >> 2];
   HEAP32[$2 + 80 >> 2] = $3;
   HEAP32[$2 + 76 >> 2] = 136300;
   HEAP32[$2 + 72 >> 2] = 136281;
   HEAP32[$2 + 68 >> 2] = 68;
   HEAP32[$2 + 64 >> 2] = 136130;
   FUNCTION_TABLE[$0]($1, 136104, $2 - -64 | 0);
   HEAP32[$2 + 140 >> 2] = 1;
   break label$2;
  }
  HEAP32[$2 + 140 >> 2] = 0;
 }
 global$0 = $2 + 144 | 0;
 return HEAP32[$2 + 140 >> 2];
}
function jspeFactorObject() {
 var $0 = 0;
 $0 = global$0 - 32 | 0;
 global$0 = $0;
 label$1 : {
  if ((HEAP32[80549] & 63) == 1) {
   HEAP32[$0 + 24 >> 2] = jsvNewWithFlags(5);
   if (!HEAP32[$0 + 24 >> 2]) {
    jspSetError();
    HEAP32[$0 + 28 >> 2] = 0;
    break label$1;
   }
   if (!(jslMatch(123) & 1)) {
    HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 24 >> 2];
    break label$1;
   }
   while (1) {
    if (HEAP32[80549] & 80 ? 0 : HEAP16[HEAP32[35539] + 2 >> 1] != 125) {
     HEAP32[$0 + 20 >> 2] = 0;
     label$9 : {
      if (jslIsIDOrReservedWord() & 1) {
       if ((HEAP32[80549] & 63) == 1) {
        HEAP32[$0 + 20 >> 2] = jslGetTokenValueAsVar();
       }
       jslGetNextToken();
       break label$9;
      }
      label$12 : {
       label$13 : {
        label$14 : {
         if (HEAP16[HEAP32[35539] + 2 >> 1] == 131 | HEAP16[HEAP32[35539] + 2 >> 1] == 130 | (HEAP16[HEAP32[35539] + 2 >> 1] == 129 | HEAP16[HEAP32[35539] + 2 >> 1] == 180)) {
          break label$14;
         }
         if (HEAP16[HEAP32[35539] + 2 >> 1] == 181 | HEAP16[HEAP32[35539] + 2 >> 1] == 182) {
          break label$14;
         }
         if (HEAP16[HEAP32[35539] + 2 >> 1] != 183) {
          break label$13;
         }
        }
        HEAP32[$0 + 20 >> 2] = jspeFactor();
        break label$12;
       }
       if (!(jslMatch(128) & 1)) {
        HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 24 >> 2];
        break label$1;
       }
      }
     }
     label$16 : {
      label$17 : {
       if (HEAP16[HEAP32[35539] + 2 >> 1] != 128) {
        break label$17;
       }
       if (!(jsvIsString(HEAP32[$0 + 20 >> 2]) & 1)) {
        break label$17;
       }
       HEAP8[$0 + 19 | 0] = jsvIsStringEqual(HEAP32[$0 + 20 >> 2], 80153) & 1;
       HEAP8[$0 + 18 | 0] = jsvIsStringEqual(HEAP32[$0 + 20 >> 2], 80157) & 1;
       if (!(HEAP8[$0 + 18 | 0] & 1 ? 0 : !(HEAP8[$0 + 19 | 0] & 1))) {
        jsvUnLock(HEAP32[$0 + 20 >> 2]);
        HEAP32[$0 + 20 >> 2] = jslGetTokenValueAsVar();
        jslGetNextToken();
        HEAP32[$0 + 12 >> 2] = jspeFunctionDefinition(0);
        jsvAddGetterOrSetter(HEAP32[$0 + 24 >> 2], HEAP32[$0 + 20 >> 2], HEAP8[$0 + 19 | 0] & 1, HEAP32[$0 + 12 >> 2]);
        jsvUnLock(HEAP32[$0 + 12 >> 2]);
       }
       break label$16;
      }
      if (!(jslMatch(58) & 1)) {
       jsvUnLock(HEAP32[$0 + 20 >> 2]);
       HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 24 >> 2];
       break label$1;
      }
      if ((HEAP32[80549] & 63) == 1) {
       HEAP32[$0 + 20 >> 2] = jsvAsArrayIndexAndUnLock(HEAP32[$0 + 20 >> 2]);
       HEAP32[$0 + 8 >> 2] = jsvFindChildFromVar(HEAP32[$0 + 24 >> 2], HEAP32[$0 + 20 >> 2], 1);
       if (HEAP32[$0 + 8 >> 2]) {
        HEAP32[$0 + 4 >> 2] = jsvSkipNameAndUnLock(__jspeAssignmentExpression(jspeConditionalExpression()));
        jsvUnLock2(jsvSetValueOfName(HEAP32[$0 + 8 >> 2], HEAP32[$0 + 4 >> 2]), HEAP32[$0 + 4 >> 2]);
       }
      }
     }
     jsvUnLock(HEAP32[$0 + 20 >> 2]);
     if (HEAP16[HEAP32[35539] + 2 >> 1] != 125) {
      if (!(jslMatch(44) & 1)) {
       HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 24 >> 2];
       break label$1;
      }
     }
     continue;
    }
    break;
   }
   if (!(jslMatch(125) & 1)) {
    HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 24 >> 2];
    break label$1;
   }
   HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 24 >> 2];
   break label$1;
  }
  jspeBlock();
  HEAP32[$0 + 28 >> 2] = 0;
 }
 global$0 = $0 + 32 | 0;
 return HEAP32[$0 + 28 >> 2];
}
function jswGetSymbolListForObjectProto($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (jsvIsNativeFunction(HEAP32[$1 + 8 >> 2]) & 1) {
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 41) {
    HEAP32[$1 + 12 >> 2] = 93238;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 56) {
    HEAP32[$1 + 12 >> 2] = 93256;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 57) {
    HEAP32[$1 + 12 >> 2] = 93265;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 58) {
    HEAP32[$1 + 12 >> 2] = 93382;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 46) {
    HEAP32[$1 + 12 >> 2] = 93400;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 59) {
    HEAP32[$1 + 12 >> 2] = 93427;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 51) {
    HEAP32[$1 + 12 >> 2] = 93562;
    break label$1;
   }
  }
  $0 = $1;
  label$10 : {
   if (jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1) {
    $2 = jsvSkipNameAndUnLock(jsvFindChildFromString(HEAP32[$1 + 8 >> 2], 93653, 0));
    break label$10;
   }
   $2 = 0;
  }
  HEAP32[$0 + 4 >> 2] = $2;
  label$12 : {
   if (!HEAP32[$1 + 4 >> 2]) {
    break label$12;
   }
   if (!(jsvIsNativeFunction(HEAP32[$1 + 4 >> 2]) & 1)) {
    break label$12;
   }
   HEAP32[$1 >> 2] = jswGetSymbolListForConstructorProto(HEAP32[$1 + 4 >> 2]);
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
   if (HEAP32[$1 >> 2]) {
    HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
    break label$1;
   }
  }
  if (jsvIsArray(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 93238;
   break label$1;
  }
  label$15 : {
   if (!(jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1)) {
    break label$15;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8) != 129) {
    break label$15;
   }
   HEAP32[$1 + 12 >> 2] = 93256;
   break label$1;
  }
  label$16 : {
   if (!(jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1)) {
    break label$16;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8) == 129) {
    break label$16;
   }
   HEAP32[$1 + 12 >> 2] = 93265;
   break label$1;
  }
  if (jsvIsPin(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 93382;
   break label$1;
  }
  if (jsvIsNumeric(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 93400;
   break label$1;
  }
  if (jsvIsFunction(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 93427;
   break label$1;
  }
  if (jsvIsString(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 93562;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 93409;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function tflite___28anonymous_20namespace_29__CalculateActivationRangeQuantizedImpl_28TfLiteFusedActivation_2c_20int_2c_20int_2c_20TfLiteTensor__2c_20int__2c_20int__29($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = global$0 + -64 | 0;
 global$0 = $6;
 HEAP32[$6 + 60 >> 2] = $0;
 HEAP32[$6 + 56 >> 2] = $1;
 HEAP32[$6 + 52 >> 2] = $2;
 HEAP32[$6 + 48 >> 2] = $3;
 HEAP32[$6 + 44 >> 2] = $4;
 HEAP32[$6 + 40 >> 2] = $5;
 HEAPF32[$6 + 36 >> 2] = HEAPF32[HEAP32[$6 + 48 >> 2] + 8 >> 2];
 HEAP32[$6 + 32 >> 2] = HEAP32[HEAP32[$6 + 48 >> 2] + 12 >> 2];
 HEAPF32[$6 + 24 >> 2] = HEAPF32[$6 + 36 >> 2];
 HEAP32[$6 + 28 >> 2] = HEAP32[$6 + 32 >> 2];
 label$1 : {
  if (HEAP32[$6 + 60 >> 2] == 1) {
   $0 = $6 + 56 | 0;
   $1 = $6 + 20 | 0;
   HEAP32[$6 + 20 >> 2] = tflite___28anonymous_20namespace_29__CalculateActivationRangeQuantizedImpl_28TfLiteFusedActivation_2c_20int_2c_20int_2c_20TfLiteTensor__2c_20int__2c_20int__29__$_0__operator_28_29_28float_29_20const($6 + 24 | 0, Math_fround(0));
   $0 = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($0, $1) >> 2];
   HEAP32[HEAP32[$6 + 44 >> 2] >> 2] = $0;
   HEAP32[HEAP32[$6 + 40 >> 2] >> 2] = HEAP32[$6 + 52 >> 2];
   break label$1;
  }
  label$3 : {
   if (HEAP32[$6 + 60 >> 2] == 3) {
    $0 = $6 + 52 | 0;
    $1 = $6 + 12 | 0;
    $2 = $6 + 56 | 0;
    $3 = $6 + 16 | 0;
    $4 = $6 + 24 | 0;
    HEAP32[$6 + 16 >> 2] = tflite___28anonymous_20namespace_29__CalculateActivationRangeQuantizedImpl_28TfLiteFusedActivation_2c_20int_2c_20int_2c_20TfLiteTensor__2c_20int__2c_20int__29__$_0__operator_28_29_28float_29_20const($4, Math_fround(0));
    $2 = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($2, $3) >> 2];
    HEAP32[HEAP32[$6 + 44 >> 2] >> 2] = $2;
    HEAP32[$6 + 12 >> 2] = tflite___28anonymous_20namespace_29__CalculateActivationRangeQuantizedImpl_28TfLiteFusedActivation_2c_20int_2c_20int_2c_20TfLiteTensor__2c_20int__2c_20int__29__$_0__operator_28_29_28float_29_20const($4, Math_fround(6));
    $0 = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($0, $1) >> 2];
    HEAP32[HEAP32[$6 + 40 >> 2] >> 2] = $0;
    break label$3;
   }
   label$5 : {
    if (HEAP32[$6 + 60 >> 2] == 2) {
     $0 = $6 + 52 | 0;
     $1 = $6 + 4 | 0;
     $2 = $6 + 56 | 0;
     $3 = $6 + 8 | 0;
     $4 = $6 + 24 | 0;
     HEAP32[$6 + 8 >> 2] = tflite___28anonymous_20namespace_29__CalculateActivationRangeQuantizedImpl_28TfLiteFusedActivation_2c_20int_2c_20int_2c_20TfLiteTensor__2c_20int__2c_20int__29__$_0__operator_28_29_28float_29_20const($4, Math_fround(-1));
     $2 = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($2, $3) >> 2];
     HEAP32[HEAP32[$6 + 44 >> 2] >> 2] = $2;
     HEAP32[$6 + 4 >> 2] = tflite___28anonymous_20namespace_29__CalculateActivationRangeQuantizedImpl_28TfLiteFusedActivation_2c_20int_2c_20int_2c_20TfLiteTensor__2c_20int__2c_20int__29__$_0__operator_28_29_28float_29_20const($4, Math_fround(1));
     $0 = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($0, $1) >> 2];
     HEAP32[HEAP32[$6 + 40 >> 2] >> 2] = $0;
     break label$5;
    }
    HEAP32[HEAP32[$6 + 44 >> 2] >> 2] = HEAP32[$6 + 56 >> 2];
    HEAP32[HEAP32[$6 + 40 >> 2] >> 2] = HEAP32[$6 + 52 >> 2];
   }
  }
 }
 global$0 = $6 - -64 | 0;
}
function graphicsFillRectDevice($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = global$0 - 32 | 0;
 global$0 = $6;
 HEAP32[$6 + 28 >> 2] = $0;
 HEAP32[$6 + 24 >> 2] = $1;
 HEAP32[$6 + 20 >> 2] = $2;
 HEAP32[$6 + 16 >> 2] = $3;
 HEAP32[$6 + 12 >> 2] = $4;
 HEAP32[$6 + 8 >> 2] = $5;
 if (HEAP32[$6 + 24 >> 2] > HEAP32[$6 + 16 >> 2]) {
  HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 24 >> 2];
  HEAP32[$6 + 24 >> 2] = HEAP32[$6 + 16 >> 2];
  HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 4 >> 2];
 }
 if (HEAP32[$6 + 20 >> 2] > HEAP32[$6 + 12 >> 2]) {
  HEAP32[$6 >> 2] = HEAP32[$6 + 20 >> 2];
  HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 12 >> 2];
  HEAP32[$6 + 12 >> 2] = HEAP32[$6 >> 2];
 }
 $0 = HEAP32[$6 + 28 >> 2];
 if (HEAP32[$6 + 24 >> 2] < (HEAPU8[$0 + 32 | 0] | HEAPU8[$0 + 33 | 0] << 8)) {
  $0 = HEAP32[$6 + 28 >> 2];
  HEAP32[$6 + 24 >> 2] = HEAPU8[$0 + 32 | 0] | HEAPU8[$0 + 33 | 0] << 8;
 }
 $0 = HEAP32[$6 + 28 >> 2];
 if (HEAP32[$6 + 20 >> 2] < (HEAPU8[$0 + 34 | 0] | HEAPU8[$0 + 35 | 0] << 8)) {
  $0 = HEAP32[$6 + 28 >> 2];
  HEAP32[$6 + 20 >> 2] = HEAPU8[$0 + 34 | 0] | HEAPU8[$0 + 35 | 0] << 8;
 }
 $0 = HEAP32[$6 + 28 >> 2];
 if (HEAP32[$6 + 16 >> 2] > (HEAPU8[$0 + 36 | 0] | HEAPU8[$0 + 37 | 0] << 8)) {
  $0 = HEAP32[$6 + 28 >> 2];
  HEAP32[$6 + 16 >> 2] = HEAPU8[$0 + 36 | 0] | HEAPU8[$0 + 37 | 0] << 8;
 }
 $0 = HEAP32[$6 + 28 >> 2];
 if (HEAP32[$6 + 12 >> 2] > (HEAPU8[$0 + 38 | 0] | HEAPU8[$0 + 39 | 0] << 8)) {
  $0 = HEAP32[$6 + 28 >> 2];
  HEAP32[$6 + 12 >> 2] = HEAPU8[$0 + 38 | 0] | HEAPU8[$0 + 39 | 0] << 8;
 }
 label$7 : {
  if (HEAP32[$6 + 16 >> 2] < HEAP32[$6 + 24 >> 2] | HEAP32[$6 + 12 >> 2] < HEAP32[$6 + 20 >> 2]) {
   break label$7;
  }
  $0 = HEAP32[$6 + 28 >> 2];
  if (HEAP32[$6 + 24 >> 2] < (HEAPU8[$0 + 40 | 0] | HEAPU8[$0 + 41 | 0] << 8) << 16 >> 16) {
   $0 = HEAP32[$6 + 28 >> 2];
   $1 = HEAP32[$6 + 24 >> 2];
   HEAP8[$0 + 40 | 0] = $1;
   HEAP8[$0 + 41 | 0] = $1 >>> 8;
  }
  $0 = HEAP32[$6 + 28 >> 2];
  if (HEAP32[$6 + 16 >> 2] > (HEAPU8[$0 + 44 | 0] | HEAPU8[$0 + 45 | 0] << 8) << 16 >> 16) {
   $0 = HEAP32[$6 + 28 >> 2];
   $1 = HEAP32[$6 + 16 >> 2];
   HEAP8[$0 + 44 | 0] = $1;
   HEAP8[$0 + 45 | 0] = $1 >>> 8;
  }
  $0 = HEAP32[$6 + 28 >> 2];
  if (HEAP32[$6 + 20 >> 2] < (HEAPU8[$0 + 42 | 0] | HEAPU8[$0 + 43 | 0] << 8) << 16 >> 16) {
   $0 = HEAP32[$6 + 28 >> 2];
   $1 = HEAP32[$6 + 20 >> 2];
   HEAP8[$0 + 42 | 0] = $1;
   HEAP8[$0 + 43 | 0] = $1 >>> 8;
  }
  $0 = HEAP32[$6 + 28 >> 2];
  if (HEAP32[$6 + 12 >> 2] > (HEAPU8[$0 + 46 | 0] | HEAPU8[$0 + 47 | 0] << 8) << 16 >> 16) {
   $0 = HEAP32[$6 + 28 >> 2];
   $1 = HEAP32[$6 + 12 >> 2];
   HEAP8[$0 + 46 | 0] = $1;
   HEAP8[$0 + 47 | 0] = $1 >>> 8;
  }
  if (!(HEAP32[$6 + 24 >> 2] != HEAP32[$6 + 16 >> 2] | HEAP32[$6 + 20 >> 2] != HEAP32[$6 + 12 >> 2])) {
   $0 = HEAP32[$6 + 28 >> 2];
   FUNCTION_TABLE[HEAPU8[$0 + 52 | 0] | HEAPU8[$0 + 53 | 0] << 8 | (HEAPU8[$0 + 54 | 0] << 16 | HEAPU8[$0 + 55 | 0] << 24)](HEAP32[$6 + 28 >> 2], HEAP32[$6 + 24 >> 2], HEAP32[$6 + 20 >> 2], HEAP32[$6 + 8 >> 2]);
   break label$7;
  }
  $0 = HEAP32[$6 + 28 >> 2];
  FUNCTION_TABLE[HEAPU8[$0 + 56 | 0] | HEAPU8[$0 + 57 | 0] << 8 | (HEAPU8[$0 + 58 | 0] << 16 | HEAPU8[$0 + 59 | 0] << 24)](HEAP32[$6 + 28 >> 2], HEAP32[$6 + 24 >> 2], HEAP32[$6 + 20 >> 2], HEAP32[$6 + 16 >> 2], HEAP32[$6 + 12 >> 2], HEAP32[$6 + 8 >> 2]);
 }
 global$0 = $6 + 32 | 0;
}
function tflite__ops__micro__fully_connected__Eval_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 label$1 : {
  if (!HEAP32[HEAP32[$2 + 36 >> 2] + 12 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$2 + 32 >> 2] = HEAP32[HEAP32[$2 + 36 >> 2] + 12 >> 2];
 HEAP32[$2 + 28 >> 2] = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], 0);
 HEAP32[$2 + 24 >> 2] = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], 1);
 HEAP32[$2 + 20 >> 2] = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], 2);
 HEAP32[$2 + 16 >> 2] = tflite__micro__GetEvalOutput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
 label$2 : {
  if (!HEAP32[HEAP32[$2 + 36 >> 2] + 8 >> 2]) {
   break label$2;
  }
 }
 HEAP32[$2 + 12 >> 2] = HEAP32[HEAP32[$2 + 36 >> 2] + 8 >> 2];
 label$3 : {
  label$4 : {
   $0 = HEAP32[HEAP32[$2 + 28 >> 2] + 8 >> 2] + -1 | 0;
   if ($0 >>> 0 > 8) {
    break label$4;
   }
   label$5 : {
    switch ($0 - 1 | 0) {
    default:
     HEAP32[$2 + 44 >> 2] = tflite__ops__micro__fully_connected__EvalFloat_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteFusedActivation_2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], HEAP32[HEAP32[$2 + 32 >> 2] >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2]);
     break label$3;
    case 7:
     HEAP32[$2 + 44 >> 2] = tflite__ops__micro__fully_connected__EvalQuantizedInt8_28TfLiteContext__2c_20TfLiteNode__2c_20tflite__ops__micro__fully_connected___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2]);
     break label$3;
    case 0:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
     break label$4;
    case 1:
     break label$5;
    }
   }
   HEAP32[$2 + 44 >> 2] = tflite__ops__micro__fully_connected__EvalQuantized_28TfLiteContext__2c_20TfLiteNode__2c_20tflite__ops__micro__fully_connected___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2]);
   break label$3;
  }
  $0 = HEAP32[HEAP32[$2 + 40 >> 2] + 20 >> 2];
  $1 = HEAP32[$2 + 40 >> 2];
  $3 = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 28 >> 2] + 8 >> 2]);
  HEAP32[$2 + 4 >> 2] = HEAP32[HEAP32[$2 + 28 >> 2] + 8 >> 2];
  HEAP32[$2 >> 2] = $3;
  FUNCTION_TABLE[$0]($1, 135101, $2);
  HEAP32[$2 + 44 >> 2] = 1;
 }
 global$0 = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}
function jswrap_graphics_quadraticBezier($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 160 | 0;
 global$0 = $3;
 HEAP32[$3 + 152 >> 2] = $0;
 HEAP32[$3 + 148 >> 2] = $1;
 HEAP32[$3 + 144 >> 2] = $2;
 HEAP32[$3 + 140 >> 2] = jsvNewWithFlags(3);
 label$1 : {
  if (!HEAP32[$3 + 140 >> 2]) {
   HEAP32[$3 + 156 >> 2] = 0;
   break label$1;
  }
  if ((jsvGetArrayLength(HEAP32[$3 + 148 >> 2]) | 0) != 6) {
   HEAP32[$3 + 156 >> 2] = HEAP32[$3 + 140 >> 2];
   break label$1;
  }
  HEAP32[$3 + 136 >> 2] = 5;
  HEAP32[$3 + 108 >> 2] = 0;
  jsvIteratorNew($3 + 48 | 0, HEAP32[$3 + 148 >> 2], 1);
  HEAP32[$3 + 44 >> 2] = 0;
  while (1) {
   if (HEAP32[$3 + 44 >> 2] < 6) {
    $0 = $3 + 112 | 0;
    $1 = $3 + 48 | 0;
    $2 = jsvIteratorGetIntegerValue($1);
    HEAP32[$0 + (HEAP32[$3 + 44 >> 2] << 2) >> 2] = $2;
    jsvIteratorNext($1);
    HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 44 >> 2] + 1;
    continue;
   }
   break;
  }
  jsvIteratorFree($3 + 48 | 0);
  if (jsvIsObject(HEAP32[$3 + 144 >> 2]) & 1) {
   HEAP32[$3 + 108 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$3 + 144 >> 2], 128077, 0));
  }
  HEAP32[$3 + 40 >> 2] = 4096;
  HEAP32[$3 + 36 >> 2] = 12;
  HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 112 >> 2] - HEAP32[$3 + 128 >> 2];
  if (HEAP32[$3 + 32 >> 2] < 0) {
   HEAP32[$3 + 32 >> 2] = 0 - HEAP32[$3 + 32 >> 2];
  }
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 116 >> 2] - HEAP32[$3 + 132 >> 2];
  if (HEAP32[$3 + 28 >> 2] < 0) {
   HEAP32[$3 + 28 >> 2] = 0 - HEAP32[$3 + 28 >> 2];
  }
  $0 = $3;
  if (HEAP32[$3 + 32 >> 2] < HEAP32[$3 + 28 >> 2]) {
   $1 = HEAP32[$3 + 32 >> 2];
  } else {
   $1 = HEAP32[$3 + 28 >> 2];
  }
  HEAP32[$0 + 24 >> 2] = $1;
  if (!HEAP32[$3 + 24 >> 2]) {
   HEAP32[$3 + 24 >> 2] = 1;
  }
  HEAP32[$3 + 20 >> 2] = (HEAP32[$3 + 136 >> 2] << 12) / HEAP32[$3 + 24 >> 2];
  if (HEAP32[$3 + 20 >> 2] >= 4096) {
   HEAP32[$3 + 20 >> 2] = 1365;
  }
  if (HEAP32[$3 + 20 >> 2] < 409) {
   HEAP32[$3 + 20 >> 2] = 409;
  }
  if (HEAP32[$3 + 108 >> 2] > 0) {
   HEAP32[$3 + 20 >> 2] = 4096 / HEAP32[$3 + 108 >> 2];
  }
  jsvArrayPush2Int(HEAP32[$3 + 140 >> 2], HEAP32[$3 + 112 >> 2], HEAP32[$3 + 116 >> 2]);
  HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 20 >> 2];
  while (1) {
   if (HEAP32[$3 + 16 >> 2] <= 4096) {
    HEAP32[$3 + 12 >> 2] = Math_imul(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 16 >> 2]) >> 12;
    HEAP32[$3 + 8 >> 2] = Math_imul(4096 - HEAP32[$3 + 16 >> 2] | 0, 4096 - HEAP32[$3 + 16 >> 2] | 0) >> 12;
    HEAP32[$3 + 4 >> 2] = Math_imul(HEAP32[$3 + 16 >> 2], 4096 - HEAP32[$3 + 16 >> 2] << 1) >> 12;
    jsvArrayPush2Int(HEAP32[$3 + 140 >> 2], ((Math_imul(HEAP32[$3 + 112 >> 2], HEAP32[$3 + 8 >> 2]) + Math_imul(HEAP32[$3 + 120 >> 2], HEAP32[$3 + 4 >> 2]) | 0) + Math_imul(HEAP32[$3 + 128 >> 2], HEAP32[$3 + 12 >> 2]) | 0) + 2048 >> 12, ((Math_imul(HEAP32[$3 + 116 >> 2], HEAP32[$3 + 8 >> 2]) + Math_imul(HEAP32[$3 + 124 >> 2], HEAP32[$3 + 4 >> 2]) | 0) + Math_imul(HEAP32[$3 + 132 >> 2], HEAP32[$3 + 12 >> 2]) | 0) + 2048 >> 12);
    HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 20 >> 2] + HEAP32[$3 + 16 >> 2];
    continue;
   }
   break;
  }
  jsvArrayPush2Int(HEAP32[$3 + 140 >> 2], HEAP32[$3 + 128 >> 2], HEAP32[$3 + 132 >> 2]);
  HEAP32[$3 + 156 >> 2] = HEAP32[$3 + 140 >> 2];
 }
 global$0 = $3 + 160 | 0;
 return HEAP32[$3 + 156 >> 2];
}
function tflite__ops__micro__conv__EvalFloat_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteConvParams__2c_20tflite__ops__micro__conv__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__2c_20TfLiteEvalTensor__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0, $9 = 0;
 $8 = global$0 - 240 | 0;
 global$0 = $8;
 $9 = $8 + 112 | 0;
 HEAP32[$8 + 236 >> 2] = $0;
 HEAP32[$8 + 232 >> 2] = $1;
 HEAP32[$8 + 228 >> 2] = $2;
 HEAP32[$8 + 224 >> 2] = $3;
 HEAP32[$8 + 220 >> 2] = $4;
 HEAP32[$8 + 216 >> 2] = $5;
 HEAP32[$8 + 212 >> 2] = $6;
 HEAP32[$8 + 208 >> 2] = 0;
 HEAP32[$8 + 204 >> 2] = 0;
 HEAP32[$8 + 200 >> 2] = $7;
 void_20tflite__CalculateActivationRange_float__28TfLiteFusedActivation_2c_20float__2c_20float__29(HEAP32[HEAP32[$8 + 228 >> 2] + 12 >> 2], $8 + 196 | 0, $8 + 192 | 0);
 HEAP8[$8 + 136 | 0] = tflite__ops__micro__conv__RuntimePaddingType_28TfLitePadding_29(HEAP32[HEAP32[$8 + 228 >> 2] >> 2]);
 HEAP16[$8 + 138 >> 1] = HEAP32[HEAP32[$8 + 224 >> 2] >> 2];
 HEAP16[$8 + 140 >> 1] = HEAP32[HEAP32[$8 + 224 >> 2] + 4 >> 2];
 HEAP16[$8 + 146 >> 1] = HEAP32[HEAP32[$8 + 228 >> 2] + 4 >> 2];
 HEAP16[$8 + 148 >> 1] = HEAP32[HEAP32[$8 + 228 >> 2] + 8 >> 2];
 HEAP16[$8 + 150 >> 1] = HEAP32[HEAP32[$8 + 228 >> 2] + 16 >> 2];
 HEAP16[$8 + 152 >> 1] = HEAP32[HEAP32[$8 + 228 >> 2] + 20 >> 2];
 HEAPF32[$8 + 184 >> 2] = HEAPF32[$8 + 196 >> 2];
 HEAPF32[$8 + 188 >> 2] = HEAPF32[$8 + 192 >> 2];
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($9, HEAP32[$8 + 220 >> 2]);
 $0 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$8 + 220 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 80 | 0, HEAP32[$8 + 216 >> 2]);
 $1 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$8 + 216 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 56 | 0, HEAP32[$8 + 212 >> 2]);
 $2 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$8 + 212 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 32 | 0, HEAP32[$8 + 200 >> 2]);
 $3 = float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$8 + 200 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 8 | 0, HEAP32[$8 + 208 >> 2]);
 tflite__reference_ops__Conv_28tflite__ConvParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float__2c_20tflite__RuntimeShape_20const__2c_20float__29($8 + 136 | 0, $8 + 112 | 0, $0, $8 + 80 | 0, $1, $8 + 56 | 0, $2, $8 + 32 | 0, $3, $8 + 8 | 0, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$8 + 208 >> 2]));
 $0 = $8 + 112 | 0;
 $1 = $8 + 80 | 0;
 $2 = $8 + 56 | 0;
 $3 = $8 + 32 | 0;
 tflite__RuntimeShape___RuntimeShape_28_29($8 + 8 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($3);
 tflite__RuntimeShape___RuntimeShape_28_29($2);
 tflite__RuntimeShape___RuntimeShape_28_29($1);
 tflite__RuntimeShape___RuntimeShape_28_29($0);
 global$0 = $8 + 240 | 0;
}
function tflite__ops__micro__depthwise_conv__EvalQuantized_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteDepthwiseConvParams__2c_20tflite__ops__micro__depthwise_conv___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0;
 $8 = global$0 - 224 | 0;
 global$0 = $8;
 HEAP32[$8 + 220 >> 2] = $0;
 HEAP32[$8 + 216 >> 2] = $1;
 HEAP32[$8 + 212 >> 2] = $2;
 HEAP32[$8 + 208 >> 2] = $3;
 HEAP32[$8 + 204 >> 2] = $4;
 HEAP32[$8 + 200 >> 2] = $5;
 HEAP32[$8 + 196 >> 2] = $6;
 HEAP32[$8 + 192 >> 2] = $7;
 HEAP32[$8 + 188 >> 2] = 0 - HEAP32[HEAP32[$8 + 208 >> 2] + 16 >> 2];
 HEAP32[$8 + 184 >> 2] = 0 - HEAP32[HEAP32[$8 + 208 >> 2] + 20 >> 2];
 HEAP32[$8 + 180 >> 2] = HEAP32[HEAP32[$8 + 208 >> 2] + 24 >> 2];
 HEAP8[$8 + 112 | 0] = 1;
 HEAP16[$8 + 114 >> 1] = HEAP32[HEAP32[$8 + 208 >> 2] >> 2];
 HEAP16[$8 + 116 >> 1] = HEAP32[HEAP32[$8 + 208 >> 2] + 4 >> 2];
 HEAP16[$8 + 122 >> 1] = HEAP32[HEAP32[$8 + 212 >> 2] + 4 >> 2];
 HEAP16[$8 + 124 >> 1] = HEAP32[HEAP32[$8 + 212 >> 2] + 8 >> 2];
 HEAP16[$8 + 126 >> 1] = HEAP32[HEAP32[$8 + 212 >> 2] + 20 >> 2];
 HEAP16[$8 + 128 >> 1] = HEAP32[HEAP32[$8 + 212 >> 2] + 24 >> 2];
 HEAP16[$8 + 130 >> 1] = HEAP32[HEAP32[$8 + 212 >> 2] + 12 >> 2];
 HEAP32[$8 + 152 >> 2] = HEAP32[HEAP32[$8 + 208 >> 2] + 44 >> 2];
 HEAP32[$8 + 156 >> 2] = HEAP32[HEAP32[$8 + 208 >> 2] + 48 >> 2];
 HEAP32[$8 + 132 >> 2] = HEAP32[$8 + 188 >> 2];
 HEAP32[$8 + 136 >> 2] = HEAP32[$8 + 184 >> 2];
 HEAP32[$8 + 140 >> 2] = HEAP32[$8 + 180 >> 2];
 HEAP32[$8 + 144 >> 2] = HEAP32[HEAP32[$8 + 208 >> 2] + 28 >> 2];
 HEAP32[$8 + 148 >> 2] = 0 - HEAP32[HEAP32[$8 + 208 >> 2] + 32 >> 2];
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 88 | 0, HEAP32[$8 + 204 >> 2]);
 $0 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$8 + 204 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 56 | 0, HEAP32[$8 + 200 >> 2]);
 $1 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$8 + 200 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 32 | 0, HEAP32[$8 + 196 >> 2]);
 $2 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$8 + 196 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 8 | 0, HEAP32[$8 + 192 >> 2]);
 tflite__reference_ops__DepthwiseConv_28tflite__DepthwiseParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29($8 + 112 | 0, $8 + 88 | 0, $0, $8 + 56 | 0, $1, $8 + 32 | 0, $2, $8 + 8 | 0, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$8 + 192 >> 2]));
 $0 = $8 + 88 | 0;
 $1 = $8 + 56 | 0;
 $2 = $8 + 32 | 0;
 tflite__RuntimeShape___RuntimeShape_28_29($8 + 8 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($2);
 tflite__RuntimeShape___RuntimeShape_28_29($1);
 tflite__RuntimeShape___RuntimeShape_28_29($0);
 global$0 = $8 + 224 | 0;
}
function tflite__ParseReshape_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0, $5 = 0, $6 = 0;
 $4 = global$0 - 80 | 0;
 global$0 = $4;
 $6 = $4 + 48 | 0;
 $5 = $4 + 56 | 0;
 HEAP32[$4 + 72 >> 2] = $0;
 HEAP32[$4 + 68 >> 2] = $1;
 HEAP32[$4 + 64 >> 2] = $2;
 HEAP32[$4 + 60 >> 2] = $3;
 tflite___28anonymous_20namespace_29__CheckParsePointerParams_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29(HEAP32[$4 + 72 >> 2], HEAP32[$4 + 68 >> 2], HEAP32[$4 + 64 >> 2], HEAP32[$4 + 60 >> 2]);
 tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__SafeBuiltinDataAllocator_28tflite__BuiltinDataAllocator__29($5, HEAP32[$4 + 64 >> 2]);
 std____2__unique_ptr_TfLiteReshapeParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__Allocate_TfLiteReshapeParams__28_29($6, $5);
 label$1 : {
  if (!(bool_20std____2__operator___TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20const__2c_20std__nullptr_t_29($4 + 48 | 0) & 1)) {
   $0 = HEAP32[$4 + 68 >> 2];
   $1 = HEAP32[$4 + 68 >> 2];
   HEAP32[$4 + 8 >> 2] = 136736;
   HEAP32[$4 + 4 >> 2] = 1448;
   HEAP32[$4 >> 2] = 136641;
   tflite__ErrorReporter__ReportError_28void__2c_20char_20const__2c_20____29($0, $1, 136618, $4);
   HEAP32[$4 + 76 >> 2] = 1;
   break label$1;
  }
  HEAP32[$4 + 32 >> 2] = tflite__Operator__builtin_options_as_ReshapeOptions_28_29_20const(HEAP32[$4 + 72 >> 2]);
  if (HEAP32[$4 + 32 >> 2]) {
   HEAP32[$4 + 28 >> 2] = tflite__Tensor__shape_28_29_20const(HEAP32[$4 + 32 >> 2]);
   if (HEAP32[$4 + 28 >> 2]) {
    HEAP32[$4 + 24 >> 2] = tflite___28anonymous_20namespace_29__FlatBufferIntVectorToArray_28int_2c_20flatbuffers__Vector_int__20const__2c_20int__2c_20tflite__ErrorReporter__2c_20char_20const__29(HEAP32[$4 + 28 >> 2], std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 48 | 0), HEAP32[$4 + 68 >> 2]);
    if (HEAP32[$4 + 24 >> 2]) {
     HEAP32[$4 + 76 >> 2] = HEAP32[$4 + 24 >> 2];
     break label$1;
    }
    $0 = flatbuffers__Vector_int___size_28_29_20const(HEAP32[$4 + 28 >> 2]);
    HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 48 | 0) + 32 >> 2] = $0;
   }
  }
  $0 = std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___release_28_29($4 + 48 | 0);
  HEAP32[HEAP32[$4 + 60 >> 2] >> 2] = $0;
  HEAP32[$4 + 76 >> 2] = 0;
 }
 HEAP32[$4 + 36 >> 2] = 1;
 std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter____unique_ptr_28_29($4 + 48 | 0);
 global$0 = $4 + 80 | 0;
 return HEAP32[$4 + 76 >> 2];
}
function mbedtls_sha1_finish($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 96 | 0;
 global$0 = $2;
 HEAP32[$2 + 92 >> 2] = $0;
 HEAP32[$2 + 88 >> 2] = $1;
 HEAP32[$2 + 76 >> 2] = HEAP32[HEAP32[$2 + 92 >> 2] + 4 >> 2] << 3 | HEAP32[HEAP32[$2 + 92 >> 2] >> 2] >>> 29;
 HEAP32[$2 + 72 >> 2] = HEAP32[HEAP32[$2 + 92 >> 2] >> 2] << 3;
 HEAP8[$2 + 64 | 0] = HEAP32[$2 + 76 >> 2] >>> 24;
 HEAP8[$2 + 65 | 0] = HEAP32[$2 + 76 >> 2] >>> 16;
 HEAP8[$2 + 66 | 0] = HEAP32[$2 + 76 >> 2] >>> 8;
 HEAP8[$2 + 67 | 0] = HEAP32[$2 + 76 >> 2];
 HEAP8[$2 + 68 | 0] = HEAP32[$2 + 72 >> 2] >>> 24;
 HEAP8[$2 + 69 | 0] = HEAP32[$2 + 72 >> 2] >>> 16;
 HEAP8[$2 + 70 | 0] = HEAP32[$2 + 72 >> 2] >>> 8;
 HEAP8[$2 + 71 | 0] = HEAP32[$2 + 72 >> 2];
 HEAP32[$2 + 84 >> 2] = HEAP32[HEAP32[$2 + 92 >> 2] >> 2] & 63;
 $0 = $2 - -64 | 0;
 $1 = $2;
 if (HEAPU32[$2 + 84 >> 2] < 56) {
  $3 = 56 - HEAP32[$2 + 84 >> 2] | 0;
 } else {
  $3 = 120 - HEAP32[$2 + 84 >> 2] | 0;
 }
 HEAP32[$1 + 80 >> 2] = $3;
 HEAP32[$2 >> 2] = 0;
 HEAP32[$2 + 4 >> 2] = 0;
 HEAP32[$2 + 56 >> 2] = 0;
 HEAP32[$2 + 60 >> 2] = 0;
 HEAP32[$2 + 48 >> 2] = 0;
 HEAP32[$2 + 52 >> 2] = 0;
 HEAP32[$2 + 40 >> 2] = 0;
 HEAP32[$2 + 44 >> 2] = 0;
 HEAP32[$2 + 32 >> 2] = 0;
 HEAP32[$2 + 36 >> 2] = 0;
 HEAP32[$2 + 24 >> 2] = 0;
 HEAP32[$2 + 28 >> 2] = 0;
 HEAP32[$2 + 16 >> 2] = 0;
 HEAP32[$2 + 20 >> 2] = 0;
 HEAP32[$2 + 8 >> 2] = 0;
 HEAP32[$2 + 12 >> 2] = 0;
 HEAP8[$2 | 0] = 128;
 mbedtls_sha1_update(HEAP32[$2 + 92 >> 2], $2, HEAP32[$2 + 80 >> 2]);
 mbedtls_sha1_update(HEAP32[$2 + 92 >> 2], $0, 8);
 HEAP8[HEAP32[$2 + 88 >> 2]] = HEAP32[HEAP32[$2 + 92 >> 2] + 8 >> 2] >>> 24;
 HEAP8[HEAP32[$2 + 88 >> 2] + 1 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 8 >> 2] >>> 16;
 HEAP8[HEAP32[$2 + 88 >> 2] + 2 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 8 >> 2] >>> 8;
 HEAP8[HEAP32[$2 + 88 >> 2] + 3 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 8 >> 2];
 HEAP8[HEAP32[$2 + 88 >> 2] + 4 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 12 >> 2] >>> 24;
 HEAP8[HEAP32[$2 + 88 >> 2] + 5 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 12 >> 2] >>> 16;
 HEAP8[HEAP32[$2 + 88 >> 2] + 6 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 12 >> 2] >>> 8;
 HEAP8[HEAP32[$2 + 88 >> 2] + 7 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 12 >> 2];
 HEAP8[HEAP32[$2 + 88 >> 2] + 8 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 16 >> 2] >>> 24;
 HEAP8[HEAP32[$2 + 88 >> 2] + 9 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 16 >> 2] >>> 16;
 HEAP8[HEAP32[$2 + 88 >> 2] + 10 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 16 >> 2] >>> 8;
 HEAP8[HEAP32[$2 + 88 >> 2] + 11 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 16 >> 2];
 HEAP8[HEAP32[$2 + 88 >> 2] + 12 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 20 >> 2] >>> 24;
 HEAP8[HEAP32[$2 + 88 >> 2] + 13 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 20 >> 2] >>> 16;
 HEAP8[HEAP32[$2 + 88 >> 2] + 14 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 20 >> 2] >>> 8;
 HEAP8[HEAP32[$2 + 88 >> 2] + 15 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 20 >> 2];
 HEAP8[HEAP32[$2 + 88 >> 2] + 16 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 24 >> 2] >>> 24;
 HEAP8[HEAP32[$2 + 88 >> 2] + 17 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 24 >> 2] >>> 16;
 HEAP8[HEAP32[$2 + 88 >> 2] + 18 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 24 >> 2] >>> 8;
 HEAP8[HEAP32[$2 + 88 >> 2] + 19 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 24 >> 2];
 global$0 = $2 + 96 | 0;
}
function tflite__ops__micro__dequantize__Prepare_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = global$0 - 128 | 0;
 global$0 = $2;
 HEAP32[$2 + 120 >> 2] = $0;
 HEAP32[$2 + 116 >> 2] = $1;
 label$1 : {
  if (!HEAP32[HEAP32[$2 + 116 >> 2] + 8 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$2 + 112 >> 2] = HEAP32[HEAP32[$2 + 116 >> 2] + 8 >> 2];
 label$2 : {
  if ((tflite__NumInputs_28TfLiteNode_20const__29(HEAP32[$2 + 116 >> 2]) | 0) != 1) {
   $0 = HEAP32[HEAP32[$2 + 120 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 120 >> 2];
   $3 = tflite__NumInputs_28TfLiteNode_20const__29(HEAP32[$2 + 116 >> 2]);
   HEAP32[$2 + 20 >> 2] = 1;
   HEAP32[$2 + 16 >> 2] = $3;
   HEAP32[$2 + 12 >> 2] = 135846;
   HEAP32[$2 + 8 >> 2] = 135830;
   HEAP32[$2 + 4 >> 2] = 50;
   HEAP32[$2 >> 2] = 135742;
   FUNCTION_TABLE[$0]($1, 135716, $2);
   HEAP32[$2 + 124 >> 2] = 1;
   break label$2;
  }
  if ((tflite__NumOutputs_28TfLiteNode_20const__29(HEAP32[$2 + 116 >> 2]) | 0) != 1) {
   $0 = HEAP32[HEAP32[$2 + 120 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 120 >> 2];
   $3 = tflite__NumOutputs_28TfLiteNode_20const__29(HEAP32[$2 + 116 >> 2]);
   HEAP32[$2 + 52 >> 2] = 1;
   HEAP32[$2 + 48 >> 2] = $3;
   HEAP32[$2 + 44 >> 2] = 135846;
   HEAP32[$2 + 40 >> 2] = 135848;
   HEAP32[$2 + 36 >> 2] = 51;
   HEAP32[$2 + 32 >> 2] = 135742;
   FUNCTION_TABLE[$0]($1, 135716, $2 + 32 | 0);
   HEAP32[$2 + 124 >> 2] = 1;
   break label$2;
  }
  HEAP32[$2 + 108 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 120 >> 2], HEAP32[$2 + 116 >> 2], 0);
  HEAP32[$2 + 104 >> 2] = tflite__GetOutput_28TfLiteContext__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 120 >> 2], HEAP32[$2 + 116 >> 2]);
  if (!(HEAP32[HEAP32[$2 + 108 >> 2] + 28 >> 2] == 3 | HEAP32[HEAP32[$2 + 108 >> 2] + 28 >> 2] == 9 | HEAP32[HEAP32[$2 + 108 >> 2] + 28 >> 2] == 7)) {
   $0 = HEAP32[HEAP32[$2 + 120 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 120 >> 2];
   HEAP32[$2 + 88 >> 2] = 135888;
   HEAP32[$2 + 84 >> 2] = 59;
   HEAP32[$2 + 80 >> 2] = 135742;
   FUNCTION_TABLE[$0]($1, 135865, $2 + 80 | 0);
   HEAP32[$2 + 124 >> 2] = 1;
   break label$2;
  }
  if (!(HEAP32[HEAP32[$2 + 104 >> 2] + 28 >> 2] == 1 | HEAP32[HEAP32[$2 + 104 >> 2] + 28 >> 2] == 2)) {
   $0 = HEAP32[HEAP32[$2 + 120 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 120 >> 2];
   HEAP32[$2 + 72 >> 2] = 135977;
   HEAP32[$2 + 68 >> 2] = 61;
   HEAP32[$2 + 64 >> 2] = 135742;
   FUNCTION_TABLE[$0]($1, 135865, $2 - -64 | 0);
   HEAP32[$2 + 124 >> 2] = 1;
   break label$2;
  }
  if (HEAP32[HEAP32[$2 + 104 >> 2] + 28 >> 2] == 2) {
   HEAPF64[$2 + 96 >> 3] = +HEAPF32[HEAP32[$2 + 108 >> 2] + 8 >> 2] / +HEAPF32[HEAP32[$2 + 104 >> 2] + 8 >> 2];
   tflite__QuantizeMultiplier_28double_2c_20int__2c_20int__29(HEAPF64[$2 + 96 >> 3], HEAP32[$2 + 112 >> 2] + 16 | 0, HEAP32[$2 + 112 >> 2] + 20 | 0);
  }
  HEAP32[HEAP32[$2 + 112 >> 2] + 8 >> 2] = HEAP32[HEAP32[$2 + 108 >> 2] + 12 >> 2];
  HEAPF64[HEAP32[$2 + 112 >> 2] >> 3] = HEAPF32[HEAP32[$2 + 108 >> 2] + 8 >> 2];
  HEAP32[HEAP32[$2 + 112 >> 2] + 24 >> 2] = HEAP32[HEAP32[$2 + 104 >> 2] + 12 >> 2];
  HEAP32[$2 + 124 >> 2] = 0;
 }
 global$0 = $2 + 128 | 0;
 return HEAP32[$2 + 124 >> 2];
}
function jslPrintTokenLineMarker($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 144 | 0;
 global$0 = $4;
 HEAP32[$4 + 140 >> 2] = $0;
 HEAP32[$4 + 136 >> 2] = $1;
 HEAP32[$4 + 132 >> 2] = $2;
 HEAP32[$4 + 128 >> 2] = $3;
 HEAP32[$4 + 124 >> 2] = 1;
 HEAP32[$4 + 120 >> 2] = 1;
 jsvGetLineAndCol(HEAP32[HEAP32[35539] + 84 >> 2], HEAP32[$4 + 132 >> 2], $4 + 124 | 0, $4 + 120 | 0);
 HEAP32[$4 + 116 >> 2] = jsvGetIndexFromLineAndCol(HEAP32[HEAP32[35539] + 84 >> 2], HEAP32[$4 + 124 >> 2], 1);
 HEAP32[$4 + 112 >> 2] = jsvGetCharsOnLine(HEAP32[HEAP32[35539] + 84 >> 2], HEAP32[$4 + 124 >> 2]);
 HEAP32[$4 + 108 >> 2] = 0;
 if (HEAP32[$4 + 128 >> 2]) {
  FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]](HEAP32[$4 + 128 >> 2], HEAP32[$4 + 136 >> 2]);
  HEAP32[$4 + 108 >> 2] = strlen(HEAP32[$4 + 128 >> 2]);
 }
 if (!(HEAPU32[$4 + 112 >> 2] <= 60 | HEAP32[$4 + 132 >> 2] - HEAP32[$4 + 116 >> 2] >>> 0 <= 30)) {
  cbprintf(HEAP32[$4 + 140 >> 2], HEAP32[$4 + 136 >> 2], 77958, 0);
  HEAP32[$4 + 104 >> 2] = (HEAP32[$4 + 132 >> 2] - 30 | 0) - HEAP32[$4 + 116 >> 2];
  HEAP32[$4 + 116 >> 2] = HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 104 >> 2] + 3 | 0);
  label$3 : {
   if (HEAPU32[$4 + 104 >> 2] <= HEAPU32[$4 + 120 >> 2]) {
    HEAP32[$4 + 120 >> 2] = HEAP32[$4 + 120 >> 2] - HEAP32[$4 + 104 >> 2];
    break label$3;
   }
   HEAP32[$4 + 120 >> 2] = 0;
  }
  HEAP32[$4 + 112 >> 2] = HEAP32[$4 + 112 >> 2] - HEAP32[$4 + 104 >> 2];
 }
 HEAP32[$4 + 100 >> 2] = 0;
 jsvStringIteratorNew($4 - -64 | 0, HEAP32[HEAP32[35539] + 84 >> 2], HEAP32[$4 + 116 >> 2]);
 HEAP8[$4 + 63 | 0] = 0;
 while (1) {
  label$6 : {
   $1 = !(jsvStringIteratorHasChar($4 - -64 | 0) & 1);
   $0 = 0;
   label$7 : {
    if ($1) {
     break label$7;
    }
    $0 = 0;
    if (HEAP32[$4 + 100 >> 2] >= 60) {
     break label$7;
    }
    $0 = HEAPU8[$4 + 63 | 0] != 255;
   }
   if (!$0) {
    break label$6;
   }
   HEAP8[$4 + 62 | 0] = jsvStringIteratorGetCharAndNext($4 - -64 | 0);
   if (HEAPU8[$4 + 62 | 0] == 10) {
    break label$6;
   }
   if (jslNeedSpaceBetween(HEAPU8[$4 + 63 | 0], HEAPU8[$4 + 62 | 0]) & 1) {
    HEAP32[$4 + 120 >> 2] = HEAP32[$4 + 120 >> 2] + 1;
    FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]](77918, HEAP32[$4 + 136 >> 2]);
   }
   $0 = $4 + 16 | 0;
   jslFunctionCharAsString(HEAPU8[$4 + 62 | 0], $0);
   HEAP32[$4 + 12 >> 2] = strlen($0);
   if (HEAP32[$4 + 12 >> 2]) {
    HEAP32[$4 + 120 >> 2] = HEAP32[$4 + 120 >> 2] + (HEAP32[$4 + 12 >> 2] - 1 | 0);
   }
   FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($4 + 16 | 0, HEAP32[$4 + 136 >> 2]);
   HEAP32[$4 + 100 >> 2] = HEAP32[$4 + 100 >> 2] + 1;
   HEAP8[$4 + 63 | 0] = HEAPU8[$4 + 62 | 0];
   continue;
  }
  break;
 }
 jsvStringIteratorFree($4 - -64 | 0);
 if (HEAPU32[$4 + 112 >> 2] > 60) {
  FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]](77958, HEAP32[$4 + 136 >> 2]);
 }
 FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]](77962, HEAP32[$4 + 136 >> 2]);
 HEAP32[$4 + 120 >> 2] = HEAP32[$4 + 108 >> 2] + HEAP32[$4 + 120 >> 2];
 while (1) {
  $0 = HEAP32[$4 + 120 >> 2];
  HEAP32[$4 + 120 >> 2] = $0 + -1;
  if ($0 >>> 0 > 1) {
   FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]](77918, HEAP32[$4 + 136 >> 2]);
   continue;
  }
  break;
 }
 FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]](77964, HEAP32[$4 + 136 >> 2]);
 global$0 = $4 + 144 | 0;
}
function graphicsFillEllipse($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0;
 $5 = global$0 + -64 | 0;
 global$0 = $5;
 $6 = $5 + 48 | 0;
 $7 = $5 + 44 | 0;
 HEAP32[$5 + 60 >> 2] = $0;
 HEAP32[$5 + 56 >> 2] = $1;
 HEAP32[$5 + 52 >> 2] = $2;
 HEAP32[$5 + 48 >> 2] = $3;
 HEAP32[$5 + 44 >> 2] = $4;
 graphicsToDeviceCoordinates(HEAP32[$5 + 60 >> 2], $5 + 56 | 0, $5 + 52 | 0);
 graphicsToDeviceCoordinates(HEAP32[$5 + 60 >> 2], $6, $7);
 HEAP32[$5 + 40 >> 2] = (HEAP32[$5 + 56 >> 2] + HEAP32[$5 + 48 >> 2] | 0) / 2;
 HEAP32[$5 + 36 >> 2] = (HEAP32[$5 + 52 >> 2] + HEAP32[$5 + 44 >> 2] | 0) / 2;
 HEAP32[$5 + 32 >> 2] = (HEAP32[$5 + 48 >> 2] - HEAP32[$5 + 56 >> 2] | 0) / 2;
 HEAP32[$5 + 28 >> 2] = (HEAP32[$5 + 44 >> 2] - HEAP32[$5 + 52 >> 2] | 0) / 2;
 HEAP32[$5 + 24 >> 2] = 0;
 HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 28 >> 2];
 HEAP32[$5 + 16 >> 2] = Math_imul(HEAP32[$5 + 32 >> 2], HEAP32[$5 + 32 >> 2]);
 HEAP32[$5 + 12 >> 2] = Math_imul(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 28 >> 2]);
 HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 12 >> 2] - Math_imul(HEAP32[$5 + 16 >> 2], (HEAP32[$5 + 28 >> 2] << 1) - 1 | 0);
 HEAP8[$5 + 3 | 0] = 0;
 while (1) {
  HEAP8[$5 + 3 | 0] = 0;
  HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 8 >> 2] << 1;
  if (HEAP32[$5 + 4 >> 2] < (Math_imul(HEAP32[$5 + 12 >> 2], (HEAP32[$5 + 24 >> 2] << 1) + 1 | 0) | 0)) {
   HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 24 >> 2] + 1;
   HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 8 >> 2] + Math_imul(HEAP32[$5 + 12 >> 2], (HEAP32[$5 + 24 >> 2] << 1) + 1 | 0);
   HEAP8[$5 + 3 | 0] = 1;
  }
  if (HEAP32[$5 + 4 >> 2] > (Math_imul(HEAP32[$5 + 16 >> 2], 0 - ((HEAP32[$5 + 20 >> 2] << 1) - 1 | 0) | 0) | 0)) {
   $0 = HEAP32[$5 + 60 >> 2];
   graphicsFillRectDevice(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 40 >> 2] + HEAP32[$5 + 24 >> 2] | 0, HEAP32[$5 + 36 >> 2] + HEAP32[$5 + 20 >> 2] | 0, HEAP32[$5 + 40 >> 2] - HEAP32[$5 + 24 >> 2] | 0, HEAP32[$5 + 36 >> 2] + HEAP32[$5 + 20 >> 2] | 0, HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
   $0 = HEAP32[$5 + 60 >> 2];
   graphicsFillRectDevice(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 40 >> 2] + HEAP32[$5 + 24 >> 2] | 0, HEAP32[$5 + 36 >> 2] - HEAP32[$5 + 20 >> 2] | 0, HEAP32[$5 + 40 >> 2] - HEAP32[$5 + 24 >> 2] | 0, HEAP32[$5 + 36 >> 2] - HEAP32[$5 + 20 >> 2] | 0, HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
   HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 20 >> 2] + -1;
   HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 8 >> 2] - Math_imul(HEAP32[$5 + 16 >> 2], (HEAP32[$5 + 20 >> 2] << 1) - 1 | 0);
   HEAP8[$5 + 3 | 0] = 1;
  }
  if (HEAP8[$5 + 3 | 0] & 1 ? HEAP32[$5 + 20 >> 2] >= 0 : 0) {
   continue;
  }
  break;
 }
 while (1) {
  label$7 : {
   $0 = HEAP32[$5 + 24 >> 2];
   HEAP32[$5 + 24 >> 2] = $0 + 1;
   if (($0 | 0) >= HEAP32[$5 + 32 >> 2]) {
    break label$7;
   }
   $0 = HEAP32[$5 + 60 >> 2];
   graphicsFillRectDevice(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 40 >> 2] + HEAP32[$5 + 24 >> 2] | 0, HEAP32[$5 + 36 >> 2], HEAP32[$5 + 40 >> 2] - HEAP32[$5 + 24 >> 2] | 0, HEAP32[$5 + 36 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
   continue;
  }
  break;
 }
 global$0 = $5 - -64 | 0;
}
function graphicsDrawLine($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0, $6 = 0, $7 = 0;
 $5 = global$0 + -64 | 0;
 global$0 = $5;
 $6 = $5 + 48 | 0;
 $7 = $5 + 44 | 0;
 HEAP32[$5 + 60 >> 2] = $0;
 HEAP32[$5 + 56 >> 2] = $1;
 HEAP32[$5 + 52 >> 2] = $2;
 HEAP32[$5 + 48 >> 2] = $3;
 HEAP32[$5 + 44 >> 2] = $4;
 graphicsToDeviceCoordinates(HEAP32[$5 + 60 >> 2], $5 + 56 | 0, $5 + 52 | 0);
 graphicsToDeviceCoordinates(HEAP32[$5 + 60 >> 2], $6, $7);
 HEAP32[$5 + 40 >> 2] = HEAP32[$5 + 48 >> 2] - HEAP32[$5 + 56 >> 2];
 HEAP32[$5 + 36 >> 2] = HEAP32[$5 + 44 >> 2] - HEAP32[$5 + 52 >> 2];
 label$1 : {
  if (HEAP32[$5 + 40 >> 2] < 0) {
   HEAP32[$5 + 40 >> 2] = 0 - HEAP32[$5 + 40 >> 2];
   break label$1;
  }
  if (!HEAP32[$5 + 40 >> 2]) {
   HEAP32[$5 + 40 >> 2] = 1;
  }
 }
 label$4 : {
  if (HEAP32[$5 + 36 >> 2] < 0) {
   HEAP32[$5 + 36 >> 2] = 0 - HEAP32[$5 + 36 >> 2];
   break label$4;
  }
  if (!HEAP32[$5 + 36 >> 2]) {
   HEAP32[$5 + 36 >> 2] = 1;
  }
 }
 label$7 : {
  if (HEAP32[$5 + 40 >> 2] > HEAP32[$5 + 36 >> 2]) {
   if (HEAP32[$5 + 56 >> 2] > HEAP32[$5 + 48 >> 2]) {
    HEAP32[$5 + 32 >> 2] = HEAP32[$5 + 56 >> 2];
    HEAP32[$5 + 56 >> 2] = HEAP32[$5 + 48 >> 2];
    HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 32 >> 2];
    HEAP32[$5 + 32 >> 2] = HEAP32[$5 + 52 >> 2];
    HEAP32[$5 + 52 >> 2] = HEAP32[$5 + 44 >> 2];
    HEAP32[$5 + 44 >> 2] = HEAP32[$5 + 32 >> 2];
   }
   HEAP32[$5 + 28 >> 2] = (HEAP32[$5 + 52 >> 2] << 8) + 128;
   HEAP32[$5 + 24 >> 2] = (HEAP32[$5 + 44 >> 2] - HEAP32[$5 + 52 >> 2] << 8) / HEAP32[$5 + 40 >> 2];
   HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 56 >> 2];
   while (1) {
    if (HEAP32[$5 + 20 >> 2] <= HEAP32[$5 + 48 >> 2]) {
     $0 = HEAP32[$5 + 60 >> 2];
     graphicsSetPixelDevice(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 20 >> 2], HEAP32[$5 + 28 >> 2] >> 8, HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
     HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 24 >> 2] + HEAP32[$5 + 28 >> 2];
     HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 20 >> 2] + 1;
     continue;
    }
    break;
   }
   break label$7;
  }
  if (HEAP32[$5 + 52 >> 2] > HEAP32[$5 + 44 >> 2]) {
   HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 56 >> 2];
   HEAP32[$5 + 56 >> 2] = HEAP32[$5 + 48 >> 2];
   HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 16 >> 2];
   HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 52 >> 2];
   HEAP32[$5 + 52 >> 2] = HEAP32[$5 + 44 >> 2];
   HEAP32[$5 + 44 >> 2] = HEAP32[$5 + 16 >> 2];
  }
  HEAP32[$5 + 12 >> 2] = (HEAP32[$5 + 56 >> 2] << 8) + 128;
  HEAP32[$5 + 8 >> 2] = (HEAP32[$5 + 48 >> 2] - HEAP32[$5 + 56 >> 2] << 8) / HEAP32[$5 + 36 >> 2];
  HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 52 >> 2];
  while (1) {
   if (HEAP32[$5 + 4 >> 2] <= HEAP32[$5 + 44 >> 2]) {
    $0 = HEAP32[$5 + 60 >> 2];
    graphicsSetPixelDevice(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 12 >> 2] >> 8, HEAP32[$5 + 4 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
    HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 8 >> 2] + HEAP32[$5 + 12 >> 2];
    HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 4 >> 2] + 1;
    continue;
   }
   break;
  }
 }
 global$0 = $5 - -64 | 0;
}
function jsvFreePtr($0) {
 var $1 = 0;
 $1 = global$0 - 48 | 0;
 global$0 = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 if (!(jsvIsNameWithValue(HEAP32[$1 + 44 >> 2]) & 1)) {
  if (jsvHasSingleChild(HEAP32[$1 + 44 >> 2]) & 1) {
   if (jsvGetFirstChild(HEAP32[$1 + 44 >> 2]) & 65535) {
    HEAP32[$1 + 40 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$1 + 44 >> 2]) & 65535);
    jsvUnRef(HEAP32[$1 + 40 >> 2]);
    jsvUnLock(HEAP32[$1 + 40 >> 2]);
   }
  }
 }
 if (jsvHasCharacterData(HEAP32[$1 + 44 >> 2]) & 1) {
  HEAP16[$1 + 38 >> 1] = jsvGetLastChild(HEAP32[$1 + 44 >> 2]);
  while (1) {
   if (HEAPU16[$1 + 38 >> 1]) {
    HEAP32[$1 + 32 >> 2] = jsvGetAddressOf(HEAPU16[$1 + 38 >> 1]);
    HEAP16[$1 + 38 >> 1] = jsvGetLastChild(HEAP32[$1 + 32 >> 2]);
    jsvFreePtrInternal(HEAP32[$1 + 32 >> 2]);
    continue;
   }
   break;
  }
  label$7 : {
   if (jsvIsFlatString(HEAP32[$1 + 44 >> 2]) & 1) {
    HEAP32[$1 + 28 >> 2] = jsvGetFlatStringBlocks(HEAP32[$1 + 44 >> 2]);
    HEAP16[$1 + 26 >> 1] = (jsvGetRef(HEAP32[$1 + 44 >> 2]) & 65535) + HEAP32[$1 + 28 >> 2];
    HEAP16[$1 + 24 >> 1] = HEAPU16[71084];
    HEAP16[$1 + 22 >> 1] = 0;
    while (1) {
     if (HEAPU16[$1 + 24 >> 1] ? HEAPU16[$1 + 24 >> 1] < HEAPU16[$1 + 26 >> 1] : 0) {
      HEAP16[$1 + 22 >> 1] = HEAPU16[$1 + 24 >> 1];
      HEAP16[$1 + 24 >> 1] = jsvGetNextSibling(jsvGetAddressOf(HEAPU16[$1 + 24 >> 1]));
      continue;
     }
     break;
    }
    while (1) {
     label$14 : {
      $0 = HEAP32[$1 + 28 >> 2];
      HEAP32[$1 + 28 >> 2] = $0 + -1;
      if (!$0) {
       break label$14;
      }
      $0 = HEAPU16[$1 + 26 >> 1];
      HEAP16[$1 + 26 >> 1] = $0 + -1;
      HEAP32[$1 + 16 >> 2] = jsvGetAddressOf($0);
      $0 = HEAP32[$1 + 16 >> 2];
      HEAP8[$0 + 13 | 0] = 0;
      HEAP8[$0 + 14 | 0] = 0;
      jsvSetNextSibling(HEAP32[$1 + 16 >> 2], HEAPU16[$1 + 24 >> 1]);
      HEAP16[$1 + 24 >> 1] = jsvGetRef(HEAP32[$1 + 16 >> 2]);
      continue;
     }
     break;
    }
    label$15 : {
     if (HEAPU16[$1 + 22 >> 1]) {
      jsvSetNextSibling(jsvGetAddressOf(HEAPU16[$1 + 22 >> 1]), HEAPU16[$1 + 24 >> 1]);
      break label$15;
     }
     HEAP16[71084] = HEAPU16[$1 + 24 >> 1];
    }
    HEAP8[142161] = 1;
    break label$7;
   }
   label$17 : {
    if (!(jsvIsBasicString(HEAP32[$1 + 44 >> 2]) & 1)) {
     break label$17;
    }
   }
  }
 }
 label$18 : {
  if (jsvHasChildren(HEAP32[$1 + 44 >> 2]) & 1) {
   HEAP16[$1 + 14 >> 1] = jsvGetFirstChild(HEAP32[$1 + 44 >> 2]);
   while (1) {
    if (HEAPU16[$1 + 14 >> 1]) {
     HEAP32[$1 + 8 >> 2] = jsvLock(HEAPU16[$1 + 14 >> 1]);
     HEAP16[$1 + 14 >> 1] = jsvGetNextSibling(HEAP32[$1 + 8 >> 2]);
     jsvSetPrevSibling(HEAP32[$1 + 8 >> 2], 0);
     jsvSetNextSibling(HEAP32[$1 + 8 >> 2], 0);
     jsvUnRef(HEAP32[$1 + 8 >> 2]);
     jsvUnLock(HEAP32[$1 + 8 >> 2]);
     continue;
    }
    break;
   }
   break label$18;
  }
  if (jsvIsName(HEAP32[$1 + 44 >> 2]) & 1) {
   if (jsvGetNextSibling(HEAP32[$1 + 44 >> 2]) & 65535) {
    jsvUnRefRef(jsvGetNextSibling(HEAP32[$1 + 44 >> 2]) & 65535);
    jsvUnRefRef(jsvGetPrevSibling(HEAP32[$1 + 44 >> 2]) & 65535);
   }
  }
 }
 jsvFreePtrInternal(HEAP32[$1 + 44 >> 2]);
 global$0 = $1 + 48 | 0;
}
function jsvReadConfigObject($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP32[$3 + 40 >> 2] = $0;
 HEAP32[$3 + 36 >> 2] = $1;
 HEAP32[$3 + 32 >> 2] = $2;
 label$1 : {
  if (jsvIsUndefined(HEAP32[$3 + 40 >> 2]) & 1) {
   HEAP8[$3 + 47 | 0] = 1;
   break label$1;
  }
  if (!(jsvIsObject(HEAP32[$3 + 40 >> 2]) & 1)) {
   jsExceptionHere(1, 79180, 0);
   HEAP8[$3 + 47 | 0] = 0;
   break label$1;
  }
  jsvObjectIteratorNew($3 + 24 | 0, HEAP32[$3 + 40 >> 2]);
  HEAP8[$3 + 23 | 0] = 1;
  while (1) {
   if (HEAP8[$3 + 23 | 0] & 1) {
    $0 = jsvObjectIteratorHasValue($3 + 24 | 0);
   } else {
    $0 = 0;
   }
   if ($0 & 1) {
    HEAP32[$3 + 16 >> 2] = jsvObjectIteratorGetKey($3 + 24 | 0);
    HEAP8[$3 + 15 | 0] = 0;
    HEAP32[$3 + 8 >> 2] = 0;
    while (1) {
     if (HEAP32[$3 + 8 >> 2] < HEAP32[$3 + 32 >> 2]) {
      if (jsvIsStringEqual(HEAP32[$3 + 16 >> 2], HEAP32[HEAP32[$3 + 36 >> 2] + Math_imul(HEAP32[$3 + 8 >> 2], 12) >> 2]) & 1) {
       HEAP8[$3 + 15 | 0] = 1;
       if (HEAP32[(HEAP32[$3 + 36 >> 2] + Math_imul(HEAP32[$3 + 8 >> 2], 12) | 0) + 8 >> 2]) {
        HEAP32[$3 + 4 >> 2] = jsvObjectIteratorGetValue($3 + 24 | 0);
        $0 = HEAPU16[(HEAP32[$3 + 36 >> 2] + Math_imul(HEAP32[$3 + 8 >> 2], 12) | 0) + 4 >> 1];
        label$12 : {
         if ($0 >>> 0 > 27) {
          break label$12;
         }
         label$13 : {
          switch ($0 + -3 | 0) {
          case 0:
          case 2:
          case 4:
          case 24:
           $0 = jsvLockAgain(HEAP32[$3 + 4 >> 2]);
           HEAP32[HEAP32[(HEAP32[$3 + 36 >> 2] + Math_imul(HEAP32[$3 + 8 >> 2], 12) | 0) + 8 >> 2] >> 2] = $0;
           break label$12;
          case 9:
           $0 = jshGetPinFromVar(HEAP32[$3 + 4 >> 2]);
           HEAP8[HEAP32[(HEAP32[$3 + 36 >> 2] + Math_imul(HEAP32[$3 + 8 >> 2], 12) | 0) + 8 >> 2]] = $0;
           break label$12;
          case 8:
           $0 = jsvGetBool(HEAP32[$3 + 4 >> 2]);
           HEAP8[HEAP32[(HEAP32[$3 + 36 >> 2] + Math_imul(HEAP32[$3 + 8 >> 2], 12) | 0) + 8 >> 2]] = $0 & 1;
           break label$12;
          case 6:
           $0 = jsvGetInteger(HEAP32[$3 + 4 >> 2]);
           HEAP32[HEAP32[(HEAP32[$3 + 36 >> 2] + Math_imul(HEAP32[$3 + 8 >> 2], 12) | 0) + 8 >> 2] >> 2] = $0;
           break label$12;
          case 7:
           break label$13;
          default:
           break label$12;
          }
         }
         $4 = jsvGetFloat(HEAP32[$3 + 4 >> 2]);
         HEAPF64[HEAP32[(HEAP32[$3 + 36 >> 2] + Math_imul(HEAP32[$3 + 8 >> 2], 12) | 0) + 8 >> 2] >> 3] = $4;
        }
        jsvUnLock(HEAP32[$3 + 4 >> 2]);
       }
      }
      HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 8 >> 2] + 1;
      continue;
     }
     break;
    }
    if (!(HEAP8[$3 + 15 | 0] & 1)) {
     HEAP32[$3 >> 2] = HEAP32[$3 + 16 >> 2];
     jsExceptionHere(1, 79214, $3);
     HEAP8[$3 + 23 | 0] = 0;
    }
    $0 = $3 + 24 | 0;
    jsvUnLock(HEAP32[$3 + 16 >> 2]);
    jsvObjectIteratorNext($0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree($3 + 24 | 0);
  HEAP8[$3 + 47 | 0] = HEAP8[$3 + 23 | 0] & 1;
 }
 global$0 = $3 + 48 | 0;
 return HEAP8[$3 + 47 | 0] & 1;
}
function jsspiSoftwareFunc($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 48 | 0;
 global$0 = $4;
 HEAP32[$4 + 44 >> 2] = $0;
 HEAP32[$4 + 40 >> 2] = $1;
 HEAP32[$4 + 36 >> 2] = $2;
 HEAP32[$4 + 32 >> 2] = $3;
 HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 32 >> 2];
 HEAP8[$4 + 27 | 0] = (HEAP8[HEAP32[$4 + 28 >> 2] + 8 | 0] & 1) != 0;
 HEAP8[$4 + 26 | 0] = (HEAPU8[HEAP32[$4 + 28 >> 2] + 8 | 0] & 2) != 0;
 HEAP32[$4 + 20 >> 2] = HEAP8[HEAP32[$4 + 28 >> 2] + 9 | 0] & 1 ? -1 : 1;
 $0 = $4;
 if (HEAP8[HEAP32[$4 + 28 >> 2] + 9 | 0] & 1) {
  $1 = -1;
 } else {
  $1 = HEAP32[$4 + 28 >> 2];
  $1 = HEAPU8[$1 + 10 | 0] | HEAPU8[$1 + 11 | 0] << 8 | (HEAPU8[$1 + 12 | 0] << 16 | HEAPU8[$1 + 13 | 0] << 24);
 }
 HEAP32[$0 + 16 >> 2] = $1;
 HEAP32[$4 + 12 >> 2] = 0;
 while (1) {
  if (HEAPU32[$4 + 12 >> 2] < HEAPU32[$4 + 36 >> 2]) {
   HEAP32[$4 + 8 >> 2] = HEAPU8[HEAP32[$4 + 44 >> 2] + HEAP32[$4 + 12 >> 2] | 0];
   HEAP32[$4 + 4 >> 2] = 0;
   $0 = $4;
   label$4 : {
    if (HEAP8[HEAP32[$4 + 28 >> 2] + 9 | 0] & 1) {
     $1 = HEAP32[$4 + 28 >> 2];
     $1 = (HEAPU8[$1 + 10 | 0] | HEAPU8[$1 + 11 | 0] << 8 | (HEAPU8[$1 + 12 | 0] << 16 | HEAPU8[$1 + 13 | 0] << 24)) - 1 | 0;
     break label$4;
    }
    $1 = 0;
   }
   HEAP32[$0 >> 2] = $1;
   while (1) {
    if (HEAP32[$4 >> 2] != HEAP32[$4 + 16 >> 2]) {
     label$8 : {
      if (!(HEAP8[$4 + 27 | 0] & 1)) {
       if (HEAPU8[HEAP32[$4 + 28 >> 2] + 7 | 0] != 255) {
        jshPinSetValue(HEAPU8[HEAP32[$4 + 28 >> 2] + 7 | 0], (HEAP32[$4 + 8 >> 2] >> HEAP32[$4 >> 2] & 1) != 0);
       }
       if (HEAPU8[HEAP32[$4 + 28 >> 2] + 5 | 0] != 255) {
        jshPinSetValue(HEAPU8[HEAP32[$4 + 28 >> 2] + 5 | 0], (HEAPU8[$4 + 26 | 0] ^ -1) & 1);
       }
       if (HEAPU8[HEAP32[$4 + 28 >> 2] + 6 | 0] != 255) {
        HEAP32[$4 + 4 >> 2] = HEAP32[$4 + 4 >> 2] << 1 | (jshPinGetValue(HEAPU8[HEAP32[$4 + 28 >> 2] + 6 | 0]) & 1 ? 1 : 0);
       }
       if (HEAPU8[HEAP32[$4 + 28 >> 2] + 5 | 0] != 255) {
        jshPinSetValue(HEAPU8[HEAP32[$4 + 28 >> 2] + 5 | 0], HEAP8[$4 + 26 | 0] & 1);
       }
       break label$8;
      }
      if (HEAPU8[HEAP32[$4 + 28 >> 2] + 5 | 0] != 255) {
       jshPinSetValue(HEAPU8[HEAP32[$4 + 28 >> 2] + 5 | 0], (HEAPU8[$4 + 26 | 0] ^ -1) & 1);
      }
      if (HEAPU8[HEAP32[$4 + 28 >> 2] + 7 | 0] != 255) {
       jshPinSetValue(HEAPU8[HEAP32[$4 + 28 >> 2] + 7 | 0], (HEAP32[$4 + 8 >> 2] >> HEAP32[$4 >> 2] & 1) != 0);
      }
      if (HEAPU8[HEAP32[$4 + 28 >> 2] + 5 | 0] != 255) {
       jshPinSetValue(HEAPU8[HEAP32[$4 + 28 >> 2] + 5 | 0], HEAP8[$4 + 26 | 0] & 1);
      }
      if (HEAPU8[HEAP32[$4 + 28 >> 2] + 6 | 0] != 255) {
       HEAP32[$4 + 4 >> 2] = HEAP32[$4 + 4 >> 2] << 1 | (jshPinGetValue(HEAPU8[HEAP32[$4 + 28 >> 2] + 6 | 0]) & 1 ? 1 : 0);
      }
     }
     HEAP32[$4 >> 2] = HEAP32[$4 + 20 >> 2] + HEAP32[$4 >> 2];
     continue;
    }
    break;
   }
   if (HEAP32[$4 + 40 >> 2]) {
    HEAP8[HEAP32[$4 + 40 >> 2] + HEAP32[$4 + 12 >> 2] | 0] = HEAP32[$4 + 4 >> 2];
   }
   HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $4 + 48 | 0;
}
function jswrap_arraybufferview_set($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $3 = global$0 - 176 | 0;
 global$0 = $3;
 HEAP32[$3 + 172 >> 2] = $0;
 HEAP32[$3 + 168 >> 2] = $1;
 HEAP32[$3 + 164 >> 2] = $2;
 label$1 : {
  label$2 : {
   if (jsvIsString(HEAP32[$3 + 168 >> 2]) & 1) {
    break label$2;
   }
   if (jsvIsArray(HEAP32[$3 + 168 >> 2]) & 1) {
    break label$2;
   }
   if (jsvIsArrayBuffer(HEAP32[$3 + 168 >> 2]) & 1) {
    break label$2;
   }
   HEAP32[$3 >> 2] = HEAP32[$3 + 168 >> 2];
   jsExceptionHere(1, 119217, $3);
   break label$1;
  }
  label$3 : {
   if (!(jsvIsArrayBuffer(HEAP32[$3 + 172 >> 2]) & 1)) {
    break label$3;
   }
   if (!(jsvIsArrayBuffer(HEAP32[$3 + 168 >> 2]) & 1)) {
    break label$3;
   }
   HEAP32[$3 + 160 >> 2] = jsvGetArrayBufferBackingString(HEAP32[$3 + 172 >> 2], 0);
   HEAP32[$3 + 156 >> 2] = jsvGetArrayBufferBackingString(HEAP32[$3 + 168 >> 2], 0);
   $0 = $3;
   if (HEAP32[$3 + 160 >> 2] == HEAP32[$3 + 156 >> 2]) {
    $1 = HEAP32[$3 + 168 >> 2];
    $2 = HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8;
    $1 = HEAP32[$3 + 172 >> 2];
    $4 = HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8;
    $1 = HEAP32[$3 + 172 >> 2];
    $1 = ($2 | 0) <= ($4 + Math_imul(HEAP32[$3 + 164 >> 2], (HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8) & 15) | 0);
   } else {
    $1 = 0;
   }
   HEAP8[$0 + 155 | 0] = $1;
   jsvUnLock2(HEAP32[$3 + 160 >> 2], HEAP32[$3 + 156 >> 2]);
   if (HEAP8[$3 + 155 | 0] & 1) {
    HEAP32[$3 + 148 >> 2] = jsvGetArrayBufferLength(HEAP32[$3 + 168 >> 2]);
    HEAP32[$3 + 144 >> 2] = HEAP32[$3 + 148 >> 2] - 1;
    while (1) {
     if (HEAP32[$3 + 144 >> 2] >= 0) {
      HEAP32[$3 + 140 >> 2] = jsvArrayBufferGet(HEAP32[$3 + 168 >> 2], HEAP32[$3 + 144 >> 2]);
      jsvArrayBufferSet(HEAP32[$3 + 172 >> 2], HEAP32[$3 + 164 >> 2] + HEAP32[$3 + 144 >> 2] | 0, HEAP32[$3 + 140 >> 2]);
      jsvUnLock(HEAP32[$3 + 140 >> 2]);
      HEAP32[$3 + 144 >> 2] = HEAP32[$3 + 144 >> 2] + -1;
      continue;
     }
     break;
    }
    break label$1;
   }
  }
  $0 = $3 + 24 | 0;
  jsvIteratorNew($3 + 80 | 0, HEAP32[$3 + 168 >> 2], 1);
  jsvArrayBufferIteratorNew($0, HEAP32[$3 + 172 >> 2], HEAP32[$3 + 164 >> 2]);
  $0 = $3;
  if (HEAPU16[$3 + 60 >> 1] & 32) {
   $1 = jsvIsString(HEAP32[$3 + 168 >> 2]);
  } else {
   $1 = 1;
  }
  HEAP8[$0 + 23 | 0] = $1 & 1;
  while (1) {
   if (jsvIteratorHasElement($3 + 80 | 0) & 1) {
    $0 = jsvArrayBufferIteratorHasElement($3 + 24 | 0);
   } else {
    $0 = 0;
   }
   if ($0 & 1) {
    label$15 : {
     if (HEAP8[$3 + 23 | 0] & 1) {
      jsvArrayBufferIteratorSetIntegerValue($3 + 24 | 0, jsvIteratorGetIntegerValue($3 + 80 | 0));
      break label$15;
     }
     $0 = $3 + 24 | 0;
     HEAP32[$3 + 16 >> 2] = jsvIteratorGetValue($3 + 80 | 0);
     jsvArrayBufferIteratorSetValue($0, HEAP32[$3 + 16 >> 2]);
     jsvUnLock(HEAP32[$3 + 16 >> 2]);
    }
    $0 = $3 + 80 | 0;
    jsvArrayBufferIteratorNext($3 + 24 | 0);
    jsvIteratorNext($0);
    continue;
   }
   break;
  }
  $0 = $3 + 80 | 0;
  jsvArrayBufferIteratorFree($3 + 24 | 0);
  jsvIteratorFree($0);
 }
 global$0 = $3 + 176 | 0;
}
function jsvNewFlatStringOfLength($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 48 | 0;
 global$0 = $1;
 HEAP32[$1 + 40 >> 2] = $0;
 HEAP8[$1 + 39 | 0] = 1;
 HEAP32[$1 + 32 >> 2] = ((HEAP32[$1 + 40 >> 2] + 14 >>> 0) / 15 | 0) + 1;
 HEAP32[$1 + 28 >> 2] = 0;
 label$1 : {
  if (HEAP32[35541]) {
   HEAP8[322179] = HEAPU8[322179] | 32;
   HEAP32[$1 + 44 >> 2] = 0;
   break label$1;
  }
  while (1) {
   HEAP8[$1 + 27 | 0] = 1;
   while (1) {
    if (HEAP8[$1 + 27 | 0] & 1) {
     HEAP8[$1 + 27 | 0] = 0;
     HEAP8[142161] = 0;
     HEAP16[$1 + 24 >> 1] = 0;
     HEAP16[$1 + 22 >> 1] = HEAPU16[71084];
     HEAP16[$1 + 20 >> 1] = HEAPU16[$1 + 22 >> 1];
     HEAP32[$1 + 16 >> 2] = 0;
     while (1) {
      label$7 : {
       if (!((HEAPU16[$1 + 22 >> 1] ? HEAPU8[142161] ^ -1 : 0) & 1)) {
        break label$7;
       }
       HEAP32[$1 + 12 >> 2] = jsvGetAddressOf(HEAPU16[$1 + 22 >> 1]);
       HEAP16[$1 + 10 >> 1] = jsvGetNextSibling(HEAP32[$1 + 12 >> 2]);
       label$10 : {
        if (!(!HEAP32[$1 + 16 >> 2] | HEAPU16[$1 + 10 >> 1] != (HEAPU16[$1 + 22 >> 1] + 1 | 0))) {
         HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 16 >> 2] + 1;
         if (HEAPU32[$1 + 16 >> 2] >= HEAPU32[$1 + 32 >> 2]) {
          HEAP32[$1 + 4 >> 2] = jsvGetAddressOf(HEAPU16[$1 + 10 >> 1]);
          HEAP16[$1 + 2 >> 1] = jsvGetNextSibling(HEAP32[$1 + 4 >> 2]);
          if (!(HEAP8[142161] & 1)) {
           label$14 : {
            if (HEAPU16[$1 + 24 >> 1]) {
             jsvSetNextSibling(jsvGetAddressOf(HEAPU16[$1 + 24 >> 1]), HEAPU16[$1 + 2 >> 1]);
             break label$14;
            }
            HEAP16[71084] = HEAPU16[$1 + 2 >> 1];
           }
           HEAP32[$1 + 28 >> 2] = jsvGetAddressOf(HEAPU16[$1 + 20 >> 1]);
           jsvResetVariable(HEAP32[$1 + 28 >> 2], 38);
           $0 = HEAP32[$1 + 28 >> 2];
           $2 = HEAP32[$1 + 40 >> 2];
           HEAP8[$0 | 0] = $2;
           HEAP8[$0 + 1 | 0] = $2 >>> 8;
           HEAP8[$0 + 2 | 0] = $2 >>> 16;
           HEAP8[$0 + 3 | 0] = $2 >>> 24;
          }
          if (HEAP32[$1 + 28 >> 2]) {
           break label$7;
          }
         }
         break label$10;
        }
        HEAP16[$1 + 24 >> 1] = HEAPU16[$1 + 22 >> 1];
        HEAP16[$1 + 20 >> 1] = HEAPU16[$1 + 10 >> 1];
        label$16 : {
         if (jsvGetAddressOf(HEAPU16[$1 + 20 >> 1] + 1 & 65535) & 3) {
          HEAP32[$1 + 16 >> 2] = 0;
          break label$16;
         }
         HEAP32[$1 + 16 >> 2] = 1;
        }
       }
       HEAP16[$1 + 22 >> 1] = HEAPU16[$1 + 10 >> 1];
       continue;
      }
      break;
     }
     if (HEAP8[142161] & 1) {
      HEAP8[$1 + 27 | 0] = 1;
     }
     continue;
    }
    break;
   }
   if (!(HEAP32[$1 + 28 >> 2] | !(HEAP8[$1 + 39 | 0] & 1))) {
    HEAP8[$1 + 39 | 0] = 0;
    jsvGarbageCollect();
    continue;
   }
   break;
  }
  if (!HEAP32[$1 + 28 >> 2]) {
   HEAP32[$1 + 44 >> 2] = 0;
   break label$1;
  }
  memset(HEAP32[$1 + 28 >> 2] + 15 | 0, 0, Math_imul(HEAP32[$1 + 32 >> 2] - 1 | 0, 15));
  HEAP8[142161] = 1;
  HEAP32[$1 + 44 >> 2] = HEAP32[$1 + 28 >> 2];
 }
 global$0 = $1 + 48 | 0;
 return HEAP32[$1 + 44 >> 2];
}
function jswrap_pipe($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP32[$3 + 36 >> 2] = $2;
 if (!(!HEAP32[$3 + 44 >> 2] | !HEAP32[$3 + 40 >> 2])) {
  HEAP32[$3 + 32 >> 2] = jspNewObject(0, 124356);
  HEAP32[$3 + 28 >> 2] = pipeGetArray(1);
  HEAP32[$3 + 24 >> 2] = jsvNewFromInteger(0);
  if (!(!HEAP32[$3 + 24 >> 2] | (!HEAP32[$3 + 32 >> 2] | !HEAP32[$3 + 28 >> 2]))) {
   HEAP32[$3 + 20 >> 2] = jspGetNamedField(HEAP32[$3 + 44 >> 2], 124361, 0);
   HEAP32[$3 + 16 >> 2] = jspGetNamedField(HEAP32[$3 + 40 >> 2], 124366, 0);
   label$4 : {
    if (jsvIsFunction(HEAP32[$3 + 20 >> 2]) & 1) {
     if (jsvIsFunction(HEAP32[$3 + 16 >> 2]) & 1) {
      HEAP32[$3 + 12 >> 2] = 64;
      HEAP8[$3 + 11 | 0] = 1;
      label$7 : {
       if (jsvIsObject(HEAP32[$3 + 36 >> 2]) & 1) {
        HEAP32[$3 + 4 >> 2] = jsvObjectGetChild(HEAP32[$3 + 36 >> 2], 124372, 0);
        if (HEAP32[$3 + 4 >> 2]) {
         jsvObjectSetChild(HEAP32[$3 + 32 >> 2], 124381, HEAP32[$3 + 4 >> 2]);
         jsvUnLock(HEAP32[$3 + 4 >> 2]);
        }
        HEAP32[$3 + 4 >> 2] = jsvObjectGetChild(HEAP32[$3 + 36 >> 2], 124393, 0);
        if (HEAP32[$3 + 4 >> 2]) {
         HEAP8[$3 + 11 | 0] = jsvGetBoolAndUnLock(HEAP32[$3 + 4 >> 2]) & 1;
        }
        HEAP32[$3 + 4 >> 2] = jsvObjectGetChild(HEAP32[$3 + 36 >> 2], 124397, 0);
        if (HEAP32[$3 + 4 >> 2]) {
         label$12 : {
          label$13 : {
           if (!(jsvIsNumeric(HEAP32[$3 + 4 >> 2]) & 1)) {
            break label$13;
           }
           if ((jsvGetInteger(HEAP32[$3 + 4 >> 2]) | 0) <= 0) {
            break label$13;
           }
           HEAP32[$3 + 12 >> 2] = jsvGetInteger(HEAP32[$3 + 4 >> 2]);
           break label$12;
          }
          jsExceptionHere(3, 124407, 0);
         }
         jsvUnLock(HEAP32[$3 + 4 >> 2]);
        }
        break label$7;
       }
       if (!(jsvIsUndefined(HEAP32[$3 + 36 >> 2]) & 1)) {
        jsExceptionHere(3, 124440, 0);
       }
      }
      jswrap_object_addEventListener(HEAP32[$3 + 44 >> 2], 124482, 566, 32768);
      jswrap_object_addEventListener(HEAP32[$3 + 40 >> 2], 124488, 565, 8);
      jswrap_object_addEventListener(HEAP32[$3 + 40 >> 2], 124482, 564, 32768);
      jsvObjectSetChildAndUnLock(HEAP32[$3 + 32 >> 2], 124397, jsvNewFromInteger(HEAP32[$3 + 12 >> 2]));
      jsvObjectSetChildAndUnLock(HEAP32[$3 + 32 >> 2], 124393, jsvNewFromBool(HEAP8[$3 + 11 | 0] & 1));
      jsvUnLock3(jsvAddNamedChild(HEAP32[$3 + 32 >> 2], HEAP32[$3 + 24 >> 2], 124494), jsvAddNamedChild(HEAP32[$3 + 32 >> 2], HEAP32[$3 + 44 >> 2], 124503), jsvAddNamedChild(HEAP32[$3 + 32 >> 2], HEAP32[$3 + 40 >> 2], 124510));
      jsvArrayPush(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 32 >> 2]);
      break label$4;
     }
     jsExceptionHere(1, 124522, 0);
     break label$4;
    }
    jsExceptionHere(1, 124613, 0);
   }
   jsvUnLock2(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 16 >> 2]);
  }
  jsvUnLock3(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 32 >> 2], HEAP32[$3 + 24 >> 2]);
 }
 global$0 = $3 + 48 | 0;
}
function jswrap_waveform_start($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $5 = global$0 - 112 | 0;
 global$0 = $5;
 HEAP32[$5 + 108 >> 2] = $0;
 HEAP8[$5 + 107 | 0] = $1;
 HEAPF64[$5 + 96 >> 3] = $2;
 HEAP32[$5 + 92 >> 2] = $3;
 HEAP8[$5 + 91 | 0] = $4;
 HEAP8[$5 + 90 | 0] = jsvGetBoolAndUnLock(jsvObjectGetChild(HEAP32[$5 + 108 >> 2], 126056, 0)) & 1;
 label$1 : {
  if (HEAP8[$5 + 90 | 0] & 1) {
   jsExceptionHere(1, 126302, 0);
   break label$1;
  }
  if (!(jshIsPinValid(HEAPU8[$5 + 107 | 0]) & 1)) {
   jsExceptionHere(1, 126330, 0);
   break label$1;
  }
  $0 = __DOUBLE_BITS(HEAPF64[$5 + 96 >> 3]);
  $1 = i64toi32_i32$HIGH_BITS & 2147483647;
  if (!(HEAPF64[$5 + 96 >> 3] < .001 ? 0 : !(($1 | 0) == 2146435072 & $0 >>> 0 >= 0 | $1 >>> 0 > 2146435072))) {
   jsExceptionHere(1, 126342, 0);
   break label$1;
  }
  HEAP32[$5 + 80 >> 2] = jshGetSystemTime();
  HEAP32[$5 + 84 >> 2] = i64toi32_i32$HIGH_BITS;
  HEAP8[$5 + 79 | 0] = 0;
  label$7 : {
   if (jsvIsObject(HEAP32[$5 + 92 >> 2]) & 1) {
    HEAPF64[$5 + 64 >> 3] = jsvGetFloatAndUnLock(jsvObjectGetChild(HEAP32[$5 + 92 >> 2], 126374, 0));
    $0 = __DOUBLE_BITS(HEAPF64[$5 + 64 >> 3]);
    $1 = i64toi32_i32$HIGH_BITS & 2147483647;
    if (!(!(HEAPF64[$5 + 64 >> 3] > 0) | (($1 | 0) == 2146435072 & $0 >>> 0 >= 0 | $1 >>> 0 > 2146435072))) {
     HEAP32[$5 + 80 >> 2] = jshGetTimeFromMilliseconds(HEAPF64[$5 + 64 >> 3] * 1e3);
     HEAP32[$5 + 84 >> 2] = i64toi32_i32$HIGH_BITS;
    }
    HEAP8[$5 + 79 | 0] = jsvGetBoolAndUnLock(jsvObjectGetChild(HEAP32[$5 + 92 >> 2], 126379, 0)) & 1;
    break label$7;
   }
   if (!(jsvIsUndefined(HEAP32[$5 + 92 >> 2]) & 1)) {
    HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 92 >> 2];
    jsExceptionHere(1, 126214, $5 + 16 | 0);
   }
  }
  HEAP8[$5 + 63 | 0] = 0;
  HEAP32[$5 + 56 >> 2] = jswrap_waveform_getBuffer(HEAP32[$5 + 108 >> 2], 0, $5 + 63 | 0);
  HEAP32[$5 + 52 >> 2] = jswrap_waveform_getBuffer(HEAP32[$5 + 108 >> 2], 1, 0);
  label$12 : {
   if (HEAP8[$5 + 63 | 0] & 1) {
    HEAP8[$5 + 51 | 0] = HEAP8[$5 + 91 | 0] & 1 ? 5 : 6;
    break label$12;
   }
   HEAP8[$5 + 51 | 0] = HEAP8[$5 + 91 | 0] & 1 ? 3 : 4;
  }
  $1 = HEAP32[$5 + 80 >> 2];
  $3 = HEAP32[$5 + 84 >> 2];
  $4 = jshGetTimeFromMilliseconds(1e3 / HEAPF64[$5 + 96 >> 3]);
  $6 = i64toi32_i32$HIGH_BITS;
  $7 = HEAPU8[$5 + 107 | 0];
  $8 = HEAP32[$5 + 56 >> 2];
  if (HEAP8[$5 + 79 | 0] & 1) {
   if (HEAP32[$5 + 52 >> 2]) {
    $0 = HEAP32[$5 + 52 >> 2];
   } else {
    $0 = HEAP32[$5 + 56 >> 2];
   }
  } else {
   $0 = 0;
  }
  if (!(jstStartSignal($1, $3, $4, $6, $7, $8, $0, HEAPU8[$5 + 51 | 0]) & 1)) {
   jsWarn(126386);
  }
  jsvUnLock2(HEAP32[$5 + 56 >> 2], HEAP32[$5 + 52 >> 2]);
  jsvObjectSetChildAndUnLock(HEAP32[$5 + 108 >> 2], 126056, jsvNewFromBool(1));
  jsvObjectSetChildAndUnLock(HEAP32[$5 + 108 >> 2], 126413, jsvNewFromFloat(HEAPF64[$5 + 96 >> 3]));
  HEAP32[$5 + 44 >> 2] = jsvObjectGetChild(HEAP32[80546], 126051, 3);
  if (!HEAP32[$5 + 44 >> 2]) {
   break label$1;
  }
  jsvArrayPush(HEAP32[$5 + 44 >> 2], HEAP32[$5 + 108 >> 2]);
  jsvUnLock(HEAP32[$5 + 44 >> 2]);
 }
 global$0 = $5 + 112 | 0;
}
function jsvSetValueOfName($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1 : {
  if (jsvIsNameWithValue(HEAP32[$2 + 24 >> 2]) & 1) {
   label$3 : {
    if (jsvIsString(HEAP32[$2 + 24 >> 2]) & 1) {
     $0 = HEAP32[$2 + 24 >> 2];
     $0 = (HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 65472;
     $1 = jsvGetCharactersInVar(HEAP32[$2 + 24 >> 2]) + 22 | 0;
     $3 = HEAP32[$2 + 24 >> 2];
     $0 = $0 | $1;
     HEAP8[$3 + 13 | 0] = $0;
     HEAP8[$3 + 14 | 0] = $0 >>> 8;
     break label$3;
    }
    $0 = HEAP32[$2 + 24 >> 2];
    $1 = HEAP32[$2 + 24 >> 2];
    $1 = (HEAPU8[$1 + 13 | 0] | HEAPU8[$1 + 14 | 0] << 8) & 65472 | 14;
    HEAP8[$0 + 13 | 0] = $1;
    HEAP8[$0 + 14 | 0] = $1 >>> 8;
   }
   jsvSetFirstChild(HEAP32[$2 + 24 >> 2], 0);
   break label$1;
  }
  if (jsvGetFirstChild(HEAP32[$2 + 24 >> 2]) & 65535) {
   jsvUnRefRef(jsvGetFirstChild(HEAP32[$2 + 24 >> 2]) & 65535);
  }
 }
 label$6 : {
  if (HEAP32[$2 + 20 >> 2]) {
   label$8 : {
    if (jsvIsInt(HEAP32[$2 + 24 >> 2]) & 1) {
     if (!(jsvIsInt(HEAP32[$2 + 20 >> 2]) & 1)) {
      if (!(jsvIsBoolean(HEAP32[$2 + 20 >> 2]) & 1)) {
       break label$8;
      }
     }
     if (jsvIsPin(HEAP32[$2 + 20 >> 2]) & 1) {
      break label$8;
     }
     $0 = HEAP32[$2 + 20 >> 2];
     HEAP32[$2 + 16 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
     if (!(HEAP32[$2 + 16 >> 2] < -32768 | HEAP32[$2 + 16 >> 2] > 32767)) {
      $0 = HEAP32[$2 + 24 >> 2];
      $0 = (HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 65472;
      $1 = jsvIsInt(HEAP32[$2 + 20 >> 2]) & 1 ? 15 : 16;
      $3 = HEAP32[$2 + 24 >> 2];
      $0 = $0 | $1;
      HEAP8[$3 + 13 | 0] = $0;
      HEAP8[$3 + 14 | 0] = $0 >>> 8;
      jsvSetFirstChild(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 16 >> 2] & 65535);
      break label$6;
     }
     break label$8;
    }
    if (jsvIsString(HEAP32[$2 + 24 >> 2]) & 1) {
     label$13 : {
      if (!(jsvIsInt(HEAP32[$2 + 20 >> 2]) & 1)) {
       break label$13;
      }
      if (jsvIsPin(HEAP32[$2 + 20 >> 2]) & 1) {
       break label$13;
      }
      $0 = HEAP32[$2 + 20 >> 2];
      HEAP32[$2 + 12 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
      if (!(HEAP32[$2 + 12 >> 2] < -32768 | HEAP32[$2 + 12 >> 2] > 32767)) {
       $0 = HEAP32[$2 + 24 >> 2];
       $0 = (HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 65472;
       $1 = jsvGetCharactersInVar(HEAP32[$2 + 24 >> 2]) + 17 | 0;
       $3 = HEAP32[$2 + 24 >> 2];
       $0 = $0 | $1;
       HEAP8[$3 + 13 | 0] = $0;
       HEAP8[$3 + 14 | 0] = $0 >>> 8;
       jsvSetFirstChild(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 12 >> 2] & 65535);
       break label$6;
      }
     }
    }
   }
   jsvSetFirstChild(HEAP32[$2 + 24 >> 2], jsvGetRef(jsvRef(HEAP32[$2 + 20 >> 2])) & 65535);
   break label$6;
  }
  jsvSetFirstChild(HEAP32[$2 + 24 >> 2], 0);
 }
 HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 24 >> 2];
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function graphicsBlendColor($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 112 | 0;
 HEAP32[$4 + 104 >> 2] = $0;
 HEAP32[$4 + 100 >> 2] = $1;
 HEAP32[$4 + 96 >> 2] = $2;
 HEAP32[$4 + 92 >> 2] = $3;
 $0 = $4;
 if (HEAP32[$4 + 92 >> 2] > 0) {
  $1 = HEAP32[$4 + 92 >> 2];
 } else {
  $1 = 0;
 }
 HEAP32[$0 + 88 >> 2] = $1;
 if (HEAPU32[$4 + 88 >> 2] > 256) {
  HEAP32[$4 + 88 >> 2] = 256;
 }
 label$4 : {
  if (!(HEAPU8[HEAP32[$4 + 104 >> 2] + 16 | 0] != 8 ? !(HEAPU8[HEAP32[$4 + 104 >> 2] + 16 | 0] == 2 | HEAPU8[HEAP32[$4 + 104 >> 2] + 16 | 0] == 4) : 0)) {
   HEAP32[$4 + 108 >> 2] = Math_imul(HEAP32[$4 + 96 >> 2], 256 - HEAP32[$4 + 88 >> 2] | 0) + Math_imul(HEAP32[$4 + 100 >> 2], HEAP32[$4 + 88 >> 2]) >>> 8;
   break label$4;
  }
  if (HEAPU8[HEAP32[$4 + 104 >> 2] + 16 | 0] == 16) {
   HEAP32[$4 + 84 >> 2] = HEAP32[$4 + 96 >> 2];
   HEAP32[$4 + 80 >> 2] = HEAP32[$4 + 84 >> 2] >>> 11 & 31;
   HEAP32[$4 + 76 >> 2] = HEAP32[$4 + 84 >> 2] >>> 5 & 63;
   HEAP32[$4 + 72 >> 2] = HEAP32[$4 + 84 >> 2] & 31;
   HEAP32[$4 + 68 >> 2] = HEAP32[$4 + 100 >> 2];
   HEAP32[$4 + 64 >> 2] = HEAP32[$4 + 68 >> 2] >>> 11 & 31;
   HEAP32[$4 + 60 >> 2] = HEAP32[$4 + 68 >> 2] >>> 5 & 63;
   HEAP32[$4 + 56 >> 2] = HEAP32[$4 + 68 >> 2] & 31;
   HEAP32[$4 + 52 >> 2] = Math_imul(HEAP32[$4 + 80 >> 2], 256 - HEAP32[$4 + 88 >> 2] | 0) + Math_imul(HEAP32[$4 + 64 >> 2], HEAP32[$4 + 88 >> 2]) >>> 8;
   HEAP32[$4 + 48 >> 2] = Math_imul(HEAP32[$4 + 76 >> 2], 256 - HEAP32[$4 + 88 >> 2] | 0) + Math_imul(HEAP32[$4 + 60 >> 2], HEAP32[$4 + 88 >> 2]) >>> 8;
   HEAP32[$4 + 44 >> 2] = Math_imul(HEAP32[$4 + 72 >> 2], 256 - HEAP32[$4 + 88 >> 2] | 0) + Math_imul(HEAP32[$4 + 56 >> 2], HEAP32[$4 + 88 >> 2]) >>> 8;
   HEAP32[$4 + 108 >> 2] = HEAP32[$4 + 44 >> 2] | HEAP32[$4 + 48 >> 2] << 5 | HEAP32[$4 + 52 >> 2] << 11;
   break label$4;
  }
  if (HEAPU8[HEAP32[$4 + 104 >> 2] + 16 | 0] == 24) {
   HEAP32[$4 + 40 >> 2] = HEAP32[$4 + 96 >> 2];
   HEAP32[$4 + 36 >> 2] = HEAP32[$4 + 40 >> 2] >>> 16 & 255;
   HEAP32[$4 + 32 >> 2] = HEAP32[$4 + 40 >> 2] >>> 8 & 255;
   HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 40 >> 2] & 255;
   HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 100 >> 2];
   HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 24 >> 2] >>> 16 & 255;
   HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 24 >> 2] >>> 8 & 255;
   HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 24 >> 2] & 255;
   HEAP32[$4 + 8 >> 2] = Math_imul(HEAP32[$4 + 36 >> 2], 256 - HEAP32[$4 + 88 >> 2] | 0) + Math_imul(HEAP32[$4 + 20 >> 2], HEAP32[$4 + 88 >> 2]) >>> 8;
   HEAP32[$4 + 4 >> 2] = Math_imul(HEAP32[$4 + 32 >> 2], 256 - HEAP32[$4 + 88 >> 2] | 0) + Math_imul(HEAP32[$4 + 16 >> 2], HEAP32[$4 + 88 >> 2]) >>> 8;
   HEAP32[$4 >> 2] = Math_imul(HEAP32[$4 + 28 >> 2], 256 - HEAP32[$4 + 88 >> 2] | 0) + Math_imul(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 88 >> 2]) >>> 8;
   HEAP32[$4 + 108 >> 2] = HEAP32[$4 >> 2] | HEAP32[$4 + 4 >> 2] << 8 | HEAP32[$4 + 8 >> 2] << 16;
   break label$4;
  }
  $0 = $4;
  if (HEAPU32[$4 + 88 >> 2] >= 128) {
   $1 = HEAP32[$4 + 100 >> 2];
  } else {
   $1 = HEAP32[$4 + 96 >> 2];
  }
  HEAP32[$0 + 108 >> 2] = $1;
 }
 return HEAP32[$4 + 108 >> 2];
}
function jsvGetInteger($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $1 = global$0 + -64 | 0;
 global$0 = $1;
 HEAP32[$1 + 56 >> 2] = $0;
 label$1 : {
  if (!HEAP32[$1 + 56 >> 2]) {
   HEAP32[$1 + 60 >> 2] = 0;
   break label$1;
  }
  if (jsvIsNull(HEAP32[$1 + 56 >> 2]) & 1) {
   HEAP32[$1 + 60 >> 2] = 0;
   break label$1;
  }
  if (jsvIsUndefined(HEAP32[$1 + 56 >> 2]) & 1) {
   HEAP32[$1 + 60 >> 2] = 0;
   break label$1;
  }
  label$5 : {
   if (!(jsvIsIntegerish(HEAP32[$1 + 56 >> 2]) & 1)) {
    if (!(jsvIsArrayBufferName(HEAP32[$1 + 56 >> 2]) & 1)) {
     break label$5;
    }
   }
   $0 = HEAP32[$1 + 56 >> 2];
   HEAP32[$1 + 60 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
   break label$1;
  }
  label$7 : {
   if (!(jsvIsArray(HEAP32[$1 + 56 >> 2]) & 1)) {
    if (!(jsvIsArrayBuffer(HEAP32[$1 + 56 >> 2]) & 1)) {
     break label$7;
    }
   }
   HEAP32[$1 + 52 >> 2] = jsvGetLength(HEAP32[$1 + 56 >> 2]);
   if (!HEAP32[$1 + 52 >> 2]) {
    HEAP32[$1 + 60 >> 2] = 0;
    break label$1;
   }
   if (HEAP32[$1 + 52 >> 2] == 1) {
    if (jsvIsArrayBuffer(HEAP32[$1 + 56 >> 2]) & 1) {
     HEAP32[$1 + 60 >> 2] = jsvGetIntegerAndUnLock(jsvArrayBufferGet(HEAP32[$1 + 56 >> 2], 0));
     break label$1;
    }
    HEAP32[$1 + 60 >> 2] = jsvGetIntegerAndUnLock(jsvSkipNameAndUnLock(jsvGetArrayItem(HEAP32[$1 + 56 >> 2], 0)));
    break label$1;
   }
  }
  if (jsvIsFloat(HEAP32[$1 + 56 >> 2]) & 1) {
   $0 = HEAP32[$1 + 56 >> 2];
   $2 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
   wasm2js_scratch_store_i32(0, HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24));
   wasm2js_scratch_store_i32(1, $2 | 0);
   $0 = __DOUBLE_BITS(+wasm2js_scratch_load_f64());
   $2 = i64toi32_i32$HIGH_BITS & 2147483647;
   if (!(($2 | 0) == 2146435072 & $0 >>> 0 >= 0 | $2 >>> 0 > 2146435072)) {
    $4 = $1;
    $2 = HEAP32[$1 + 56 >> 2];
    $0 = HEAPU8[$2 + 4 | 0] | HEAPU8[$2 + 5 | 0] << 8 | (HEAPU8[$2 + 6 | 0] << 16 | HEAPU8[$2 + 7 | 0] << 24);
    wasm2js_scratch_store_i32(0, HEAPU8[$2 | 0] | HEAPU8[$2 + 1 | 0] << 8 | (HEAPU8[$2 + 2 | 0] << 16 | HEAPU8[$2 + 3 | 0] << 24));
    wasm2js_scratch_store_i32(1, $0 | 0);
    $3 = +wasm2js_scratch_load_f64();
    label$15 : {
     if (Math_abs($3) < 0x8000000000000000) {
      $0 = ~~$3 >>> 0;
      break label$15;
     }
     $0 = 0;
    }
    HEAP32[$4 + 60 >> 2] = $0;
    break label$1;
   }
   HEAP32[$1 + 60 >> 2] = 0;
   break label$1;
  }
  label$17 : {
   if (!(jsvIsString(HEAP32[$1 + 56 >> 2]) & 1)) {
    break label$17;
   }
   if (!(jsvIsStringNumericInt(HEAP32[$1 + 56 >> 2], 1) & 1)) {
    break label$17;
   }
   label$18 : {
    if ((jsvGetString(HEAP32[$1 + 56 >> 2], $1 + 16 | 0, 32) | 0) == 32) {
     jsExceptionHere(1, 78511, 0);
     break label$18;
    }
    HEAP32[$1 + 60 >> 2] = stringToInt($1 + 16 | 0);
    break label$1;
   }
  }
  HEAP32[$1 + 60 >> 2] = 0;
 }
 global$0 = $1 - -64 | 0;
 return HEAP32[$1 + 60 >> 2];
}
function jswrap_typedarray_constructor($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 112 | 0;
 global$0 = $4;
 HEAP16[$4 + 106 >> 1] = $0;
 HEAP32[$4 + 100 >> 2] = $1;
 HEAP32[$4 + 96 >> 2] = $2;
 HEAP32[$4 + 92 >> 2] = $3;
 HEAP32[$4 + 88 >> 2] = 0;
 HEAP8[$4 + 87 | 0] = 0;
 label$1 : {
  label$2 : {
   if (!(jsvIsArrayBuffer(HEAP32[$4 + 100 >> 2]) & 1)) {
    break label$2;
   }
   $0 = HEAP32[$4 + 100 >> 2];
   if ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8) != 129) {
    break label$2;
   }
   HEAP32[$4 + 88 >> 2] = jsvLockAgain(HEAP32[$4 + 100 >> 2]);
   break label$1;
  }
  label$3 : {
   if (jsvIsNumeric(HEAP32[$4 + 100 >> 2]) & 1) {
    HEAP32[$4 + 92 >> 2] = jsvGetInteger(HEAP32[$4 + 100 >> 2]);
    HEAP32[$4 + 96 >> 2] = 0;
    HEAP32[$4 + 88 >> 2] = jswrap_arraybuffer_constructor(Math_imul(HEAP32[$4 + 92 >> 2], HEAPU16[$4 + 106 >> 1] & 15));
    break label$3;
   }
   label$5 : {
    if (!(jsvIsArray(HEAP32[$4 + 100 >> 2]) & 1)) {
     if (!(jsvIsArrayBuffer(HEAP32[$4 + 100 >> 2]) & 1)) {
      break label$5;
     }
    }
    HEAP32[$4 + 92 >> 2] = jsvGetLength(HEAP32[$4 + 100 >> 2]);
    HEAP32[$4 + 96 >> 2] = 0;
    HEAP32[$4 + 88 >> 2] = jswrap_arraybuffer_constructor(Math_imul(HEAP32[$4 + 92 >> 2], HEAPU16[$4 + 106 >> 1] & 15));
    HEAP8[$4 + 87 | 0] = 1;
   }
  }
 }
 label$7 : {
  if (!HEAP32[$4 + 88 >> 2]) {
   HEAP32[$4 >> 2] = HEAP32[$4 + 100 >> 2];
   jsExceptionHere(1, 119178, $4);
   HEAP32[$4 + 108 >> 2] = 0;
   break label$7;
  }
  if (!HEAP32[$4 + 92 >> 2]) {
   HEAP32[$4 + 92 >> 2] = (jsvGetArrayBufferLength(HEAP32[$4 + 88 >> 2]) - HEAP32[$4 + 96 >> 2] | 0) / (HEAPU16[$4 + 106 >> 1] & 15);
   if (HEAP32[$4 + 92 >> 2] < 0) {
    HEAP32[$4 + 92 >> 2] = 0;
   }
  }
  HEAP32[$4 + 80 >> 2] = jsvNewWithFlags(4);
  if (HEAP32[$4 + 80 >> 2]) {
   $0 = HEAP32[$4 + 80 >> 2];
   $1 = HEAPU16[$4 + 106 >> 1];
   HEAP8[$0 + 4 | 0] = $1;
   HEAP8[$0 + 5 | 0] = $1 >>> 8;
   $0 = HEAP32[$4 + 80 >> 2];
   $1 = HEAP32[$4 + 96 >> 2];
   HEAP8[$0 | 0] = $1;
   HEAP8[$0 + 1 | 0] = $1 >>> 8;
   $0 = HEAP32[$4 + 80 >> 2];
   $1 = HEAP32[$4 + 92 >> 2];
   HEAP8[$0 + 2 | 0] = $1;
   HEAP8[$0 + 3 | 0] = $1 >>> 8;
   jsvSetFirstChild(HEAP32[$4 + 80 >> 2], jsvGetRef(jsvRef(HEAP32[$4 + 88 >> 2])) & 65535);
   if (HEAP8[$4 + 87 | 0] & 1) {
    jsvIteratorNew($4 + 16 | 0, HEAP32[$4 + 100 >> 2], 0);
    while (1) {
     if (jsvIteratorHasElement($4 + 16 | 0) & 1) {
      HEAP32[$4 + 12 >> 2] = jsvIteratorGetKey($4 + 16 | 0);
      if (jsvIsInt(HEAP32[$4 + 12 >> 2]) & 1) {
       HEAP32[$4 + 8 >> 2] = jsvIteratorGetValue($4 + 16 | 0);
       jsvArrayBufferSet(HEAP32[$4 + 80 >> 2], jsvGetInteger(HEAP32[$4 + 12 >> 2]), HEAP32[$4 + 8 >> 2]);
       jsvUnLock(HEAP32[$4 + 8 >> 2]);
      }
      $0 = $4 + 16 | 0;
      jsvUnLock(HEAP32[$4 + 12 >> 2]);
      jsvIteratorNext($0);
      continue;
     }
     break;
    }
    jsvIteratorFree($4 + 16 | 0);
   }
  }
  jsvUnLock(HEAP32[$4 + 88 >> 2]);
  HEAP32[$4 + 108 >> 2] = HEAP32[$4 + 80 >> 2];
 }
 global$0 = $4 + 112 | 0;
 return HEAP32[$4 + 108 >> 2];
}
function graphicsDrawChar4x6($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0;
 $7 = global$0 - 48 | 0;
 global$0 = $7;
 HEAP32[$7 + 44 >> 2] = $0;
 HEAP32[$7 + 40 >> 2] = $1;
 HEAP32[$7 + 36 >> 2] = $2;
 HEAP8[$7 + 35 | 0] = $3;
 HEAP16[$7 + 32 >> 1] = $4;
 HEAP16[$7 + 30 >> 1] = $5;
 HEAP8[$7 + 29 | 0] = $6;
 HEAP32[$7 + 24 >> 2] = HEAPU8[$7 + 35 | 0] - 33;
 label$1 : {
  if (!(HEAP32[$7 + 24 >> 2] < 100 ? HEAP32[$7 + 24 >> 2] >= 0 : 0)) {
   if (HEAP8[$7 + 29 | 0] & 1) {
    $0 = HEAP32[$7 + 44 >> 2];
    graphicsFillRect(HEAP32[$7 + 44 >> 2], HEAP32[$7 + 40 >> 2], HEAP32[$7 + 36 >> 2], HEAP32[$7 + 40 >> 2] + (HEAPU16[$7 + 32 >> 1] << 1) | 0, HEAP32[$7 + 36 >> 2] + Math_imul(HEAPU16[$7 + 30 >> 1], 5) | 0, HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24));
   }
   break label$1;
  }
  HEAP32[$7 + 20 >> 2] = HEAP32[$7 + 24 >> 2] % 5;
  HEAP32[$7 + 24 >> 2] = Math_imul(HEAP32[$7 + 24 >> 2] / 5 | 0, 6);
  HEAP32[$7 + 16 >> 2] = 0;
  while (1) {
   if (HEAP32[$7 + 16 >> 2] < 6) {
    HEAP32[$7 + 12 >> 2] = HEAPU16[(HEAP32[$7 + 24 >> 2] + HEAP32[$7 + 16 >> 2] << 1) + 104272 >> 1] >> Math_imul(HEAP32[$7 + 20 >> 2], 3);
    HEAP32[$7 + 8 >> 2] = HEAP32[$7 + 36 >> 2] + Math_imul(HEAP32[$7 + 16 >> 2], HEAPU16[$7 + 30 >> 1]);
    HEAP32[$7 + 4 >> 2] = 0;
    while (1) {
     if (HEAP32[$7 + 4 >> 2] < 3) {
      HEAP8[$7 + 3 | 0] = (HEAP32[$7 + 12 >> 2] & 4) != 0;
      if (!(HEAP8[$7 + 3 | 0] & 1 ? 0 : !(HEAP8[$7 + 29 | 0] & 1))) {
       $1 = HEAP32[$7 + 44 >> 2];
       $2 = HEAP32[$7 + 40 >> 2] + Math_imul(HEAP32[$7 + 4 >> 2], HEAPU16[$7 + 32 >> 1]) | 0;
       $3 = HEAP32[$7 + 8 >> 2];
       $4 = (HEAP32[$7 + 40 >> 2] + Math_imul(HEAPU16[$7 + 32 >> 1], HEAP32[$7 + 4 >> 2] + 1 | 0) | 0) - 1 | 0;
       $5 = (HEAP32[$7 + 8 >> 2] + HEAPU16[$7 + 30 >> 1] | 0) - 1 | 0;
       label$11 : {
        if (HEAP8[$7 + 3 | 0] & 1) {
         $0 = HEAP32[$7 + 44 >> 2];
         $0 = HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24);
         break label$11;
        }
        $0 = HEAP32[$7 + 44 >> 2];
        $0 = HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24);
       }
       graphicsFillRect($1, $2, $3, $4, $5, $0);
      }
      HEAP32[$7 + 12 >> 2] = HEAP32[$7 + 12 >> 2] << 1;
      HEAP32[$7 + 4 >> 2] = HEAP32[$7 + 4 >> 2] + 1;
      continue;
     }
     break;
    }
    HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 16 >> 2] + 1;
    continue;
   }
   break;
  }
  if (!(HEAP8[$7 + 29 | 0] & 1)) {
   break label$1;
  }
  $0 = HEAP32[$7 + 44 >> 2];
  graphicsFillRect(HEAP32[$7 + 44 >> 2], HEAP32[$7 + 40 >> 2] + Math_imul(HEAPU16[$7 + 32 >> 1], 3) | 0, HEAP32[$7 + 36 >> 2], (HEAP32[$7 + 40 >> 2] + (HEAPU16[$7 + 32 >> 1] << 2) | 0) - 1 | 0, (HEAP32[$7 + 36 >> 2] + Math_imul(HEAPU16[$7 + 30 >> 1], 6) | 0) - 1 | 0, HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24));
 }
 global$0 = $7 + 48 | 0;
}
function jslTokenAsString($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 label$1 : {
  if (!(HEAP32[$3 + 12 >> 2] <= 32 | HEAP32[$3 + 12 >> 2] >= 128)) {
   HEAP8[HEAP32[$3 + 8 >> 2]] = 39;
   HEAP8[HEAP32[$3 + 8 >> 2] + 1 | 0] = HEAP32[$3 + 12 >> 2];
   HEAP8[HEAP32[$3 + 8 >> 2] + 2 | 0] = 39;
   HEAP8[HEAP32[$3 + 8 >> 2] + 3 | 0] = 0;
   break label$1;
  }
  label$3 : {
   label$4 : {
    label$5 : {
     label$6 : {
      label$7 : {
       label$8 : {
        label$9 : {
         label$10 : {
          label$11 : {
           label$12 : {
            label$13 : {
             label$14 : {
              $0 = HEAP32[$3 + 12 >> 2];
              if ($0) {
               if (($0 | 0) == 128) {
                break label$14;
               }
               if (($0 | 0) == 129) {
                break label$13;
               }
               if (($0 | 0) == 130) {
                break label$12;
               }
               if (($0 | 0) == 131) {
                break label$11;
               }
               if (($0 | 0) == 132) {
                break label$10;
               }
               if (($0 | 0) == 133) {
                break label$9;
               }
               if (($0 | 0) == 134) {
                break label$8;
               }
               if (($0 | 0) == 135) {
                break label$7;
               }
               if (($0 | 0) == 136) {
                break label$6;
               }
               if (($0 | 0) == 137) {
                break label$5;
               }
               if (($0 | 0) == 255) {
                break label$4;
               }
               break label$3;
              }
              strcpy(HEAP32[$3 + 8 >> 2], 77756);
              break label$1;
             }
             strcpy(HEAP32[$3 + 8 >> 2], 77760);
             break label$1;
            }
            strcpy(HEAP32[$3 + 8 >> 2], 77763);
            break label$1;
           }
           strcpy(HEAP32[$3 + 8 >> 2], 77767);
           break label$1;
          }
          strcpy(HEAP32[$3 + 8 >> 2], 77773);
          break label$1;
         }
         strcpy(HEAP32[$3 + 8 >> 2], 77780);
         break label$1;
        }
        strcpy(HEAP32[$3 + 8 >> 2], 77798);
        break label$1;
       }
       strcpy(HEAP32[$3 + 8 >> 2], 77815);
       break label$1;
      }
      strcpy(HEAP32[$3 + 8 >> 2], 77843);
      break label$1;
     }
     strcpy(HEAP32[$3 + 8 >> 2], 77849);
     break label$1;
    }
    strcpy(HEAP32[$3 + 8 >> 2], 77866);
    break label$1;
   }
   strcpy(HEAP32[$3 + 8 >> 2], 77885);
   break label$1;
  }
  if (!(HEAP32[$3 + 12 >> 2] < 138 | HEAP32[$3 + 12 >> 2] > 198)) {
   strcpy(HEAP32[$3 + 8 >> 2], jslReservedWordAsString(HEAP32[$3 + 12 >> 2]));
   break label$1;
  }
  $0 = HEAP32[$3 + 8 >> 2];
  $1 = HEAP32[$3 + 4 >> 2];
  HEAP32[$3 >> 2] = HEAP32[$3 + 12 >> 2];
  espruino_snprintf($0, $1, 77894, $3);
 }
 global$0 = $3 + 16 | 0;
}
function graphicsDrawChar6x8($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0;
 $7 = global$0 - 48 | 0;
 global$0 = $7;
 HEAP32[$7 + 44 >> 2] = $0;
 HEAP32[$7 + 40 >> 2] = $1;
 HEAP32[$7 + 36 >> 2] = $2;
 HEAP8[$7 + 35 | 0] = $3;
 HEAP16[$7 + 32 >> 1] = $4;
 HEAP16[$7 + 30 >> 1] = $5;
 HEAP8[$7 + 29 | 0] = $6;
 HEAP32[$7 + 24 >> 2] = HEAPU8[$7 + 35 | 0] - 33;
 label$1 : {
  if (!(HEAP32[$7 + 24 >> 2] < 223 ? HEAP32[$7 + 24 >> 2] >= 0 : 0)) {
   if (HEAP8[$7 + 29 | 0] & 1) {
    $0 = HEAP32[$7 + 44 >> 2];
    graphicsFillRect(HEAP32[$7 + 44 >> 2], HEAP32[$7 + 40 >> 2], HEAP32[$7 + 36 >> 2], HEAP32[$7 + 40 >> 2] + Math_imul(HEAPU16[$7 + 32 >> 1], 5) | 0, HEAP32[$7 + 36 >> 2] + Math_imul(HEAPU16[$7 + 30 >> 1], 7) | 0, HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24));
   }
   break label$1;
  }
  HEAP32[$7 + 20 >> 2] = HEAP32[$7 + 24 >> 2] % 6;
  HEAP32[$7 + 24 >> 2] = HEAP32[$7 + 24 >> 2] / 6 << 3;
  HEAP32[$7 + 16 >> 2] = 0;
  while (1) {
   if (HEAP32[$7 + 16 >> 2] < 8) {
    HEAP32[$7 + 12 >> 2] = HEAP32[(HEAP32[$7 + 24 >> 2] + HEAP32[$7 + 16 >> 2] << 2) + 104512 >> 2] >>> Math_imul(HEAP32[$7 + 20 >> 2], 5);
    HEAP32[$7 + 8 >> 2] = HEAP32[$7 + 36 >> 2] + Math_imul(HEAP32[$7 + 16 >> 2], HEAPU16[$7 + 30 >> 1]);
    HEAP32[$7 + 4 >> 2] = 0;
    while (1) {
     if (HEAP32[$7 + 4 >> 2] < 5) {
      HEAP8[$7 + 3 | 0] = (HEAP32[$7 + 12 >> 2] & 16) != 0;
      if (!(HEAP8[$7 + 3 | 0] & 1 ? 0 : !(HEAP8[$7 + 29 | 0] & 1))) {
       $1 = HEAP32[$7 + 44 >> 2];
       $2 = HEAP32[$7 + 40 >> 2] + Math_imul(HEAP32[$7 + 4 >> 2], HEAPU16[$7 + 32 >> 1]) | 0;
       $3 = HEAP32[$7 + 8 >> 2];
       $4 = (HEAP32[$7 + 40 >> 2] + Math_imul(HEAPU16[$7 + 32 >> 1], HEAP32[$7 + 4 >> 2] + 1 | 0) | 0) - 1 | 0;
       $5 = (HEAP32[$7 + 8 >> 2] + HEAPU16[$7 + 30 >> 1] | 0) - 1 | 0;
       label$11 : {
        if (HEAP8[$7 + 3 | 0] & 1) {
         $0 = HEAP32[$7 + 44 >> 2];
         $0 = HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24);
         break label$11;
        }
        $0 = HEAP32[$7 + 44 >> 2];
        $0 = HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24);
       }
       graphicsFillRect($1, $2, $3, $4, $5, $0);
      }
      HEAP32[$7 + 12 >> 2] = HEAP32[$7 + 12 >> 2] << 1;
      HEAP32[$7 + 4 >> 2] = HEAP32[$7 + 4 >> 2] + 1;
      continue;
     }
     break;
    }
    HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 16 >> 2] + 1;
    continue;
   }
   break;
  }
  if (!(HEAP8[$7 + 29 | 0] & 1)) {
   break label$1;
  }
  $0 = HEAP32[$7 + 44 >> 2];
  graphicsFillRect(HEAP32[$7 + 44 >> 2], HEAP32[$7 + 40 >> 2] + Math_imul(HEAPU16[$7 + 32 >> 1], 5) | 0, HEAP32[$7 + 36 >> 2], (HEAP32[$7 + 40 >> 2] + Math_imul(HEAPU16[$7 + 32 >> 1], 6) | 0) - 1 | 0, (HEAP32[$7 + 36 >> 2] + (HEAPU16[$7 + 30 >> 1] << 3) | 0) - 1 | 0, HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24));
 }
 global$0 = $7 + 48 | 0;
}
function tflite__ops__micro__depthwise_conv__EvalQuantizedPerChannel_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteDepthwiseConvParams__2c_20tflite__ops__micro__depthwise_conv___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0;
 $8 = global$0 - 208 | 0;
 global$0 = $8;
 HEAP32[$8 + 204 >> 2] = $0;
 HEAP32[$8 + 200 >> 2] = $1;
 HEAP32[$8 + 196 >> 2] = $2;
 HEAP32[$8 + 192 >> 2] = $3;
 HEAP32[$8 + 188 >> 2] = $4;
 HEAP32[$8 + 184 >> 2] = $5;
 HEAP32[$8 + 180 >> 2] = $6;
 HEAP32[$8 + 176 >> 2] = $7;
 HEAP8[$8 + 112 | 0] = 1;
 HEAP16[$8 + 114 >> 1] = HEAP32[HEAP32[$8 + 192 >> 2] >> 2];
 HEAP16[$8 + 116 >> 1] = HEAP32[HEAP32[$8 + 192 >> 2] + 4 >> 2];
 HEAP16[$8 + 122 >> 1] = HEAP32[HEAP32[$8 + 196 >> 2] + 4 >> 2];
 HEAP16[$8 + 124 >> 1] = HEAP32[HEAP32[$8 + 196 >> 2] + 8 >> 2];
 HEAP16[$8 + 126 >> 1] = HEAP32[HEAP32[$8 + 196 >> 2] + 20 >> 2];
 HEAP16[$8 + 128 >> 1] = HEAP32[HEAP32[$8 + 196 >> 2] + 24 >> 2];
 HEAP16[$8 + 130 >> 1] = HEAP32[HEAP32[$8 + 196 >> 2] + 12 >> 2];
 HEAP32[$8 + 132 >> 2] = 0 - HEAP32[HEAP32[$8 + 192 >> 2] + 16 >> 2];
 HEAP32[$8 + 136 >> 2] = 0;
 HEAP32[$8 + 140 >> 2] = HEAP32[HEAP32[$8 + 192 >> 2] + 24 >> 2];
 HEAP32[$8 + 152 >> 2] = -128;
 HEAP32[$8 + 156 >> 2] = 127;
 $0 = HEAP32[HEAP32[$8 + 192 >> 2] + 36 >> 2];
 $1 = HEAP32[HEAP32[$8 + 192 >> 2] + 40 >> 2];
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 88 | 0, HEAP32[$8 + 188 >> 2]);
 $2 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$8 + 188 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 56 | 0, HEAP32[$8 + 184 >> 2]);
 $3 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$8 + 184 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 32 | 0, HEAP32[$8 + 180 >> 2]);
 $4 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$8 + 180 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 8 | 0, HEAP32[$8 + 176 >> 2]);
 tflite__reference_integer_ops__DepthwiseConvPerChannel_28tflite__DepthwiseParams_20const__2c_20int_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($8 + 112 | 0, $0, $1, $8 + 88 | 0, $2, $8 + 56 | 0, $3, $8 + 32 | 0, $4, $8 + 8 | 0, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$8 + 176 >> 2]));
 $0 = $8 + 88 | 0;
 $1 = $8 + 56 | 0;
 $2 = $8 + 32 | 0;
 tflite__RuntimeShape___RuntimeShape_28_29($8 + 8 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($2);
 tflite__RuntimeShape___RuntimeShape_28_29($1);
 tflite__RuntimeShape___RuntimeShape_28_29($0);
 global$0 = $8 + 208 | 0;
}
function jsvGetString($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 80 | 0;
 global$0 = $3;
 HEAP32[$3 + 72 >> 2] = $0;
 HEAP32[$3 + 68 >> 2] = $1;
 HEAP32[$3 + 64 >> 2] = $2;
 HEAP32[$3 + 60 >> 2] = jsvGetConstString(HEAP32[$3 + 72 >> 2]);
 label$1 : {
  if (HEAP32[$3 + 60 >> 2]) {
   HEAP32[$3 + 64 >> 2] = HEAP32[$3 + 64 >> 2] + -1;
   HEAP32[$3 + 56 >> 2] = 0;
   while (1) {
    if (HEAP8[HEAP32[$3 + 60 >> 2] + HEAP32[$3 + 56 >> 2] | 0] ? HEAPU32[$3 + 56 >> 2] < HEAPU32[$3 + 64 >> 2] : 0) {
     HEAP8[HEAP32[$3 + 68 >> 2] + HEAP32[$3 + 56 >> 2] | 0] = HEAPU8[HEAP32[$3 + 60 >> 2] + HEAP32[$3 + 56 >> 2] | 0];
     HEAP32[$3 + 56 >> 2] = HEAP32[$3 + 56 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP8[HEAP32[$3 + 68 >> 2] + HEAP32[$3 + 56 >> 2] | 0] = 0;
   HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 56 >> 2];
   break label$1;
  }
  if (jsvIsInt(HEAP32[$3 + 72 >> 2]) & 1) {
   $0 = HEAP32[$3 + 72 >> 2];
   itostr(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), HEAP32[$3 + 68 >> 2], 10);
   HEAP32[$3 + 76 >> 2] = strlen(HEAP32[$3 + 68 >> 2]);
   break label$1;
  }
  if (jsvIsFloat(HEAP32[$3 + 72 >> 2]) & 1) {
   $0 = HEAP32[$3 + 72 >> 2];
   $1 = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
   $0 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
   wasm2js_scratch_store_i32(0, $1 | 0);
   wasm2js_scratch_store_i32(1, $0 | 0);
   ftoa_bounded(+wasm2js_scratch_load_f64(), HEAP32[$3 + 68 >> 2], HEAP32[$3 + 64 >> 2]);
   HEAP32[$3 + 76 >> 2] = strlen(HEAP32[$3 + 68 >> 2]);
   break label$1;
  }
  if (jsvHasCharacterData(HEAP32[$3 + 72 >> 2]) & 1) {
   HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 64 >> 2];
   jsvStringIteratorNew($3 + 16 | 0, HEAP32[$3 + 72 >> 2], 0);
   while (1) {
    if (jsvStringIteratorHasChar($3 + 16 | 0) & 1) {
     $0 = HEAP32[$3 + 52 >> 2];
     HEAP32[$3 + 52 >> 2] = $0 + -1;
     if ($0 >>> 0 <= 1) {
      HEAP8[HEAP32[$3 + 68 >> 2]] = 0;
      jsvStringIteratorFree($3 + 16 | 0);
      HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 64 >> 2];
      break label$1;
     }
     $0 = $3 + 16 | 0;
     $1 = jsvStringIteratorGetChar($0);
     $2 = HEAP32[$3 + 68 >> 2];
     HEAP32[$3 + 68 >> 2] = $2 + 1;
     HEAP8[$2 | 0] = $1;
     jsvStringIteratorNext($0);
     continue;
    }
    break;
   }
   jsvStringIteratorFree($3 + 16 | 0);
   HEAP8[HEAP32[$3 + 68 >> 2]] = 0;
   HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 64 >> 2] - HEAP32[$3 + 52 >> 2];
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = jsvAsString(HEAP32[$3 + 72 >> 2]);
  if (HEAP32[$3 + 12 >> 2]) {
   HEAP32[$3 + 8 >> 2] = jsvGetStringChars(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 68 >> 2], HEAP32[$3 + 64 >> 2]);
   jsvUnLock(HEAP32[$3 + 12 >> 2]);
   HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 8 >> 2];
   break label$1;
  }
  HEAP8[HEAP32[$3 + 68 >> 2]] = 0;
  jsExceptionHere(4, 78440, 0);
  HEAP32[$3 + 76 >> 2] = 0;
 }
 global$0 = $3 + 80 | 0;
 return HEAP32[$3 + 76 >> 2];
}
function _jsvCountJsVarsUsedRecursive($0, $1) {
 var $2 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP8[$2 + 39 | 0] = $1;
 label$1 : {
  if (!HEAP32[$2 + 40 >> 2]) {
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  label$3 : {
   if (HEAP8[$2 + 39 | 0] & 1) {
    $0 = HEAP32[$2 + 40 >> 2];
    if (!((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 256)) {
     HEAP32[$2 + 44 >> 2] = 0;
     break label$1;
    }
    $0 = HEAP32[$2 + 40 >> 2];
    $1 = (HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & -257;
    HEAP8[$0 + 13 | 0] = $1;
    HEAP8[$0 + 14 | 0] = $1 >>> 8;
    break label$3;
   }
   $0 = HEAP32[$2 + 40 >> 2];
   if ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 256) {
    HEAP32[$2 + 44 >> 2] = 0;
    break label$1;
   }
   $0 = HEAP32[$2 + 40 >> 2];
   $1 = HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8 | 256;
   HEAP8[$0 + 13 | 0] = $1;
   HEAP8[$0 + 14 | 0] = $1 >>> 8;
  }
  HEAP32[$2 + 32 >> 2] = 1;
  label$7 : {
   label$8 : {
    if (!(jsvHasSingleChild(HEAP32[$2 + 40 >> 2]) & 1)) {
     if (!(jsvHasChildren(HEAP32[$2 + 40 >> 2]) & 1)) {
      break label$8;
     }
    }
    HEAP16[$2 + 30 >> 1] = jsvGetFirstChild(HEAP32[$2 + 40 >> 2]);
    while (1) {
     if (HEAPU16[$2 + 30 >> 1]) {
      HEAP32[$2 + 24 >> 2] = jsvLock(HEAPU16[$2 + 30 >> 1]);
      HEAP32[$2 + 32 >> 2] = _jsvCountJsVarsUsedRecursive(HEAP32[$2 + 24 >> 2], HEAP8[$2 + 39 | 0] & 1) + HEAP32[$2 + 32 >> 2];
      label$12 : {
       if (jsvHasChildren(HEAP32[$2 + 40 >> 2]) & 1) {
        HEAP16[$2 + 30 >> 1] = jsvGetNextSibling(HEAP32[$2 + 24 >> 2]);
        break label$12;
       }
       HEAP16[$2 + 30 >> 1] = 0;
      }
      jsvUnLock(HEAP32[$2 + 24 >> 2]);
      continue;
     }
     break;
    }
    break label$7;
   }
   if (jsvIsFlatString(HEAP32[$2 + 40 >> 2]) & 1) {
    HEAP32[$2 + 32 >> 2] = jsvGetFlatStringBlocks(HEAP32[$2 + 40 >> 2]) + HEAP32[$2 + 32 >> 2];
   }
  }
  if (jsvHasCharacterData(HEAP32[$2 + 40 >> 2]) & 1) {
   HEAP16[$2 + 22 >> 1] = jsvGetLastChild(HEAP32[$2 + 40 >> 2]);
   while (1) {
    if (HEAPU16[$2 + 22 >> 1]) {
     HEAP32[$2 + 16 >> 2] = jsvLock(HEAPU16[$2 + 22 >> 1]);
     HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 32 >> 2] + 1;
     HEAP16[$2 + 22 >> 1] = jsvGetLastChild(HEAP32[$2 + 16 >> 2]);
     jsvUnLock(HEAP32[$2 + 16 >> 2]);
     continue;
    }
    break;
   }
  }
  label$18 : {
   if (!(jsvIsName(HEAP32[$2 + 40 >> 2]) & 1)) {
    break label$18;
   }
   if (jsvIsNameWithValue(HEAP32[$2 + 40 >> 2]) & 1) {
    break label$18;
   }
   if (!(jsvGetFirstChild(HEAP32[$2 + 40 >> 2]) & 65535)) {
    break label$18;
   }
   HEAP32[$2 + 12 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$2 + 40 >> 2]) & 65535);
   HEAP32[$2 + 32 >> 2] = _jsvCountJsVarsUsedRecursive(HEAP32[$2 + 12 >> 2], HEAP8[$2 + 39 | 0] & 1) + HEAP32[$2 + 32 >> 2];
   jsvUnLock(HEAP32[$2 + 12 >> 2]);
  }
  HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
 }
 global$0 = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}
function jswrap_pin_getInfo($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 + -64 | 0;
 global$0 = $1;
 HEAP32[$1 + 56 >> 2] = $0;
 HEAP8[$1 + 55 | 0] = jshGetPinFromVar(HEAP32[$1 + 56 >> 2]);
 label$1 : {
  if (!(jshIsPinValid(HEAPU8[$1 + 55 | 0]) & 1)) {
   HEAP32[$1 + 60 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 48 >> 2] = Math_imul(HEAPU8[$1 + 55 | 0], 3) + 109872;
  HEAP32[$1 + 44 >> 2] = jsvNewWithFlags(5);
  if (!HEAP32[$1 + 44 >> 2]) {
   HEAP32[$1 + 60 >> 2] = 0;
   break label$1;
  }
  HEAP8[$1 + 42 | 0] = HEAPU8[HEAP32[$1 + 48 >> 2]] - -64;
  HEAP8[$1 + 43 | 0] = 0;
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 44 >> 2], 123164, jsvNewFromString($1 + 42 | 0));
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 44 >> 2], 123169, jsvNewFromInteger(HEAPU8[HEAP32[$1 + 48 >> 2] + 1 | 0]));
  if (HEAPU8[HEAP32[$1 + 48 >> 2] + 2 | 0]) {
   HEAP32[$1 + 36 >> 2] = jsvNewWithFlags(5);
   if (HEAP32[$1 + 36 >> 2]) {
    HEAP32[$1 + 32 >> 2] = jsvNewWithFlags(3);
    if (HEAP32[$1 + 32 >> 2]) {
     HEAP32[$1 + 28 >> 2] = 0;
     while (1) {
      if (HEAP32[$1 + 28 >> 2] < 0) {
       if (HEAPU8[HEAP32[$1 + 48 >> 2] + 2 | 0] & 32 << HEAP32[$1 + 28 >> 2]) {
        jsvArrayPushAndUnLock(HEAP32[$1 + 32 >> 2], jsvNewFromInteger(HEAP32[$1 + 28 >> 2] + 1 | 0));
       }
       HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 28 >> 2] + 1;
       continue;
      }
      break;
     }
     jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 123173, HEAP32[$1 + 32 >> 2]);
    }
    jsvObjectSetChildAndUnLock(HEAP32[$1 + 44 >> 2], 123178, jsvNewFromInteger(HEAPU8[HEAP32[$1 + 48 >> 2] + 2 | 0] & 31));
   }
  }
  HEAP32[$1 + 24 >> 2] = jsvNewWithFlags(5);
  if (HEAP32[$1 + 24 >> 2]) {
   HEAP32[$1 + 20 >> 2] = 0;
   while (1) {
    if (HEAP32[$1 + 20 >> 2] < 0) {
     $0 = (HEAP32[$1 + 48 >> 2] + 3 | 0) + (HEAP32[$1 + 20 >> 2] << 1) | 0;
     if (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8) {
      HEAP32[$1 + 16 >> 2] = jsvNewWithFlags(5);
      if (HEAP32[$1 + 16 >> 2]) {
       $0 = (HEAP32[$1 + 48 >> 2] + 3 | 0) + (HEAP32[$1 + 20 >> 2] << 1) | 0;
       jshPinFunctionToString(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8, 8, $1);
       jsvObjectSetChildAndUnLock(HEAP32[$1 + 16 >> 2], 123186, jsvNewFromString($1));
       $0 = (HEAP32[$1 + 48 >> 2] + 3 | 0) + (HEAP32[$1 + 20 >> 2] << 1) | 0;
       jsvObjectSetChildAndUnLock(HEAP32[$1 + 16 >> 2], 123191, jsvNewFromInteger((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8) & 15));
       $0 = (HEAP32[$1 + 48 >> 2] + 3 | 0) + (HEAP32[$1 + 20 >> 2] << 1) | 0;
       jshPinFunctionToString(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8, 3, $1);
       jsvObjectSetChildAndUnLock(HEAP32[$1 + 24 >> 2], $1, HEAP32[$1 + 16 >> 2]);
      }
     }
     HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 20 >> 2] + 1;
     continue;
    }
    break;
   }
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 44 >> 2], 123194, HEAP32[$1 + 24 >> 2]);
  }
  HEAP32[$1 + 60 >> 2] = HEAP32[$1 + 44 >> 2];
 }
 global$0 = $1 - -64 | 0;
 return HEAP32[$1 + 60 >> 2];
}
function tflite__ops__micro__conv__EvalQuantizedPerChannel_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteConvParams__2c_20tflite__ops__micro__conv__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0;
 $8 = global$0 - 208 | 0;
 global$0 = $8;
 HEAP32[$8 + 204 >> 2] = $0;
 HEAP32[$8 + 200 >> 2] = $1;
 HEAP32[$8 + 196 >> 2] = $2;
 HEAP32[$8 + 192 >> 2] = $3;
 HEAP32[$8 + 188 >> 2] = $4;
 HEAP32[$8 + 184 >> 2] = $5;
 HEAP32[$8 + 180 >> 2] = $6;
 HEAP32[$8 + 176 >> 2] = $7;
 HEAP32[$8 + 172 >> 2] = 0;
 HEAP32[$8 + 132 >> 2] = 0 - HEAP32[HEAP32[$8 + 192 >> 2] + 16 >> 2];
 HEAP32[$8 + 140 >> 2] = HEAP32[HEAP32[$8 + 192 >> 2] + 24 >> 2];
 HEAP16[$8 + 124 >> 1] = HEAP32[HEAP32[$8 + 196 >> 2] + 8 >> 2];
 HEAP16[$8 + 122 >> 1] = HEAP32[HEAP32[$8 + 196 >> 2] + 4 >> 2];
 HEAP16[$8 + 128 >> 1] = HEAP32[HEAP32[$8 + 196 >> 2] + 20 >> 2];
 HEAP16[$8 + 126 >> 1] = HEAP32[HEAP32[$8 + 196 >> 2] + 16 >> 2];
 HEAP16[$8 + 116 >> 1] = HEAP32[HEAP32[$8 + 192 >> 2] + 4 >> 2];
 HEAP16[$8 + 114 >> 1] = HEAP32[HEAP32[$8 + 192 >> 2] >> 2];
 HEAP32[$8 + 152 >> 2] = HEAP32[HEAP32[$8 + 192 >> 2] + 44 >> 2];
 HEAP32[$8 + 156 >> 2] = HEAP32[HEAP32[$8 + 192 >> 2] + 48 >> 2];
 $0 = HEAP32[HEAP32[$8 + 192 >> 2] + 36 >> 2];
 $1 = HEAP32[HEAP32[$8 + 192 >> 2] + 40 >> 2];
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 88 | 0, HEAP32[$8 + 188 >> 2]);
 $2 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$8 + 188 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 56 | 0, HEAP32[$8 + 184 >> 2]);
 $3 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$8 + 184 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 32 | 0, HEAP32[$8 + 180 >> 2]);
 $4 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$8 + 180 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 8 | 0, HEAP32[$8 + 176 >> 2]);
 tflite__reference_integer_ops__ConvPerChannel_28tflite__ConvParams_20const__2c_20int_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($8 + 112 | 0, $0, $1, $8 + 88 | 0, $2, $8 + 56 | 0, $3, $8 + 32 | 0, $4, $8 + 8 | 0, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$8 + 176 >> 2]));
 $0 = $8 + 88 | 0;
 $1 = $8 + 56 | 0;
 $2 = $8 + 32 | 0;
 tflite__RuntimeShape___RuntimeShape_28_29($8 + 8 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($2);
 tflite__RuntimeShape___RuntimeShape_28_29($1);
 tflite__RuntimeShape___RuntimeShape_28_29($0);
 global$0 = $8 + 208 | 0;
}
function jslNewStringFromLexer($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 128 | 0;
 global$0 = $2;
 HEAP32[$2 + 120 >> 2] = $0;
 HEAP32[$2 + 116 >> 2] = $1;
 HEAP32[$2 + 112 >> 2] = (HEAP32[$2 + 116 >> 2] + 1 | 0) - jsvStringIteratorGetIndex(HEAP32[$2 + 120 >> 2]);
 HEAP32[$2 + 108 >> 2] = 0;
 label$1 : {
  if (HEAPU32[$2 + 112 >> 2] > 21) {
   HEAP32[$2 + 108 >> 2] = jsvNewFlatStringOfLength(HEAP32[$2 + 112 >> 2]);
   if (HEAP32[$2 + 108 >> 2]) {
    $0 = $2 - -64 | 0;
    HEAP32[$2 + 104 >> 2] = jsvGetFlatStringPointer(HEAP32[$2 + 108 >> 2]);
    $1 = HEAPU8[HEAP32[$2 + 120 >> 2] + 36 | 0];
    $3 = HEAP32[$2 + 104 >> 2];
    HEAP32[$2 + 104 >> 2] = $3 + 1;
    HEAP8[$3 | 0] = $1;
    jsvStringIteratorClone($0, HEAP32[$2 + 120 >> 2]);
    while (1) {
     if (jsvStringIteratorHasChar($2 - -64 | 0) & 1) {
      $0 = HEAP32[$2 + 112 >> 2] + -1 | 0;
      HEAP32[$2 + 112 >> 2] = $0;
      $0 = $0 >>> 0 > 0;
     } else {
      $0 = 0;
     }
     if ($0) {
      $0 = jsvStringIteratorGetCharAndNext($2 - -64 | 0);
      $1 = HEAP32[$2 + 104 >> 2];
      HEAP32[$2 + 104 >> 2] = $1 + 1;
      HEAP8[$1 | 0] = $0;
      continue;
     }
     break;
    }
    jsvStringIteratorFree($2 - -64 | 0);
    HEAP32[$2 + 124 >> 2] = HEAP32[$2 + 108 >> 2];
    break label$1;
   }
  }
  HEAP32[$2 + 108 >> 2] = jsvNewWithFlags(27);
  if (!HEAP32[$2 + 108 >> 2]) {
   HEAP32[$2 + 124 >> 2] = 0;
   break label$1;
  }
  $0 = $2 + 16 | 0;
  HEAP32[$2 + 60 >> 2] = jsvLockAgain(HEAP32[$2 + 108 >> 2]);
  HEAP8[HEAP32[$2 + 60 >> 2]] = HEAPU8[HEAP32[$2 + 120 >> 2] + 36 | 0];
  HEAP32[$2 + 56 >> 2] = 1;
  HEAP32[$2 + 52 >> 2] = HEAP32[$2 + 112 >> 2];
  jsvStringIteratorClone($0, HEAP32[$2 + 120 >> 2]);
  while (1) {
   label$10 : {
    if (jsvStringIteratorHasChar($2 + 16 | 0) & 1) {
     $0 = HEAP32[$2 + 112 >> 2] + -1 | 0;
     HEAP32[$2 + 112 >> 2] = $0;
     $0 = $0 >>> 0 > 0;
    } else {
     $0 = 0;
    }
    if (!$0) {
     break label$10;
    }
    HEAP8[$2 + 15 | 0] = jsvStringIteratorGetCharAndNext($2 + 16 | 0);
    if (HEAPU32[$2 + 56 >> 2] >= jsvGetMaxCharactersInVar(HEAP32[$2 + 60 >> 2]) >>> 0) {
     jsvSetCharactersInVar(HEAP32[$2 + 60 >> 2], HEAP32[$2 + 56 >> 2]);
     HEAP32[$2 + 8 >> 2] = jsvNewWithFlags(41);
     if (!HEAP32[$2 + 8 >> 2]) {
      break label$10;
     }
     jsvSetLastChild(HEAP32[$2 + 60 >> 2], jsvGetRef(HEAP32[$2 + 8 >> 2]) & 65535);
     jsvUnLock(HEAP32[$2 + 60 >> 2]);
     HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 8 >> 2];
     HEAP32[$2 + 56 >> 2] = 0;
    }
    $0 = HEAPU8[$2 + 15 | 0];
    $1 = HEAP32[$2 + 60 >> 2];
    $3 = HEAP32[$2 + 56 >> 2];
    HEAP32[$2 + 56 >> 2] = $3 + 1;
    HEAP8[$1 + $3 | 0] = $0;
    continue;
   }
   break;
  }
  jsvSetCharactersInVar(HEAP32[$2 + 60 >> 2], HEAP32[$2 + 56 >> 2]);
  jsvUnLock(HEAP32[$2 + 60 >> 2]);
  jsvStringIteratorFree($2 + 16 | 0);
  HEAP32[$2 + 124 >> 2] = HEAP32[$2 + 108 >> 2];
 }
 global$0 = $2 + 128 | 0;
 return HEAP32[$2 + 124 >> 2];
}
function tflite__reference_ops__FullyConnected_28tflite__FullyConnectedParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0, $10 = Math_fround(0);
 $9 = global$0 - 96 | 0;
 global$0 = $9;
 HEAP32[$9 + 92 >> 2] = $0;
 HEAP32[$9 + 88 >> 2] = $1;
 HEAP32[$9 + 84 >> 2] = $2;
 HEAP32[$9 + 80 >> 2] = $3;
 HEAP32[$9 + 76 >> 2] = $4;
 HEAP32[$9 + 72 >> 2] = $5;
 HEAP32[$9 + 68 >> 2] = $6;
 HEAP32[$9 + 64 >> 2] = $7;
 HEAP32[$9 + 60 >> 2] = $8;
 HEAPF32[$9 + 56 >> 2] = HEAPF32[HEAP32[$9 + 92 >> 2] + 28 >> 2];
 HEAPF32[$9 + 52 >> 2] = HEAPF32[HEAP32[$9 + 92 >> 2] + 32 >> 2];
 HEAP32[$9 + 48 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 64 >> 2]);
 HEAP32[$9 + 44 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 80 >> 2]);
 HEAP32[$9 + 40 >> 2] = tflite__FlatSizeSkipDim_28tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$9 + 64 >> 2], HEAP32[$9 + 48 >> 2] - 1 | 0);
 HEAP32[$9 + 36 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$9 + 80 >> 2], HEAP32[$9 + 44 >> 2] - 2 | 0, HEAP32[$9 + 64 >> 2], HEAP32[$9 + 48 >> 2] - 1 | 0);
 HEAP32[$9 + 32 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 80 >> 2], HEAP32[$9 + 44 >> 2] - 1 | 0);
 HEAP32[$9 + 28 >> 2] = 0;
 while (1) {
  if (HEAP32[$9 + 28 >> 2] < HEAP32[$9 + 40 >> 2]) {
   HEAP32[$9 + 24 >> 2] = 0;
   while (1) {
    if (HEAP32[$9 + 24 >> 2] < HEAP32[$9 + 36 >> 2]) {
     HEAPF32[$9 + 20 >> 2] = 0;
     HEAP32[$9 + 16 >> 2] = 0;
     while (1) {
      if (HEAP32[$9 + 16 >> 2] < HEAP32[$9 + 32 >> 2]) {
       HEAPF32[$9 + 20 >> 2] = HEAPF32[$9 + 20 >> 2] + Math_fround(HEAPF32[HEAP32[$9 + 84 >> 2] + (HEAP32[$9 + 16 >> 2] + Math_imul(HEAP32[$9 + 28 >> 2], HEAP32[$9 + 32 >> 2]) << 2) >> 2] * HEAPF32[HEAP32[$9 + 76 >> 2] + (HEAP32[$9 + 16 >> 2] + Math_imul(HEAP32[$9 + 24 >> 2], HEAP32[$9 + 32 >> 2]) << 2) >> 2]);
       HEAP32[$9 + 16 >> 2] = HEAP32[$9 + 16 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAPF32[$9 + 12 >> 2] = 0;
     if (HEAP32[$9 + 68 >> 2]) {
      HEAPF32[$9 + 12 >> 2] = HEAPF32[HEAP32[$9 + 68 >> 2] + (HEAP32[$9 + 24 >> 2] << 2) >> 2];
     }
     $10 = float_20tflite__ActivationFunctionWithMinMax_float__28float_2c_20float_2c_20float_29(Math_fround(HEAPF32[$9 + 20 >> 2] + HEAPF32[$9 + 12 >> 2]), HEAPF32[$9 + 56 >> 2], HEAPF32[$9 + 52 >> 2]);
     HEAPF32[HEAP32[$9 + 60 >> 2] + (HEAP32[$9 + 24 >> 2] + Math_imul(HEAP32[$9 + 36 >> 2], HEAP32[$9 + 28 >> 2]) << 2) >> 2] = $10;
     HEAP32[$9 + 24 >> 2] = HEAP32[$9 + 24 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$9 + 28 >> 2] = HEAP32[$9 + 28 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $9 + 96 | 0;
}
function jspeGetBinaryExpressionPrecedence($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  label$2 : {
   $0 = HEAP32[$1 + 8 >> 2] + -37 | 0;
   if ($0 >>> 0 > 149) {
    break label$2;
   }
   label$3 : {
    switch ($0 - 1 | 0) {
    case 122:
     HEAP32[$1 + 12 >> 2] = 1;
     break label$1;
    case 120:
     HEAP32[$1 + 12 >> 2] = 2;
     break label$1;
    case 86:
     HEAP32[$1 + 12 >> 2] = 3;
     break label$1;
    case 56:
     HEAP32[$1 + 12 >> 2] = 4;
     break label$1;
    case 0:
     HEAP32[$1 + 12 >> 2] = 5;
     break label$1;
    case 100:
    case 101:
    case 102:
    case 103:
     HEAP32[$1 + 12 >> 2] = 6;
     break label$1;
    case 22:
    case 24:
    case 104:
    case 107:
    case 148:
     HEAP32[$1 + 12 >> 2] = 7;
     break label$1;
    case 147:
     HEAP32[$1 + 12 >> 2] = HEAP32[80549] & 256 ? 0 : 7;
     break label$1;
    case 105:
    case 108:
    case 109:
     HEAP32[$1 + 12 >> 2] = 8;
     break label$1;
    case 5:
    case 7:
     HEAP32[$1 + 12 >> 2] = 9;
     break label$1;
    case 1:
    case 2:
    case 3:
    case 6:
    case 8:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 23:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 87:
    case 88:
    case 89:
    case 90:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 97:
    case 98:
    case 99:
    case 106:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
    case 119:
    case 121:
    case 123:
    case 124:
    case 125:
    case 126:
    case 127:
    case 128:
    case 129:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 136:
    case 137:
    case 138:
    case 139:
    case 140:
    case 141:
    case 142:
    case 143:
    case 144:
    case 145:
    case 146:
     break label$2;
    default:
     break label$3;
    }
   }
   HEAP32[$1 + 12 >> 2] = 10;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 return HEAP32[$1 + 12 >> 2];
}
function tflite__ops__micro__activations__SoftmaxQuantized_28TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__2c_20tflite__SoftmaxParams_20const__29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 176 | 0;
 global$0 = $3;
 HEAP32[$3 + 172 >> 2] = $0;
 HEAP32[$3 + 168 >> 2] = $1;
 HEAP32[$3 + 164 >> 2] = $2;
 label$1 : {
  if (HEAP32[HEAP32[$3 + 172 >> 2] + 8 >> 2] == 3) {
   $0 = HEAP32[$3 + 164 >> 2];
   tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($3 + 136 | 0, HEAP32[$3 + 172 >> 2]);
   $1 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$3 + 172 >> 2]);
   tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($3 + 104 | 0, HEAP32[$3 + 168 >> 2]);
   void_20tflite__reference_ops__Softmax_unsigned_20char_2c_20unsigned_20char__28tflite__SoftmaxParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29($0, $3 + 136 | 0, $1, $3 + 104 | 0, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$3 + 168 >> 2]));
   $0 = $3 + 136 | 0;
   tflite__RuntimeShape___RuntimeShape_28_29($3 + 104 | 0);
   break label$1;
  }
  label$3 : {
   if (HEAP32[HEAP32[$3 + 168 >> 2] + 8 >> 2] == 7) {
    $0 = HEAP32[$3 + 164 >> 2];
    tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($3 + 80 | 0, HEAP32[$3 + 172 >> 2]);
    $1 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$3 + 172 >> 2]);
    tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($3 + 56 | 0, HEAP32[$3 + 168 >> 2]);
    void_20tflite__reference_ops__Softmax_signed_20char_2c_20short__28tflite__SoftmaxParams_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20short__29($0, $3 + 80 | 0, $1, $3 + 56 | 0, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$3 + 168 >> 2]));
    $0 = $3 + 80 | 0;
    tflite__RuntimeShape___RuntimeShape_28_29($3 + 56 | 0);
    break label$3;
   }
   $0 = HEAP32[$3 + 164 >> 2];
   tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($3 + 32 | 0, HEAP32[$3 + 172 >> 2]);
   $1 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$3 + 172 >> 2]);
   tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($3 + 8 | 0, HEAP32[$3 + 168 >> 2]);
   void_20tflite__reference_ops__Softmax_signed_20char_2c_20signed_20char__28tflite__SoftmaxParams_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($0, $3 + 32 | 0, $1, $3 + 8 | 0, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$3 + 168 >> 2]));
   $0 = $3 + 32 | 0;
   tflite__RuntimeShape___RuntimeShape_28_29($3 + 8 | 0);
  }
 }
 tflite__RuntimeShape___RuntimeShape_28_29($0);
 global$0 = $3 + 176 | 0;
}
function jswrap_graphics_createImage($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 96 | 0;
 global$0 = $1;
 HEAP32[$1 + 88 >> 2] = $0;
 label$1 : {
  if (!(jsvIsString(HEAP32[$1 + 88 >> 2]) & 1)) {
   jsExceptionHere(3, 127423, 0);
   HEAP32[$1 + 92 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 84 >> 2] = 0;
  HEAP32[$1 + 80 >> 2] = 0;
  HEAP32[$1 + 76 >> 2] = 0;
  HEAP32[$1 + 72 >> 2] = 0;
  HEAP32[$1 + 68 >> 2] = 0;
  jsvStringIteratorNew($1 + 32 | 0, HEAP32[$1 + 88 >> 2], 0);
  while (1) {
   if (jsvStringIteratorHasChar($1 + 32 | 0) & 1) {
    HEAP8[$1 + 31 | 0] = jsvStringIteratorGetCharAndNext($1 + 32 | 0);
    label$5 : {
     if (HEAP8[$1 + 31 | 0] == 10) {
      if (!(HEAP32[$1 + 84 >> 2] | HEAP32[$1 + 80 >> 2])) {
       HEAP32[$1 + 68 >> 2] = 1;
       break label$5;
      }
      HEAP32[$1 + 84 >> 2] = 0;
      HEAP32[$1 + 80 >> 2] = HEAP32[$1 + 80 >> 2] + 1;
      break label$5;
     }
     if (HEAP32[$1 + 80 >> 2] >= HEAP32[$1 + 72 >> 2]) {
      HEAP32[$1 + 72 >> 2] = HEAP32[$1 + 80 >> 2] + 1;
     }
     HEAP32[$1 + 84 >> 2] = HEAP32[$1 + 84 >> 2] + 1;
     if (HEAP32[$1 + 84 >> 2] > HEAP32[$1 + 76 >> 2]) {
      HEAP32[$1 + 76 >> 2] = HEAP32[$1 + 84 >> 2];
     }
    }
    continue;
   }
   break;
  }
  jsvStringIteratorFree($1 + 32 | 0);
  HEAP32[$1 + 24 >> 2] = jsvNewWithFlags(5);
  if (!HEAP32[$1 + 24 >> 2]) {
   HEAP32[$1 + 92 >> 2] = 0;
   break label$1;
  }
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 24 >> 2], 127442, jsvNewFromInteger(HEAP32[$1 + 76 >> 2]));
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 24 >> 2], 127448, jsvNewFromInteger(HEAP32[$1 + 72 >> 2]));
  HEAP32[$1 + 20 >> 2] = Math_imul(HEAP32[$1 + 76 >> 2], HEAP32[$1 + 72 >> 2]) + 7 >> 3;
  HEAP32[$1 + 16 >> 2] = jsvNewStringOfLength(HEAP32[$1 + 20 >> 2], 0);
  if (!HEAP32[$1 + 16 >> 2]) {
   jsvUnLock(HEAP32[$1 + 24 >> 2]);
   HEAP32[$1 + 92 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 84 >> 2] = 0;
  HEAP32[$1 + 80 >> 2] = 0;
  jsvStringIteratorNew($1 + 32 | 0, HEAP32[$1 + 88 >> 2], HEAP32[$1 + 68 >> 2]);
  while (1) {
   if (jsvStringIteratorHasChar($1 + 32 | 0) & 1) {
    HEAP8[$1 + 15 | 0] = jsvStringIteratorGetCharAndNext($1 + 32 | 0);
    label$14 : {
     if (HEAP8[$1 + 15 | 0] == 10) {
      HEAP32[$1 + 84 >> 2] = 0;
      HEAP32[$1 + 80 >> 2] = HEAP32[$1 + 80 >> 2] + 1;
      break label$14;
     }
     if (HEAP8[$1 + 15 | 0] != 32) {
      HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 84 >> 2] + Math_imul(HEAP32[$1 + 80 >> 2], HEAP32[$1 + 76 >> 2]);
      jsvSetCharInString(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 8 >> 2] >>> 3, 128 >> (HEAP32[$1 + 8 >> 2] & 7) << 24 >> 24);
     }
     HEAP32[$1 + 84 >> 2] = HEAP32[$1 + 84 >> 2] + 1;
    }
    continue;
   }
   break;
  }
  jsvStringIteratorFree($1 + 32 | 0);
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 24 >> 2], 127455, HEAP32[$1 + 16 >> 2]);
  HEAP32[$1 + 92 >> 2] = HEAP32[$1 + 24 >> 2];
 }
 global$0 = $1 + 96 | 0;
 return HEAP32[$1 + 92 >> 2];
}
function jsfBankListFiles($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 112 | 0;
 global$0 = $5;
 HEAP32[$5 + 108 >> 2] = $0;
 HEAP32[$5 + 104 >> 2] = 134217728;
 HEAP32[$5 + 100 >> 2] = $1;
 HEAP32[$5 + 96 >> 2] = $2;
 HEAP32[$5 + 92 >> 2] = $3;
 HEAP32[$5 + 88 >> 2] = $4;
 $0 = $5 + 56 | 0;
 HEAP32[$0 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
 if (jsfGetFileHeader(HEAP32[$5 + 104 >> 2], $0, 1) & 1) {
  while (1) {
   label$3 : {
    if (!HEAP32[$5 + 60 >> 2]) {
     break label$3;
    }
    HEAP32[$5 + 52 >> 2] = jsfGetFileFlags($5 + 56 | 0);
    if (!(!HEAP32[$5 + 96 >> 2] | HEAP32[$5 + 96 >> 2] & HEAP32[$5 + 52 >> 2]) | HEAP32[$5 + 92 >> 2] & HEAP32[$5 + 52 >> 2]) {
     break label$3;
    }
    if (HEAP32[$5 + 52 >> 2] & 64) {
     HEAP32[$5 + 48 >> 2] = 0;
     while (1) {
      if (HEAP32[$5 + 48 >> 2] + 1 >>> 0 < 28 ? HEAP8[(HEAP32[$5 + 48 >> 2] + $5 | 0) + 61 | 0] : 0) {
       HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 48 >> 2] + 1;
       continue;
      }
      break;
     }
     if (HEAP8[HEAP32[$5 + 48 >> 2] + ($5 + 60 | 0) | 0] != 1) {
      break label$3;
     }
     if (HEAP32[$5 + 96 >> 2] & 64) {
      HEAP8[HEAP32[$5 + 48 >> 2] + ($5 + 60 | 0) | 0] = 0;
     }
    }
    HEAP32[$5 + 32 >> 2] = HEAP32[$5 + 84 >> 2];
    $0 = HEAP32[$5 + 80 >> 2];
    HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 76 >> 2];
    HEAP32[$5 + 28 >> 2] = $0;
    $0 = HEAP32[$5 + 72 >> 2];
    HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 68 >> 2];
    HEAP32[$5 + 20 >> 2] = $0;
    $0 = HEAP32[$5 + 64 >> 2];
    HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 60 >> 2];
    HEAP32[$5 + 12 >> 2] = $0;
    HEAP32[$5 + 44 >> 2] = jsfVarFromName($5 + 8 | 0);
    HEAP8[$5 + 43 | 0] = 1;
    if (HEAP32[$5 + 100 >> 2]) {
     HEAP32[$5 + 36 >> 2] = jswrap_string_match(HEAP32[$5 + 44 >> 2], HEAP32[$5 + 100 >> 2]);
     $0 = $5;
     if (jsvIsUndefined(HEAP32[$5 + 36 >> 2]) & 1) {
      $1 = 1;
     } else {
      $1 = jsvIsNull(HEAP32[$5 + 36 >> 2]);
     }
     HEAP8[$0 + 43 | 0] = ($1 ^ -1) & 1;
     jsvUnLock(HEAP32[$5 + 36 >> 2]);
    }
    if (!(!HEAP32[$5 + 88 >> 2] | !(HEAP8[$5 + 43 | 0] & 1))) {
     HEAP32[HEAP32[$5 + 88 >> 2] >> 2] = HEAP32[HEAP32[$5 + 88 >> 2] >> 2] << 1 | HEAP32[HEAP32[$5 + 88 >> 2] >> 2] >>> 31;
     $0 = HEAP32[HEAP32[$5 + 88 >> 2] >> 2] ^ HEAP32[$5 + 104 >> 2] ^ jsvGetIntegerAndUnLock(jswrap_espruino_CRC32(HEAP32[$5 + 44 >> 2]));
     HEAP32[HEAP32[$5 + 88 >> 2] >> 2] = $0;
    }
    label$15 : {
     if (!(!(HEAP8[$5 + 43 | 0] & 1) | !HEAP32[$5 + 108 >> 2])) {
      jsvArrayPushAndUnLock(HEAP32[$5 + 108 >> 2], HEAP32[$5 + 44 >> 2]);
      break label$15;
     }
     jsvUnLock(HEAP32[$5 + 44 >> 2]);
    }
   }
   if (jsfGetNextFileHeader($5 + 104 | 0, $5 + 56 | 0, 1) & 1) {
    continue;
   }
   break;
  }
 }
 global$0 = $5 + 112 | 0;
}
function utilTimerRemoveTask($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 8 >> 2] = 13;
 HEAP32[$2 + 4 >> 2] = $0;
 HEAP8[$2 + 3 | 0] = HEAPU8[324177];
 label$1 : {
  if (HEAPU8[$2 + 3 | 0] != HEAPU8[324178]) {
   HEAP8[$2 + 2 | 0] = HEAPU8[324178] + 15 & 15;
   HEAP8[$2 + 3 | 0] = HEAPU8[$2 + 3 | 0] + 15 & 15;
   while (1) {
    if (HEAPU8[$2 + 3 | 0] != HEAPU8[$2 + 2 | 0]) {
     if (FUNCTION_TABLE[HEAP32[$2 + 8 >> 2]](Math_imul(HEAPU8[$2 + 3 | 0], 25) + 324192 | 0, HEAP32[$2 + 4 >> 2]) & 1) {
      HEAP8[$2 + 1 | 0] = HEAPU8[$2 + 3 | 0] + 15 & 15;
      while (1) {
       if (HEAPU8[$2 + 1 | 0] != HEAPU8[$2 + 2 | 0]) {
        $1 = Math_imul(HEAPU8[$2 + 1 | 0], 25) + 324192 | 0;
        $4 = HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8 | (HEAPU8[$1 + 6 | 0] << 16 | HEAPU8[$1 + 7 | 0] << 24);
        $0 = Math_imul(HEAPU8[$2 + 3 | 0], 25) + 324192 | 0;
        $3 = HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24);
        HEAP8[$0 | 0] = $3;
        HEAP8[$0 + 1 | 0] = $3 >>> 8;
        HEAP8[$0 + 2 | 0] = $3 >>> 16;
        HEAP8[$0 + 3 | 0] = $3 >>> 24;
        HEAP8[$0 + 4 | 0] = $4;
        HEAP8[$0 + 5 | 0] = $4 >>> 8;
        HEAP8[$0 + 6 | 0] = $4 >>> 16;
        HEAP8[$0 + 7 | 0] = $4 >>> 24;
        HEAP8[$0 + 24 | 0] = HEAPU8[$1 + 24 | 0];
        $3 = HEAPU8[$1 + 20 | 0] | HEAPU8[$1 + 21 | 0] << 8 | (HEAPU8[$1 + 22 | 0] << 16 | HEAPU8[$1 + 23 | 0] << 24);
        $4 = HEAPU8[$1 + 16 | 0] | HEAPU8[$1 + 17 | 0] << 8 | (HEAPU8[$1 + 18 | 0] << 16 | HEAPU8[$1 + 19 | 0] << 24);
        HEAP8[$0 + 16 | 0] = $4;
        HEAP8[$0 + 17 | 0] = $4 >>> 8;
        HEAP8[$0 + 18 | 0] = $4 >>> 16;
        HEAP8[$0 + 19 | 0] = $4 >>> 24;
        HEAP8[$0 + 20 | 0] = $3;
        HEAP8[$0 + 21 | 0] = $3 >>> 8;
        HEAP8[$0 + 22 | 0] = $3 >>> 16;
        HEAP8[$0 + 23 | 0] = $3 >>> 24;
        $3 = HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8 | (HEAPU8[$1 + 14 | 0] << 16 | HEAPU8[$1 + 15 | 0] << 24);
        $1 = HEAPU8[$1 + 8 | 0] | HEAPU8[$1 + 9 | 0] << 8 | (HEAPU8[$1 + 10 | 0] << 16 | HEAPU8[$1 + 11 | 0] << 24);
        HEAP8[$0 + 8 | 0] = $1;
        HEAP8[$0 + 9 | 0] = $1 >>> 8;
        HEAP8[$0 + 10 | 0] = $1 >>> 16;
        HEAP8[$0 + 11 | 0] = $1 >>> 24;
        HEAP8[$0 + 12 | 0] = $3;
        HEAP8[$0 + 13 | 0] = $3 >>> 8;
        HEAP8[$0 + 14 | 0] = $3 >>> 16;
        HEAP8[$0 + 15 | 0] = $3 >>> 24;
        HEAP8[$2 + 3 | 0] = HEAPU8[$2 + 1 | 0];
        HEAP8[$2 + 1 | 0] = HEAPU8[$2 + 3 | 0] + 15 & 15;
        continue;
       }
       break;
      }
      HEAP8[324178] = HEAPU8[324178] + 1 & 15;
      HEAP8[$2 + 15 | 0] = 1;
      break label$1;
     } else {
      HEAP8[$2 + 3 | 0] = HEAPU8[$2 + 3 | 0] + 15 & 15;
      continue;
     }
    }
    break;
   }
  }
  HEAP8[$2 + 15 | 0] = 0;
 }
 global$0 = $2 + 16 | 0;
 return HEAP8[$2 + 15 | 0] & 1;
}
function jswrap_spi_send($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $3 = global$0 - 304 | 0;
 global$0 = $3;
 $4 = $3 + 200 | 0;
 HEAP32[$3 + 296 >> 2] = $0;
 HEAP32[$3 + 292 >> 2] = $1;
 HEAP8[$3 + 291 | 0] = $2;
 HEAP8[$3 + 290 | 0] = jsiGetDeviceFromClass(HEAP32[$3 + 296 >> 2]);
 label$1 : {
  if (!(jsspiGetSendFunction(HEAP32[$3 + 296 >> 2], $4, $4 + 4 | 0) & 1)) {
   HEAP32[$3 + 300 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 196 >> 2] = 0;
  if (!(HEAPU8[$3 + 290 | 0] < 24 | HEAPU8[$3 + 290 | 0] > 24)) {
   jshPinSetState(HEAPU8[$3 + 290 | 0], 1);
  }
  if (HEAPU8[$3 + 291 | 0] != 255) {
   jshPinOutput(HEAPU8[$3 + 291 | 0], 0);
  }
  label$5 : {
   if (jsvIsNumeric(HEAP32[$3 + 292 >> 2]) & 1) {
    $0 = $3 + 195 | 0;
    $1 = $3 + 200 | 0;
    HEAP8[$3 + 195 | 0] = jsvGetInteger(HEAP32[$3 + 292 >> 2]);
    FUNCTION_TABLE[HEAP32[$3 + 200 >> 2]]($0, $0, 1, $1 + 4 | 0);
    HEAP32[$3 + 196 >> 2] = jsvNewFromInteger(HEAPU8[$3 + 195 | 0]);
    break label$5;
   }
   label$7 : {
    if (jsvIsString(HEAP32[$3 + 292 >> 2]) & 1) {
     $0 = $3 + 24 | 0;
     HEAP32[$3 + 196 >> 2] = jsvNewWithFlags(27);
     jsvStringIteratorNew($0, HEAP32[$3 + 292 >> 2], 0);
     while (1) {
      if (jsvStringIteratorHasChar($3 + 24 | 0) & 1) {
       $0 = jspIsInterrupted() ^ -1;
      } else {
       $0 = 0;
      }
      if ($0 & 1) {
       jsvStringIteratorGetPtrAndNext($3 + 24 | 0, $3 + 20 | 0, $3 + 16 | 0);
       while (1) {
        if (HEAP32[$3 + 16 >> 2]) {
         $0 = $3;
         if (HEAPU32[$3 + 16 >> 2] > 128) {
          $1 = 128;
         } else {
          $1 = HEAP32[$3 + 16 >> 2];
         }
         HEAP32[$0 + 12 >> 2] = $1;
         $0 = $3 - -64 | 0;
         FUNCTION_TABLE[HEAP32[$3 + 200 >> 2]](HEAP32[$3 + 20 >> 2], $0, HEAP32[$3 + 12 >> 2], $3 + 204 | 0);
         jsvAppendStringBuf(HEAP32[$3 + 196 >> 2], $0, HEAP32[$3 + 12 >> 2]);
         HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 16 >> 2] - HEAP32[$3 + 12 >> 2];
         HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 12 >> 2] + HEAP32[$3 + 20 >> 2];
         continue;
        }
        break;
       }
       continue;
      }
      break;
     }
     jsvStringIteratorFree($3 + 24 | 0);
     break label$7;
    }
    HEAP32[$3 + 8 >> 2] = jsvIterateCallbackCount(HEAP32[$3 + 292 >> 2]);
    HEAP32[$3 + 196 >> 2] = jsvNewTypedArray(1, HEAP32[$3 + 8 >> 2]);
    if (HEAP32[$3 + 196 >> 2]) {
     HEAP32[$3 + 224 >> 2] = 0;
     HEAP32[$3 + 220 >> 2] = 0;
     $0 = $3 + 200 | 0;
     jsvArrayBufferIteratorNew($0 + 28 | 0, HEAP32[$3 + 196 >> 2], 0);
     jsvIterateBufferCallback(HEAP32[$3 + 292 >> 2], 591, $0);
     jsvArrayBufferIteratorFree($0 + 28 | 0);
    }
   }
  }
  if (HEAPU8[$3 + 291 | 0] != 255) {
   jshPinOutput(HEAPU8[$3 + 291 | 0], 1);
  }
  HEAP32[$3 + 300 >> 2] = HEAP32[$3 + 196 >> 2];
 }
 global$0 = $3 + 304 | 0;
 return HEAP32[$3 + 300 >> 2];
}
function tflite__ops__micro__depthwise_conv__EvalFloat_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteDepthwiseConvParams__2c_20tflite__ops__micro__depthwise_conv___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0, $9 = 0;
 $8 = global$0 - 208 | 0;
 global$0 = $8;
 $9 = $8 + 80 | 0;
 HEAP32[$8 + 204 >> 2] = $0;
 HEAP32[$8 + 200 >> 2] = $1;
 HEAP32[$8 + 196 >> 2] = $2;
 HEAP32[$8 + 192 >> 2] = $3;
 HEAP32[$8 + 188 >> 2] = $4;
 HEAP32[$8 + 184 >> 2] = $5;
 HEAP32[$8 + 180 >> 2] = $6;
 HEAP32[$8 + 176 >> 2] = $7;
 void_20tflite__CalculateActivationRange_float__28TfLiteFusedActivation_2c_20float__2c_20float__29(HEAP32[HEAP32[$8 + 196 >> 2] + 16 >> 2], $8 + 172 | 0, $8 + 168 | 0);
 HEAP8[$8 + 104 | 0] = 1;
 HEAP16[$8 + 106 >> 1] = HEAP32[HEAP32[$8 + 192 >> 2] >> 2];
 HEAP16[$8 + 108 >> 1] = HEAP32[HEAP32[$8 + 192 >> 2] + 4 >> 2];
 HEAP16[$8 + 114 >> 1] = HEAP32[HEAP32[$8 + 196 >> 2] + 4 >> 2];
 HEAP16[$8 + 116 >> 1] = HEAP32[HEAP32[$8 + 196 >> 2] + 8 >> 2];
 HEAP16[$8 + 118 >> 1] = HEAP32[HEAP32[$8 + 196 >> 2] + 20 >> 2];
 HEAP16[$8 + 120 >> 1] = HEAP32[HEAP32[$8 + 196 >> 2] + 24 >> 2];
 HEAP16[$8 + 122 >> 1] = HEAP32[HEAP32[$8 + 196 >> 2] + 12 >> 2];
 HEAPF32[$8 + 152 >> 2] = HEAPF32[$8 + 172 >> 2];
 HEAPF32[$8 + 156 >> 2] = HEAPF32[$8 + 168 >> 2];
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($9, HEAP32[$8 + 188 >> 2]);
 $0 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$8 + 188 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 48 | 0, HEAP32[$8 + 184 >> 2]);
 $1 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$8 + 184 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 24 | 0, HEAP32[$8 + 180 >> 2]);
 $2 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$8 + 180 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8, HEAP32[$8 + 176 >> 2]);
 tflite__reference_ops__DepthwiseConv_28tflite__DepthwiseParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($8 + 104 | 0, $8 + 80 | 0, $0, $8 + 48 | 0, $1, $8 + 24 | 0, $2, $8, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$8 + 176 >> 2]));
 $0 = $8 + 80 | 0;
 $1 = $8 + 48 | 0;
 $2 = $8 + 24 | 0;
 tflite__RuntimeShape___RuntimeShape_28_29($8);
 tflite__RuntimeShape___RuntimeShape_28_29($2);
 tflite__RuntimeShape___RuntimeShape_28_29($1);
 tflite__RuntimeShape___RuntimeShape_28_29($0);
 global$0 = $8 + 208 | 0;
}
function jsserialSoftwareFunc($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = global$0 - 80 | 0;
 global$0 = $2;
 HEAP8[$2 + 79 | 0] = $0;
 HEAP32[$2 + 72 >> 2] = $1;
 HEAP32[$2 + 68 >> 2] = HEAP32[$2 + 72 >> 2];
 if (jshIsPinValid(HEAPU8[HEAP32[$2 + 68 >> 2] + 5 | 0]) & 1) {
  $1 = $2 + 8 | 0;
  HEAP32[$2 + 64 >> 2] = (1 << HEAPU8[HEAP32[$2 + 68 >> 2] + 10 | 0]) - 1;
  HEAP32[$2 + 60 >> 2] = HEAPU8[HEAP32[$2 + 68 >> 2] + 10 | 0];
  HEAP32[$2 + 64 >> 2] = HEAPU8[$2 + 79 | 0] & (1 << HEAPU8[HEAP32[$2 + 68 >> 2] + 8 | 0]) - 1 | HEAP32[$2 + 64 >> 2] << HEAPU8[HEAP32[$2 + 68 >> 2] + 8 | 0];
  HEAP32[$2 + 60 >> 2] = HEAPU8[HEAP32[$2 + 68 >> 2] + 8 | 0] + HEAP32[$2 + 60 >> 2];
  HEAP32[$2 + 64 >> 2] = HEAP32[$2 + 64 >> 2] << 1;
  HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 60 >> 2] + 1;
  $0 = HEAP32[$2 + 68 >> 2];
  HEAP32[$2 + 48 >> 2] = jshGetTimeFromMilliseconds(1e3 / +(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)));
  HEAP32[$2 + 52 >> 2] = i64toi32_i32$HIGH_BITS;
  label$2 : {
   if (jstGetLastPinTimerTask(HEAPU8[HEAP32[$2 + 68 >> 2] + 5 | 0], $1) & 1) {
    $1 = HEAPU8[$2 + 8 | 0] | HEAPU8[$2 + 9 | 0] << 8 | (HEAPU8[$2 + 10 | 0] << 16 | HEAPU8[$2 + 11 | 0] << 24);
    $4 = $1;
    $3 = $1 + HEAP32[$2 + 48 >> 2] | 0;
    $1 = HEAP32[$2 + 52 >> 2] + ($1 >> 31) | 0;
    HEAP32[$2 + 40 >> 2] = $3;
    HEAP32[$2 + 44 >> 2] = $3 >>> 0 < $4 >>> 0 ? $1 + 1 | 0 : $1;
    break label$2;
   }
   $4 = jshGetSystemTime();
   $3 = i64toi32_i32$HIGH_BITS;
   $0 = jshGetTimeFromMilliseconds(1);
   $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
   $4 = $0 + $4 | 0;
   if ($4 >>> 0 < $0 >>> 0) {
    $3 = $3 + 1 | 0;
   }
   HEAP32[$2 + 40 >> 2] = $4;
   HEAP32[$2 + 44 >> 2] = $3;
  }
  HEAP32[$2 + 4 >> 2] = 0;
  while (1) {
   if (HEAP32[$2 + 60 >> 2]) {
    HEAP8[$2 + 3 | 0] = (HEAP32[$2 + 64 >> 2] & 1) != 0;
    HEAP32[$2 + 64 >> 2] = HEAP32[$2 + 64 >> 2] >> 1;
    HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 60 >> 2] + -1;
    jstPinOutputAtTime(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 44 >> 2], HEAP32[$2 + 68 >> 2] + 5 | 0, HEAP8[$2 + 3 | 0] & 1);
    $1 = HEAP32[$2 + 52 >> 2] + HEAP32[$2 + 44 >> 2] | 0;
    $3 = HEAP32[$2 + 40 >> 2];
    $4 = $3 + HEAP32[$2 + 48 >> 2] | 0;
    if ($4 >>> 0 < $3 >>> 0) {
     $1 = $1 + 1 | 0;
    }
    HEAP32[$2 + 40 >> 2] = $4;
    HEAP32[$2 + 44 >> 2] = $1;
    continue;
   }
   break;
  }
  $4 = HEAP32[$2 + 40 >> 2];
  $3 = HEAP32[$2 + 44 >> 2];
  $0 = HEAP32[$2 + 4 >> 2];
  $0 = __wasm_i64_mul(HEAP32[$2 + 48 >> 2], HEAP32[$2 + 52 >> 2], $0, $0 >> 31);
  $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
  $4 = $0 + $4 | 0;
  if ($4 >>> 0 < $0 >>> 0) {
   $3 = $3 + 1 | 0;
  }
  HEAP32[$2 + 40 >> 2] = $4;
  HEAP32[$2 + 44 >> 2] = $3;
  jstPinOutputAtTime(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 44 >> 2], HEAP32[$2 + 68 >> 2] + 5 | 0, 1);
 }
 global$0 = $2 + 80 | 0;
}
function jswrap_function_replaceWith($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 label$1 : {
  label$2 : {
   if (jsvIsFunction(HEAP32[$2 + 28 >> 2]) & 1) {
    if (jsvIsFunction(HEAP32[$2 + 24 >> 2]) & 1) {
     break label$2;
    }
   }
   jsExceptionHere(3, 124073, 0);
   break label$1;
  }
  if ((jsvIsNativeFunction(HEAP32[$2 + 28 >> 2]) & 1) != (jsvIsNativeFunction(HEAP32[$2 + 24 >> 2]) & 1)) {
   label$5 : {
    if (jsvIsNativeFunction(HEAP32[$2 + 24 >> 2]) & 1) {
     $0 = HEAP32[$2 + 28 >> 2];
     $1 = HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8 | 64;
     HEAP8[$0 + 13 | 0] = $1;
     HEAP8[$0 + 14 | 0] = $1 >>> 8;
     break label$5;
    }
    $0 = HEAP32[$2 + 28 >> 2];
    $1 = (HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & -65;
    HEAP8[$0 + 13 | 0] = $1;
    HEAP8[$0 + 14 | 0] = $1 >>> 8;
   }
  }
  if ((jsvIsFunctionReturn(HEAP32[$2 + 28 >> 2]) & 1) != (jsvIsFunctionReturn(HEAP32[$2 + 24 >> 2]) & 1)) {
   label$8 : {
    if (jsvIsFunctionReturn(HEAP32[$2 + 24 >> 2]) & 1) {
     $0 = HEAP32[$2 + 28 >> 2];
     $1 = HEAP32[$2 + 28 >> 2];
     $1 = (HEAPU8[$1 + 13 | 0] | HEAPU8[$1 + 14 | 0] << 8) & -64 | 8;
     HEAP8[$0 + 13 | 0] = $1;
     HEAP8[$0 + 14 | 0] = $1 >>> 8;
     break label$8;
    }
    $0 = HEAP32[$2 + 28 >> 2];
    $1 = HEAP32[$2 + 28 >> 2];
    $1 = (HEAPU8[$1 + 13 | 0] | HEAPU8[$1 + 14 | 0] << 8) & -64 | 7;
    HEAP8[$0 + 13 | 0] = $1;
    HEAP8[$0 + 14 | 0] = $1 >>> 8;
   }
  }
  $0 = $2 + 8 | 0;
  HEAP32[$2 + 20 >> 2] = jsvFindChildFromString(HEAP32[$2 + 28 >> 2], 124103, 0);
  HEAP32[$2 + 16 >> 2] = jsvFindChildFromString(HEAP32[$2 + 28 >> 2], 124108, 0);
  jsvRemoveAllChildren(HEAP32[$2 + 28 >> 2]);
  jsvObjectIteratorNew($0, HEAP32[$2 + 24 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue($2 + 8 | 0) & 1) {
    $0 = $2 + 8 | 0;
    HEAP32[$2 + 4 >> 2] = jsvObjectIteratorGetKey($0);
    jsvObjectIteratorNext($0);
    label$12 : {
     if (jsvIsStringEqual(HEAP32[$2 + 4 >> 2], 124103) & 1) {
      break label$12;
     }
     if (jsvIsStringEqual(HEAP32[$2 + 4 >> 2], 124108) & 1) {
      break label$12;
     }
     HEAP32[$2 >> 2] = jsvCopy(HEAP32[$2 + 4 >> 2], 1);
     if (HEAP32[$2 >> 2]) {
      jsvAddName(HEAP32[$2 + 28 >> 2], HEAP32[$2 >> 2]);
      jsvUnLock(HEAP32[$2 >> 2]);
     }
    }
    jsvUnLock(HEAP32[$2 + 4 >> 2]);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree($2 + 8 | 0);
  if (HEAP32[$2 + 20 >> 2]) {
   jsvAddName(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 20 >> 2]);
  }
  jsvUnLock(HEAP32[$2 + 20 >> 2]);
  if (HEAP32[$2 + 16 >> 2]) {
   jsvAddName(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 16 >> 2]);
  }
  jsvUnLock(HEAP32[$2 + 16 >> 2]);
 }
 global$0 = $2 + 32 | 0;
}
function jspGetVarNamedField($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 112 | 0;
 global$0 = $3;
 HEAP32[$3 + 104 >> 2] = $0;
 HEAP32[$3 + 100 >> 2] = $1;
 HEAP8[$3 + 99 | 0] = $2;
 HEAP32[$3 + 92 >> 2] = 0;
 if (jsvHasChildren(HEAP32[$3 + 104 >> 2]) & 1) {
  HEAP32[$3 + 92 >> 2] = jsvFindChildFromVar(HEAP32[$3 + 104 >> 2], HEAP32[$3 + 100 >> 2], 0);
 }
 if (!HEAP32[$3 + 92 >> 2]) {
  label$3 : {
   label$4 : {
    if (!(jsvIsArrayBuffer(HEAP32[$3 + 104 >> 2]) & 1)) {
     break label$4;
    }
    if (!(jsvIsInt(HEAP32[$3 + 100 >> 2]) & 1)) {
     break label$4;
    }
    HEAP32[$3 + 92 >> 2] = jsvMakeIntoVariableName(jsvNewFromInteger(jsvGetInteger(HEAP32[$3 + 100 >> 2])), HEAP32[$3 + 104 >> 2]);
    if (HEAP32[$3 + 92 >> 2]) {
     $0 = HEAP32[$3 + 92 >> 2];
     $1 = HEAP32[$3 + 92 >> 2];
     $1 = (HEAPU8[$1 + 13 | 0] | HEAPU8[$1 + 14 | 0] << 8) & -64 | 13;
     HEAP8[$0 + 13 | 0] = $1;
     HEAP8[$0 + 14 | 0] = $1 >>> 8;
    }
    break label$3;
   }
   label$6 : {
    label$7 : {
     if (!(jsvIsString(HEAP32[$3 + 104 >> 2]) & 1)) {
      break label$7;
     }
     if (!(jsvIsInt(HEAP32[$3 + 100 >> 2]) & 1)) {
      break label$7;
     }
     HEAP32[$3 + 88 >> 2] = jsvGetInteger(HEAP32[$3 + 100 >> 2]);
     label$8 : {
      label$9 : {
       if (HEAP32[$3 + 88 >> 2] < 0) {
        break label$9;
       }
       if (HEAP32[$3 + 88 >> 2] >= (jsvGetStringLength(HEAP32[$3 + 104 >> 2]) | 0)) {
        break label$9;
       }
       $0 = $3 + 87 | 0;
       HEAP8[$3 + 87 | 0] = jsvGetCharInString(HEAP32[$3 + 104 >> 2], HEAP32[$3 + 88 >> 2]);
       HEAP32[$3 + 92 >> 2] = jsvNewStringOfLength(1, $0);
       break label$8;
      }
      if (HEAP8[$3 + 99 | 0] & 1) {
       HEAP32[$3 + 92 >> 2] = jsvCreateNewChild(HEAP32[$3 + 104 >> 2], HEAP32[$3 + 100 >> 2], 0);
      }
     }
     break label$6;
    }
    $0 = $3 + 16 | 0;
    jsvGetString(HEAP32[$3 + 100 >> 2], $0, 64);
    HEAP32[$3 + 92 >> 2] = jspGetNamedFieldInParents(HEAP32[$3 + 104 >> 2], $0, HEAP8[$3 + 99 | 0] & 1);
    label$11 : {
     if (HEAP32[$3 + 92 >> 2]) {
      break label$11;
     }
     if (!(jsvIsFunction(HEAP32[$3 + 104 >> 2]) & 1)) {
      break label$11;
     }
     if (!(jsvIsStringEqual(HEAP32[$3 + 100 >> 2], 79516) & 1)) {
      break label$11;
     }
     HEAP32[$3 + 12 >> 2] = jsvNewWithFlags(5);
     HEAP32[$3 + 92 >> 2] = jsvAddNamedChild(HEAP32[$3 + 104 >> 2], HEAP32[$3 + 12 >> 2], 79516);
     jsvUnLock(HEAP32[$3 + 12 >> 2]);
    }
   }
  }
 }
 label$12 : {
  if (HEAP8[$3 + 99 | 0] & 1) {
   HEAP32[$3 + 108 >> 2] = HEAP32[$3 + 92 >> 2];
   break label$12;
  }
  HEAP32[$3 + 108 >> 2] = jsvSkipNameAndUnLock(HEAP32[$3 + 92 >> 2]);
 }
 global$0 = $3 + 112 | 0;
 return HEAP32[$3 + 108 >> 2];
}
function tflite__reference_ops__Softmax_28tflite__SoftmaxParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = Math_fround(0);
 $5 = global$0 + -64 | 0;
 global$0 = $5;
 HEAP32[$5 + 60 >> 2] = $0;
 HEAP32[$5 + 56 >> 2] = $1;
 HEAP32[$5 + 52 >> 2] = $2;
 HEAP32[$5 + 48 >> 2] = $3;
 HEAP32[$5 + 44 >> 2] = $4;
 HEAP32[$5 + 40 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 56 >> 2]) - 1;
 HEAP32[$5 + 36 >> 2] = tflite__MatchingFlatSizeSkipDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__29(HEAP32[$5 + 56 >> 2], HEAP32[$5 + 40 >> 2], HEAP32[$5 + 48 >> 2]);
 HEAP32[$5 + 32 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 56 >> 2], HEAP32[$5 + 40 >> 2], HEAP32[$5 + 48 >> 2], HEAP32[$5 + 40 >> 2]);
 HEAP32[$5 + 28 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 28 >> 2] < HEAP32[$5 + 36 >> 2]) {
   HEAPF32[$5 + 24 >> 2] = -3.4028234663852886e+38;
   HEAP32[$5 + 20 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 20 >> 2] < HEAP32[$5 + 32 >> 2]) {
     HEAPF32[$5 + 24 >> 2] = HEAPF32[float_20const__20std____2__max_float__28float_20const__2c_20float_20const__29($5 + 24 | 0, HEAP32[$5 + 52 >> 2] + (HEAP32[$5 + 20 >> 2] + Math_imul(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 32 >> 2]) << 2) | 0) >> 2];
     HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 20 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAPF32[$5 + 16 >> 2] = 0;
   HEAP32[$5 + 12 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 12 >> 2] < HEAP32[$5 + 32 >> 2]) {
     $6 = exp_28float_29(Math_fround(Math_fround(HEAPF32[HEAP32[$5 + 52 >> 2] + (HEAP32[$5 + 12 >> 2] + Math_imul(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 32 >> 2]) << 2) >> 2] - HEAPF32[$5 + 24 >> 2]) * Math_fround(HEAPF64[HEAP32[$5 + 60 >> 2] >> 3])));
     HEAPF32[$5 + 16 >> 2] = HEAPF32[$5 + 16 >> 2] + $6;
     HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 12 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 8 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 8 >> 2] < HEAP32[$5 + 32 >> 2]) {
     $6 = exp_28float_29(Math_fround(Math_fround(HEAPF32[HEAP32[$5 + 52 >> 2] + (HEAP32[$5 + 8 >> 2] + Math_imul(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 32 >> 2]) << 2) >> 2] - HEAPF32[$5 + 24 >> 2]) * Math_fround(HEAPF64[HEAP32[$5 + 60 >> 2] >> 3])));
     HEAPF32[HEAP32[$5 + 44 >> 2] + (HEAP32[$5 + 8 >> 2] + Math_imul(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 32 >> 2]) << 2) >> 2] = $6 / HEAPF32[$5 + 16 >> 2];
     HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 8 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 28 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $5 - -64 | 0;
}
function jswrap_string_match($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 label$1 : {
  if (!(jsvIsString(HEAP32[$2 + 40 >> 2]) & 1)) {
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  if (jsvIsUndefined(HEAP32[$2 + 36 >> 2]) & 1) {
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  if (jsvIsInstanceOf(HEAP32[$2 + 36 >> 2], 126e3) & 1) {
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 36 >> 2], 126007, jsvNewFromInteger(0));
   HEAP32[$2 + 32 >> 2] = jswrap_regexp_exec(HEAP32[$2 + 36 >> 2], HEAP32[$2 + 40 >> 2]);
   if (!(jswrap_regexp_hasFlag(HEAP32[$2 + 36 >> 2], 103) & 1)) {
    HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
    break label$1;
   }
   HEAP32[$2 + 28 >> 2] = jsvNewWithFlags(3);
   if (!HEAP32[$2 + 28 >> 2]) {
    HEAP32[$2 + 44 >> 2] = 0;
    break label$1;
   }
   while (1) {
    if (HEAP32[$2 + 32 >> 2]) {
     $0 = jsvIsNull(HEAP32[$2 + 32 >> 2]) ^ -1;
    } else {
     $0 = 0;
    }
    if ($0 & 1) {
     HEAP32[$2 + 24 >> 2] = jsvGetArrayItem(HEAP32[$2 + 32 >> 2], 0);
     HEAP32[$2 + 20 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$2 + 32 >> 2], 126017, 0));
     HEAP32[$2 + 16 >> 2] = jsvGetStringLength(HEAP32[$2 + 24 >> 2]);
     HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 20 >> 2] + HEAP32[$2 + 16 >> 2];
     jsvArrayPushAndUnLock(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2]);
     jsvUnLock(HEAP32[$2 + 32 >> 2]);
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 36 >> 2], 126007, jsvNewFromInteger(HEAP32[$2 + 12 >> 2] + (HEAP32[$2 + 16 >> 2] ? 0 : 1) | 0));
     HEAP32[$2 + 32 >> 2] = jswrap_regexp_exec(HEAP32[$2 + 36 >> 2], HEAP32[$2 + 40 >> 2]);
     continue;
    }
    break;
   }
   jsvUnLock(HEAP32[$2 + 32 >> 2]);
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 36 >> 2], 126007, jsvNewFromInteger(0));
   HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 28 >> 2];
   break label$1;
  }
  HEAP32[$2 + 36 >> 2] = jsvAsString(HEAP32[$2 + 36 >> 2]);
  HEAP32[$2 + 8 >> 2] = jswrap_string_indexOf(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], 0, 0);
  if (HEAP32[$2 + 8 >> 2] >= 0) {
   HEAP32[$2 + 4 >> 2] = jsvNewWithFlags(3);
   if (!HEAP32[$2 + 4 >> 2]) {
    jsvUnLock(HEAP32[$2 + 36 >> 2]);
    HEAP32[$2 + 44 >> 2] = 0;
    break label$1;
   }
   jsvArrayPush(HEAP32[$2 + 4 >> 2], HEAP32[$2 + 36 >> 2]);
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 4 >> 2], 126017, jsvNewFromInteger(HEAP32[$2 + 8 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 4 >> 2], 126023, HEAP32[$2 + 36 >> 2]);
   HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 4 >> 2];
   break label$1;
  }
  jsvUnLock(HEAP32[$2 + 36 >> 2]);
  HEAP32[$2 + 44 >> 2] = jsvNewWithFlags(2);
 }
 global$0 = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}
function jswrap_atob($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 128 | 0;
 global$0 = $1;
 HEAP32[$1 + 120 >> 2] = $0;
 label$1 : {
  if (!(jsvIsString(HEAP32[$1 + 120 >> 2]) & 1)) {
   HEAP32[$1 >> 2] = HEAP32[$1 + 120 >> 2];
   jsExceptionHere(1, 121401, $1);
   HEAP32[$1 + 124 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 116 >> 2] = jsvGetStringLength(HEAP32[$1 + 120 >> 2]);
  HEAP32[$1 + 112 >> 2] = Math_imul(HEAP32[$1 + 116 >> 2], 3) >>> 2;
  if ((jsvGetCharInString(HEAP32[$1 + 120 >> 2], HEAP32[$1 + 116 >> 2] - 1 | 0) & 255) == 61) {
   HEAP32[$1 + 112 >> 2] = HEAP32[$1 + 112 >> 2] + -1;
  }
  if ((jsvGetCharInString(HEAP32[$1 + 120 >> 2], HEAP32[$1 + 116 >> 2] - 2 | 0) & 255) == 61) {
   HEAP32[$1 + 112 >> 2] = HEAP32[$1 + 112 >> 2] + -1;
  }
  HEAP32[$1 + 108 >> 2] = jsvNewStringOfLength(HEAP32[$1 + 112 >> 2], 0);
  if (!HEAP32[$1 + 108 >> 2]) {
   HEAP32[$1 + 124 >> 2] = 0;
   break label$1;
  }
  $0 = $1 + 32 | 0;
  jsvStringIteratorNew($1 + 72 | 0, HEAP32[$1 + 120 >> 2], 0);
  jsvStringIteratorNew($0, HEAP32[$1 + 108 >> 2], 0);
  while (1) {
   if (jsvStringIteratorHasChar($1 + 72 | 0) & 1) {
    $0 = isWhitespace(jsvStringIteratorGetChar($1 + 72 | 0) << 24 >> 24);
   } else {
    $0 = 0;
   }
   if ($0 & 1) {
    jsvStringIteratorNext($1 + 72 | 0);
    continue;
   }
   break;
  }
  while (1) {
   if (jsvStringIteratorHasChar($1 + 72 | 0) & 1) {
    $0 = jspIsInterrupted() ^ -1;
   } else {
    $0 = 0;
   }
   if ($0 & 1) {
    HEAP32[$1 + 28 >> 2] = 0;
    HEAP32[$1 + 20 >> 2] = 0;
    HEAP32[$1 + 24 >> 2] = 0;
    while (1) {
     if (HEAP32[$1 + 24 >> 2] < 4) {
      if (jsvStringIteratorHasChar($1 + 72 | 0) & 1) {
       HEAP32[$1 + 16 >> 2] = jswrap_atob_decode(jsvStringIteratorGetCharAndNext($1 + 72 | 0) << 24 >> 24);
       if (HEAP32[$1 + 16 >> 2] >= 0) {
        HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 28 >> 2] | HEAP32[$1 + 16 >> 2] << Math_imul(3 - HEAP32[$1 + 24 >> 2] | 0, 6);
        HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 24 >> 2];
       }
      }
      HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 24 >> 2] + 1;
      continue;
     }
     break;
    }
    if (HEAP32[$1 + 20 >> 2] > 0) {
     jsvStringIteratorSetCharAndNext($1 + 32 | 0, HEAP32[$1 + 28 >> 2] >>> 16 << 24 >> 24);
    }
    if (HEAP32[$1 + 20 >> 2] > 1) {
     jsvStringIteratorSetCharAndNext($1 + 32 | 0, HEAP32[$1 + 28 >> 2] >>> 8 << 24 >> 24);
    }
    if (HEAP32[$1 + 20 >> 2] > 2) {
     jsvStringIteratorSetCharAndNext($1 + 32 | 0, HEAP32[$1 + 28 >> 2] << 24 >> 24);
    }
    continue;
   }
   break;
  }
  $0 = $1 + 32 | 0;
  jsvStringIteratorFree($1 + 72 | 0);
  jsvStringIteratorFree($0);
  HEAP32[$1 + 124 >> 2] = HEAP32[$1 + 108 >> 2];
 }
 global$0 = $1 + 128 | 0;
 return HEAP32[$1 + 124 >> 2];
}
function jswrap_espruino_nativeCall($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 176 | 0;
 global$0 = $3;
 HEAP32[$3 + 168 >> 2] = $0;
 HEAP32[$3 + 164 >> 2] = $1;
 HEAP32[$3 + 160 >> 2] = $2;
 HEAP32[$3 + 156 >> 2] = 0;
 label$1 : {
  if (!(jsvIsUndefined(HEAP32[$3 + 164 >> 2]) & 1)) {
   label$3 : {
    if (jsvIsString(HEAP32[$3 + 164 >> 2]) & 1) {
     HEAP32[$3 + 28 >> 2] = jslSetLex($3 + 32 | 0);
     jslInit(HEAP32[$3 + 164 >> 2]);
     HEAP8[$3 + 23 | 0] = 1;
     HEAP32[$3 + 16 >> 2] = 0;
     HEAP32[$3 + 24 >> 2] = nativeCallGetCType();
     label$5 : {
      if (HEAP32[$3 + 24 >> 2] >= 0) {
       $0 = HEAP32[$3 + 24 >> 2];
       $1 = HEAP32[$3 + 16 >> 2];
       HEAP32[$3 + 16 >> 2] = $1 + 1;
       HEAP32[$3 + 156 >> 2] = HEAP32[$3 + 156 >> 2] | $0 << Math_imul($1, 3);
       break label$5;
      }
      HEAP8[$3 + 23 | 0] = 0;
     }
     if (HEAP8[$3 + 23 | 0] & 1) {
      HEAP8[$3 + 23 | 0] = jslMatch(40) & 1;
     }
     while (1) {
      $0 = 0;
      label$9 : {
       if (!(HEAP8[$3 + 23 | 0] & 1)) {
        break label$9;
       }
       $0 = 0;
       if (!HEAP16[$3 + 34 >> 1]) {
        break label$9;
       }
       $0 = HEAP16[$3 + 34 >> 1] != 41;
      }
      if ($0) {
       HEAP32[$3 + 24 >> 2] = nativeCallGetCType();
       label$11 : {
        if (HEAP32[$3 + 24 >> 2] >= 0) {
         $0 = HEAP32[$3 + 24 >> 2];
         $1 = HEAP32[$3 + 16 >> 2];
         HEAP32[$3 + 16 >> 2] = $1 + 1;
         HEAP32[$3 + 156 >> 2] = HEAP32[$3 + 156 >> 2] | $0 << Math_imul($1, 3);
         if (HEAP16[$3 + 34 >> 1] != 41) {
          HEAP8[$3 + 23 | 0] = jslMatch(44) & 1;
         }
         break label$11;
        }
        HEAP8[$3 + 23 | 0] = 0;
       }
       continue;
      }
      break;
     }
     if (HEAP8[$3 + 23 | 0] & 1) {
      HEAP8[$3 + 23 | 0] = jslMatch(41) & 1;
     }
     jslKill();
     jslSetLex(HEAP32[$3 + 28 >> 2]);
     if (HEAP32[$3 + 156 >> 2] & -65536) {
      HEAP8[$3 + 23 | 0] = 0;
     }
     if (!(HEAP8[$3 + 23 | 0] & 1)) {
      HEAP32[$3 >> 2] = HEAP32[$3 + 16 >> 2];
      jsExceptionHere(1, 120022, $3);
      HEAP32[$3 + 172 >> 2] = 0;
      break label$1;
     }
     break label$3;
    }
    jsExceptionHere(1, 120068, 0);
    HEAP32[$3 + 172 >> 2] = 0;
    break label$1;
   }
  }
  HEAP32[$3 + 12 >> 2] = jsvNewNativeFunction(HEAP32[$3 + 168 >> 2], HEAP32[$3 + 156 >> 2] & 65535);
  if (HEAP32[$3 + 160 >> 2]) {
   HEAP32[$3 + 8 >> 2] = jsvAsFlatString(HEAP32[$3 + 160 >> 2]);
   jsvUnLock2(jsvAddNamedChild(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], 120086), HEAP32[$3 + 8 >> 2]);
  }
  HEAP32[$3 + 172 >> 2] = HEAP32[$3 + 12 >> 2];
 }
 global$0 = $3 + 176 | 0;
 return HEAP32[$3 + 172 >> 2];
}
function jswrap_e_dumpVariables() {
 var $0 = 0, $1 = 0;
 $0 = global$0 - 96 | 0;
 global$0 = $0;
 jsiConsolePrintf(120524, 0);
 HEAP32[$0 + 92 >> 2] = 0;
 while (1) {
  if (HEAPU32[$0 + 92 >> 2] < HEAPU32[35415]) {
   HEAP16[$0 + 90 >> 1] = HEAP32[$0 + 92 >> 2] + 1;
   HEAP32[$0 + 84 >> 2] = _jsvGetAddressOf(HEAPU16[$0 + 90 >> 1]);
   $1 = HEAP32[$0 + 84 >> 2];
   label$3 : {
    if (!((HEAPU8[$1 + 13 | 0] | HEAPU8[$1 + 14 | 0] << 8) & 63)) {
     break label$3;
    }
    if (jsvIsStringExt(HEAP32[$0 + 84 >> 2]) & 1) {
     break label$3;
    }
    HEAP32[$0 + 80 >> 2] = 1;
    label$4 : {
     if (jsvIsFlatString(HEAP32[$0 + 84 >> 2]) & 1) {
      HEAP32[$0 + 76 >> 2] = jsvGetFlatStringBlocks(HEAP32[$0 + 84 >> 2]);
      HEAP32[$0 + 92 >> 2] = HEAP32[$0 + 76 >> 2] + HEAP32[$0 + 92 >> 2];
      HEAP32[$0 + 80 >> 2] = HEAP32[$0 + 76 >> 2] + HEAP32[$0 + 80 >> 2];
      break label$4;
     }
     if (jsvHasCharacterData(HEAP32[$0 + 84 >> 2]) & 1) {
      HEAP16[$0 + 74 >> 1] = jsvGetLastChild(HEAP32[$0 + 84 >> 2]);
      while (1) {
       if (HEAPU16[$0 + 74 >> 1]) {
        HEAP32[$0 + 68 >> 2] = jsvLock(HEAPU16[$0 + 74 >> 1]);
        HEAP32[$0 + 80 >> 2] = HEAP32[$0 + 80 >> 2] + 1;
        HEAP16[$0 + 74 >> 1] = jsvGetLastChild(HEAP32[$0 + 68 >> 2]);
        jsvUnLock(HEAP32[$0 + 68 >> 2]);
        continue;
       }
       break;
      }
     }
    }
    $1 = HEAPU16[$0 + 90 >> 1];
    HEAP32[$0 + 52 >> 2] = HEAP32[$0 + 80 >> 2];
    HEAP32[$0 + 48 >> 2] = $1;
    jsiConsolePrintf(120548, $0 + 48 | 0);
    label$9 : {
     if (jsvIsName(HEAP32[$0 + 84 >> 2]) & 1) {
      HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 84 >> 2];
      jsiConsolePrintf(120555, $0 + 16 | 0);
      break label$9;
     }
     HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 84 >> 2];
     jsiConsolePrintf(120559, $0 + 32 | 0);
    }
    label$11 : {
     if (!(jsvHasSingleChild(HEAP32[$0 + 84 >> 2]) & 1)) {
      if (!(jsvHasChildren(HEAP32[$0 + 84 >> 2]) & 1)) {
       break label$11;
      }
     }
     HEAP16[$0 + 66 >> 1] = jsvGetFirstChild(HEAP32[$0 + 84 >> 2]);
     while (1) {
      if (HEAPU16[$0 + 66 >> 1]) {
       HEAP32[$0 + 60 >> 2] = jsvLock(HEAPU16[$0 + 66 >> 1]);
       HEAP32[$0 >> 2] = HEAPU16[$0 + 66 >> 1];
       jsiConsolePrintf(120561, $0);
       label$15 : {
        if (jsvHasChildren(HEAP32[$0 + 84 >> 2]) & 1) {
         HEAP16[$0 + 66 >> 1] = jsvGetNextSibling(HEAP32[$0 + 60 >> 2]);
         break label$15;
        }
        HEAP16[$0 + 66 >> 1] = 0;
       }
       jsvUnLock(HEAP32[$0 + 60 >> 2]);
       continue;
      }
      break;
     }
    }
    jsiConsolePrintString(120516);
   }
   HEAP32[$0 + 92 >> 2] = HEAP32[$0 + 92 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $0 + 96 | 0;
}
function jsiDumpObjectState($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = global$0 + -64 | 0;
 global$0 = $4;
 $5 = $4 + 40 | 0;
 HEAP32[$4 + 60 >> 2] = $0;
 HEAP32[$4 + 56 >> 2] = $1;
 HEAP32[$4 + 52 >> 2] = $2;
 HEAP32[$4 + 48 >> 2] = $3;
 HEAP32[$4 + 44 >> 2] = jsvGetInternalFunctionCheckerFor(HEAP32[$4 + 48 >> 2]);
 jsvObjectIteratorNew($5, HEAP32[$4 + 48 >> 2]);
 while (1) {
  if (jsvObjectIteratorHasValue($4 + 40 | 0) & 1) {
   $0 = $4 + 40 | 0;
   HEAP32[$4 + 36 >> 2] = jsvObjectIteratorGetKey($0);
   HEAP32[$4 + 32 >> 2] = jsvObjectIteratorGetValue($0);
   label$3 : {
    if (HEAP32[$4 + 44 >> 2]) {
     if (FUNCTION_TABLE[HEAP32[$4 + 44 >> 2]](HEAP32[$4 + 36 >> 2]) & 1) {
      break label$3;
     }
    }
    label$5 : {
     if (jsvIsStringEqual(HEAP32[$4 + 36 >> 2], 81145) & 1) {
      HEAP32[$4 + 28 >> 2] = jsvNewFromStringVar(HEAP32[$4 + 52 >> 2], 0, 2147483647);
      if (HEAP32[$4 + 28 >> 2]) {
       jsvAppendString(HEAP32[$4 + 28 >> 2], 81155);
       jsiDumpObjectState(HEAP32[$4 + 60 >> 2], HEAP32[$4 + 56 >> 2], HEAP32[$4 + 28 >> 2], HEAP32[$4 + 32 >> 2]);
       jsvUnLock(HEAP32[$4 + 28 >> 2]);
      }
      break label$5;
     }
     label$8 : {
      if (jsvIsStringEqualOrStartsWith(HEAP32[$4 + 36 >> 2], 81166, 1) & 1) {
       if (jsvIsArray(HEAP32[$4 + 32 >> 2]) & 1) {
        jsvObjectIteratorNew($4 + 24 | 0, HEAP32[$4 + 32 >> 2]);
        while (1) {
         if (jsvObjectIteratorHasValue($4 + 24 | 0) & 1) {
          $0 = $4 + 24 | 0;
          HEAP32[$4 + 20 >> 2] = jsvObjectIteratorGetValue($0);
          jsiDumpEvent(HEAP32[$4 + 60 >> 2], HEAP32[$4 + 56 >> 2], HEAP32[$4 + 52 >> 2], HEAP32[$4 + 36 >> 2], HEAP32[$4 + 20 >> 2]);
          jsvUnLock(HEAP32[$4 + 20 >> 2]);
          jsvObjectIteratorNext($0);
          continue;
         }
         break;
        }
        jsvObjectIteratorFree($4 + 24 | 0);
        break label$8;
       }
       jsiDumpEvent(HEAP32[$4 + 60 >> 2], HEAP32[$4 + 56 >> 2], HEAP32[$4 + 52 >> 2], HEAP32[$4 + 36 >> 2], HEAP32[$4 + 32 >> 2]);
       break label$8;
      }
      if (!(jsvIsNative(HEAP32[$4 + 32 >> 2]) & 1)) {
       $0 = HEAP32[$4 + 60 >> 2];
       $1 = HEAP32[$4 + 56 >> 2];
       $2 = HEAP32[$4 + 52 >> 2];
       HEAP32[$4 + 4 >> 2] = HEAP32[$4 + 36 >> 2];
       HEAP32[$4 >> 2] = $2;
       cbprintf($0, $1, 81170, $4);
       jsiDumpJSON(HEAP32[$4 + 60 >> 2], HEAP32[$4 + 56 >> 2], HEAP32[$4 + 32 >> 2], 0);
       FUNCTION_TABLE[HEAP32[$4 + 60 >> 2]](81179, HEAP32[$4 + 56 >> 2]);
      }
     }
    }
   }
   $0 = $4 + 40 | 0;
   jsvUnLock2(HEAP32[$4 + 32 >> 2], HEAP32[$4 + 36 >> 2]);
   jsvObjectIteratorNext($0);
   continue;
  }
  break;
 }
 jsvObjectIteratorFree($4 + 40 | 0);
 global$0 = $4 - -64 | 0;
}
function jsfGetJSONForFunctionWithCallback($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 + -64 | 0;
 global$0 = $4;
 HEAP32[$4 + 60 >> 2] = $0;
 HEAP32[$4 + 56 >> 2] = $1;
 HEAP32[$4 + 52 >> 2] = $2;
 HEAP32[$4 + 48 >> 2] = $3;
 HEAP32[$4 + 44 >> 2] = 0;
 jsvObjectIteratorNew($4 + 40 | 0, HEAP32[$4 + 60 >> 2]);
 HEAP8[$4 + 39 | 0] = 1;
 cbprintf(HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2], 122669, 0);
 while (1) {
  if (jsvObjectIteratorHasValue($4 + 40 | 0) & 1) {
   HEAP32[$4 + 32 >> 2] = jsvObjectIteratorGetKey($4 + 40 | 0);
   label$3 : {
    if (jsvIsFunctionParameter(HEAP32[$4 + 32 >> 2]) & 1) {
     label$5 : {
      if (HEAP8[$4 + 39 | 0] & 1) {
       HEAP8[$4 + 39 | 0] = 0;
       break label$5;
      }
      cbprintf(HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2], 122671, 0);
     }
     HEAP32[$4 + 28 >> 2] = jsvNewFromStringVar(HEAP32[$4 + 32 >> 2], 1, 2147483647);
     $0 = HEAP32[$4 + 52 >> 2];
     $1 = HEAP32[$4 + 48 >> 2];
     HEAP32[$4 >> 2] = HEAP32[$4 + 28 >> 2];
     cbprintf($0, $1, 122673, $4);
     jsvUnLock(HEAP32[$4 + 28 >> 2]);
     break label$3;
    }
    label$7 : {
     if (!(jsvIsString(HEAP32[$4 + 32 >> 2]) & 1)) {
      break label$7;
     }
     if (!(jsvIsStringEqual(HEAP32[$4 + 32 >> 2], 122676) & 1)) {
      break label$7;
     }
     HEAP32[$4 + 44 >> 2] = jsvObjectIteratorGetValue($4 + 40 | 0);
    }
   }
   $0 = $4 + 40 | 0;
   jsvUnLock(HEAP32[$4 + 32 >> 2]);
   jsvObjectIteratorNext($0);
   continue;
  }
  break;
 }
 jsvObjectIteratorFree($4 + 40 | 0);
 cbprintf(HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2], 122681, 0);
 label$8 : {
  if (jsvIsNative(HEAP32[$4 + 60 >> 2]) & 1) {
   cbprintf(HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2], 122684, 0);
   break label$8;
  }
  label$10 : {
   if (HEAP32[$4 + 44 >> 2]) {
    if (HEAP32[$4 + 56 >> 2] & 8) {
     $0 = HEAP32[$4 + 52 >> 2];
     $1 = HEAP32[$4 + 48 >> 2];
     HEAP32[$4 + 16 >> 2] = HEAP32[35430];
     cbprintf($0, $1, 122702, $4 + 16 | 0);
     break label$10;
    }
    HEAP8[$4 + 27 | 0] = (jsvGetStringIndexOf(HEAP32[$4 + 44 >> 2], 10) | 0) >= 0;
    FUNCTION_TABLE[HEAP32[$4 + 52 >> 2]](HEAP8[$4 + 27 | 0] & 1 ? 122707 : 122712, HEAP32[$4 + 48 >> 2]);
    if (jsvIsFunctionReturn(HEAP32[$4 + 60 >> 2]) & 1) {
     FUNCTION_TABLE[HEAP32[$4 + 52 >> 2]](122714, HEAP32[$4 + 48 >> 2]);
    }
    jslPrintTokenisedString(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2]);
    FUNCTION_TABLE[HEAP32[$4 + 52 >> 2]](HEAP8[$4 + 27 | 0] & 1 ? 122722 : 122725, HEAP32[$4 + 48 >> 2]);
    break label$10;
   }
   cbprintf(HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2], 122727, 0);
  }
 }
 jsvUnLock(HEAP32[$4 + 44 >> 2]);
 global$0 = $4 - -64 | 0;
}
function jswrap_require($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 256 | 0;
 global$0 = $1;
 HEAP32[$1 + 248 >> 2] = $0;
 label$1 : {
  if (!(jsvIsString(HEAP32[$1 + 248 >> 2]) & 1)) {
   HEAP32[$1 + 48 >> 2] = HEAP32[$1 + 248 >> 2];
   jsExceptionHere(3, 122912, $1 + 48 | 0);
   HEAP32[$1 + 252 >> 2] = 0;
   break label$1;
  }
  if (jsvGetString(HEAP32[$1 + 248 >> 2], $1 + 112 | 0, 128) >>> 0 >= 128) {
   jsExceptionHere(3, 122960, 0);
   HEAP32[$1 + 252 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 108 >> 2] = jswrap_modules_getModuleList();
  if (!HEAP32[$1 + 108 >> 2]) {
   HEAP32[$1 + 252 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 104 >> 2] = jsvSkipNameAndUnLock(jsvFindChildFromString(HEAP32[$1 + 108 >> 2], $1 + 112 | 0, 0));
  jsvUnLock(HEAP32[$1 + 108 >> 2]);
  if (HEAP32[$1 + 104 >> 2]) {
   HEAP32[$1 + 252 >> 2] = HEAP32[$1 + 104 >> 2];
   break label$1;
  }
  HEAP32[$1 + 100 >> 2] = jswGetBuiltInLibrary($1 + 112 | 0);
  if (HEAP32[$1 + 100 >> 2]) {
   HEAP32[$1 + 104 >> 2] = jsvNewNativeFunction(HEAP32[$1 + 100 >> 2], 0);
  }
  label$7 : {
   if (HEAP32[$1 + 104 >> 2]) {
    break label$7;
   }
   if (strlen($1 + 112 | 0) >>> 0 > 28) {
    break label$7;
   }
   jsfNameFromString($1 + 72 | 0, $1 + 112 | 0);
   HEAP32[$1 + 40 >> 2] = HEAP32[$1 + 96 >> 2];
   $0 = HEAP32[$1 + 92 >> 2];
   HEAP32[$1 + 32 >> 2] = HEAP32[$1 + 88 >> 2];
   HEAP32[$1 + 36 >> 2] = $0;
   $0 = HEAP32[$1 + 84 >> 2];
   HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 80 >> 2];
   HEAP32[$1 + 28 >> 2] = $0;
   $0 = HEAP32[$1 + 76 >> 2];
   HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 72 >> 2];
   HEAP32[$1 + 20 >> 2] = $0;
   HEAP32[$1 + 68 >> 2] = jsfReadFile($1 + 16 | 0, 0, 0);
   if (HEAP32[$1 + 68 >> 2]) {
    HEAP32[$1 + 104 >> 2] = jspEvaluateModule(HEAP32[$1 + 68 >> 2]);
    jsvUnLock(HEAP32[$1 + 68 >> 2]);
   }
  }
  if (!HEAP32[$1 + 104 >> 2]) {
   HEAP32[$1 + 64 >> 2] = jswGetBuiltInJSLibrary($1 + 112 | 0);
   if (HEAP32[$1 + 64 >> 2]) {
    HEAP32[$1 + 60 >> 2] = jsvNewNativeString(HEAP32[$1 + 64 >> 2], strlen(HEAP32[$1 + 64 >> 2]));
    if (HEAP32[$1 + 60 >> 2]) {
     HEAP32[$1 + 104 >> 2] = jspEvaluateModule(HEAP32[$1 + 60 >> 2]);
     jsvUnLock(HEAP32[$1 + 60 >> 2]);
    }
   }
  }
  label$12 : {
   if (HEAP32[$1 + 104 >> 2]) {
    HEAP32[$1 + 56 >> 2] = jswrap_modules_getModuleList();
    if (HEAP32[$1 + 56 >> 2]) {
     jsvObjectSetChild(HEAP32[$1 + 56 >> 2], $1 + 112 | 0, HEAP32[$1 + 104 >> 2]);
    }
    jsvUnLock(HEAP32[$1 + 56 >> 2]);
    break label$12;
   }
   HEAP32[$1 >> 2] = $1 + 112;
   jsExceptionHere(1, 122997, $1);
  }
  HEAP32[$1 + 252 >> 2] = HEAP32[$1 + 104 >> 2];
 }
 global$0 = $1 + 256 | 0;
 return HEAP32[$1 + 252 >> 2];
}
function jsvAddName($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 24 >> 2] = jsvRef(HEAP32[$2 + 24 >> 2]);
 label$1 : {
  if (!(jsvIsArray(HEAP32[$2 + 28 >> 2]) & 1)) {
   break label$1;
  }
  if (!(jsvIsInt(HEAP32[$2 + 24 >> 2]) & 1)) {
   break label$1;
  }
  $0 = HEAP32[$2 + 24 >> 2];
  HEAP32[$2 + 20 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
  if (HEAP32[$2 + 20 >> 2] >= (jsvGetArrayLength(HEAP32[$2 + 28 >> 2]) | 0)) {
   jsvSetArrayLength(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 20 >> 2] + 1 | 0);
  }
 }
 label$3 : {
  if (jsvGetLastChild(HEAP32[$2 + 28 >> 2]) & 65535) {
   HEAP32[$2 + 16 >> 2] = jsvLock(jsvGetLastChild(HEAP32[$2 + 28 >> 2]) & 65535);
   if (jsvIsArray(HEAP32[$2 + 28 >> 2]) & 1) {
    while (1) {
     if (HEAP32[$2 + 16 >> 2]) {
      $0 = (jsvCompareInteger(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 16 >> 2]) | 0) < 0;
     } else {
      $0 = 0;
     }
     if ($0) {
      HEAP16[$2 + 14 >> 1] = jsvGetPrevSibling(HEAP32[$2 + 16 >> 2]);
      jsvUnLock(HEAP32[$2 + 16 >> 2]);
      HEAP32[$2 + 16 >> 2] = jsvLockSafe(HEAPU16[$2 + 14 >> 1]);
      continue;
     }
     break;
    }
   }
   label$10 : {
    if (HEAP32[$2 + 16 >> 2]) {
     label$12 : {
      if (jsvGetNextSibling(HEAP32[$2 + 16 >> 2]) & 65535) {
       HEAP32[$2 + 8 >> 2] = jsvLock(jsvGetNextSibling(HEAP32[$2 + 16 >> 2]) & 65535);
       jsvSetPrevSibling(HEAP32[$2 + 8 >> 2], jsvGetRef(HEAP32[$2 + 24 >> 2]) & 65535);
       jsvSetNextSibling(HEAP32[$2 + 24 >> 2], jsvGetRef(HEAP32[$2 + 8 >> 2]) & 65535);
       jsvUnLock(HEAP32[$2 + 8 >> 2]);
       break label$12;
      }
      jsvSetLastChild(HEAP32[$2 + 28 >> 2], jsvGetRef(HEAP32[$2 + 24 >> 2]) & 65535);
     }
     jsvSetNextSibling(HEAP32[$2 + 16 >> 2], jsvGetRef(HEAP32[$2 + 24 >> 2]) & 65535);
     jsvSetPrevSibling(HEAP32[$2 + 24 >> 2], jsvGetRef(HEAP32[$2 + 16 >> 2]) & 65535);
     jsvUnLock(HEAP32[$2 + 16 >> 2]);
     break label$10;
    }
    HEAP32[$2 + 4 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$2 + 28 >> 2]) & 65535);
    jsvSetPrevSibling(HEAP32[$2 + 4 >> 2], jsvGetRef(HEAP32[$2 + 24 >> 2]) & 65535);
    jsvUnLock(HEAP32[$2 + 4 >> 2]);
    jsvSetNextSibling(HEAP32[$2 + 24 >> 2], jsvGetFirstChild(HEAP32[$2 + 28 >> 2]) & 65535);
    jsvSetFirstChild(HEAP32[$2 + 28 >> 2], jsvGetRef(HEAP32[$2 + 24 >> 2]) & 65535);
   }
   break label$3;
  }
  HEAP16[$2 + 2 >> 1] = jsvGetRef(HEAP32[$2 + 24 >> 2]);
  jsvSetFirstChild(HEAP32[$2 + 28 >> 2], HEAPU16[$2 + 2 >> 1]);
  jsvSetLastChild(HEAP32[$2 + 28 >> 2], HEAPU16[$2 + 2 >> 1]);
 }
 global$0 = $2 + 32 | 0;
}
function tflite__ops__micro__activations__SoftmaxPrepare_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = global$0 - 112 | 0;
 global$0 = $2;
 HEAP32[$2 + 104 >> 2] = $0;
 HEAP32[$2 + 100 >> 2] = $1;
 HEAP32[$2 + 96 >> 2] = HEAP32[HEAP32[$2 + 100 >> 2] + 12 >> 2];
 label$1 : {
  if ((tflite__NumInputs_28TfLiteNode_20const__29(HEAP32[$2 + 100 >> 2]) | 0) != 1) {
   $0 = HEAP32[HEAP32[$2 + 104 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 104 >> 2];
   $3 = tflite__NumInputs_28TfLiteNode_20const__29(HEAP32[$2 + 100 >> 2]);
   HEAP32[$2 + 20 >> 2] = 1;
   HEAP32[$2 + 16 >> 2] = $3;
   HEAP32[$2 + 12 >> 2] = 134554;
   HEAP32[$2 + 8 >> 2] = 134538;
   HEAP32[$2 + 4 >> 2] = 119;
   HEAP32[$2 >> 2] = 134453;
   FUNCTION_TABLE[$0]($1, 134427, $2);
   HEAP32[$2 + 108 >> 2] = 1;
   break label$1;
  }
  if ((tflite__NumOutputs_28TfLiteNode_20const__29(HEAP32[$2 + 100 >> 2]) | 0) != 1) {
   $0 = HEAP32[HEAP32[$2 + 104 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 104 >> 2];
   $3 = tflite__NumOutputs_28TfLiteNode_20const__29(HEAP32[$2 + 100 >> 2]);
   HEAP32[$2 + 52 >> 2] = 1;
   HEAP32[$2 + 48 >> 2] = $3;
   HEAP32[$2 + 44 >> 2] = 134554;
   HEAP32[$2 + 40 >> 2] = 134556;
   HEAP32[$2 + 36 >> 2] = 120;
   HEAP32[$2 + 32 >> 2] = 134453;
   FUNCTION_TABLE[$0]($1, 134427, $2 + 32 | 0);
   HEAP32[$2 + 108 >> 2] = 1;
   break label$1;
  }
  HEAP32[$2 + 92 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 104 >> 2], HEAP32[$2 + 100 >> 2], 0);
  $0 = global$0 - 16 | 0;
  HEAP32[$0 + 12 >> 2] = HEAP32[$2 + 92 >> 2];
  if (HEAP32[HEAP32[HEAP32[$0 + 12 >> 2] + 20 >> 2] >> 2] < 1) {
   $0 = HEAP32[HEAP32[$2 + 104 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 104 >> 2];
   HEAP32[$2 + 72 >> 2] = 134596;
   HEAP32[$2 + 68 >> 2] = 122;
   HEAP32[$2 + 64 >> 2] = 134453;
   FUNCTION_TABLE[$0]($1, 134573, $2 - -64 | 0);
   HEAP32[$2 + 108 >> 2] = 1;
   break label$1;
  }
  HEAP32[$2 + 88 >> 2] = tflite__GetOutput_28TfLiteContext__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 104 >> 2], HEAP32[$2 + 100 >> 2]);
  label$6 : {
   if (!HEAP32[HEAP32[$2 + 100 >> 2] + 8 >> 2]) {
    break label$6;
   }
  }
  HEAP32[$2 + 84 >> 2] = HEAP32[HEAP32[$2 + 100 >> 2] + 8 >> 2];
  HEAP32[$2 + 108 >> 2] = tflite__ops__micro__activations___28anonymous_20namespace_29__CalculateSoftmaxParams_28TfLiteContext__2c_20TfLiteTensor_20const__2c_20TfLiteTensor__2c_20TfLiteSoftmaxParams_20const__2c_20tflite__SoftmaxParams__29(HEAP32[$2 + 104 >> 2], HEAP32[$2 + 92 >> 2], HEAP32[$2 + 88 >> 2], HEAP32[$2 + 96 >> 2], HEAP32[$2 + 84 >> 2]);
 }
 global$0 = $2 + 112 | 0;
 return HEAP32[$2 + 108 >> 2];
}
function tflite__ops__micro__pooling___28anonymous_20namespace_29__AverageEvalQuantized_28TfLiteContext__2c_20TfLiteNode_20const__2c_20TfLitePoolParams_20const__2c_20tflite__ops__micro__pooling___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = global$0 - 176 | 0;
 global$0 = $6;
 HEAP32[$6 + 172 >> 2] = $0;
 HEAP32[$6 + 168 >> 2] = $1;
 HEAP32[$6 + 164 >> 2] = $2;
 HEAP32[$6 + 160 >> 2] = $3;
 HEAP32[$6 + 156 >> 2] = $4;
 HEAP32[$6 + 152 >> 2] = $5;
 HEAP32[$6 + 116 >> 2] = HEAP32[HEAP32[$6 + 164 >> 2] + 8 >> 2];
 HEAP32[$6 + 120 >> 2] = HEAP32[HEAP32[$6 + 164 >> 2] + 4 >> 2];
 HEAP32[$6 + 124 >> 2] = HEAP32[HEAP32[$6 + 164 >> 2] + 16 >> 2];
 HEAP32[$6 + 128 >> 2] = HEAP32[HEAP32[$6 + 164 >> 2] + 12 >> 2];
 HEAP16[$6 + 108 >> 1] = HEAP32[HEAP32[$6 + 160 >> 2] + 4 >> 2];
 HEAP16[$6 + 106 >> 1] = HEAP32[HEAP32[$6 + 160 >> 2] >> 2];
 HEAP32[$6 + 132 >> 2] = HEAP32[HEAP32[$6 + 160 >> 2] + 16 >> 2];
 HEAP32[$6 + 136 >> 2] = HEAP32[HEAP32[$6 + 160 >> 2] + 20 >> 2];
 label$2 : {
  if (HEAP32[HEAP32[$6 + 156 >> 2] + 8 >> 2] == 3) {
   tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($6 + 80 | 0, HEAP32[$6 + 156 >> 2]);
   $0 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$6 + 156 >> 2]);
   tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($6 + 48 | 0, HEAP32[$6 + 152 >> 2]);
   tflite__reference_ops__AveragePool_28tflite__PoolParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29($6 + 104 | 0, $6 + 80 | 0, $0, $6 + 48 | 0, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$6 + 152 >> 2]));
   $0 = $6 + 80 | 0;
   tflite__RuntimeShape___RuntimeShape_28_29($6 + 48 | 0);
   break label$2;
  }
  tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($6 + 24 | 0, HEAP32[$6 + 156 >> 2]);
  $0 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$6 + 156 >> 2]);
  tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($6, HEAP32[$6 + 152 >> 2]);
  tflite__reference_integer_ops__AveragePool_28tflite__PoolParams_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($6 + 104 | 0, $6 + 24 | 0, $0, $6, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$6 + 152 >> 2]));
  $0 = $6 + 24 | 0;
  tflite__RuntimeShape___RuntimeShape_28_29($6);
 }
 tflite__RuntimeShape___RuntimeShape_28_29($0);
 global$0 = $6 + 176 | 0;
}
function handlePipe($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 + -64 | 0;
 global$0 = $3;
 HEAP32[$3 + 56 >> 2] = $0;
 HEAP32[$3 + 52 >> 2] = $1;
 HEAP32[$3 + 48 >> 2] = $2;
 HEAP8[$3 + 47 | 0] = jsvGetBoolAndUnLock(jsvObjectGetChild(HEAP32[$3 + 48 >> 2], 124704, 0)) & 1;
 label$1 : {
  if (HEAP8[$3 + 47 | 0] & 1) {
   HEAP8[$3 + 63 | 0] = 0;
   break label$1;
  }
  HEAP32[$3 + 40 >> 2] = jsvObjectGetChild(HEAP32[$3 + 48 >> 2], 124494, 0);
  HEAP32[$3 + 36 >> 2] = jsvObjectGetChild(HEAP32[$3 + 48 >> 2], 124397, 0);
  HEAP32[$3 + 32 >> 2] = jsvObjectGetChild(HEAP32[$3 + 48 >> 2], 124503, 0);
  HEAP32[$3 + 28 >> 2] = jsvObjectGetChild(HEAP32[$3 + 48 >> 2], 124510, 0);
  HEAP8[$3 + 27 | 0] = 0;
  if (!(!HEAP32[$3 + 32 >> 2] | !HEAP32[$3 + 28 >> 2] | (!HEAP32[$3 + 36 >> 2] | !HEAP32[$3 + 40 >> 2]))) {
   HEAP32[$3 + 20 >> 2] = jspGetNamedField(HEAP32[$3 + 32 >> 2], 124361, 0);
   HEAP32[$3 + 16 >> 2] = jspGetNamedField(HEAP32[$3 + 28 >> 2], 124366, 0);
   label$4 : {
    label$5 : {
     if (!(jsvIsFunction(HEAP32[$3 + 20 >> 2]) & 1)) {
      break label$5;
     }
     if (!(jsvIsFunction(HEAP32[$3 + 16 >> 2]) & 1)) {
      break label$5;
     }
     HEAP32[$3 + 12 >> 2] = jspExecuteFunction(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 32 >> 2], 1, $3 + 36 | 0);
     if (HEAP32[$3 + 12 >> 2]) {
      HEAP32[$3 + 8 >> 2] = jsvGetLength(HEAP32[$3 + 12 >> 2]);
      if (HEAP32[$3 + 8 >> 2] > 0) {
       HEAP32[$3 + 4 >> 2] = jspExecuteFunction(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 28 >> 2], 1, $3 + 12 | 0);
       label$8 : {
        if (!(jsvIsBoolean(HEAP32[$3 + 4 >> 2]) & 1)) {
         break label$8;
        }
        if (jsvGetBool(HEAP32[$3 + 4 >> 2]) & 1) {
         break label$8;
        }
        jsvObjectSetChildAndUnLock(HEAP32[$3 + 48 >> 2], 124704, jsvNewFromBool(1));
       }
       jsvUnLock(HEAP32[$3 + 4 >> 2]);
       jsvSetInteger(HEAP32[$3 + 40 >> 2], jsvGetInteger(HEAP32[$3 + 40 >> 2]) + HEAP32[$3 + 8 >> 2] | 0);
      }
      jsvUnLock(HEAP32[$3 + 12 >> 2]);
      HEAP8[$3 + 27 | 0] = 1;
     }
     break label$4;
    }
    if (!(jsvIsFunction(HEAP32[$3 + 20 >> 2]) & 1)) {
     jsExceptionHere(1, 124714, 0);
    }
    if (!(jsvIsFunction(HEAP32[$3 + 16 >> 2]) & 1)) {
     jsExceptionHere(1, 124781, 0);
    }
   }
   jsvUnLock2(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 16 >> 2]);
  }
  if (!(HEAP8[$3 + 27 | 0] & 1)) {
   handlePipeClose(HEAP32[$3 + 56 >> 2], HEAP32[$3 + 52 >> 2], HEAP32[$3 + 48 >> 2]);
  }
  jsvUnLock3(HEAP32[$3 + 32 >> 2], HEAP32[$3 + 28 >> 2], HEAP32[$3 + 36 >> 2]);
  jsvUnLock(HEAP32[$3 + 40 >> 2]);
  HEAP8[$3 + 63 | 0] = HEAP8[$3 + 27 | 0] & 1;
 }
 global$0 = $3 - -64 | 0;
 return HEAP8[$3 + 63 | 0] & 1;
}
function _jswrap_drawImageLayerGetPixel($0, $1) {
 var $2 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 HEAP32[$2 + 32 >> 2] = HEAP32[HEAP32[$2 + 40 >> 2] + 180 >> 2] + 127;
 HEAP32[$2 + 28 >> 2] = HEAP32[HEAP32[$2 + 40 >> 2] + 184 >> 2] + 127;
 label$1 : {
  if (!(HEAP32[$2 + 32 >> 2] < 0 | HEAP32[$2 + 28 >> 2] < 0 | (HEAP32[$2 + 32 >> 2] >= HEAP32[HEAP32[$2 + 40 >> 2] + 156 >> 2] | HEAP32[$2 + 28 >> 2] >= HEAP32[HEAP32[$2 + 40 >> 2] + 160 >> 2]))) {
   HEAP32[$2 + 24 >> 2] = 0;
   HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 32 >> 2] >> 8;
   HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 28 >> 2] >> 8;
   label$3 : {
    if (HEAP32[HEAP32[$2 + 40 >> 2] + 44 >> 2] == 8) {
     jsvStringIteratorGoto(HEAP32[$2 + 40 >> 2] + 120 | 0, HEAP32[HEAP32[$2 + 40 >> 2] + 56 >> 2], (HEAP32[HEAP32[$2 + 40 >> 2] + 60 >> 2] + HEAP32[$2 + 20 >> 2] | 0) + Math_imul(HEAP32[$2 + 16 >> 2], HEAP32[HEAP32[$2 + 40 >> 2] + 80 >> 2]) | 0);
     HEAP32[$2 + 24 >> 2] = jsvStringIteratorGetChar(HEAP32[$2 + 40 >> 2] + 120 | 0) & 255;
     break label$3;
    }
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 20 >> 2] + Math_imul(HEAP32[$2 + 16 >> 2], HEAP32[HEAP32[$2 + 40 >> 2] + 36 >> 2]);
    HEAP32[$2 + 8 >> 2] = Math_imul(HEAP32[$2 + 12 >> 2], HEAP32[HEAP32[$2 + 40 >> 2] + 44 >> 2]);
    jsvStringIteratorGoto(HEAP32[$2 + 40 >> 2] + 120 | 0, HEAP32[HEAP32[$2 + 40 >> 2] + 56 >> 2], HEAP32[HEAP32[$2 + 40 >> 2] + 60 >> 2] + (HEAP32[$2 + 8 >> 2] >> 3) | 0);
    HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] & 7;
    HEAP32[$2 + 24 >> 2] = jsvStringIteratorGetChar(HEAP32[$2 + 40 >> 2] + 120 | 0) & 255;
    HEAP32[$2 + 4 >> 2] = 8 - (HEAP32[$2 + 8 >> 2] + HEAP32[HEAP32[$2 + 40 >> 2] + 44 >> 2] | 0);
    while (1) {
     if (HEAP32[$2 + 4 >> 2] < 0) {
      jsvStringIteratorNext(HEAP32[$2 + 40 >> 2] + 120 | 0);
      HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 24 >> 2] << 8 | jsvStringIteratorGetChar(HEAP32[$2 + 40 >> 2] + 120 | 0) & 255;
      HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + 8;
      continue;
     }
     break;
    }
    HEAP32[$2 + 24 >> 2] = HEAP32[HEAP32[$2 + 40 >> 2] + 72 >> 2] & HEAP32[$2 + 24 >> 2] >>> HEAP32[$2 + 4 >> 2];
   }
   if (HEAP32[HEAP32[$2 + 40 >> 2] + 52 >> 2] != HEAP32[$2 + 24 >> 2]) {
    if (HEAP32[HEAP32[$2 + 40 >> 2] + 64 >> 2]) {
     HEAP32[$2 + 24 >> 2] = HEAPU16[HEAP32[HEAP32[$2 + 40 >> 2] + 64 >> 2] + ((HEAP32[$2 + 24 >> 2] & HEAP32[HEAP32[$2 + 40 >> 2] + 68 >> 2]) << 1) >> 1];
    }
    HEAP32[HEAP32[$2 + 36 >> 2] >> 2] = HEAP32[$2 + 24 >> 2];
    HEAP8[$2 + 47 | 0] = 1;
    break label$1;
   }
  }
  HEAP8[$2 + 47 | 0] = 0;
 }
 global$0 = $2 + 48 | 0;
 return HEAP8[$2 + 47 | 0] & 1;
}
function tflite__ops__micro__pooling___28anonymous_20namespace_29__MaxEvalQuantized_28TfLiteContext__2c_20TfLiteNode__2c_20TfLitePoolParams__2c_20tflite__ops__micro__pooling___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = global$0 - 176 | 0;
 global$0 = $6;
 HEAP32[$6 + 172 >> 2] = $0;
 HEAP32[$6 + 168 >> 2] = $1;
 HEAP32[$6 + 164 >> 2] = $2;
 HEAP32[$6 + 160 >> 2] = $3;
 HEAP32[$6 + 156 >> 2] = $4;
 HEAP32[$6 + 152 >> 2] = $5;
 HEAP32[$6 + 116 >> 2] = HEAP32[HEAP32[$6 + 164 >> 2] + 8 >> 2];
 HEAP32[$6 + 120 >> 2] = HEAP32[HEAP32[$6 + 164 >> 2] + 4 >> 2];
 HEAP32[$6 + 124 >> 2] = HEAP32[HEAP32[$6 + 164 >> 2] + 16 >> 2];
 HEAP32[$6 + 128 >> 2] = HEAP32[HEAP32[$6 + 164 >> 2] + 12 >> 2];
 HEAP16[$6 + 108 >> 1] = HEAP32[HEAP32[$6 + 160 >> 2] + 4 >> 2];
 HEAP16[$6 + 106 >> 1] = HEAP32[HEAP32[$6 + 160 >> 2] >> 2];
 HEAP32[$6 + 132 >> 2] = HEAP32[HEAP32[$6 + 160 >> 2] + 16 >> 2];
 HEAP32[$6 + 136 >> 2] = HEAP32[HEAP32[$6 + 160 >> 2] + 20 >> 2];
 label$1 : {
  if (HEAP32[HEAP32[$6 + 156 >> 2] + 8 >> 2] == 3) {
   tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($6 + 80 | 0, HEAP32[$6 + 156 >> 2]);
   $0 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$6 + 156 >> 2]);
   tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($6 + 48 | 0, HEAP32[$6 + 152 >> 2]);
   tflite__reference_ops__MaxPool_28tflite__PoolParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29($6 + 104 | 0, $6 + 80 | 0, $0, $6 + 48 | 0, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$6 + 152 >> 2]));
   $0 = $6 + 80 | 0;
   tflite__RuntimeShape___RuntimeShape_28_29($6 + 48 | 0);
   break label$1;
  }
  tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($6 + 24 | 0, HEAP32[$6 + 156 >> 2]);
  $0 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$6 + 156 >> 2]);
  tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($6, HEAP32[$6 + 152 >> 2]);
  tflite__reference_integer_ops__MaxPool_28tflite__PoolParams_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($6 + 104 | 0, $6 + 24 | 0, $0, $6, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$6 + 152 >> 2]));
  $0 = $6 + 24 | 0;
  tflite__RuntimeShape___RuntimeShape_28_29($6);
 }
 tflite__RuntimeShape___RuntimeShape_28_29($0);
 global$0 = $6 + 176 | 0;
}
function handlePipeClose($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP32[$3 + 36 >> 2] = $2;
 jsiQueueObjectCallbacks(HEAP32[$3 + 36 >> 2], 124381, $3 + 36 | 0, 1);
 HEAP32[$3 + 32 >> 2] = jsvObjectGetChild(HEAP32[$3 + 36 >> 2], 124503, 0);
 HEAP32[$3 + 28 >> 2] = jsvObjectGetChild(HEAP32[$3 + 36 >> 2], 124510, 0);
 if (!(!HEAP32[$3 + 32 >> 2] | !HEAP32[$3 + 28 >> 2])) {
  HEAP32[$3 + 24 >> 2] = jsvObjectGetChild(HEAP32[$3 + 32 >> 2], 124854, 0);
  label$2 : {
   if (!HEAP32[$3 + 24 >> 2]) {
    break label$2;
   }
   if (!jsvGetStringLength(HEAP32[$3 + 24 >> 2])) {
    break label$2;
   }
   jsvObjectRemoveChild(HEAP32[$3 + 32 >> 2], 124854);
   HEAP32[$3 + 20 >> 2] = jspGetNamedField(HEAP32[$3 + 28 >> 2], 124366, 0);
   if (jsvIsFunction(HEAP32[$3 + 20 >> 2]) & 1) {
    jsvUnLock(jspExecuteFunction(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 28 >> 2], 1, $3 + 24 | 0));
   }
   jsvUnLock(HEAP32[$3 + 20 >> 2]);
   HEAP32[$3 + 16 >> 2] = jsvObjectGetChild(HEAP32[$3 + 36 >> 2], 124494, 0);
   jsvSetInteger(HEAP32[$3 + 16 >> 2], jsvGetInteger(HEAP32[$3 + 16 >> 2]) + jsvGetStringLength(HEAP32[$3 + 24 >> 2]) | 0);
   jsvUnLock(HEAP32[$3 + 16 >> 2]);
  }
  jsvUnLock(HEAP32[$3 + 24 >> 2]);
 }
 if (jsvGetBoolAndUnLock(jsvObjectGetChild(HEAP32[$3 + 36 >> 2], 124393, 0)) & 1) {
  if (HEAP32[$3 + 28 >> 2]) {
   jswrap_object_removeAllListeners_cstr(HEAP32[$3 + 28 >> 2], 124488);
   jswrap_object_removeAllListeners_cstr(HEAP32[$3 + 28 >> 2], 124482);
   HEAP32[$3 + 12 >> 2] = jspGetNamedField(HEAP32[$3 + 28 >> 2], 124393, 0);
   if (jsvIsFunction(HEAP32[$3 + 12 >> 2]) & 1) {
    jsvUnLock(jspExecuteFunction(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 28 >> 2], 0, 0));
   }
   jsvUnLock(HEAP32[$3 + 12 >> 2]);
   HEAP32[$3 + 8 >> 2] = jspGetNamedField(HEAP32[$3 + 28 >> 2], 124482, 0);
   if (jsvIsFunction(HEAP32[$3 + 8 >> 2]) & 1) {
    jsvUnLock(jspExecuteFunction(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 28 >> 2], 0, 0));
   }
   jsvUnLock(HEAP32[$3 + 8 >> 2]);
  }
  if (HEAP32[$3 + 32 >> 2]) {
   jswrap_object_removeAllListeners_cstr(HEAP32[$3 + 32 >> 2], 124482);
   HEAP32[$3 + 4 >> 2] = jspGetNamedField(HEAP32[$3 + 32 >> 2], 124482, 0);
   if (jsvIsFunction(HEAP32[$3 + 4 >> 2]) & 1) {
    jsvUnLock(jspExecuteFunction(HEAP32[$3 + 4 >> 2], HEAP32[$3 + 32 >> 2], 0, 0));
   }
   jsvUnLock(HEAP32[$3 + 4 >> 2]);
  }
 }
 jsvUnLock2(HEAP32[$3 + 32 >> 2], HEAP32[$3 + 28 >> 2]);
 HEAP32[$3 >> 2] = jsvObjectIteratorGetKey(HEAP32[$3 + 40 >> 2]);
 jsvRemoveChild(HEAP32[$3 + 44 >> 2], HEAP32[$3 >> 2]);
 jsvUnLock(HEAP32[$3 >> 2]);
 global$0 = $3 + 48 | 0;
}
function jspeFactorFunctionCall() {
 var $0 = 0, $1 = 0;
 $0 = global$0 - 48 | 0;
 global$0 = $0;
 HEAP8[$0 + 43 | 0] = 0;
 label$1 : {
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 184) {
   jslGetNextToken();
   HEAP8[$0 + 43 | 0] = 1;
   if (HEAP16[HEAP32[35539] + 2 >> 1] == 184) {
    jsExceptionHere(1, 80114, 0);
    jspSetError();
    HEAP32[$0 + 44 >> 2] = 0;
    break label$1;
   }
  }
  $1 = $0 + 36 | 0;
  HEAP32[$0 + 36 >> 2] = 0;
  HEAP8[$0 + 35 | 0] = HEAP16[HEAP32[35539] + 2 >> 1] == 196;
  HEAP32[$0 + 28 >> 2] = jspeFactorMember(jspeFactor(), $1);
  if (HEAP8[$0 + 35 | 0] & 1) {
   jsvUnLock(HEAP32[$0 + 36 >> 2]);
   HEAP32[$0 + 36 >> 2] = jsvLockAgainSafe(HEAP32[80548]);
  }
  while (1) {
   label$6 : {
    if (HEAP16[HEAP32[35539] + 2 >> 1] != 40) {
     $1 = 0;
     if (!(HEAP8[$0 + 43 | 0] & 1)) {
      break label$6;
     }
     $1 = 0;
     if ((HEAP32[80549] & 63) != 1) {
      break label$6;
     }
    }
    $1 = jspIsInterrupted() ^ -1;
   }
   if ($1 & 1) {
    HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 28 >> 2];
    HEAP32[$0 + 20 >> 2] = jsvSkipName(HEAP32[$0 + 24 >> 2]);
    label$9 : {
     if (!(!(HEAP8[$0 + 43 | 0] & 1) | (HEAP32[80549] & 63) != 1)) {
      HEAP8[$0 + 19 | 0] = HEAP16[HEAP32[35539] + 2 >> 1] == 40;
      HEAP32[$0 + 28 >> 2] = jspeConstruct(HEAP32[$0 + 20 >> 2], HEAP32[$0 + 24 >> 2], HEAP8[$0 + 19 | 0] & 1);
      HEAP8[$0 + 43 | 0] = 0;
      break label$9;
     }
     HEAP32[$0 + 28 >> 2] = jspeFunctionCall(HEAP32[$0 + 20 >> 2], HEAP32[$0 + 24 >> 2], HEAP32[$0 + 36 >> 2], 1, 0, 0);
    }
    $1 = $0 + 36 | 0;
    jsvUnLock3(HEAP32[$0 + 24 >> 2], HEAP32[$0 + 20 >> 2], HEAP32[$0 + 36 >> 2]);
    HEAP32[$0 + 36 >> 2] = 0;
    HEAP32[$0 + 28 >> 2] = jspeFactorMember(HEAP32[$0 + 28 >> 2], $1);
    continue;
   }
   break;
  }
  label$11 : {
   if (!HEAP32[$0 + 36 >> 2]) {
    break label$11;
   }
   if (!(jsvIsBasicName(HEAP32[$0 + 28 >> 2]) & 1)) {
    break label$11;
   }
   if (jsvIsNewChild(HEAP32[$0 + 28 >> 2]) & 1) {
    break label$11;
   }
   HEAP32[$0 + 12 >> 2] = jsvLockSafe(jsvGetFirstChild(HEAP32[$0 + 28 >> 2]) & 65535);
   if (jsvIsGetterOrSetter(HEAP32[$0 + 12 >> 2]) & 1) {
    HEAP32[$0 + 8 >> 2] = jsvCopyNameOnly(HEAP32[$0 + 28 >> 2], 0, 1);
    HEAP32[$0 + 4 >> 2] = jsvCreateNewChild(HEAP32[$0 + 36 >> 2], HEAP32[$0 + 8 >> 2], HEAP32[$0 + 12 >> 2]);
    jsvUnLock2(HEAP32[$0 + 8 >> 2], HEAP32[$0 + 28 >> 2]);
    HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 4 >> 2];
   }
   jsvUnLock(HEAP32[$0 + 12 >> 2]);
  }
  jsvUnLock(HEAP32[$0 + 36 >> 2]);
  HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 28 >> 2];
 }
 global$0 = $0 + 48 | 0;
 return HEAP32[$0 + 44 >> 2];
}
function jsserialEventCallbackIdle() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $0 = global$0 + -64 | 0;
 global$0 = $0;
 HEAP8[$0 + 62 | 0] = 0;
 HEAP32[$0 + 56 >> 2] = jsserialGetSerialList(0);
 label$1 : {
  if (!HEAP32[$0 + 56 >> 2]) {
   HEAP8[$0 + 63 | 0] = 0;
   break label$1;
  }
  jsvObjectIteratorNew($0 + 48 | 0, HEAP32[$0 + 56 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue($0 + 48 | 0) & 1) {
    HEAP32[$0 + 44 >> 2] = jsvObjectIteratorGetValue($0 + 48 | 0);
    HEAP32[$0 + 40 >> 2] = jsvObjectGetChild(HEAP32[$0 + 44 >> 2], 83598, 0);
    HEAP32[$0 + 36 >> 2] = jsvGetFlatStringPointer(HEAP32[$0 + 40 >> 2]);
    if (HEAP32[$0 + 36 >> 2]) {
     if (HEAPU8[HEAP32[$0 + 36 >> 2] + 88 | 0]) {
      HEAP32[$0 + 24 >> 2] = jshGetSystemTime();
      HEAP32[$0 + 28 >> 2] = i64toi32_i32$HIGH_BITS;
      $2 = HEAP32[$0 + 24 >> 2];
      $1 = HEAP32[$0 + 36 >> 2];
      $3 = HEAP32[$1 + 72 >> 2];
      $1 = HEAP32[$0 + 28 >> 2] - (($2 >>> 0 < $3 >>> 0) + HEAP32[$1 + 76 >> 2] | 0) | 0;
      HEAP32[$0 + 16 >> 2] = $2 - $3;
      HEAP32[$0 + 20 >> 2] = $1;
      $3 = $0;
      $4 = jshGetMillisecondsFromTime(HEAP32[$0 + 16 >> 2], HEAP32[$0 + 20 >> 2]) * +HEAP32[HEAP32[$0 + 36 >> 2] + 80 >> 2] / 1e3 + .5;
      label$7 : {
       if (Math_abs($4) < 2147483648) {
        $2 = ~~$4;
        break label$7;
       }
       $2 = -2147483648;
      }
      HEAP32[$3 + 12 >> 2] = $2;
      label$9 : {
       if (HEAP32[$0 + 12 >> 2] > 10) {
        $1 = HEAP32[$0 + 36 >> 2];
        HEAP32[$1 + 84 >> 2] = HEAP32[$1 + 84 >> 2] | (1 << HEAP32[$0 + 12 >> 2]) - 1 << HEAPU8[HEAP32[$0 + 36 >> 2] + 88 | 0];
        $1 = HEAP32[$0 + 36 >> 2];
        HEAP8[$1 + 88 | 0] = HEAP32[$0 + 12 >> 2] + HEAPU8[$1 + 88 | 0];
        jsserialCheckForCharacter(HEAP32[$0 + 36 >> 2]);
        HEAP8[HEAP32[$0 + 36 >> 2] + 88 | 0] = 0;
        break label$9;
       }
       HEAP8[$0 + 62 | 0] = 1;
      }
     }
     if (HEAPU8[HEAP32[$0 + 36 >> 2] + 64 | 0]) {
      HEAP32[$0 + 8 >> 2] = jsvNewStringOfLength(HEAPU8[HEAP32[$0 + 36 >> 2] + 64 | 0], HEAP32[$0 + 36 >> 2]);
      HEAP8[HEAP32[$0 + 36 >> 2] + 64 | 0] = 0;
      if (HEAP32[$0 + 8 >> 2]) {
       jswrap_stream_pushData(HEAP32[$0 + 44 >> 2], HEAP32[$0 + 8 >> 2]);
       jsvUnLock(HEAP32[$0 + 8 >> 2]);
      }
     }
    }
    $1 = $0 + 48 | 0;
    jsvUnLock2(HEAP32[$0 + 40 >> 2], HEAP32[$0 + 44 >> 2]);
    jsvObjectIteratorNext($1);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree($0 + 48 | 0);
  jsvUnLock(HEAP32[$0 + 56 >> 2]);
  HEAP8[$0 + 63 | 0] = HEAP8[$0 + 62 | 0] & 1;
 }
 global$0 = $0 - -64 | 0;
 return HEAP8[$0 + 63 | 0] & 1;
}
function tflite__ParseSoftmax_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0, $5 = 0, $6 = 0, $7 = Math_fround(0);
 $4 = global$0 + -64 | 0;
 global$0 = $4;
 $6 = $4 + 32 | 0;
 $5 = $4 + 40 | 0;
 HEAP32[$4 + 56 >> 2] = $0;
 HEAP32[$4 + 52 >> 2] = $1;
 HEAP32[$4 + 48 >> 2] = $2;
 HEAP32[$4 + 44 >> 2] = $3;
 tflite___28anonymous_20namespace_29__CheckParsePointerParams_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29(HEAP32[$4 + 56 >> 2], HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2], HEAP32[$4 + 44 >> 2]);
 tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__SafeBuiltinDataAllocator_28tflite__BuiltinDataAllocator__29($5, HEAP32[$4 + 48 >> 2]);
 std____2__unique_ptr_TfLiteSoftmaxParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__Allocate_TfLiteSoftmaxParams__28_29($6, $5);
 label$1 : {
  if (!(bool_20std____2__operator___TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20const__2c_20std__nullptr_t_29($4 + 32 | 0) & 1)) {
   $0 = HEAP32[$4 + 52 >> 2];
   $1 = HEAP32[$4 + 52 >> 2];
   HEAP32[$4 + 8 >> 2] = 136736;
   HEAP32[$4 + 4 >> 2] = 1538;
   HEAP32[$4 >> 2] = 136641;
   tflite__ErrorReporter__ReportError_28void__2c_20char_20const__2c_20____29($0, $1, 136618, $4);
   HEAP32[$4 + 60 >> 2] = 1;
   break label$1;
  }
  HEAP32[$4 + 16 >> 2] = tflite__Operator__builtin_options_as_SoftmaxOptions_28_29_20const(HEAP32[$4 + 56 >> 2]);
  if (HEAP32[$4 + 16 >> 2]) {
   $7 = tflite__SoftmaxOptions__beta_28_29_20const(HEAP32[$4 + 16 >> 2]);
   HEAPF32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 32 | 0) >> 2] = $7;
  }
  $0 = std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___release_28_29($4 + 32 | 0);
  HEAP32[HEAP32[$4 + 44 >> 2] >> 2] = $0;
  HEAP32[$4 + 60 >> 2] = 0;
 }
 HEAP32[$4 + 20 >> 2] = 1;
 std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter____unique_ptr_28_29($4 + 32 | 0);
 global$0 = $4 - -64 | 0;
 return HEAP32[$4 + 60 >> 2];
}
function jspeTemplateLiteral() {
 var $0 = 0, $1 = 0;
 $0 = global$0 - 144 | 0;
 global$0 = $0;
 HEAP32[$0 + 140 >> 2] = 0;
 if ((HEAP32[80549] & 63) == 1) {
  HEAP32[$0 + 136 >> 2] = jslGetTokenValueAsVar();
  HEAP32[$0 + 140 >> 2] = jsvNewWithFlags(27);
  if (!(!HEAP32[$0 + 140 >> 2] | !HEAP32[$0 + 136 >> 2])) {
   $1 = $0 + 56 | 0;
   jsvStringIteratorNew($0 + 96 | 0, HEAP32[$0 + 136 >> 2], 0);
   jsvStringIteratorNew($1, HEAP32[$0 + 140 >> 2], 0);
   while (1) {
    label$4 : {
     if (!(jsvStringIteratorHasChar($0 + 96 | 0) & 1)) {
      break label$4;
     }
     HEAP8[$0 + 55 | 0] = jsvStringIteratorGetCharAndNext($0 + 96 | 0);
     label$5 : {
      if (HEAP8[$0 + 55 | 0] == 36) {
       HEAP8[$0 + 55 | 0] = jsvStringIteratorGetChar($0 + 96 | 0);
       label$7 : {
        if (HEAP8[$0 + 55 | 0] == 123) {
         jsvStringIteratorNext($0 + 96 | 0);
         HEAP32[$0 + 48 >> 2] = 1;
         HEAP32[$0 + 44 >> 2] = jsvNewWithFlags(27);
         if (!HEAP32[$0 + 44 >> 2]) {
          break label$4;
         }
         jsvStringIteratorNew($0 + 8 | 0, HEAP32[$0 + 44 >> 2], 0);
         while (1) {
          label$10 : {
           if (!(jsvStringIteratorHasChar($0 + 96 | 0) & 1)) {
            break label$10;
           }
           HEAP8[$0 + 55 | 0] = jsvStringIteratorGetCharAndNext($0 + 96 | 0);
           if (HEAP8[$0 + 55 | 0] == 123) {
            HEAP32[$0 + 48 >> 2] = HEAP32[$0 + 48 >> 2] + 1;
           }
           if (HEAP8[$0 + 55 | 0] == 125) {
            HEAP32[$0 + 48 >> 2] = HEAP32[$0 + 48 >> 2] + -1;
            if (!HEAP32[$0 + 48 >> 2]) {
             break label$10;
            }
           }
           jsvStringIteratorAppend($0 + 8 | 0, HEAP8[$0 + 55 | 0]);
           continue;
          }
          break;
         }
         $1 = $0 + 56 | 0;
         jsvStringIteratorFree($0 + 8 | 0);
         HEAP32[$0 + 4 >> 2] = jspEvaluateExpressionVar(HEAP32[$0 + 44 >> 2]);
         jsvUnLock(HEAP32[$0 + 44 >> 2]);
         HEAP32[$0 + 4 >> 2] = jsvAsStringAndUnLock(HEAP32[$0 + 4 >> 2]);
         jsvStringIteratorAppendString($1, HEAP32[$0 + 4 >> 2], 0, 2147483647);
         jsvUnLock(HEAP32[$0 + 4 >> 2]);
         break label$7;
        }
        jsvStringIteratorAppend($0 + 56 | 0, 36);
       }
       break label$5;
      }
      jsvStringIteratorAppend($0 + 56 | 0, HEAP8[$0 + 55 | 0]);
     }
     continue;
    }
    break;
   }
   $1 = $0 + 56 | 0;
   jsvStringIteratorFree($0 + 96 | 0);
   jsvStringIteratorFree($1);
  }
  jsvUnLock(HEAP32[$0 + 136 >> 2]);
 }
 jslGetNextToken();
 global$0 = $0 + 144 | 0;
 return HEAP32[$0 + 140 >> 2];
}
function jswrap_btoa($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = global$0 - 144 | 0;
 global$0 = $1;
 HEAP32[$1 + 136 >> 2] = $0;
 label$1 : {
  if (!(jsvIsIterable(HEAP32[$1 + 136 >> 2]) & 1)) {
   HEAP32[$1 >> 2] = HEAP32[$1 + 136 >> 2];
   jsExceptionHere(1, 121365, $1);
   HEAP32[$1 + 140 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 132 >> 2] = jsvGetLength(HEAP32[$1 + 136 >> 2]);
  HEAP32[$1 + 128 >> 2] = (HEAP32[$1 + 132 >> 2] + 2 >>> 0) / 3 << 2;
  HEAP32[$1 + 124 >> 2] = jsvNewStringOfLength(HEAP32[$1 + 128 >> 2], 0);
  if (!HEAP32[$1 + 124 >> 2]) {
   HEAP32[$1 + 140 >> 2] = 0;
   break label$1;
  }
  $0 = $1 + 24 | 0;
  jsvIteratorNew($1 - -64 | 0, HEAP32[$1 + 136 >> 2], 1);
  jsvStringIteratorNew($0, HEAP32[$1 + 124 >> 2], 0);
  HEAP32[$1 + 20 >> 2] = 0;
  while (1) {
   if (jsvIteratorHasElement($1 - -64 | 0) & 1) {
    $0 = jspIsInterrupted() ^ -1;
   } else {
    $0 = 0;
   }
   if ($0 & 1) {
    $0 = $1 - -64 | 0;
    HEAP32[$1 + 16 >> 2] = jsvIteratorGetIntegerValue($0) & 255;
    jsvIteratorNext($0);
    HEAP32[$1 + 12 >> 2] = 0;
    HEAP32[$1 + 8 >> 2] = 0;
    label$8 : {
     if (jsvIteratorHasElement($0) & 1) {
      $0 = $1 - -64 | 0;
      HEAP32[$1 + 12 >> 2] = jsvIteratorGetIntegerValue($0) & 255;
      jsvIteratorNext($0);
      label$10 : {
       if (jsvIteratorHasElement($0) & 1) {
        $0 = $1 - -64 | 0;
        HEAP32[$1 + 8 >> 2] = jsvIteratorGetIntegerValue($0) & 255;
        jsvIteratorNext($0);
        HEAP32[$1 + 20 >> 2] = 0;
        break label$10;
       }
       HEAP32[$1 + 20 >> 2] = 1;
      }
      break label$8;
     }
     HEAP32[$1 + 20 >> 2] = 2;
    }
    HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 8 >> 2] + ((HEAP32[$1 + 16 >> 2] << 16) + (HEAP32[$1 + 12 >> 2] << 8) | 0);
    $0 = $1 + 24 | 0;
    jsvStringIteratorSetCharAndNext($0, jswrap_btoa_encode(HEAP32[$1 + 4 >> 2] >> 18) << 24 >> 24);
    jsvStringIteratorSetCharAndNext($0, jswrap_btoa_encode(HEAP32[$1 + 4 >> 2] >> 12) << 24 >> 24);
    $0 = $1 + 24 | 0;
    if (HEAP32[$1 + 20 >> 2] > 1) {
     $2 = 61;
    } else {
     $2 = jswrap_btoa_encode(HEAP32[$1 + 4 >> 2] >> 6);
    }
    jsvStringIteratorSetCharAndNext($0, $2 << 24 >> 24);
    $0 = $1 + 24 | 0;
    if (HEAP32[$1 + 20 >> 2] > 0) {
     $2 = 61;
    } else {
     $2 = jswrap_btoa_encode(HEAP32[$1 + 4 >> 2]);
    }
    jsvStringIteratorSetCharAndNext($0, $2 << 24 >> 24);
    continue;
   }
   break;
  }
  $0 = $1 + 24 | 0;
  jsvIteratorFree($1 - -64 | 0);
  jsvStringIteratorFree($0);
  HEAP32[$1 + 140 >> 2] = HEAP32[$1 + 124 >> 2];
 }
 global$0 = $1 + 144 | 0;
 return HEAP32[$1 + 140 >> 2];
}
function tflite__ops__micro__fully_connected__Prepare_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = global$0 + -64 | 0;
 global$0 = $2;
 HEAP32[$2 + 56 >> 2] = $0;
 HEAP32[$2 + 52 >> 2] = $1;
 label$1 : {
  if (!HEAP32[HEAP32[$2 + 52 >> 2] + 8 >> 2]) {
   break label$1;
  }
 }
 label$2 : {
  if (!HEAP32[HEAP32[$2 + 52 >> 2] + 12 >> 2]) {
   break label$2;
  }
 }
 HEAP32[$2 + 48 >> 2] = HEAP32[HEAP32[$2 + 52 >> 2] + 8 >> 2];
 HEAP32[$2 + 44 >> 2] = HEAP32[HEAP32[$2 + 52 >> 2] + 12 >> 2];
 HEAP32[$2 + 40 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 52 >> 2], 0);
 HEAP32[$2 + 36 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 52 >> 2], 1);
 HEAP32[$2 + 32 >> 2] = tflite__GetOptionalInputTensor_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 52 >> 2]);
 HEAP32[$2 + 28 >> 2] = tflite__GetOutput_28TfLiteContext__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 52 >> 2]);
 label$3 : {
  if (HEAP32[HEAP32[$2 + 40 >> 2] + 28 >> 2] != HEAP32[HEAP32[$2 + 28 >> 2] + 28 >> 2]) {
   $0 = HEAP32[HEAP32[$2 + 56 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 56 >> 2];
   $3 = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 40 >> 2] + 28 >> 2]);
   HEAP32[$2 + 20 >> 2] = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 28 >> 2] + 28 >> 2]);
   HEAP32[$2 + 16 >> 2] = $3;
   HEAP32[$2 + 12 >> 2] = 134946;
   HEAP32[$2 + 8 >> 2] = 134934;
   HEAP32[$2 + 4 >> 2] = 100;
   HEAP32[$2 >> 2] = 134841;
   FUNCTION_TABLE[$0]($1, 134815, $2);
   HEAP32[$2 + 60 >> 2] = 1;
   break label$3;
  }
  if (HEAP32[HEAP32[$2 + 40 >> 2] + 28 >> 2] != HEAP32[HEAP32[$2 + 36 >> 2] + 28 >> 2]) {
   FUNCTION_TABLE[HEAP32[HEAP32[$2 + 56 >> 2] + 20 >> 2]](HEAP32[$2 + 56 >> 2], 134959, 0);
   HEAP32[$2 + 60 >> 2] = 1;
   break label$3;
  }
  HEAP32[$2 + 60 >> 2] = tflite__ops__micro__fully_connected___28anonymous_20namespace_29__CalculateOpData_28TfLiteContext__2c_20TfLiteFusedActivation_2c_20TfLiteType_2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor__2c_20tflite__ops__micro__fully_connected___28anonymous_20namespace_29__OpData__29(HEAP32[$2 + 56 >> 2], HEAP32[HEAP32[$2 + 44 >> 2] >> 2], HEAP32[HEAP32[$2 + 40 >> 2] + 28 >> 2], HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], HEAP32[$2 + 32 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 48 >> 2]);
 }
 global$0 = $2 - -64 | 0;
 return HEAP32[$2 + 60 >> 2];
}
function graphicsGetFromVar($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1 : {
  if (!HEAP32[$2 + 4 >> 2]) {
   HEAP8[$2 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$2 + 8 >> 2];
  $1 = HEAP32[$2 + 4 >> 2];
  HEAP8[$0 | 0] = $1;
  HEAP8[$0 + 1 | 0] = $1 >>> 8;
  HEAP8[$0 + 2 | 0] = $1 >>> 16;
  HEAP8[$0 + 3 | 0] = $1 >>> 24;
  HEAP32[$2 >> 2] = jsvObjectGetChild(HEAP32[$2 + 4 >> 2], 108415, 0);
  if (HEAP32[$2 >> 2]) {
   jsvGetStringChars(HEAP32[$2 >> 2], HEAP32[$2 + 8 >> 2] + 4 | 0, 44);
   jsvUnLock(HEAP32[$2 >> 2]);
   $0 = HEAP32[$2 + 8 >> 2];
   HEAP8[$0 + 52 | 0] = 532;
   HEAP8[$0 + 53 | 0] = 2;
   HEAP8[$0 + 54 | 0] = 0;
   HEAP8[$0 + 55 | 0] = 0;
   $0 = HEAP32[$2 + 8 >> 2];
   HEAP8[$0 + 60 | 0] = 531;
   HEAP8[$0 + 61 | 0] = 2;
   HEAP8[$0 + 62 | 0] = 0;
   HEAP8[$0 + 63 | 0] = 0;
   $0 = HEAP32[$2 + 8 >> 2];
   HEAP8[$0 + 56 | 0] = 530;
   HEAP8[$0 + 57 | 0] = 2;
   HEAP8[$0 + 58 | 0] = 0;
   HEAP8[$0 + 59 | 0] = 0;
   $0 = HEAP32[$2 + 8 >> 2];
   HEAP8[$0 + 64 | 0] = 529;
   HEAP8[$0 + 65 | 0] = 2;
   HEAP8[$0 + 66 | 0] = 0;
   HEAP8[$0 + 67 | 0] = 0;
   $0 = HEAP32[$2 + 8 >> 2];
   HEAP8[$0 + 68 | 0] = 528;
   HEAP8[$0 + 69 | 0] = 2;
   HEAP8[$0 + 70 | 0] = 0;
   HEAP8[$0 + 71 | 0] = 0;
   $0 = HEAP32[$2 + 8 >> 2];
   label$4 : {
    if (!(HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24))) {
     lcdSetCallbacks_ArrayBuffer(HEAP32[$2 + 8 >> 2]);
     break label$4;
    }
    $0 = HEAP32[$2 + 8 >> 2];
    label$6 : {
     if ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24)) == 1) {
      $1 = global$0 - 16 | 0;
      HEAP32[$1 + 12 >> 2] = HEAP32[$2 + 8 >> 2];
      $0 = HEAP32[$1 + 12 >> 2];
      HEAP8[$0 + 52 | 0] = 547;
      HEAP8[$0 + 53 | 0] = 2;
      HEAP8[$0 + 54 | 0] = 0;
      HEAP8[$0 + 55 | 0] = 0;
      $0 = HEAP32[$1 + 12 >> 2];
      HEAP8[$0 + 56 | 0] = 546;
      HEAP8[$0 + 57 | 0] = 2;
      HEAP8[$0 + 58 | 0] = 0;
      HEAP8[$0 + 59 | 0] = 0;
      break label$6;
     }
     $0 = HEAP32[$2 + 8 >> 2];
     label$8 : {
      if ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24)) == 6) {
       lcdMemLCD_setCallbacks(HEAP32[$2 + 8 >> 2]);
       break label$8;
      }
      jsExceptionHere(4, 108420, 0);
     }
    }
   }
   HEAP8[$2 + 15 | 0] = 1;
   break label$1;
  }
  HEAP8[$2 + 15 | 0] = 0;
 }
 global$0 = $2 + 16 | 0;
 return HEAP8[$2 + 15 | 0] & 1;
}
function jsvCopyNameOnly($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP8[$3 + 23 | 0] = $1;
 HEAP8[$3 + 22 | 0] = $2;
 $0 = HEAP32[$3 + 24 >> 2];
 HEAP16[$3 + 20 >> 1] = HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8;
 HEAP32[$3 + 16 >> 2] = 0;
 label$1 : {
  if (!(HEAP8[$3 + 22 | 0] & 1)) {
   $0 = HEAP32[$3 + 24 >> 2];
   HEAP16[$3 + 14 >> 1] = (HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63;
   label$3 : {
    if (!(HEAPU16[$3 + 14 >> 1] < 14 | HEAPU16[$3 + 14 >> 1] > 16)) {
     HEAP16[$3 + 20 >> 1] = HEAPU16[$3 + 20 >> 1] & -64 | 9;
     break label$3;
    }
    label$5 : {
     if (jsvGetLastChild(HEAP32[$3 + 24 >> 2]) & 65535) {
      HEAP32[$3 + 16 >> 2] = jsvNewFromStringVar(HEAP32[$3 + 24 >> 2], 0, 2147483647);
      if (!HEAP32[$3 + 16 >> 2]) {
       HEAP32[$3 + 28 >> 2] = 0;
       break label$1;
      }
      break label$5;
     }
     HEAP16[$3 + 20 >> 1] = HEAPU16[$3 + 20 >> 1] & 65472 | jsvGetCharactersInVar(HEAP32[$3 + 24 >> 2]) + 27;
    }
   }
  }
  if (!HEAP32[$3 + 16 >> 2]) {
   HEAP32[$3 + 16 >> 2] = jsvNewWithFlags(HEAPU16[$3 + 20 >> 1] & 127);
   if (!HEAP32[$3 + 16 >> 2]) {
    HEAP32[$3 + 28 >> 2] = 0;
    break label$1;
   }
   $0 = HEAP32[$3 + 16 >> 2];
   $1 = HEAP32[$3 + 24 >> 2];
   $1 = HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24);
   HEAP8[$0 | 0] = $1;
   HEAP8[$0 + 1 | 0] = $1 >>> 8;
   HEAP8[$0 + 2 | 0] = $1 >>> 16;
   HEAP8[$0 + 3 | 0] = $1 >>> 24;
   if (jsvHasCharacterData(HEAP32[$3 + 24 >> 2]) & 1) {
    if (jsvGetLastChild(HEAP32[$3 + 24 >> 2]) & 65535) {
     HEAP32[$3 + 8 >> 2] = jsvLock(jsvGetLastChild(HEAP32[$3 + 24 >> 2]) & 65535);
     HEAP32[$3 + 4 >> 2] = jsvCopy(HEAP32[$3 + 8 >> 2], 1);
     if (HEAP32[$3 + 4 >> 2]) {
      jsvSetLastChild(HEAP32[$3 + 16 >> 2], jsvGetRef(HEAP32[$3 + 4 >> 2]) & 65535);
      jsvUnLock(HEAP32[$3 + 4 >> 2]);
     }
     jsvUnLock(HEAP32[$3 + 8 >> 2]);
    }
   }
  }
  label$13 : {
   if (!(HEAP8[$3 + 23 | 0] & 1)) {
    break label$13;
   }
   if (!(jsvGetFirstChild(HEAP32[$3 + 24 >> 2]) & 65535)) {
    break label$13;
   }
   label$14 : {
    if (jsvIsNameWithValue(HEAP32[$3 + 24 >> 2]) & 1) {
     jsvSetFirstChild(HEAP32[$3 + 16 >> 2], jsvGetFirstChild(HEAP32[$3 + 24 >> 2]) & 65535);
     break label$14;
    }
    jsvSetFirstChild(HEAP32[$3 + 16 >> 2], jsvRefRef(jsvGetFirstChild(HEAP32[$3 + 24 >> 2]) & 65535) & 65535);
   }
  }
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 16 >> 2];
 }
 global$0 = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}
function tflite__ops__micro__fully_connected__EvalQuantizedInt8_28TfLiteContext__2c_20TfLiteNode__2c_20tflite__ops__micro__fully_connected___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0;
 $7 = global$0 - 176 | 0;
 global$0 = $7;
 HEAP32[$7 + 172 >> 2] = $0;
 HEAP32[$7 + 168 >> 2] = $1;
 HEAP32[$7 + 164 >> 2] = $2;
 HEAP32[$7 + 160 >> 2] = $3;
 HEAP32[$7 + 156 >> 2] = $4;
 HEAP32[$7 + 152 >> 2] = $5;
 HEAP32[$7 + 148 >> 2] = $6;
 HEAP32[$7 + 104 >> 2] = 0 - HEAP32[HEAP32[$7 + 164 >> 2] + 20 >> 2];
 HEAP32[$7 + 108 >> 2] = 0 - HEAP32[HEAP32[$7 + 164 >> 2] + 24 >> 2];
 HEAP32[$7 + 112 >> 2] = HEAP32[HEAP32[$7 + 164 >> 2] + 28 >> 2];
 HEAP32[$7 + 116 >> 2] = HEAP32[HEAP32[$7 + 164 >> 2] >> 2];
 HEAP32[$7 + 120 >> 2] = 0 - HEAP32[HEAP32[$7 + 164 >> 2] + 4 >> 2];
 HEAP32[$7 + 124 >> 2] = HEAP32[HEAP32[$7 + 164 >> 2] + 8 >> 2];
 HEAP32[$7 + 128 >> 2] = HEAP32[HEAP32[$7 + 164 >> 2] + 12 >> 2];
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 80 | 0, HEAP32[$7 + 160 >> 2]);
 $0 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$7 + 160 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 48 | 0, HEAP32[$7 + 156 >> 2]);
 $1 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$7 + 156 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 24 | 0, HEAP32[$7 + 152 >> 2]);
 $2 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$7 + 152 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7, HEAP32[$7 + 148 >> 2]);
 tflite__reference_integer_ops__FullyConnected_28tflite__FullyConnectedParams_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($7 + 104 | 0, $7 + 80 | 0, $0, $7 + 48 | 0, $1, $7 + 24 | 0, $2, $7, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$7 + 148 >> 2]));
 $0 = $7 + 80 | 0;
 $1 = $7 + 48 | 0;
 $2 = $7 + 24 | 0;
 tflite__RuntimeShape___RuntimeShape_28_29($7);
 tflite__RuntimeShape___RuntimeShape_28_29($2);
 tflite__RuntimeShape___RuntimeShape_28_29($1);
 tflite__RuntimeShape___RuntimeShape_28_29($0);
 global$0 = $7 + 176 | 0;
 return 0;
}
function jswrap_graphics_setRotation($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 96 | 0;
 global$0 = $3;
 HEAP32[$3 + 88 >> 2] = $0;
 HEAP32[$3 + 84 >> 2] = $1;
 HEAP8[$3 + 83 | 0] = $2;
 label$1 : {
  if (!(graphicsGetFromVar($3 + 8 | 0, HEAP32[$3 + 88 >> 2]) & 1)) {
   HEAP32[$3 + 92 >> 2] = 0;
   break label$1;
  }
  $0 = (HEAPU8[$3 + 16 | 0] | HEAPU8[$3 + 17 | 0] << 8 | (HEAPU8[$3 + 18 | 0] << 16 | HEAPU8[$3 + 19 | 0] << 24)) & -113;
  HEAP8[$3 + 16 | 0] = $0;
  HEAP8[$3 + 17 | 0] = $0 >>> 8;
  HEAP8[$3 + 18 | 0] = $0 >>> 16;
  HEAP8[$3 + 19 | 0] = $0 >>> 24;
  $0 = HEAP32[$3 + 84 >> 2];
  label$3 : {
   if ($0 >>> 0 > 3) {
    break label$3;
   }
   label$4 : {
    switch ($0 - 1 | 0) {
    case 0:
     $0 = HEAPU8[$3 + 16 | 0] | HEAPU8[$3 + 17 | 0] << 8 | (HEAPU8[$3 + 18 | 0] << 16 | HEAPU8[$3 + 19 | 0] << 24) | 48;
     HEAP8[$3 + 16 | 0] = $0;
     HEAP8[$3 + 17 | 0] = $0 >>> 8;
     HEAP8[$3 + 18 | 0] = $0 >>> 16;
     HEAP8[$3 + 19 | 0] = $0 >>> 24;
     break label$3;
    case 1:
     $0 = HEAPU8[$3 + 16 | 0] | HEAPU8[$3 + 17 | 0] << 8 | (HEAPU8[$3 + 18 | 0] << 16 | HEAPU8[$3 + 19 | 0] << 24) | 96;
     HEAP8[$3 + 16 | 0] = $0;
     HEAP8[$3 + 17 | 0] = $0 >>> 8;
     HEAP8[$3 + 18 | 0] = $0 >>> 16;
     HEAP8[$3 + 19 | 0] = $0 >>> 24;
     break label$3;
    case 2:
     break label$4;
    default:
     break label$3;
    }
   }
   $0 = HEAPU8[$3 + 16 | 0] | HEAPU8[$3 + 17 | 0] << 8 | (HEAPU8[$3 + 18 | 0] << 16 | HEAPU8[$3 + 19 | 0] << 24) | 80;
   HEAP8[$3 + 16 | 0] = $0;
   HEAP8[$3 + 17 | 0] = $0 >>> 8;
   HEAP8[$3 + 18 | 0] = $0 >>> 16;
   HEAP8[$3 + 19 | 0] = $0 >>> 24;
  }
  if (HEAP8[$3 + 83 | 0] & 1) {
   label$8 : {
    if ((HEAPU8[$3 + 16 | 0] | HEAPU8[$3 + 17 | 0] << 8 | (HEAPU8[$3 + 18 | 0] << 16 | HEAPU8[$3 + 19 | 0] << 24)) & 16) {
     $0 = (HEAPU8[$3 + 16 | 0] | HEAPU8[$3 + 17 | 0] << 8 | (HEAPU8[$3 + 18 | 0] << 16 | HEAPU8[$3 + 19 | 0] << 24)) ^ 64;
     HEAP8[$3 + 16 | 0] = $0;
     HEAP8[$3 + 17 | 0] = $0 >>> 8;
     HEAP8[$3 + 18 | 0] = $0 >>> 16;
     HEAP8[$3 + 19 | 0] = $0 >>> 24;
     break label$8;
    }
    $0 = (HEAPU8[$3 + 16 | 0] | HEAPU8[$3 + 17 | 0] << 8 | (HEAPU8[$3 + 18 | 0] << 16 | HEAPU8[$3 + 19 | 0] << 24)) ^ 32;
    HEAP8[$3 + 16 | 0] = $0;
    HEAP8[$3 + 17 | 0] = $0 >>> 8;
    HEAP8[$3 + 18 | 0] = $0 >>> 16;
    HEAP8[$3 + 19 | 0] = $0 >>> 24;
   }
  }
  graphicsSetVar($3 + 8 | 0);
  HEAP32[$3 + 92 >> 2] = jsvLockAgain(HEAP32[$3 + 88 >> 2]);
 }
 global$0 = $3 + 96 | 0;
 return HEAP32[$3 + 92 >> 2];
}
function btnHandlerCommon($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = 1;
 HEAP8[$2 + 11 | 0] = $0;
 HEAP8[$2 + 10 | 0] = $1;
 label$1 : {
  if (!(HEAP32[84156] ? 0 : !(HEAP32[84154] | HEAP32[84155]))) {
   label$4 : {
    if (!(!(HEAP32[84152] & 8) | HEAP32[$2 + 12 >> 2] != 3 ? !((HEAP32[$2 + 12 >> 2] == 1 ? HEAP32[84152] & 2 : 0) | (HEAP32[$2 + 12 >> 2] == 2 ? HEAP32[84152] & 4 : 0)) : 0)) {
     HEAP16[168314] = 0;
     if (HEAP8[$2 + 11 | 0] & 1) {
      HEAP8[$2 + 9 | 0] = 0;
      if (!(!(HEAP8[$2 + 11 | 0] & 1) | (!HEAP32[84154] | HEAP32[84152] & 32768))) {
       HEAP32[84158] = HEAP32[84158] | 2;
       HEAP8[$2 + 9 | 0] = 1;
      }
      if (!(!(HEAP8[$2 + 11 | 0] & 1) | (!HEAP32[84155] | HEAP32[84152] & 65536))) {
       HEAP32[84158] = HEAP32[84158] | 8;
       HEAP8[$2 + 9 | 0] = 1;
      }
      if (!(!(HEAP8[$2 + 11 | 0] & 1) | (!HEAP32[84156] | !(HEAP32[84152] & 131072)))) {
       HEAP32[84158] = HEAP32[84158] | 64;
       HEAP8[$2 + 9 | 0] = 1;
      }
      if (HEAP8[$2 + 9 | 0] & 1) {
       HEAP8[336636] = HEAP32[$2 + 12 >> 2];
       $3 = jshGetSystemTime();
       $1 = i64toi32_i32$HIGH_BITS;
       $0 = jshGetTimeFromMilliseconds(100);
       $1 = i64toi32_i32$HIGH_BITS + $1 | 0;
       $3 = $0 + $3 | 0;
       if ($3 >>> 0 < $0 >>> 0) {
        $1 = $1 + 1 | 0;
       }
       HEAP32[84160] = $3;
       HEAP32[84161] = $1;
       break label$1;
      }
     }
     break label$4;
    }
    if (!(HEAP32[84152] & 32768)) {
     break label$1;
    }
    HEAP16[168314] = 0;
   }
  }
  if (HEAP32[$2 + 12 >> 2] == 1) {
   HEAP16[168324] = 0;
  }
  HEAP32[$2 >> 2] = jshGetSystemTime();
  HEAP32[$2 + 4 >> 2] = i64toi32_i32$HIGH_BITS;
  if (HEAP32[$2 + 12 >> 2] == HEAP8[336636]) {
   $0 = HEAP32[$2 + 4 >> 2];
   $1 = HEAP32[84161];
   if (!(HEAP8[$2 + 11 | 0] & 1 ? ($0 | 0) > ($1 | 0) ? 1 : ($0 | 0) >= ($1 | 0) ? HEAPU32[$2 >> 2] < HEAPU32[84160] ? 0 : 1 : 0 : 0)) {
    $3 = HEAP32[$2 >> 2];
    $1 = HEAP32[$2 + 4 >> 2];
    $0 = jshGetTimeFromMilliseconds(100);
    $1 = i64toi32_i32$HIGH_BITS + $1 | 0;
    $3 = $0 + $3 | 0;
    if ($3 >>> 0 < $0 >>> 0) {
     $1 = $1 + 1 | 0;
    }
    HEAP32[84160] = $3;
    HEAP32[84161] = $1;
    break label$1;
   }
   HEAP8[336636] = 0;
   HEAP32[84160] = 0;
   HEAP32[84161] = 0;
  }
  if (HEAP32[84152] & 131072) {
   break label$1;
  }
  jshPushIOEvent((HEAPU8[$2 + 10 | 0] | (HEAP8[$2 + 11 | 0] & 1 ? 32 : 0)) & 255, HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]);
 }
 global$0 = $2 + 16 | 0;
}
function memcpy($0, $1, $2) {
 var $3 = 0, $4 = 0;
 if ($2 >>> 0 >= 8192) {
  emscripten_memcpy_big($0 | 0, $1 | 0, $2 | 0) | 0;
  return;
 }
 $3 = $0 + $2 | 0;
 label$2 : {
  if (!(($0 ^ $1) & 3)) {
   label$4 : {
    if (($2 | 0) < 1) {
     $2 = $0;
     break label$4;
    }
    if (!($0 & 3)) {
     $2 = $0;
     break label$4;
    }
    $2 = $0;
    while (1) {
     HEAP8[$2 | 0] = HEAPU8[$1 | 0];
     $1 = $1 + 1 | 0;
     $2 = $2 + 1 | 0;
     if ($2 >>> 0 >= $3 >>> 0) {
      break label$4;
     }
     if ($2 & 3) {
      continue;
     }
     break;
    }
   }
   $0 = $3 & -4;
   label$8 : {
    if ($0 >>> 0 < 64) {
     break label$8;
    }
    $4 = $0 + -64 | 0;
    if ($2 >>> 0 > $4 >>> 0) {
     break label$8;
    }
    while (1) {
     HEAP32[$2 >> 2] = HEAP32[$1 >> 2];
     HEAP32[$2 + 4 >> 2] = HEAP32[$1 + 4 >> 2];
     HEAP32[$2 + 8 >> 2] = HEAP32[$1 + 8 >> 2];
     HEAP32[$2 + 12 >> 2] = HEAP32[$1 + 12 >> 2];
     HEAP32[$2 + 16 >> 2] = HEAP32[$1 + 16 >> 2];
     HEAP32[$2 + 20 >> 2] = HEAP32[$1 + 20 >> 2];
     HEAP32[$2 + 24 >> 2] = HEAP32[$1 + 24 >> 2];
     HEAP32[$2 + 28 >> 2] = HEAP32[$1 + 28 >> 2];
     HEAP32[$2 + 32 >> 2] = HEAP32[$1 + 32 >> 2];
     HEAP32[$2 + 36 >> 2] = HEAP32[$1 + 36 >> 2];
     HEAP32[$2 + 40 >> 2] = HEAP32[$1 + 40 >> 2];
     HEAP32[$2 + 44 >> 2] = HEAP32[$1 + 44 >> 2];
     HEAP32[$2 + 48 >> 2] = HEAP32[$1 + 48 >> 2];
     HEAP32[$2 + 52 >> 2] = HEAP32[$1 + 52 >> 2];
     HEAP32[$2 + 56 >> 2] = HEAP32[$1 + 56 >> 2];
     HEAP32[$2 + 60 >> 2] = HEAP32[$1 + 60 >> 2];
     $1 = $1 - -64 | 0;
     $2 = $2 - -64 | 0;
     if ($2 >>> 0 <= $4 >>> 0) {
      continue;
     }
     break;
    }
   }
   if ($2 >>> 0 >= $0 >>> 0) {
    break label$2;
   }
   while (1) {
    HEAP32[$2 >> 2] = HEAP32[$1 >> 2];
    $1 = $1 + 4 | 0;
    $2 = $2 + 4 | 0;
    if ($2 >>> 0 < $0 >>> 0) {
     continue;
    }
    break;
   }
   break label$2;
  }
  if ($3 >>> 0 < 4) {
   $2 = $0;
   break label$2;
  }
  $4 = $3 + -4 | 0;
  if ($4 >>> 0 < $0 >>> 0) {
   $2 = $0;
   break label$2;
  }
  $2 = $0;
  while (1) {
   HEAP8[$2 | 0] = HEAPU8[$1 | 0];
   HEAP8[$2 + 1 | 0] = HEAPU8[$1 + 1 | 0];
   HEAP8[$2 + 2 | 0] = HEAPU8[$1 + 2 | 0];
   HEAP8[$2 + 3 | 0] = HEAPU8[$1 + 3 | 0];
   $1 = $1 + 4 | 0;
   $2 = $2 + 4 | 0;
   if ($2 >>> 0 <= $4 >>> 0) {
    continue;
   }
   break;
  }
 }
 if ($2 >>> 0 < $3 >>> 0) {
  while (1) {
   HEAP8[$2 | 0] = HEAPU8[$1 | 0];
   $1 = $1 + 1 | 0;
   $2 = $2 + 1 | 0;
   if (($3 | 0) != ($2 | 0)) {
    continue;
   }
   break;
  }
 }
}
function graphicsSetModifiedAndClip($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 32 | 0;
 HEAP32[$5 + 28 >> 2] = $0;
 HEAP32[$5 + 24 >> 2] = $1;
 HEAP32[$5 + 20 >> 2] = $2;
 HEAP32[$5 + 16 >> 2] = $3;
 HEAP32[$5 + 12 >> 2] = $4;
 HEAP8[$5 + 11 | 0] = 0;
 $0 = HEAP32[$5 + 28 >> 2];
 if (HEAP32[HEAP32[$5 + 24 >> 2] >> 2] < (HEAPU8[$0 + 32 | 0] | HEAPU8[$0 + 33 | 0] << 8)) {
  $0 = HEAP32[$5 + 28 >> 2];
  HEAP32[HEAP32[$5 + 24 >> 2] >> 2] = HEAPU8[$0 + 32 | 0] | HEAPU8[$0 + 33 | 0] << 8;
  HEAP8[$5 + 11 | 0] = 1;
 }
 $0 = HEAP32[$5 + 28 >> 2];
 if (HEAP32[HEAP32[$5 + 20 >> 2] >> 2] < (HEAPU8[$0 + 34 | 0] | HEAPU8[$0 + 35 | 0] << 8)) {
  $0 = HEAP32[$5 + 28 >> 2];
  HEAP32[HEAP32[$5 + 20 >> 2] >> 2] = HEAPU8[$0 + 34 | 0] | HEAPU8[$0 + 35 | 0] << 8;
  HEAP8[$5 + 11 | 0] = 1;
 }
 $0 = HEAP32[$5 + 28 >> 2];
 if (HEAP32[HEAP32[$5 + 16 >> 2] >> 2] > (HEAPU8[$0 + 36 | 0] | HEAPU8[$0 + 37 | 0] << 8)) {
  $0 = HEAP32[$5 + 28 >> 2];
  HEAP32[HEAP32[$5 + 16 >> 2] >> 2] = HEAPU8[$0 + 36 | 0] | HEAPU8[$0 + 37 | 0] << 8;
  HEAP8[$5 + 11 | 0] = 1;
 }
 $0 = HEAP32[$5 + 28 >> 2];
 if (HEAP32[HEAP32[$5 + 12 >> 2] >> 2] > (HEAPU8[$0 + 38 | 0] | HEAPU8[$0 + 39 | 0] << 8)) {
  $0 = HEAP32[$5 + 28 >> 2];
  HEAP32[HEAP32[$5 + 12 >> 2] >> 2] = HEAPU8[$0 + 38 | 0] | HEAPU8[$0 + 39 | 0] << 8;
  HEAP8[$5 + 11 | 0] = 1;
 }
 $0 = HEAP32[$5 + 28 >> 2];
 if (HEAP32[HEAP32[$5 + 24 >> 2] >> 2] < (HEAPU8[$0 + 40 | 0] | HEAPU8[$0 + 41 | 0] << 8) << 16 >> 16) {
  $0 = HEAP32[$5 + 28 >> 2];
  $1 = HEAP32[HEAP32[$5 + 24 >> 2] >> 2];
  HEAP8[$0 + 40 | 0] = $1;
  HEAP8[$0 + 41 | 0] = $1 >>> 8;
  HEAP8[$5 + 11 | 0] = 1;
 }
 $0 = HEAP32[$5 + 28 >> 2];
 if (HEAP32[HEAP32[$5 + 16 >> 2] >> 2] > (HEAPU8[$0 + 44 | 0] | HEAPU8[$0 + 45 | 0] << 8) << 16 >> 16) {
  $0 = HEAP32[$5 + 28 >> 2];
  $1 = HEAP32[HEAP32[$5 + 16 >> 2] >> 2];
  HEAP8[$0 + 44 | 0] = $1;
  HEAP8[$0 + 45 | 0] = $1 >>> 8;
  HEAP8[$5 + 11 | 0] = 1;
 }
 $0 = HEAP32[$5 + 28 >> 2];
 if (HEAP32[HEAP32[$5 + 20 >> 2] >> 2] < (HEAPU8[$0 + 42 | 0] | HEAPU8[$0 + 43 | 0] << 8) << 16 >> 16) {
  $0 = HEAP32[$5 + 28 >> 2];
  $1 = HEAP32[HEAP32[$5 + 20 >> 2] >> 2];
  HEAP8[$0 + 42 | 0] = $1;
  HEAP8[$0 + 43 | 0] = $1 >>> 8;
  HEAP8[$5 + 11 | 0] = 1;
 }
 $0 = HEAP32[$5 + 28 >> 2];
 if (HEAP32[HEAP32[$5 + 12 >> 2] >> 2] > (HEAPU8[$0 + 46 | 0] | HEAPU8[$0 + 47 | 0] << 8) << 16 >> 16) {
  $0 = HEAP32[$5 + 28 >> 2];
  $1 = HEAP32[HEAP32[$5 + 12 >> 2] >> 2];
  HEAP8[$0 + 46 | 0] = $1;
  HEAP8[$0 + 47 | 0] = $1 >>> 8;
  HEAP8[$5 + 11 | 0] = 1;
 }
 return HEAP8[$5 + 11 | 0] & 1;
}
function jswrap_array_slice($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 112 | 0;
 global$0 = $3;
 HEAP32[$3 + 104 >> 2] = $0;
 HEAP32[$3 + 100 >> 2] = $1;
 HEAP32[$3 + 96 >> 2] = $2;
 HEAP32[$3 + 92 >> 2] = jsvGetLength(HEAP32[$3 + 104 >> 2]);
 HEAP32[$3 + 88 >> 2] = HEAP32[$3 + 92 >> 2];
 if (!(jsvIsUndefined(HEAP32[$3 + 96 >> 2]) & 1)) {
  HEAP32[$3 + 88 >> 2] = jsvGetInteger(HEAP32[$3 + 96 >> 2]);
 }
 HEAP32[$3 + 84 >> 2] = 0;
 HEAP32[$3 + 80 >> 2] = HEAP32[$3 + 92 >> 2];
 HEAP32[$3 + 76 >> 2] = jsvNewWithFlags(3);
 label$2 : {
  if (!HEAP32[$3 + 76 >> 2]) {
   HEAP32[$3 + 108 >> 2] = 0;
   break label$2;
  }
  label$4 : {
   if (HEAP32[$3 + 100 >> 2] < 0) {
    $0 = $3;
    if ((HEAP32[$3 + 92 >> 2] + HEAP32[$3 + 100 >> 2] | 0) > 0) {
     $1 = HEAP32[$3 + 92 >> 2] + HEAP32[$3 + 100 >> 2] | 0;
    } else {
     $1 = 0;
    }
    HEAP32[$0 + 84 >> 2] = $1;
    break label$4;
   }
   $0 = $3;
   if (HEAP32[$3 + 100 >> 2] < HEAP32[$3 + 92 >> 2]) {
    $1 = HEAP32[$3 + 100 >> 2];
   } else {
    $1 = HEAP32[$3 + 92 >> 2];
   }
   HEAP32[$0 + 84 >> 2] = $1;
  }
  label$10 : {
   if (HEAP32[$3 + 88 >> 2] < 0) {
    $0 = $3;
    if ((HEAP32[$3 + 92 >> 2] + HEAP32[$3 + 88 >> 2] | 0) > 0) {
     $1 = HEAP32[$3 + 92 >> 2] + HEAP32[$3 + 88 >> 2] | 0;
    } else {
     $1 = 0;
    }
    HEAP32[$0 + 80 >> 2] = $1;
    break label$10;
   }
   $0 = $3;
   if (HEAP32[$3 + 88 >> 2] < HEAP32[$3 + 92 >> 2]) {
    $1 = HEAP32[$3 + 88 >> 2];
   } else {
    $1 = HEAP32[$3 + 92 >> 2];
   }
   HEAP32[$0 + 80 >> 2] = $1;
  }
  HEAP8[$3 + 75 | 0] = 0;
  jsvIteratorNew($3 + 8 | 0, HEAP32[$3 + 104 >> 2], 1);
  while (1) {
   if (jsvIteratorHasElement($3 + 8 | 0) & 1) {
    $0 = HEAPU8[$3 + 75 | 0] ^ -1;
   } else {
    $0 = 0;
   }
   if ($0 & 1) {
    HEAP32[$3 + 4 >> 2] = jsvGetIntegerAndUnLock(jsvIteratorGetKey($3 + 8 | 0));
    label$20 : {
     if (HEAP32[$3 + 4 >> 2] < HEAP32[$3 + 84 >> 2]) {
      jsvIteratorNext($3 + 8 | 0);
      break label$20;
     }
     label$22 : {
      if (HEAP32[$3 + 84 >> 2] < HEAP32[$3 + 80 >> 2]) {
       $0 = $3 + 8 | 0;
       jsvArrayPushAndUnLock(HEAP32[$3 + 76 >> 2], jsvIteratorGetValue($0));
       jsvIteratorNext($0);
       HEAP32[$3 + 84 >> 2] = HEAP32[$3 + 84 >> 2] + 1;
       break label$22;
      }
      HEAP8[$3 + 75 | 0] = 1;
     }
    }
    continue;
   }
   break;
  }
  jsvIteratorFree($3 + 8 | 0);
  HEAP32[$3 + 108 >> 2] = HEAP32[$3 + 76 >> 2];
 }
 global$0 = $3 + 112 | 0;
 return HEAP32[$3 + 108 >> 2];
}
function _jswrap_promise_resolve_or_reject($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP32[$3 + 36 >> 2] = $2;
 jsvObjectRemoveChild(HEAP32[$3 + 44 >> 2], 125099);
 jsvObjectRemoveChild(HEAP32[$3 + 44 >> 2], 125104);
 HEAP32[$3 + 32 >> 2] = jsvObjectGetChild(HEAP32[$3 + 44 >> 2], 125109, 0);
 jsvObjectRemoveChild(HEAP32[$3 + 44 >> 2], 125109);
 HEAP32[$3 + 28 >> 2] = 0;
 label$1 : {
  if (jsvIsArray(HEAP32[$3 + 36 >> 2]) & 1) {
   jsvObjectIteratorNew($3 + 24 | 0, HEAP32[$3 + 36 >> 2]);
   HEAP8[$3 + 23 | 0] = 1;
   while (1) {
    if (jsvObjectIteratorHasValue($3 + 24 | 0) & 1) {
     $0 = $3 + 40 | 0;
     HEAP32[$3 + 16 >> 2] = jsvObjectIteratorGetValue($3 + 24 | 0);
     HEAP32[$3 + 12 >> 2] = jspExecuteFunction(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 44 >> 2], 1, $0);
     label$5 : {
      if (HEAP8[$3 + 23 | 0] & 1) {
       HEAP8[$3 + 23 | 0] = 0;
       HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2];
       break label$5;
      }
      jsvUnLock(HEAP32[$3 + 12 >> 2]);
     }
     $0 = $3 + 24 | 0;
     jsvUnLock(HEAP32[$3 + 16 >> 2]);
     jsvObjectIteratorNext($0);
     continue;
    }
    break;
   }
   jsvObjectIteratorFree($3 + 24 | 0);
   break label$1;
  }
  if (HEAP32[$3 + 36 >> 2]) {
   HEAP32[$3 + 28 >> 2] = jspExecuteFunction(HEAP32[$3 + 36 >> 2], HEAP32[$3 + 44 >> 2], 1, $3 + 40 | 0);
  }
 }
 HEAP32[$3 + 8 >> 2] = jspGetException();
 label$8 : {
  if (HEAP32[$3 + 8 >> 2]) {
   _jswrap_promise_queuereject(HEAP32[$3 + 32 >> 2], HEAP32[$3 + 8 >> 2]);
   jsvUnLock3(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 28 >> 2], HEAP32[$3 + 32 >> 2]);
   break label$8;
  }
  if (HEAP32[$3 + 32 >> 2]) {
   label$11 : {
    if (_jswrap_promise_is_promise(HEAP32[$3 + 28 >> 2]) & 1) {
     HEAP32[$3 + 4 >> 2] = jsvNewNativeFunction(585, 32776);
     HEAP32[$3 >> 2] = jsvNewNativeFunction(584, 32776);
     if (!(!HEAP32[$3 + 4 >> 2] | !HEAP32[$3 >> 2])) {
      jsvObjectSetChild(HEAP32[$3 + 4 >> 2], 125115, HEAP32[$3 + 32 >> 2]);
      jsvObjectSetChild(HEAP32[$3 >> 2], 125115, HEAP32[$3 + 32 >> 2]);
      _jswrap_promise_add(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 4 >> 2], 1);
      _jswrap_promise_add(HEAP32[$3 + 28 >> 2], HEAP32[$3 >> 2], 0);
     }
     jsvUnLock2(HEAP32[$3 + 4 >> 2], HEAP32[$3 >> 2]);
     break label$11;
    }
    _jswrap_promise_queueresolve(HEAP32[$3 + 32 >> 2], HEAP32[$3 + 28 >> 2]);
   }
  }
  jsvUnLock2(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 32 >> 2]);
 }
 global$0 = $3 + 48 | 0;
}
function lcdMemLCD_scrollX($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 + -64 | 0;
 global$0 = $4;
 HEAP32[$4 + 60 >> 2] = $0;
 HEAP32[$4 + 56 >> 2] = $1;
 HEAP32[$4 + 52 >> 2] = $2;
 HEAP32[$4 + 48 >> 2] = $3;
 HEAP32[$4 + 44 >> 2] = HEAP32[$4 + 56 >> 2] + 2;
 HEAP32[$4 + 40 >> 2] = HEAP32[$4 + 52 >> 2] + 2;
 label$1 : {
  if (!HEAP32[$4 + 48 >> 2]) {
   memcpy(HEAP32[$4 + 56 >> 2], HEAP32[$4 + 52 >> 2], 68);
   break label$1;
  }
  label$3 : {
   if (HEAP32[$4 + 48 >> 2] < 0) {
    HEAP32[$4 + 36 >> 2] = Math_imul(0 - HEAP32[$4 + 48 >> 2] | 0, 3);
    HEAP32[$4 + 32 >> 2] = HEAP32[$4 + 36 >> 2] >> 5;
    HEAP32[$4 + 36 >> 2] = HEAP32[$4 + 36 >> 2] & 31;
    HEAP32[$4 + 28 >> 2] = 528 - HEAP32[$4 + 36 >> 2] >> 5;
    HEAP32[$4 + 24 >> 2] = 0;
    while (1) {
     if (HEAP32[$4 + 24 >> 2] <= HEAP32[$4 + 28 >> 2]) {
      $0 = HEAP32[HEAP32[$4 + 40 >> 2] + (HEAP32[$4 + 24 >> 2] + HEAP32[$4 + 32 >> 2] << 2) >> 2];
      $1 = ($0 >>> 24 | $0 >>> 8 & 65280 | ($0 << 8 & 16711680 | $0 << 24)) << HEAP32[$4 + 36 >> 2];
      $0 = HEAP32[HEAP32[$4 + 40 >> 2] + ((HEAP32[$4 + 24 >> 2] + HEAP32[$4 + 32 >> 2] | 0) + 1 << 2) >> 2];
      $0 = $1 | ($0 >>> 24 | $0 >>> 8 & 65280 | ($0 << 8 & 16711680 | $0 << 24)) >>> 32 - HEAP32[$4 + 36 >> 2];
      HEAP32[HEAP32[$4 + 44 >> 2] + (HEAP32[$4 + 24 >> 2] << 2) >> 2] = $0 >>> 24 | $0 >>> 8 & 65280 | ($0 << 8 & 16711680 | $0 << 24);
      HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 24 >> 2] + 1;
      continue;
     }
     break;
    }
    break label$3;
   }
   HEAP32[$4 + 20 >> 2] = Math_imul(HEAP32[$4 + 48 >> 2], 3);
   HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 20 >> 2] >> 5;
   HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 20 >> 2] & 31;
   HEAP32[$4 + 12 >> 2] = 543 - HEAP32[$4 + 20 >> 2] >> 5;
   HEAP32[$4 + 8 >> 2] = 0;
   while (1) {
    if (HEAP32[$4 + 8 >> 2] <= HEAP32[$4 + 12 >> 2]) {
     $0 = HEAP32[HEAP32[$4 + 40 >> 2] + (HEAP32[$4 + 8 >> 2] - HEAP32[$4 + 16 >> 2] << 2) >> 2];
     $1 = ($0 >>> 24 | $0 >>> 8 & 65280 | ($0 << 8 & 16711680 | $0 << 24)) >>> HEAP32[$4 + 20 >> 2];
     $0 = HEAP32[HEAP32[$4 + 40 >> 2] + (HEAP32[$4 + 8 >> 2] - (HEAP32[$4 + 16 >> 2] + 1 | 0) << 2) >> 2];
     $0 = $1 | ($0 >>> 24 | $0 >>> 8 & 65280 | ($0 << 8 & 16711680 | $0 << 24)) << 32 - HEAP32[$4 + 20 >> 2];
     HEAP32[HEAP32[$4 + 44 >> 2] + (HEAP32[$4 + 8 >> 2] << 2) >> 2] = $0 >>> 24 | $0 >>> 8 & 65280 | ($0 << 8 & 16711680 | $0 << 24);
     HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 8 >> 2] + 1;
     continue;
    }
    break;
   }
  }
 }
 global$0 = $4 - -64 | 0;
}
function jswrap_graphics_createCallback($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 128 | 0;
 global$0 = $4;
 HEAP32[$4 + 120 >> 2] = $0;
 HEAP32[$4 + 116 >> 2] = $1;
 HEAP32[$4 + 112 >> 2] = $2;
 HEAP32[$4 + 108 >> 2] = $3;
 label$1 : {
  label$2 : {
   if (!(HEAP32[$4 + 120 >> 2] <= 0 | HEAP32[$4 + 116 >> 2] <= 0 | HEAP32[$4 + 120 >> 2] > 32767)) {
    if (HEAP32[$4 + 116 >> 2] <= 32767) {
     break label$2;
    }
   }
   jsExceptionHere(1, 127108, 0);
   HEAP32[$4 + 124 >> 2] = 0;
   break label$1;
  }
  if (!(isValidBPP(HEAP32[$4 + 112 >> 2]) & 1)) {
   jsExceptionHere(1, 127121, 0);
   HEAP32[$4 + 124 >> 2] = 0;
   break label$1;
  }
  HEAP32[$4 + 104 >> 2] = 0;
  HEAP32[$4 + 100 >> 2] = 0;
  label$5 : {
   if (jsvIsObject(HEAP32[$4 + 108 >> 2]) & 1) {
    jsvUnLock(HEAP32[$4 + 104 >> 2]);
    HEAP32[$4 + 104 >> 2] = jsvObjectGetChild(HEAP32[$4 + 108 >> 2], 127353, 0);
    HEAP32[$4 + 100 >> 2] = jsvObjectGetChild(HEAP32[$4 + 108 >> 2], 127362, 0);
    break label$5;
   }
   HEAP32[$4 + 104 >> 2] = jsvLockAgain(HEAP32[$4 + 108 >> 2]);
  }
  if (!(jsvIsFunction(HEAP32[$4 + 104 >> 2]) & 1)) {
   HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 104 >> 2];
   jsExceptionHere(1, 127371, $4 + 16 | 0);
   jsvUnLock2(HEAP32[$4 + 104 >> 2], HEAP32[$4 + 100 >> 2]);
   HEAP32[$4 + 124 >> 2] = 0;
   break label$1;
  }
  label$8 : {
   if (jsvIsUndefined(HEAP32[$4 + 100 >> 2]) & 1) {
    break label$8;
   }
   if (jsvIsFunction(HEAP32[$4 + 100 >> 2]) & 1) {
    break label$8;
   }
   HEAP32[$4 >> 2] = HEAP32[$4 + 100 >> 2];
   jsExceptionHere(1, 127371, $4);
   jsvUnLock2(HEAP32[$4 + 104 >> 2], HEAP32[$4 + 100 >> 2]);
   HEAP32[$4 + 124 >> 2] = 0;
   break label$1;
  }
  HEAP32[$4 + 96 >> 2] = jspNewObject(0, 127133);
  if (!HEAP32[$4 + 96 >> 2]) {
   HEAP32[$4 + 124 >> 2] = 0;
   break label$1;
  }
  HEAP8[$4 + 28 | 0] = 1;
  HEAP8[$4 + 29 | 0] = 0;
  HEAP8[$4 + 30 | 0] = 0;
  HEAP8[$4 + 31 | 0] = 0;
  $1 = $4 + 24 | 0;
  graphicsStructInit($1, HEAP32[$4 + 120 >> 2], HEAP32[$4 + 116 >> 2], HEAP32[$4 + 112 >> 2]);
  $0 = HEAP32[$4 + 96 >> 2];
  HEAP8[$4 + 24 | 0] = $0;
  HEAP8[$4 + 25 | 0] = $0 >>> 8;
  HEAP8[$4 + 26 | 0] = $0 >>> 16;
  HEAP8[$4 + 27 | 0] = $0 >>> 24;
  lcdInit_JS($1, HEAP32[$4 + 104 >> 2], HEAP32[$4 + 100 >> 2]);
  graphicsSetVar($1);
  jsvUnLock2(HEAP32[$4 + 104 >> 2], HEAP32[$4 + 100 >> 2]);
  HEAP32[$4 + 124 >> 2] = HEAP32[$4 + 96 >> 2];
 }
 global$0 = $4 + 128 | 0;
 return HEAP32[$4 + 124 >> 2];
}
function heatshrink_encoder_poll($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP32[$3 + 40 >> 2] = $0;
 HEAP32[$3 + 36 >> 2] = $1;
 HEAP32[$3 + 32 >> 2] = 128;
 HEAP32[$3 + 28 >> 2] = $2;
 label$1 : {
  if (!(HEAP32[$3 + 28 >> 2] ? !(!HEAP32[$3 + 40 >> 2] | !HEAP32[$3 + 36 >> 2]) : 0)) {
   HEAP32[$3 + 44 >> 2] = -1;
   break label$1;
  }
  if (!HEAP32[$3 + 32 >> 2]) {
   HEAP32[$3 + 44 >> 2] = -2;
   break label$1;
  }
  HEAP32[HEAP32[$3 + 28 >> 2] >> 2] = 0;
  HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 36 >> 2];
  HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 32 >> 2];
  HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 28 >> 2];
  while (1) {
   HEAP8[$3 + 15 | 0] = HEAPU8[HEAP32[$3 + 40 >> 2] + 12 | 0];
   label$6 : {
    $0 = HEAPU8[$3 + 15 | 0];
    if ($0 >>> 0 <= 9) {
     label$8 : {
      switch ($0 - 1 | 0) {
      default:
       HEAP32[$3 + 44 >> 2] = 0;
       break label$1;
      case 0:
       do_indexing(HEAP32[$3 + 40 >> 2]);
       HEAP8[HEAP32[$3 + 40 >> 2] + 12 | 0] = 2;
       break label$6;
      case 1:
       $0 = st_step_search(HEAP32[$3 + 40 >> 2]);
       HEAP8[HEAP32[$3 + 40 >> 2] + 12 | 0] = $0;
       break label$6;
      case 2:
       $0 = st_yield_tag_bit(HEAP32[$3 + 40 >> 2], $3 + 16 | 0);
       HEAP8[HEAP32[$3 + 40 >> 2] + 12 | 0] = $0;
       break label$6;
      case 3:
       $0 = st_yield_literal(HEAP32[$3 + 40 >> 2], $3 + 16 | 0);
       HEAP8[HEAP32[$3 + 40 >> 2] + 12 | 0] = $0;
       break label$6;
      case 4:
       $0 = st_yield_br_index(HEAP32[$3 + 40 >> 2], $3 + 16 | 0);
       HEAP8[HEAP32[$3 + 40 >> 2] + 12 | 0] = $0;
       break label$6;
      case 5:
       $0 = st_yield_br_length(HEAP32[$3 + 40 >> 2], $3 + 16 | 0);
       HEAP8[HEAP32[$3 + 40 >> 2] + 12 | 0] = $0;
       break label$6;
      case 6:
       $0 = st_save_backlog(HEAP32[$3 + 40 >> 2]);
       HEAP8[HEAP32[$3 + 40 >> 2] + 12 | 0] = $0;
       break label$6;
      case 7:
       $0 = st_flush_bit_buffer(HEAP32[$3 + 40 >> 2], $3 + 16 | 0);
       HEAP8[HEAP32[$3 + 40 >> 2] + 12 | 0] = $0;
       break;
      case 8:
       break label$8;
      }
     }
     HEAP32[$3 + 44 >> 2] = 0;
     break label$1;
    }
    HEAP32[$3 + 44 >> 2] = -2;
    break label$1;
   }
   if (HEAPU8[HEAP32[$3 + 40 >> 2] + 12 | 0] == HEAPU8[$3 + 15 | 0]) {
    if (HEAP32[HEAP32[$3 + 28 >> 2] >> 2] == HEAP32[$3 + 32 >> 2]) {
     HEAP32[$3 + 44 >> 2] = 1;
     break label$1;
    }
   }
   continue;
  }
 }
 global$0 = $3 + 48 | 0;
 return HEAP32[$3 + 44 >> 2];
}
function jswrap_graphics_drawPoly_X($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = global$0 - 192 | 0;
 global$0 = $3;
 HEAP32[$3 + 184 >> 2] = $0;
 HEAP32[$3 + 180 >> 2] = $1;
 HEAP8[$3 + 179 | 0] = $2;
 HEAP8[$3 + 178 | 0] = 0;
 label$1 : {
  if (!(graphicsGetFromVar($3 + 104 | 0, HEAP32[$3 + 184 >> 2]) & 1)) {
   HEAP32[$3 + 188 >> 2] = 0;
   break label$1;
  }
  if (!(jsvIsIterable(HEAP32[$3 + 180 >> 2]) & 1)) {
   HEAP32[$3 + 188 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 100 >> 2] = 1;
  HEAP32[$3 + 96 >> 2] = 596;
  HEAP32[$3 + 76 >> 2] = 0;
  jsvIteratorNew($3 + 16 | 0, HEAP32[$3 + 180 >> 2], 1);
  while (1) {
   label$5 : {
    if (!(jsvIteratorHasElement($3 + 16 | 0) & 1)) {
     break label$5;
    }
    $0 = $3;
    $1 = $3 + 16 | 0;
    $4 = jsvIteratorGetFloatValue($1) * +HEAP32[$3 + 100 >> 2] + .5;
    label$6 : {
     if (Math_abs($4) < 2147483648) {
      $2 = ~~$4;
      break label$6;
     }
     $2 = -2147483648;
    }
    HEAP32[$0 + 12 >> 2] = $2;
    jsvIteratorNext($1);
    if (!(jsvIteratorHasElement($1) & 1)) {
     break label$5;
    }
    $0 = $3;
    $2 = $3 + 16 | 0;
    $4 = jsvIteratorGetFloatValue($2) * +HEAP32[$3 + 100 >> 2] + .5;
    label$8 : {
     if (Math_abs($4) < 2147483648) {
      $1 = ~~$4;
      break label$8;
     }
     $1 = -2147483648;
    }
    HEAP32[$0 + 8 >> 2] = $1;
    jsvIteratorNext($2);
    label$10 : {
     if (!HEAP32[$3 + 76 >> 2]) {
      HEAP32[$3 + 84 >> 2] = HEAP32[$3 + 12 >> 2];
      HEAP32[$3 + 80 >> 2] = HEAP32[$3 + 8 >> 2];
      break label$10;
     }
     FUNCTION_TABLE[HEAP32[$3 + 96 >> 2]]($3 + 104 | 0, HEAP32[$3 + 92 >> 2], HEAP32[$3 + 88 >> 2], HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
    }
    HEAP32[$3 + 92 >> 2] = HEAP32[$3 + 12 >> 2];
    HEAP32[$3 + 88 >> 2] = HEAP32[$3 + 8 >> 2];
    HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 76 >> 2] + 1;
    continue;
   }
   break;
  }
  jsvIteratorFree($3 + 16 | 0);
  $0 = HEAP32[$3 + 92 >> 2] / HEAP32[$3 + 100 >> 2] | 0;
  HEAP8[$3 + 131 | 0] = $0;
  HEAP8[$3 + 132 | 0] = $0 >>> 8;
  $0 = HEAP32[$3 + 88 >> 2] / HEAP32[$3 + 100 >> 2] | 0;
  HEAP8[$3 + 133 | 0] = $0;
  HEAP8[$3 + 134 | 0] = $0 >>> 8;
  if (HEAP8[$3 + 179 | 0] & 1) {
   FUNCTION_TABLE[HEAP32[$3 + 96 >> 2]]($3 + 104 | 0, HEAP32[$3 + 92 >> 2], HEAP32[$3 + 88 >> 2], HEAP32[$3 + 84 >> 2], HEAP32[$3 + 80 >> 2]);
  }
  graphicsSetVar($3 + 104 | 0);
  HEAP32[$3 + 188 >> 2] = jsvLockAgain(HEAP32[$3 + 184 >> 2]);
 }
 global$0 = $3 + 192 | 0;
 return HEAP32[$3 + 188 >> 2];
}
function utilTimerGetLastTask($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 HEAP8[$3 + 15 | 0] = HEAPU8[324177];
 label$1 : {
  if (HEAPU8[$3 + 15 | 0] != HEAPU8[324178]) {
   HEAP8[$3 + 15 | 0] = HEAPU8[$3 + 15 | 0] + 15 & 15;
   while (1) {
    if (HEAPU8[$3 + 15 | 0] != (HEAPU8[324178] + 15 & 15)) {
     if (FUNCTION_TABLE[HEAP32[$3 + 24 >> 2]](Math_imul(HEAPU8[$3 + 15 | 0], 25) + 324192 | 0, HEAP32[$3 + 20 >> 2]) & 1) {
      $1 = Math_imul(HEAPU8[$3 + 15 | 0], 25) + 324192 | 0;
      $4 = HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8 | (HEAPU8[$1 + 6 | 0] << 16 | HEAPU8[$1 + 7 | 0] << 24);
      $0 = HEAP32[$3 + 16 >> 2];
      $2 = HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24);
      HEAP8[$0 | 0] = $2;
      HEAP8[$0 + 1 | 0] = $2 >>> 8;
      HEAP8[$0 + 2 | 0] = $2 >>> 16;
      HEAP8[$0 + 3 | 0] = $2 >>> 24;
      HEAP8[$0 + 4 | 0] = $4;
      HEAP8[$0 + 5 | 0] = $4 >>> 8;
      HEAP8[$0 + 6 | 0] = $4 >>> 16;
      HEAP8[$0 + 7 | 0] = $4 >>> 24;
      HEAP8[$0 + 24 | 0] = HEAPU8[$1 + 24 | 0];
      $2 = HEAPU8[$1 + 20 | 0] | HEAPU8[$1 + 21 | 0] << 8 | (HEAPU8[$1 + 22 | 0] << 16 | HEAPU8[$1 + 23 | 0] << 24);
      $4 = HEAPU8[$1 + 16 | 0] | HEAPU8[$1 + 17 | 0] << 8 | (HEAPU8[$1 + 18 | 0] << 16 | HEAPU8[$1 + 19 | 0] << 24);
      HEAP8[$0 + 16 | 0] = $4;
      HEAP8[$0 + 17 | 0] = $4 >>> 8;
      HEAP8[$0 + 18 | 0] = $4 >>> 16;
      HEAP8[$0 + 19 | 0] = $4 >>> 24;
      HEAP8[$0 + 20 | 0] = $2;
      HEAP8[$0 + 21 | 0] = $2 >>> 8;
      HEAP8[$0 + 22 | 0] = $2 >>> 16;
      HEAP8[$0 + 23 | 0] = $2 >>> 24;
      $2 = HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8 | (HEAPU8[$1 + 14 | 0] << 16 | HEAPU8[$1 + 15 | 0] << 24);
      $1 = HEAPU8[$1 + 8 | 0] | HEAPU8[$1 + 9 | 0] << 8 | (HEAPU8[$1 + 10 | 0] << 16 | HEAPU8[$1 + 11 | 0] << 24);
      HEAP8[$0 + 8 | 0] = $1;
      HEAP8[$0 + 9 | 0] = $1 >>> 8;
      HEAP8[$0 + 10 | 0] = $1 >>> 16;
      HEAP8[$0 + 11 | 0] = $1 >>> 24;
      HEAP8[$0 + 12 | 0] = $2;
      HEAP8[$0 + 13 | 0] = $2 >>> 8;
      HEAP8[$0 + 14 | 0] = $2 >>> 16;
      HEAP8[$0 + 15 | 0] = $2 >>> 24;
      HEAP8[$3 + 31 | 0] = 1;
      break label$1;
     } else {
      HEAP8[$3 + 15 | 0] = HEAPU8[$3 + 15 | 0] + 15 & 15;
      continue;
     }
    }
    break;
   }
  }
  HEAP8[$3 + 31 | 0] = 0;
 }
 global$0 = $3 + 32 | 0;
 return HEAP8[$3 + 31 | 0] & 1;
}
function lcdGetPixel_ArrayBuffer($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $3 = global$0 - 112 | 0;
 global$0 = $3;
 $4 = $3 + 32 | 0;
 HEAP32[$3 + 108 >> 2] = $0;
 HEAP32[$3 + 104 >> 2] = $1;
 HEAP32[$3 + 100 >> 2] = $2;
 HEAP32[$3 + 96 >> 2] = 0;
 $0 = HEAP32[$3 + 108 >> 2];
 HEAP32[$3 + 92 >> 2] = HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24);
 HEAP32[$3 + 88 >> 2] = lcdGetPixelIndex_ArrayBuffer(HEAP32[$3 + 108 >> 2], HEAP32[$3 + 104 >> 2], HEAP32[$3 + 100 >> 2], 1);
 jsvArrayBufferIteratorNew($4, HEAP32[$3 + 92 >> 2], HEAP32[$3 + 88 >> 2] >>> 3);
 label$1 : {
  if (HEAPU8[HEAP32[$3 + 108 >> 2] + 16 | 0] & 7) {
   HEAP32[$3 + 88 >> 2] = HEAP32[$3 + 88 >> 2] & 7;
   HEAP32[$3 + 28 >> 2] = (1 << HEAPU8[HEAP32[$3 + 108 >> 2] + 16 | 0]) - 1;
   HEAP32[$3 + 24 >> 2] = jsvArrayBufferIteratorGetIntegerValue($3 + 32 | 0);
   $0 = $3;
   $1 = HEAP32[$3 + 108 >> 2];
   $2 = 8 - (HEAP32[$3 + 88 >> 2] + HEAPU8[HEAP32[$3 + 108 >> 2] + 16 | 0] | 0) | 0;
   label$3 : {
    if ((HEAPU8[$1 + 8 | 0] | HEAPU8[$1 + 9 | 0] << 8 | (HEAPU8[$1 + 10 | 0] << 16 | HEAPU8[$1 + 11 | 0] << 24)) & 4) {
     break label$3;
    }
    $2 = HEAP32[$3 + 88 >> 2];
   }
   HEAP32[$0 + 20 >> 2] = $2;
   HEAP32[$3 + 96 >> 2] = HEAP32[$3 + 28 >> 2] & HEAP32[$3 + 24 >> 2] >>> HEAP32[$3 + 20 >> 2];
   break label$1;
  }
  $0 = HEAP32[$3 + 108 >> 2];
  label$5 : {
   if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 4) {
    HEAP32[$3 + 16 >> 2] = HEAPU8[HEAP32[$3 + 108 >> 2] + 16 | 0] - 8;
    while (1) {
     if (HEAP32[$3 + 16 >> 2] >= 0) {
      $0 = $3 + 32 | 0;
      HEAP32[$3 + 96 >> 2] = jsvArrayBufferIteratorGetIntegerValue($0) << HEAP32[$3 + 16 >> 2] | HEAP32[$3 + 96 >> 2];
      jsvArrayBufferIteratorNext($0);
      HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 16 >> 2] - 8;
      continue;
     }
     break;
    }
    break label$5;
   }
   HEAP32[$3 + 12 >> 2] = 0;
   while (1) {
    if (HEAP32[$3 + 12 >> 2] < HEAPU8[HEAP32[$3 + 108 >> 2] + 16 | 0]) {
     $0 = $3 + 32 | 0;
     HEAP32[$3 + 96 >> 2] = jsvArrayBufferIteratorGetIntegerValue($0) << HEAP32[$3 + 12 >> 2] | HEAP32[$3 + 96 >> 2];
     jsvArrayBufferIteratorNext($0);
     HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + 8;
     continue;
    }
    break;
   }
  }
 }
 jsvArrayBufferIteratorFree($3 + 32 | 0);
 global$0 = $3 + 112 | 0;
 return HEAP32[$3 + 96 >> 2];
}
function stringToIntWithRadix($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 + -64 | 0;
 global$0 = $4;
 HEAP32[$4 + 52 >> 2] = $0;
 HEAP32[$4 + 48 >> 2] = $1;
 HEAP32[$4 + 44 >> 2] = $2;
 HEAP32[$4 + 40 >> 2] = $3;
 while (1) {
  if (isWhitespace(HEAP8[HEAP32[$4 + 52 >> 2]]) & 1) {
   HEAP32[$4 + 52 >> 2] = HEAP32[$4 + 52 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP8[$4 + 39 | 0] = 0;
 HEAP32[$4 + 24 >> 2] = 0;
 HEAP32[$4 + 28 >> 2] = 0;
 label$3 : {
  if (HEAP8[HEAP32[$4 + 52 >> 2]] == 45) {
   HEAP8[$4 + 39 | 0] = 1;
   HEAP32[$4 + 52 >> 2] = HEAP32[$4 + 52 >> 2] + 1;
   break label$3;
  }
  if (HEAP8[HEAP32[$4 + 52 >> 2]] == 43) {
   HEAP32[$4 + 52 >> 2] = HEAP32[$4 + 52 >> 2] + 1;
  }
 }
 HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 52 >> 2];
 if (HEAP32[$4 + 40 >> 2]) {
  HEAP32[HEAP32[$4 + 40 >> 2] >> 2] = HEAP32[$4 + 52 >> 2];
 }
 $0 = $4;
 if (HEAP32[$4 + 48 >> 2]) {
  $1 = HEAP32[$4 + 48 >> 2];
 } else {
  $1 = getRadix($4 + 52 | 0, HEAP32[$4 + 44 >> 2]);
 }
 HEAP32[$0 + 16 >> 2] = $1;
 label$9 : {
  if (!HEAP32[$4 + 16 >> 2]) {
   HEAP32[$4 + 56 >> 2] = 0;
   HEAP32[$4 + 60 >> 2] = 0;
   break label$9;
  }
  while (1) {
   label$12 : {
    if (!HEAPU8[HEAP32[$4 + 52 >> 2]]) {
     break label$12;
    }
    HEAP32[$4 + 12 >> 2] = chtod(HEAP8[HEAP32[$4 + 52 >> 2]]);
    if (HEAP32[$4 + 12 >> 2] < 0 | HEAP32[$4 + 12 >> 2] >= HEAP32[$4 + 16 >> 2]) {
     break label$12;
    }
    $0 = HEAP32[$4 + 12 >> 2];
    $3 = $0;
    $2 = $0 >> 31;
    $0 = HEAP32[$4 + 16 >> 2];
    $0 = __wasm_i64_mul(HEAP32[$4 + 24 >> 2], HEAP32[$4 + 28 >> 2], $0, $0 >> 31);
    $2 = i64toi32_i32$HIGH_BITS + $2 | 0;
    $3 = $0 + $3 | 0;
    if ($3 >>> 0 < $0 >>> 0) {
     $2 = $2 + 1 | 0;
    }
    HEAP32[$4 + 24 >> 2] = $3;
    HEAP32[$4 + 28 >> 2] = $2;
    HEAP32[$4 + 52 >> 2] = HEAP32[$4 + 52 >> 2] + 1;
    continue;
   }
   break;
  }
  if (HEAP32[$4 + 44 >> 2]) {
   HEAP8[HEAP32[$4 + 44 >> 2]] = HEAP32[$4 + 52 >> 2] == HEAP32[$4 + 20 >> 2];
  }
  if (HEAP32[$4 + 40 >> 2]) {
   HEAP32[HEAP32[$4 + 40 >> 2] >> 2] = HEAP32[$4 + 52 >> 2];
  }
  if (HEAP8[$4 + 39 | 0] & 1) {
   $0 = HEAP32[$4 + 24 >> 2];
   $1 = 0 - (HEAP32[$4 + 28 >> 2] + (0 < $0 >>> 0) | 0) | 0;
   HEAP32[$4 + 56 >> 2] = 0 - $0;
   HEAP32[$4 + 60 >> 2] = $1;
   break label$9;
  }
  $0 = HEAP32[$4 + 28 >> 2];
  HEAP32[$4 + 56 >> 2] = HEAP32[$4 + 24 >> 2];
  HEAP32[$4 + 60 >> 2] = $0;
 }
 global$0 = $4 - -64 | 0;
 i64toi32_i32$HIGH_BITS = HEAP32[$4 + 60 >> 2];
 return HEAP32[$4 + 56 >> 2];
}
function tflite__ops__micro__pooling__AverageEval_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1 : {
  if (!HEAP32[HEAP32[$2 + 20 >> 2] + 12 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$2 + 16 >> 2] = HEAP32[HEAP32[$2 + 20 >> 2] + 12 >> 2];
 label$2 : {
  if (!HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2]) {
   break label$2;
  }
 }
 HEAP32[$2 + 12 >> 2] = HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2];
 HEAP32[$2 + 8 >> 2] = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], 0);
 HEAP32[$2 + 4 >> 2] = tflite__micro__GetEvalOutput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2]);
 label$3 : {
  label$4 : {
   label$5 : {
    $0 = HEAP32[HEAP32[$2 + 8 >> 2] + 8 >> 2] + -1 | 0;
    if ($0 >>> 0 > 8) {
     break label$5;
    }
    label$6 : {
     switch ($0 - 1 | 0) {
     default:
      tflite__ops__micro__pooling___28anonymous_20namespace_29__AverageEvalFloat_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20TfLitePoolParams_20const__2c_20tflite__ops__micro__pooling___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
      break label$4;
     case 0:
     case 2:
     case 3:
     case 4:
     case 5:
     case 6:
      break label$5;
     case 1:
     case 7:
      break label$6;
     }
    }
    tflite__ops__micro__pooling___28anonymous_20namespace_29__AverageEvalQuantized_28TfLiteContext__2c_20TfLiteNode_20const__2c_20TfLitePoolParams_20const__2c_20tflite__ops__micro__pooling___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
    break label$4;
   }
   $0 = HEAP32[HEAP32[$2 + 24 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 24 >> 2];
   HEAP32[$2 >> 2] = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 8 >> 2] + 8 >> 2]);
   FUNCTION_TABLE[$0]($1, 134353, $2);
   HEAP32[$2 + 28 >> 2] = 1;
   break label$3;
  }
  HEAP32[$2 + 28 >> 2] = 0;
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function jswrap_banglejs_appRect() {
 var $0 = 0, $1 = 0;
 $0 = global$0 - 128 | 0;
 global$0 = $0;
 HEAP32[$0 + 120 >> 2] = jsvNewWithFlags(5);
 label$1 : {
  if (!HEAP32[$0 + 120 >> 2]) {
   HEAP32[$0 + 124 >> 2] = 0;
   break label$1;
  }
  $1 = $0 + 40 | 0;
  HEAP32[$0 + 116 >> 2] = jsvObjectGetChild(HEAP32[80546], 110016, 0);
  if (!(graphicsGetFromVar($1, HEAP32[$0 + 116 >> 2]) & 1)) {
   HEAP8[$0 + 52 | 0] = 176;
   HEAP8[$0 + 53 | 0] = 0;
   HEAP8[$0 + 54 | 0] = 176;
   HEAP8[$0 + 55 | 0] = 0;
  }
  jsvUnLock(HEAP32[$0 + 116 >> 2]);
  HEAP32[$0 + 36 >> 2] = jsvObjectGetChild(HEAP32[80545], 111555, 0);
  HEAP32[$0 + 32 >> 2] = 0;
  HEAP32[$0 + 28 >> 2] = 0;
  if (jsvIsObject(HEAP32[$0 + 36 >> 2]) & 1) {
   jsvObjectIteratorNew($0 + 24 | 0, HEAP32[$0 + 36 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue($0 + 24 | 0) & 1) {
     HEAP32[$0 + 20 >> 2] = jsvObjectIteratorGetValue($0 + 24 | 0);
     HEAP32[$0 + 16 >> 2] = jsvObjectGetChild(HEAP32[$0 + 20 >> 2], 111563, 0);
     if (jsvIsString(HEAP32[$0 + 16 >> 2]) & 1) {
      HEAP8[$0 + 15 | 0] = jsvGetCharInString(HEAP32[$0 + 16 >> 2], 0);
      if (HEAP8[$0 + 15 | 0] == 116) {
       HEAP32[$0 + 32 >> 2] = 24;
      }
      if (HEAP8[$0 + 15 | 0] == 98) {
       HEAP32[$0 + 28 >> 2] = 24;
      }
     }
     $1 = $0 + 24 | 0;
     jsvUnLock2(HEAP32[$0 + 16 >> 2], HEAP32[$0 + 20 >> 2]);
     jsvObjectIteratorNext($1);
     continue;
    }
    break;
   }
   jsvObjectIteratorFree($0 + 24 | 0);
  }
  jsvUnLock(HEAP32[$0 + 36 >> 2]);
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 120 >> 2], 110430, jsvNewFromInteger(0));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 120 >> 2], 110432, jsvNewFromInteger(HEAP32[$0 + 32 >> 2]));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 120 >> 2], 111568, jsvNewFromInteger(HEAPU8[$0 + 52 | 0] | HEAPU8[$0 + 53 | 0] << 8));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 120 >> 2], 111570, jsvNewFromInteger((HEAPU8[$0 + 54 | 0] | HEAPU8[$0 + 55 | 0] << 8) - (HEAP32[$0 + 32 >> 2] + HEAP32[$0 + 28 >> 2] | 0) | 0));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 120 >> 2], 111572, jsvNewFromInteger((HEAPU8[$0 + 52 | 0] | HEAPU8[$0 + 53 | 0] << 8) - 1 | 0));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 120 >> 2], 111575, jsvNewFromInteger((HEAPU8[$0 + 54 | 0] | HEAPU8[$0 + 55 | 0] << 8) - (HEAP32[$0 + 28 >> 2] + 1 | 0) | 0));
  HEAP32[$0 + 124 >> 2] = HEAP32[$0 + 120 >> 2];
 }
 global$0 = $0 + 128 | 0;
 return HEAP32[$0 + 124 >> 2];
}
function jsiHandleNewLine($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP8[$1 + 31 | 0] = $0;
 label$1 : {
  if (jsiAtEndOfInputLine() & 1) {
   label$3 : {
    if (!(HEAP8[$1 + 31 | 0] & 1)) {
     break label$3;
    }
    if ((jsiCountBracketsInInput() | 0) > 0) {
     break label$3;
    }
    if (jsiShowInputLine() & 1) {
     jsiConsolePrintString(81553);
    }
    if (!(HEAPU16[161112] & 2)) {
     HEAP8[322232] = 1;
    }
    HEAP32[$1 + 24 >> 2] = jsvStringTrimRight(HEAP32[80557]);
    jsiClearInputLine(0);
    label$6 : {
     if (HEAPU16[161112] & 8) {
      jsiDebuggerLine(HEAP32[$1 + 24 >> 2]);
      jsiHistoryAddLine(HEAP32[$1 + 24 >> 2]);
      jsvUnLock(HEAP32[$1 + 24 >> 2]);
      break label$6;
     }
     HEAP32[$1 + 20 >> 2] = jspEvaluateVar(HEAP32[$1 + 24 >> 2], 0, HEAPU16[161124]);
     HEAP8[$1 + 19 | 0] = jsvIsEmptyString(HEAP32[$1 + 24 >> 2]) & 1;
     if (!(HEAP8[$1 + 19 | 0] & 1)) {
      jsiHistoryAddLine(HEAP32[$1 + 24 >> 2]);
     }
     jsvUnLock(HEAP32[$1 + 24 >> 2]);
     HEAP16[161124] = 0;
     label$9 : {
      if (!(jsiEcho() & 1)) {
       break label$9;
      }
      if (jspHasError() & 1 | HEAP8[$1 + 19 | 0] & 1) {
       break label$9;
      }
      jsiConsolePrintChar(61);
      jsfPrintJSON(HEAP32[$1 + 20 >> 2], 813);
      jsiConsolePrintString(81553);
     }
     jsvUnLock(HEAP32[$1 + 20 >> 2]);
    }
    jsiCheckErrors();
    HEAP16[161112] = HEAPU16[161112] & -3;
    break label$1;
   }
   if (jsiShowInputLine() & 1) {
    jsiConsolePrintString(81740);
   }
   jsiIsAboutToEditInputLine();
   jsiAppendToInputLine(81553);
   HEAP32[80559] = HEAP32[80559] + 1;
   break label$1;
  }
  jsiIsAboutToEditInputLine();
  if (jsiShowInputLine() & 1) {
   jsiConsolePrintString(81039);
  }
  HEAP32[$1 + 12 >> 2] = jsvNewWithFlags(27);
  if (HEAPU32[80559] > 0) {
   jsvAppendStringVar(HEAP32[$1 + 12 >> 2], HEAP32[80557], 0, HEAP32[80559]);
  }
  jsvAppendCharacter(HEAP32[$1 + 12 >> 2], 10);
  jsvAppendStringVar(HEAP32[$1 + 12 >> 2], HEAP32[80557], HEAP32[80559], 2147483647);
  jsiInputLineCursorMoved();
  jsvUnLock(HEAP32[80557]);
  HEAP32[80557] = HEAP32[$1 + 12 >> 2];
  if (jsiShowInputLine() & 1) {
   jsiConsolePrintStringVarWithNewLineChar(HEAP32[80557], HEAP32[80559], 58);
   jsiMoveCursorChar(HEAP32[80557], jsvGetStringLength(HEAP32[80557]), HEAP32[80559] + 1 | 0);
  }
  HEAP32[80559] = HEAP32[80559] + 1;
 }
 global$0 = $1 + 32 | 0;
}
function tflite__ops__micro__pooling__MaxEval_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1 : {
  if (!HEAP32[HEAP32[$2 + 20 >> 2] + 12 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$2 + 16 >> 2] = HEAP32[HEAP32[$2 + 20 >> 2] + 12 >> 2];
 label$2 : {
  if (!HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2]) {
   break label$2;
  }
 }
 HEAP32[$2 + 12 >> 2] = HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2];
 HEAP32[$2 + 8 >> 2] = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], 0);
 HEAP32[$2 + 4 >> 2] = tflite__micro__GetEvalOutput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2]);
 label$3 : {
  label$4 : {
   label$5 : {
    $0 = HEAP32[HEAP32[$2 + 8 >> 2] + 8 >> 2] + -1 | 0;
    if ($0 >>> 0 > 8) {
     break label$5;
    }
    label$6 : {
     switch ($0 - 1 | 0) {
     default:
      tflite__ops__micro__pooling___28anonymous_20namespace_29__MaxEvalFloat_28TfLiteContext__2c_20TfLiteNode__2c_20TfLitePoolParams__2c_20tflite__ops__micro__pooling___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
      break label$4;
     case 0:
     case 2:
     case 3:
     case 4:
     case 5:
     case 6:
      break label$5;
     case 1:
     case 7:
      break label$6;
     }
    }
    tflite__ops__micro__pooling___28anonymous_20namespace_29__MaxEvalQuantized_28TfLiteContext__2c_20TfLiteNode__2c_20TfLitePoolParams__2c_20tflite__ops__micro__pooling___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
    break label$4;
   }
   $0 = HEAP32[HEAP32[$2 + 24 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 24 >> 2];
   HEAP32[$2 >> 2] = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 8 >> 2] + 8 >> 2]);
   FUNCTION_TABLE[$0]($1, 134394, $2);
   HEAP32[$2 + 28 >> 2] = 1;
   break label$3;
  }
  HEAP32[$2 + 28 >> 2] = 0;
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function jshFromDeviceString($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (HEAP8[HEAP32[$1 + 8 >> 2]] == 76) {
   if (!strcmp(HEAP32[$1 + 8 >> 2] + 1 | 0, 83192)) {
    HEAP8[$1 + 15 | 0] = 17;
    break label$1;
   }
   if (!strcmp(HEAP32[$1 + 8 >> 2] + 1 | 0, 83201)) {
    HEAP8[$1 + 15 | 0] = 18;
    break label$1;
   }
  }
  if (!(HEAP8[HEAP32[$1 + 8 >> 2]] != 85 | HEAP8[HEAP32[$1 + 8 >> 2] + 1 | 0] != 83 | (HEAP8[HEAP32[$1 + 8 >> 2] + 3 | 0] | HEAP8[HEAP32[$1 + 8 >> 2] + 2 | 0] != 66))) {
   HEAP8[$1 + 15 | 0] = 21;
   break label$1;
  }
  label$6 : {
   if (HEAP8[HEAP32[$1 + 8 >> 2]] == 84) {
    if (!strcmp(HEAP32[$1 + 8 >> 2] + 1 | 0, 83210)) {
     HEAP8[$1 + 15 | 0] = 20;
     break label$1;
    }
    break label$6;
   }
   label$9 : {
    if (HEAP8[HEAP32[$1 + 8 >> 2]] == 83) {
     label$11 : {
      if (HEAP8[HEAP32[$1 + 8 >> 2] + 1 | 0] != 101 | HEAP8[HEAP32[$1 + 8 >> 2] + 2 | 0] != 114 | (HEAP8[HEAP32[$1 + 8 >> 2] + 3 | 0] != 105 | HEAP8[HEAP32[$1 + 8 >> 2] + 4 | 0] != 97)) {
       break label$11;
      }
      if (HEAP8[HEAP32[$1 + 8 >> 2] + 5 | 0] != 108 | HEAP8[HEAP32[$1 + 8 >> 2] + 6 | 0] < 49 | (HEAP8[HEAP32[$1 + 8 >> 2] + 7 | 0] | (HEAP8[HEAP32[$1 + 8 >> 2] + 6 | 0] - 49 | 0) >= 1)) {
       break label$11;
      }
      HEAP8[$1 + 15 | 0] = HEAP8[HEAP32[$1 + 8 >> 2] + 6 | 0] + -27;
      break label$1;
     }
     label$12 : {
      if (HEAP8[HEAP32[$1 + 8 >> 2] + 1 | 0] != 80 | HEAP8[HEAP32[$1 + 8 >> 2] + 2 | 0] != 73 | (HEAP8[HEAP32[$1 + 8 >> 2] + 3 | 0] < 49 | (HEAP8[HEAP32[$1 + 8 >> 2] + 3 | 0] - 49 | 0) >= 1)) {
       break label$12;
      }
      if (HEAP8[HEAP32[$1 + 8 >> 2] + 4 | 0]) {
       break label$12;
      }
      HEAP8[$1 + 15 | 0] = HEAP8[HEAP32[$1 + 8 >> 2] + 3 | 0] + -25;
      break label$1;
     }
     break label$9;
    }
    label$13 : {
     if (HEAP8[HEAP32[$1 + 8 >> 2]] != 73 | HEAP8[HEAP32[$1 + 8 >> 2] + 1 | 0] != 50 | (HEAP8[HEAP32[$1 + 8 >> 2] + 2 | 0] != 67 | HEAP8[HEAP32[$1 + 8 >> 2] + 3 | 0] < 49)) {
      break label$13;
     }
     if (HEAP8[HEAP32[$1 + 8 >> 2] + 4 | 0] | (HEAP8[HEAP32[$1 + 8 >> 2] + 3 | 0] - 49 | 0) >= 1) {
      break label$13;
     }
     HEAP8[$1 + 15 | 0] = HEAP8[HEAP32[$1 + 8 >> 2] + 3 | 0] + -24;
     break label$1;
    }
   }
  }
  HEAP8[$1 + 15 | 0] = 0;
 }
 global$0 = $1 + 16 | 0;
 return HEAPU8[$1 + 15 | 0];
}
function _jswrap_graphics_stringMetrics($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 192 | 0;
 global$0 = $5;
 HEAP32[$5 + 188 >> 2] = $0;
 HEAP32[$5 + 184 >> 2] = $1;
 HEAP32[$5 + 180 >> 2] = $2;
 HEAP32[$5 + 176 >> 2] = $3;
 HEAP32[$5 + 172 >> 2] = $4;
 $0 = $5 + 160 | 0;
 _jswrap_graphics_getFontInfo(HEAP32[$5 + 188 >> 2], $0);
 HEAP32[$5 + 156 >> 2] = _jswrap_graphics_getFontHeightInternal(HEAP32[$5 + 188 >> 2], $0);
 HEAP32[$5 + 152 >> 2] = jsvAsString(HEAP32[$5 + 184 >> 2]);
 $0 = $5 + 112 | 0;
 $1 = HEAP32[$5 + 152 >> 2];
 if (HEAP32[$5 + 180 >> 2] < 0) {
  $2 = 0;
 } else {
  $2 = HEAP32[$5 + 180 >> 2];
 }
 jsvStringIteratorNew($0, $1, $2);
 HEAP32[$5 + 108 >> 2] = 0;
 HEAP32[$5 + 104 >> 2] = HEAP32[$5 + 156 >> 2];
 HEAP32[$5 + 100 >> 2] = 0;
 while (1) {
  label$3 : {
   if (!(jsvStringIteratorHasChar($5 + 112 | 0) & 1)) {
    break label$3;
   }
   HEAP8[$5 + 99 | 0] = jsvStringIteratorGetCharAndNext($5 + 112 | 0);
   if (HEAP8[$5 + 99 | 0] == 10) {
    if (HEAP32[$5 + 108 >> 2] > HEAP32[$5 + 100 >> 2]) {
     HEAP32[$5 + 100 >> 2] = HEAP32[$5 + 108 >> 2];
    }
    HEAP32[$5 + 108 >> 2] = 0;
    HEAP32[$5 + 104 >> 2] = HEAP32[$5 + 156 >> 2] + HEAP32[$5 + 104 >> 2];
    if (HEAP32[$5 + 180 >> 2] >= 0) {
     break label$3;
    }
   }
   if (!HEAP8[$5 + 99 | 0]) {
    $0 = $5 + 8 | 0;
    HEAP32[$5 + 4 >> 2] = jsvStringIteratorGetIndex($5 + 112 | 0);
    if (_jswrap_graphics_parseImage(HEAP32[$5 + 188 >> 2], HEAP32[$5 + 152 >> 2], HEAP32[$5 + 4 >> 2], $0) & 1) {
     $0 = $5 + 8 | 0;
     jsvStringIteratorGoto($5 + 112 | 0, HEAP32[$5 + 152 >> 2], HEAPU16[$5 + 58 >> 1] + (HEAP32[$5 + 4 >> 2] + HEAPU16[$5 + 56 >> 1] | 0) | 0);
     _jswrap_graphics_freeImageInfo($0);
     HEAP32[$5 + 108 >> 2] = HEAP32[$5 + 8 >> 2] + HEAP32[$5 + 108 >> 2];
    }
    continue;
   }
   HEAP32[$5 + 108 >> 2] = _jswrap_graphics_getCharWidth(HEAP32[$5 + 188 >> 2], $5 + 160 | 0, HEAP8[$5 + 99 | 0]) + HEAP32[$5 + 108 >> 2];
   continue;
  }
  break;
 }
 jsvStringIteratorFree($5 + 112 | 0);
 jsvUnLock(HEAP32[$5 + 152 >> 2]);
 if (HEAP32[$5 + 176 >> 2]) {
  $0 = HEAP32[$5 + 176 >> 2];
  if (HEAP32[$5 + 108 >> 2] > HEAP32[$5 + 100 >> 2]) {
   $1 = HEAP32[$5 + 108 >> 2];
  } else {
   $1 = HEAP32[$5 + 100 >> 2];
  }
  HEAP32[$0 >> 2] = $1;
 }
 if (HEAP32[$5 + 172 >> 2]) {
  HEAP32[HEAP32[$5 + 172 >> 2] >> 2] = HEAP32[$5 + 104 >> 2];
 }
 global$0 = $5 + 192 | 0;
}
function jswrap_spi_write($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = global$0 - 80 | 0;
 global$0 = $2;
 $3 = $2 - -64 | 0;
 $4 = $2 + 48 | 0;
 HEAP32[$2 + 76 >> 2] = $0;
 HEAP32[$2 + 72 >> 2] = $1;
 HEAP8[$2 + 71 | 0] = jsiGetDeviceFromClass(HEAP32[$2 + 76 >> 2]);
 label$1 : {
  if (!(jsspiGetSendFunction(HEAP32[$2 + 76 >> 2], $3, $4) & 1)) {
   break label$1;
  }
  HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 64 >> 2];
  $1 = $2 + 48 | 0;
  $4 = HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8 | (HEAPU8[$1 + 6 | 0] << 16 | HEAPU8[$1 + 7 | 0] << 24);
  $0 = $2 + 24 | 0;
  $3 = $0;
  $5 = HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24);
  HEAP8[$3 + 4 | 0] = $5;
  HEAP8[$3 + 5 | 0] = $5 >>> 8;
  HEAP8[$3 + 6 | 0] = $5 >>> 16;
  HEAP8[$3 + 7 | 0] = $5 >>> 24;
  HEAP8[$3 + 8 | 0] = $4;
  HEAP8[$3 + 9 | 0] = $4 >>> 8;
  HEAP8[$3 + 10 | 0] = $4 >>> 16;
  HEAP8[$3 + 11 | 0] = $4 >>> 24;
  $3 = HEAPU8[$1 + 10 | 0] | HEAPU8[$1 + 11 | 0] << 8 | (HEAPU8[$1 + 12 | 0] << 16 | HEAPU8[$1 + 13 | 0] << 24);
  $1 = HEAPU8[$1 + 6 | 0] | HEAPU8[$1 + 7 | 0] << 8 | (HEAPU8[$1 + 8 | 0] << 16 | HEAPU8[$1 + 9 | 0] << 24);
  HEAP8[$0 + 10 | 0] = $1;
  HEAP8[$0 + 11 | 0] = $1 >>> 8;
  HEAP8[$0 + 12 | 0] = $1 >>> 16;
  HEAP8[$0 + 13 | 0] = $1 >>> 24;
  HEAP8[$0 + 14 | 0] = $3;
  HEAP8[$0 + 15 | 0] = $3 >>> 8;
  HEAP8[$0 + 16 | 0] = $3 >>> 16;
  HEAP8[$0 + 17 | 0] = $3 >>> 24;
  HEAP8[$2 + 23 | 0] = 255;
  HEAP32[$2 + 16 >> 2] = jsvGetArrayLength(HEAP32[$2 + 72 >> 2]);
  if (HEAP32[$2 + 16 >> 2] > 0) {
   HEAP32[$2 + 12 >> 2] = jsvGetArrayItem(HEAP32[$2 + 72 >> 2], HEAP32[$2 + 16 >> 2] - 1 | 0);
   if (jsvIsPin(HEAP32[$2 + 12 >> 2]) & 1) {
    HEAP8[$2 + 23 | 0] = jshGetPinFromVar(HEAP32[$2 + 12 >> 2]);
    jsvUnLock(jsvArrayPop(HEAP32[$2 + 72 >> 2]));
   }
   jsvUnLock(HEAP32[$2 + 12 >> 2]);
  }
  if (!(HEAPU8[$2 + 71 | 0] < 24 | HEAPU8[$2 + 71 | 0] > 24)) {
   jshPinSetState(HEAPU8[$2 + 71 | 0], 0);
  }
  if (HEAPU8[$2 + 23 | 0] != 255) {
   jshPinOutput(HEAPU8[$2 + 23 | 0], 0);
  }
  jsvIterateBufferCallback(HEAP32[$2 + 72 >> 2], 592, $2 + 24 | 0);
  if (!(HEAPU8[$2 + 71 | 0] < 24 | HEAPU8[$2 + 71 | 0] > 24)) {
   jshUSARTUnSetup(HEAPU8[$2 + 71 | 0]);
  }
  if (HEAPU8[$2 + 23 | 0] == 255) {
   break label$1;
  }
  jshPinOutput(HEAPU8[$2 + 23 | 0], 1);
 }
 global$0 = $2 + 80 | 0;
}
function jswrap_graphics_setFontCustom($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0;
 $5 = global$0 - 112 | 0;
 global$0 = $5;
 HEAP32[$5 + 104 >> 2] = $0;
 HEAP32[$5 + 100 >> 2] = $1;
 HEAP32[$5 + 96 >> 2] = $2;
 HEAP32[$5 + 92 >> 2] = $3;
 HEAP32[$5 + 88 >> 2] = $4;
 label$1 : {
  if (!(graphicsGetFromVar($5 + 16 | 0, HEAP32[$5 + 104 >> 2]) & 1)) {
   HEAP32[$5 + 108 >> 2] = 0;
   break label$1;
  }
  if (!(jsvIsString(HEAP32[$5 + 100 >> 2]) & 1)) {
   jsExceptionHere(1, 127567, 0);
   HEAP32[$5 + 108 >> 2] = 0;
   break label$1;
  }
  if (!(HEAP32[$5 + 96 >> 2] <= 255 ? HEAP32[$5 + 96 >> 2] >= 0 : 0)) {
   jsExceptionHere(1, 127596, 0);
   HEAP32[$5 + 108 >> 2] = 0;
   break label$1;
  }
  label$6 : {
   if (jsvIsString(HEAP32[$5 + 92 >> 2]) & 1) {
    break label$6;
   }
   if (jsvIsInt(HEAP32[$5 + 92 >> 2]) & 1) {
    break label$6;
   }
   jsExceptionHere(1, 127625, 0);
   HEAP32[$5 + 108 >> 2] = 0;
   break label$1;
  }
  HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 88 >> 2] >> 8 & 255;
  if (HEAP32[$5 + 12 >> 2] < 1) {
   HEAP32[$5 + 12 >> 2] = 1;
  }
  HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 88 >> 2] >> 16;
  if (HEAP32[$5 + 8 >> 2] < 1) {
   HEAP32[$5 + 8 >> 2] = 1;
  }
  label$9 : {
   if (HEAP32[$5 + 8 >> 2] == 1) {
    HEAP32[$5 + 4 >> 2] = 32768;
    break label$9;
   }
   label$11 : {
    if (HEAP32[$5 + 8 >> 2] == 2) {
     HEAP32[$5 + 4 >> 2] = 40960;
     break label$11;
    }
    label$13 : {
     if (HEAP32[$5 + 8 >> 2] == 4) {
      HEAP32[$5 + 4 >> 2] = 49152;
      break label$13;
     }
     jsExceptionHere(1, 127667, 0);
     HEAP32[$5 + 108 >> 2] = 0;
     break label$1;
    }
   }
  }
  $0 = $5 + 16 | 0;
  HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 88 >> 2] & 255;
  jsvObjectSetChild(HEAP32[$5 + 104 >> 2], 127547, HEAP32[$5 + 100 >> 2]);
  jsvObjectSetChild(HEAP32[$5 + 104 >> 2], 127552, HEAP32[$5 + 92 >> 2]);
  jsvObjectSetChildAndUnLock(HEAP32[$5 + 104 >> 2], 127557, jsvNewFromInteger(HEAP32[$5 + 88 >> 2]));
  jsvObjectSetChildAndUnLock(HEAP32[$5 + 104 >> 2], 127562, jsvNewFromInteger(HEAP32[$5 + 96 >> 2]));
  $1 = HEAP32[$5 + 12 >> 2] + HEAP32[$5 + 4 >> 2] | 0;
  HEAP8[$5 + 41 | 0] = $1;
  HEAP8[$5 + 42 | 0] = $1 >>> 8;
  graphicsSetVar($0);
  HEAP32[$5 + 108 >> 2] = jsvLockAgain(HEAP32[$5 + 104 >> 2]);
 }
 global$0 = $5 + 112 | 0;
 return HEAP32[$5 + 108 >> 2];
}
function escapeCharacter($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP8[$2 + 11 | 0] = $0;
 HEAP8[$2 + 10 | 0] = $1;
 label$1 : {
  if (HEAP8[$2 + 11 | 0] == 8) {
   HEAP32[$2 + 12 >> 2] = 79414;
   break label$1;
  }
  if (HEAP8[$2 + 11 | 0] == 9) {
   HEAP32[$2 + 12 >> 2] = 79417;
   break label$1;
  }
  if (HEAP8[$2 + 11 | 0] == 10) {
   HEAP32[$2 + 12 >> 2] = 79420;
   break label$1;
  }
  if (!(HEAP8[$2 + 10 | 0] & 1 | HEAP8[$2 + 11 | 0] != 11)) {
   HEAP32[$2 + 12 >> 2] = 79423;
   break label$1;
  }
  if (HEAP8[$2 + 11 | 0] == 12) {
   HEAP32[$2 + 12 >> 2] = 79426;
   break label$1;
  }
  if (HEAP8[$2 + 11 | 0] == 13) {
   HEAP32[$2 + 12 >> 2] = 79429;
   break label$1;
  }
  if (HEAP8[$2 + 11 | 0] == 92) {
   HEAP32[$2 + 12 >> 2] = 79432;
   break label$1;
  }
  if (HEAP8[$2 + 11 | 0] == 34) {
   HEAP32[$2 + 12 >> 2] = 79435;
   break label$1;
  }
  HEAP8[$2 + 9 | 0] = HEAPU8[$2 + 11 | 0];
  if (!(HEAP8[$2 + 10 | 0] & 1 | HEAPU8[$2 + 9 | 0] >= 8)) {
   HEAP8[322172] = 92;
   HEAP8[322173] = HEAPU8[$2 + 9 | 0] + 48;
   HEAP8[322174] = 0;
   HEAP32[$2 + 12 >> 2] = 322172;
   break label$1;
  }
  if (!(HEAPU8[$2 + 9 | 0] < 127 ? HEAPU8[$2 + 9 | 0] >= 32 : 0)) {
   HEAP8[322172] = 92;
   HEAP32[$2 + 4 >> 2] = 2;
   label$13 : {
    if (HEAP8[$2 + 10 | 0] & 1) {
     HEAP8[322173] = 117;
     $0 = HEAP32[$2 + 4 >> 2];
     HEAP32[$2 + 4 >> 2] = $0 + 1;
     HEAP8[$0 + 322172 | 0] = 48;
     $0 = HEAP32[$2 + 4 >> 2];
     HEAP32[$2 + 4 >> 2] = $0 + 1;
     HEAP8[$0 + 322172 | 0] = 48;
     break label$13;
    }
    HEAP8[322173] = 120;
   }
   HEAP32[$2 >> 2] = HEAPU8[$2 + 9 | 0] >> 4;
   if (HEAP32[$2 >> 2] < 10) {
    $0 = HEAP32[$2 >> 2] + 48 | 0;
   } else {
    $0 = HEAP32[$2 >> 2] + 55 | 0;
   }
   $1 = HEAP32[$2 + 4 >> 2];
   HEAP32[$2 + 4 >> 2] = $1 + 1;
   HEAP8[$1 + 322172 | 0] = $0;
   HEAP32[$2 >> 2] = HEAPU8[$2 + 9 | 0] & 15;
   if (HEAP32[$2 >> 2] < 10) {
    $0 = HEAP32[$2 >> 2] + 48 | 0;
   } else {
    $0 = HEAP32[$2 >> 2] + 55 | 0;
   }
   $1 = HEAP32[$2 + 4 >> 2];
   HEAP32[$2 + 4 >> 2] = $1 + 1;
   HEAP8[$1 + 322172 | 0] = $0;
   $0 = HEAP32[$2 + 4 >> 2];
   HEAP32[$2 + 4 >> 2] = $0 + 1;
   HEAP8[$0 + 322172 | 0] = 0;
   HEAP32[$2 + 12 >> 2] = 322172;
   break label$1;
  }
  HEAP8[322173] = 0;
  HEAP8[322172] = HEAPU8[$2 + 11 | 0];
  HEAP32[$2 + 12 >> 2] = 322172;
 }
 return HEAP32[$2 + 12 >> 2];
}
function jswrap_array_includes($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 112 | 0;
 global$0 = $3;
 HEAP32[$3 + 104 >> 2] = $0;
 HEAP32[$3 + 100 >> 2] = $1;
 HEAP32[$3 + 96 >> 2] = $2;
 if (HEAP32[$3 + 96 >> 2] < 0) {
  HEAP32[$3 + 96 >> 2] = jsvGetLength(HEAP32[$3 + 104 >> 2]) + HEAP32[$3 + 96 >> 2];
 }
 if (HEAP32[$3 + 96 >> 2] < 0) {
  HEAP32[$3 + 96 >> 2] = 0;
 }
 $1 = jsvIsFloat(HEAP32[$3 + 100 >> 2]) & 1;
 $0 = $3;
 if ($1) {
  $1 = __DOUBLE_BITS(jsvGetFloat(HEAP32[$3 + 100 >> 2]));
  $2 = i64toi32_i32$HIGH_BITS & 2147483647;
  $1 = ($2 | 0) == 2146435072 & $1 >>> 0 > 0 | $2 >>> 0 > 2146435072;
 } else {
  $1 = 0;
 }
 HEAP8[$0 + 95 | 0] = $1;
 label$5 : {
  if (!(jsvIsIterable(HEAP32[$3 + 104 >> 2]) & 1)) {
   HEAP8[$3 + 111 | 0] = 0;
   break label$5;
  }
  jsvIteratorNew($3 + 32 | 0, HEAP32[$3 + 104 >> 2], 0);
  while (1) {
   if (jsvIteratorHasElement($3 + 32 | 0) & 1) {
    HEAP32[$3 + 28 >> 2] = jsvIteratorGetKey($3 + 32 | 0);
    label$9 : {
     if (!(jsvIsInt(HEAP32[$3 + 28 >> 2]) & 1)) {
      break label$9;
     }
     if ((jsvGetInteger(HEAP32[$3 + 28 >> 2]) | 0) < HEAP32[$3 + 96 >> 2]) {
      break label$9;
     }
     HEAP32[$3 + 24 >> 2] = jsvIteratorGetValue($3 + 32 | 0);
     label$10 : {
      label$11 : {
       if (HEAP32[$3 + 24 >> 2] == HEAP32[$3 + 100 >> 2]) {
        break label$11;
       }
       if (jsvMathsOpTypeEqual(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 100 >> 2]) & 1) {
        break label$11;
       }
       if (!(HEAP8[$3 + 95 | 0] & 1)) {
        break label$10;
       }
       if (!(jsvIsFloat(HEAP32[$3 + 24 >> 2]) & 1)) {
        break label$10;
       }
       $0 = __DOUBLE_BITS(jsvGetFloat(HEAP32[$3 + 24 >> 2]));
       $1 = i64toi32_i32$HIGH_BITS & 2147483647;
       if (($1 | 0) == 2146435072 & $0 >>> 0 > 0 | $1 >>> 0 > 2146435072) {
        break label$11;
       }
       break label$10;
      }
      $0 = $3 + 32 | 0;
      jsvUnLock2(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2]);
      jsvIteratorFree($0);
      HEAP8[$3 + 111 | 0] = 1;
      break label$5;
     }
     jsvUnLock(HEAP32[$3 + 24 >> 2]);
    }
    $0 = $3 + 32 | 0;
    jsvUnLock(HEAP32[$3 + 28 >> 2]);
    jsvIteratorNext($0);
    continue;
   }
   break;
  }
  jsvIteratorFree($3 + 32 | 0);
  HEAP8[$3 + 111 | 0] = 0;
 }
 global$0 = $3 + 112 | 0;
 return HEAP8[$3 + 111 | 0] & 1;
}
function tflite__MicroAllocator__AllocateTfLiteEvalTensors_28tflite__Model_20const__2c_20TfLiteEvalTensor___29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 + -64 | 0;
 global$0 = $3;
 HEAP32[$3 + 56 >> 2] = $0;
 HEAP32[$3 + 52 >> 2] = $1;
 HEAP32[$3 + 48 >> 2] = $2;
 $0 = HEAP32[$3 + 56 >> 2];
 label$1 : {
  if (!HEAP32[$3 + 48 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$3 + 44 >> 2] = tflite__MicroAllocator__GetSubGraphFromModel_28tflite__Model_20const__29($0, HEAP32[$3 + 52 >> 2]);
 label$2 : {
  if (!HEAP32[$3 + 44 >> 2]) {
   break label$2;
  }
 }
 HEAP32[$3 + 40 >> 2] = flatbuffers__Vector_int___size_28_29_20const(tflite__Tensor__shape_28_29_20const(HEAP32[$3 + 44 >> 2]));
 $1 = HEAP32[$0 + 4 >> 2];
 HEAP32[$3 + 36 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$1 >> 2] + 12 >> 2]]($1, Math_imul(HEAP32[$3 + 40 >> 2], 12), 4);
 label$3 : {
  if (!HEAP32[$3 + 36 >> 2]) {
   $0 = HEAP32[$0 + 8 >> 2];
   HEAP32[$3 >> 2] = Math_imul(HEAP32[$3 + 40 >> 2], 12);
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 132532, $3);
   HEAP32[$3 + 60 >> 2] = 1;
   break label$3;
  }
  HEAP32[$3 + 32 >> 2] = 0;
  while (1) {
   if (HEAPU32[$3 + 32 >> 2] < HEAPU32[$3 + 40 >> 2]) {
    HEAP32[$3 + 28 >> 2] = tflite__internal__InitializeTfLiteEvalTensorFromFlatbuffer_28tflite__SimpleMemoryAllocator__2c_20tflite__Tensor_20const__2c_20flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer__20__20const__2c_20tflite__ErrorReporter__2c_20TfLiteEvalTensor__29(HEAP32[$0 + 4 >> 2], flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph__20___Get_28unsigned_20int_29_20const(tflite__Tensor__shape_28_29_20const(HEAP32[$3 + 44 >> 2]), HEAP32[$3 + 32 >> 2]), tflite__Tensor__quantization_28_29_20const(HEAP32[$3 + 52 >> 2]), HEAP32[$0 + 8 >> 2], HEAP32[$3 + 36 >> 2] + Math_imul(HEAP32[$3 + 32 >> 2], 12) | 0);
    if (HEAP32[$3 + 28 >> 2]) {
     $0 = HEAP32[$0 + 8 >> 2];
     HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 32 >> 2];
     tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 132603, $3 + 16 | 0);
     HEAP32[$3 + 60 >> 2] = 1;
     break label$3;
    } else {
     HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 32 >> 2] + 1;
     continue;
    }
   }
   break;
  }
  HEAP32[HEAP32[$3 + 48 >> 2] >> 2] = HEAP32[$3 + 36 >> 2];
  HEAP32[$3 + 60 >> 2] = 0;
 }
 global$0 = $3 - -64 | 0;
 return HEAP32[$3 + 60 >> 2];
}
function jsspiGetSendFunction($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP32[$3 + 40 >> 2] = $0;
 HEAP32[$3 + 36 >> 2] = $1;
 HEAP32[$3 + 32 >> 2] = $2;
 HEAP8[$3 + 31 | 0] = jsiGetDeviceFromClass(HEAP32[$3 + 40 >> 2]);
 label$1 : {
  if (!(HEAPU8[$3 + 31 | 0] < 24 | HEAPU8[$3 + 31 | 0] > 24)) {
   if (!(jshIsDeviceInitialised(HEAPU8[$3 + 31 | 0]) & 1)) {
    $0 = $3 + 16 | 0;
    jshSPIInitInfo($0);
    jshUSARTSetup(HEAPU8[$3 + 31 | 0], $0);
   }
   HEAP32[HEAP32[$3 + 36 >> 2] >> 2] = 17;
   HEAP8[HEAP32[$3 + 32 >> 2]] = HEAPU8[$3 + 31 | 0];
   HEAP8[$3 + 47 | 0] = 1;
   break label$1;
  }
  if (!HEAPU8[$3 + 31 | 0]) {
   $0 = $3 + 16 | 0;
   HEAP32[$3 + 12 >> 2] = jsvObjectGetChild(HEAP32[$3 + 40 >> 2], 83758, 0);
   jsspiPopulateSPIInfo($0, HEAP32[$3 + 12 >> 2]);
   jsvUnLock(HEAP32[$3 + 12 >> 2]);
   label$5 : {
    label$6 : {
     if (HEAPU8[$3 + 23 | 0] == 255 | HEAPU8[$3 + 22 | 0] != 255 | (HEAPU8[$3 + 24 | 0] | HEAPU8[$3 + 21 | 0] == 255)) {
      break label$6;
     }
     if (!(HEAP8[$3 + 25 | 0] & 1)) {
      break label$6;
     }
     HEAP32[HEAP32[$3 + 36 >> 2] >> 2] = 18;
     break label$5;
    }
    HEAP32[HEAP32[$3 + 36 >> 2] >> 2] = 19;
   }
   $2 = $3 + 16 | 0;
   $0 = HEAPU8[$2 + 4 | 0] | HEAPU8[$2 + 5 | 0] << 8 | (HEAPU8[$2 + 6 | 0] << 16 | HEAPU8[$2 + 7 | 0] << 24);
   $1 = HEAP32[$3 + 32 >> 2];
   $4 = HEAPU8[$2 | 0] | HEAPU8[$2 + 1 | 0] << 8 | (HEAPU8[$2 + 2 | 0] << 16 | HEAPU8[$2 + 3 | 0] << 24);
   HEAP8[$1 | 0] = $4;
   HEAP8[$1 + 1 | 0] = $4 >>> 8;
   HEAP8[$1 + 2 | 0] = $4 >>> 16;
   HEAP8[$1 + 3 | 0] = $4 >>> 24;
   HEAP8[$1 + 4 | 0] = $0;
   HEAP8[$1 + 5 | 0] = $0 >>> 8;
   HEAP8[$1 + 6 | 0] = $0 >>> 16;
   HEAP8[$1 + 7 | 0] = $0 >>> 24;
   $0 = HEAPU8[$2 + 10 | 0] | HEAPU8[$2 + 11 | 0] << 8 | (HEAPU8[$2 + 12 | 0] << 16 | HEAPU8[$2 + 13 | 0] << 24);
   $2 = HEAPU8[$2 + 6 | 0] | HEAPU8[$2 + 7 | 0] << 8 | (HEAPU8[$2 + 8 | 0] << 16 | HEAPU8[$2 + 9 | 0] << 24);
   HEAP8[$1 + 6 | 0] = $2;
   HEAP8[$1 + 7 | 0] = $2 >>> 8;
   HEAP8[$1 + 8 | 0] = $2 >>> 16;
   HEAP8[$1 + 9 | 0] = $2 >>> 24;
   HEAP8[$1 + 10 | 0] = $0;
   HEAP8[$1 + 11 | 0] = $0 >>> 8;
   HEAP8[$1 + 12 | 0] = $0 >>> 16;
   HEAP8[$1 + 13 | 0] = $0 >>> 24;
   HEAP8[$3 + 47 | 0] = 1;
   break label$1;
  }
  HEAP8[$3 + 47 | 0] = 0;
 }
 global$0 = $3 + 48 | 0;
 return HEAP8[$3 + 47 | 0] & 1;
}
function __trunctfdf2($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $6 = global$0 - 32 | 0;
 global$0 = $6;
 $4 = $3 & 2147483647;
 $8 = $4;
 $4 = $4 + -1006698496 | 0;
 $7 = $2;
 $5 = $2;
 if ($2 >>> 0 < 0) {
  $4 = $4 + 1 | 0;
 }
 $9 = $5;
 $5 = $4;
 $4 = $8 + -1140785152 | 0;
 $10 = $7;
 if ($7 >>> 0 < 0) {
  $4 = $4 + 1 | 0;
 }
 label$1 : {
  if (($4 | 0) == ($5 | 0) & $9 >>> 0 < $10 >>> 0 | $5 >>> 0 < $4 >>> 0) {
   $4 = $3 << 4 | $2 >>> 28;
   $2 = $2 << 4 | $1 >>> 28;
   $1 = $1 & 268435455;
   $7 = $1;
   if (($1 | 0) == 134217728 & $0 >>> 0 >= 1 | $1 >>> 0 > 134217728) {
    $4 = $4 + 1073741824 | 0;
    $0 = $2 + 1 | 0;
    if ($0 >>> 0 < 1) {
     $4 = $4 + 1 | 0;
    }
    $5 = $0;
    break label$1;
   }
   $5 = $2;
   $4 = $4 - (($2 >>> 0 < 0) + -1073741824 | 0) | 0;
   if ($0 | $7 ^ 134217728) {
    break label$1;
   }
   $0 = $5 + ($5 & 1) | 0;
   if ($0 >>> 0 < $5 >>> 0) {
    $4 = $4 + 1 | 0;
   }
   $5 = $0;
   break label$1;
  }
  if (!(!$7 & ($8 | 0) == 2147418112 ? !($0 | $1) : ($8 | 0) == 2147418112 & $7 >>> 0 < 0 | $8 >>> 0 < 2147418112)) {
   $4 = $3 << 4 | $2 >>> 28;
   $5 = $2 << 4 | $1 >>> 28;
   $4 = $4 & 524287 | 2146959360;
   break label$1;
  }
  $5 = 0;
  $4 = 2146435072;
  if (($8 | 0) == 1140785151 & $7 >>> 0 > 4294967295 | $8 >>> 0 > 1140785151) {
   break label$1;
  }
  $4 = 0;
  $7 = $8 >>> 16;
  if ($7 >>> 0 < 15249) {
   break label$1;
  }
  $4 = $3 & 65535 | 65536;
  __lshrti3($6, $0, $1, $2, $4, 15361 - $7 | 0);
  __ashlti3($6 + 16 | 0, $0, $1, $2, $4, $7 + -15233 | 0);
  $2 = HEAP32[$6 + 4 >> 2];
  $0 = HEAP32[$6 + 8 >> 2];
  $4 = HEAP32[$6 + 12 >> 2] << 4 | $0 >>> 28;
  $5 = $0 << 4 | $2 >>> 28;
  $0 = $2 & 268435455;
  $2 = $0;
  $1 = HEAP32[$6 >> 2] | ((HEAP32[$6 + 16 >> 2] | HEAP32[$6 + 24 >> 2]) != 0 | (HEAP32[$6 + 20 >> 2] | HEAP32[$6 + 28 >> 2]) != 0);
  if (($0 | 0) == 134217728 & $1 >>> 0 >= 1 | $0 >>> 0 > 134217728) {
   $0 = $5 + 1 | 0;
   if ($0 >>> 0 < 1) {
    $4 = $4 + 1 | 0;
   }
   $5 = $0;
   break label$1;
  }
  if ($1 | $2 ^ 134217728) {
   break label$1;
  }
  $0 = $5 + ($5 & 1) | 0;
  if ($0 >>> 0 < $5 >>> 0) {
   $4 = $4 + 1 | 0;
  }
  $5 = $0;
 }
 global$0 = $6 + 32 | 0;
 $0 = $3 & -2147483648 | $4;
 wasm2js_scratch_store_i32(0, $5 | 0);
 wasm2js_scratch_store_i32(1, $0 | 0);
 return +wasm2js_scratch_load_f64();
}
function jswrap_i2c_readFrom($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0;
 $4 = global$0 - 112 | 0;
 $3 = $4;
 global$0 = $3;
 $5 = $3 + 94 | 0;
 HEAP32[$3 + 104 >> 2] = $0;
 HEAP32[$3 + 100 >> 2] = $1;
 HEAP32[$3 + 96 >> 2] = $2;
 HEAP8[$3 + 95 | 0] = jsiGetDeviceFromClass(HEAP32[$3 + 104 >> 2]);
 HEAP8[$3 + 94 | 0] = 1;
 HEAP32[$3 + 88 >> 2] = i2c_get_address(HEAP32[$3 + 100 >> 2], $5);
 label$1 : {
  if (HEAP32[$3 + 96 >> 2] <= 0) {
   HEAP32[$3 + 108 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$3 + 96 >> 2] + 256 >>> 0 > 1e6) {
   jsExceptionHere(1, 125869, 0);
   HEAP32[$3 + 108 >> 2] = 0;
   break label$1;
  }
  $0 = $4 - (HEAP32[$3 + 96 >> 2] + 15 & -16) | 0;
  global$0 = $0;
  HEAP32[$3 + 84 >> 2] = $0;
  label$4 : {
   if (!(HEAPU8[$3 + 95 | 0] < 25 | HEAPU8[$3 + 95 | 0] > 25)) {
    jshI2CWrite(HEAPU8[$3 + 95 | 0], HEAP32[$3 + 88 >> 2] & 255, HEAP32[$3 + 96 >> 2], HEAP32[$3 + 84 >> 2], HEAP8[$3 + 94 | 0] & 1);
    break label$4;
   }
   label$6 : {
    if (!HEAPU8[$3 + 95 | 0]) {
     $0 = $3 + 72 | 0;
     HEAP32[$3 + 68 >> 2] = jsvObjectGetChild(HEAP32[$3 + 104 >> 2], 125679, 0);
     if (jsi2cPopulateI2CInfo($0, HEAP32[$3 + 68 >> 2]) & 1) {
      $0 = $3 + 72 | 0;
      HEAP8[$3 + 78 | 0] = jsvGetBoolAndUnLock(jsvObjectGetChild(HEAP32[$3 + 104 >> 2], 125861, 0)) & 1;
      jsi2cRead($0, HEAP32[$3 + 88 >> 2] & 255, HEAP32[$3 + 96 >> 2], HEAP32[$3 + 84 >> 2], HEAP8[$3 + 94 | 0] & 1);
     }
     jsvUnLock2(jsvObjectSetChild(HEAP32[$3 + 104 >> 2], 125861, jsvNewFromBool(HEAP8[$3 + 78 | 0] & 1)), HEAP32[$3 + 68 >> 2]);
     break label$6;
    }
    HEAP32[$3 + 108 >> 2] = 0;
    break label$1;
   }
  }
  HEAP32[$3 + 64 >> 2] = jsvNewTypedArray(1, HEAP32[$3 + 96 >> 2]);
  if (HEAP32[$3 + 64 >> 2]) {
   jsvArrayBufferIteratorNew($3 + 8 | 0, HEAP32[$3 + 64 >> 2], 0);
   HEAP32[$3 + 4 >> 2] = 0;
   while (1) {
    if (HEAPU32[$3 + 4 >> 2] < HEAPU32[$3 + 96 >> 2]) {
     $0 = $3 + 8 | 0;
     jsvArrayBufferIteratorSetByteValue($0, HEAP8[HEAP32[$3 + 84 >> 2] + HEAP32[$3 + 4 >> 2] | 0]);
     jsvArrayBufferIteratorNext($0);
     HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] + 1;
     continue;
    }
    break;
   }
   jsvArrayBufferIteratorFree($3 + 8 | 0);
  }
  HEAP32[$3 + 108 >> 2] = HEAP32[$3 + 64 >> 2];
 }
 global$0 = $3 + 112 | 0;
 return HEAP32[$3 + 108 >> 2];
}
function jswrap_array_reduce($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 176 | 0;
 global$0 = $3;
 HEAP32[$3 + 168 >> 2] = $0;
 HEAP32[$3 + 164 >> 2] = $1;
 HEAP32[$3 + 160 >> 2] = $2;
 HEAP32[$3 + 156 >> 2] = 118868;
 label$1 : {
  if (!(jsvIsIterable(HEAP32[$3 + 168 >> 2]) & 1)) {
   HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 156 >> 2];
   jsExceptionHere(1, 118875, $3 + 32 | 0);
   HEAP32[$3 + 172 >> 2] = 0;
   break label$1;
  }
  if (!(jsvIsFunction(HEAP32[$3 + 164 >> 2]) & 1)) {
   HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 156 >> 2];
   jsExceptionHere(1, 118925, $3 + 16 | 0);
   HEAP32[$3 + 172 >> 2] = 0;
   break label$1;
  }
  $0 = $3 + 88 | 0;
  HEAP32[$3 + 152 >> 2] = jsvLockAgainSafe(HEAP32[$3 + 160 >> 2]);
  jsvIteratorNew($0, HEAP32[$3 + 168 >> 2], 0);
  if (!HEAP32[$3 + 152 >> 2]) {
   HEAP8[$3 + 87 | 0] = 0;
   while (1) {
    if (HEAP8[$3 + 87 | 0] & 1) {
     $0 = 0;
    } else {
     $0 = jsvIteratorHasElement($3 + 88 | 0);
    }
    if ($0 & 1) {
     HEAP32[$3 + 80 >> 2] = jsvIteratorGetKey($3 + 88 | 0);
     if (jsvIsInt(HEAP32[$3 + 80 >> 2]) & 1) {
      HEAP32[$3 + 152 >> 2] = jsvIteratorGetValue($3 + 88 | 0);
      HEAP8[$3 + 87 | 0] = 1;
     }
     $0 = $3 + 88 | 0;
     jsvUnLock(HEAP32[$3 + 80 >> 2]);
     jsvIteratorNext($0);
     continue;
    }
    break;
   }
   if (!HEAP32[$3 + 152 >> 2]) {
    HEAP32[$3 >> 2] = HEAP32[$3 + 156 >> 2];
    jsExceptionHere(1, 118972, $3);
   }
  }
  while (1) {
   if (jsvIteratorHasElement($3 + 88 | 0) & 1) {
    HEAP32[$3 + 76 >> 2] = jsvIteratorGetKey($3 + 88 | 0);
    if (jsvIsInt(HEAP32[$3 + 76 >> 2]) & 1) {
     $0 = $3 + 48 | 0;
     $1 = $3 + 88 | 0;
     HEAP32[$3 + 72 >> 2] = jsvGetInteger(HEAP32[$3 + 76 >> 2]);
     HEAP32[$3 + 48 >> 2] = HEAP32[$3 + 152 >> 2];
     HEAP32[$3 + 52 >> 2] = jsvIteratorGetValue($1);
     HEAP32[$3 + 56 >> 2] = jsvNewFromInteger(HEAP32[$3 + 72 >> 2]);
     HEAP32[$3 + 60 >> 2] = HEAP32[$3 + 168 >> 2];
     HEAP32[$3 + 152 >> 2] = jspeFunctionCall(HEAP32[$3 + 164 >> 2], 0, 0, 0, 4, $0);
     jsvUnLockMany(3, $0);
    }
    $0 = $3 + 88 | 0;
    jsvUnLock(HEAP32[$3 + 76 >> 2]);
    jsvIteratorNext($0);
    continue;
   }
   break;
  }
  jsvIteratorFree($3 + 88 | 0);
  HEAP32[$3 + 172 >> 2] = HEAP32[$3 + 152 >> 2];
 }
 global$0 = $3 + 176 | 0;
 return HEAP32[$3 + 172 >> 2];
}
function jswrap_waveform_idle() {
 var $0 = 0, $1 = 0;
 $0 = global$0 + -64 | 0;
 global$0 = $0;
 HEAP32[$0 + 60 >> 2] = jsvObjectGetChild(HEAP32[80546], 126051, 0);
 if (HEAP32[$0 + 60 >> 2]) {
  jsvObjectIteratorNew($0 + 56 | 0, HEAP32[$0 + 60 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue($0 + 56 | 0) & 1) {
    HEAP32[$0 + 52 >> 2] = jsvObjectIteratorGetValue($0 + 56 | 0);
    HEAP8[$0 + 51 | 0] = jsvGetBoolAndUnLock(jsvObjectGetChild(HEAP32[$0 + 52 >> 2], 126056, 0)) & 1;
    if (HEAP8[$0 + 51 | 0] & 1) {
     $1 = $0 + 16 | 0;
     HEAP32[$0 + 44 >> 2] = jswrap_waveform_getBuffer(HEAP32[$0 + 52 >> 2], 0, 0);
     label$5 : {
      if (!(jstGetLastBufferTimerTask(HEAP32[$0 + 44 >> 2], $1) & 1)) {
       $1 = $0 + 12 | 0;
       HEAP32[$0 + 12 >> 2] = jsvObjectGetChild(HEAP32[$0 + 52 >> 2], 126064, 0);
       jsiQueueObjectCallbacks(HEAP32[$0 + 52 >> 2], 126071, $1, 1);
       jsvUnLock(HEAP32[$0 + 12 >> 2]);
       HEAP8[$0 + 51 | 0] = 0;
       jsvObjectSetChildAndUnLock(HEAP32[$0 + 52 >> 2], 126056, jsvNewFromBool(HEAP8[$0 + 51 | 0] & 1));
       break label$5;
      }
      if (!(!(HEAPU8[$0 + 30 | 0] | HEAPU8[$0 + 31 | 0] << 8) | (HEAPU8[$0 + 30 | 0] | HEAPU8[$0 + 31 | 0] << 8) == (HEAPU8[$0 + 28 | 0] | HEAPU8[$0 + 29 | 0] << 8))) {
       HEAP32[$0 + 8 >> 2] = (jsvGetRef(HEAP32[$0 + 44 >> 2]) & 65535) == (HEAPU8[$0 + 28 | 0] | HEAPU8[$0 + 29 | 0] << 8) ? 0 : 1;
       HEAP32[$0 + 4 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$0 + 52 >> 2], 126081, 9));
       if (HEAP32[$0 + 4 >> 2] != HEAP32[$0 + 8 >> 2]) {
        jsvObjectSetChildAndUnLock(HEAP32[$0 + 52 >> 2], 126081, jsvNewFromInteger(HEAP32[$0 + 8 >> 2]));
        HEAP32[$0 >> 2] = jsvObjectGetChild(HEAP32[$0 + 52 >> 2], HEAP32[$0 + 8 >> 2] ? 126064 : 126095, 0);
        jsiQueueObjectCallbacks(HEAP32[$0 + 52 >> 2], 126103, $0, 1);
        jsvUnLock(HEAP32[$0 >> 2]);
       }
      }
     }
     jsvUnLock(HEAP32[$0 + 44 >> 2]);
    }
    jsvUnLock(HEAP32[$0 + 52 >> 2]);
    label$9 : {
     if (!(HEAP8[$0 + 51 | 0] & 1)) {
      jsvObjectIteratorRemoveAndGotoNext($0 + 56 | 0, HEAP32[$0 + 60 >> 2]);
      break label$9;
     }
     jsvObjectIteratorNext($0 + 56 | 0);
    }
    continue;
   }
   break;
  }
  jsvObjectIteratorFree($0 + 56 | 0);
  jsvUnLock(HEAP32[$0 + 60 >> 2]);
 }
 global$0 = $0 - -64 | 0;
 return 0;
}
function jswrap_io_shiftOut($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 96 | 0;
 global$0 = $3;
 HEAP32[$3 + 92 >> 2] = $0;
 HEAP32[$3 + 88 >> 2] = $1;
 HEAP32[$3 + 84 >> 2] = $2;
 HEAP32[$3 + 76 >> 2] = 0;
 HEAP8[$3 + 72 | 0] = 255;
 HEAP8[$3 + 73 | 0] = 0;
 HEAP32[$3 + 80 >> 2] = 1;
 HEAP32[$3 + 16 >> 2] = 122076;
 HEAP16[$3 + 20 >> 1] = 12;
 $0 = $3 - -64 | 0;
 HEAP32[$3 + 24 >> 2] = $0 + 8;
 HEAP32[$3 + 28 >> 2] = 122080;
 HEAP16[$3 + 32 >> 1] = 11;
 HEAP32[$3 + 36 >> 2] = $0 + 9;
 HEAP32[$3 + 40 >> 2] = 122087;
 HEAP16[$3 + 44 >> 1] = 9;
 HEAP32[$3 + 48 >> 2] = $0 + 16;
 label$1 : {
  if (!(jsvReadConfigObject(HEAP32[$3 + 88 >> 2], $3 + 16 | 0, 3) & 1)) {
   break label$1;
  }
  HEAP8[$3 + 73 | 0] = ((HEAP8[$3 + 73 | 0] & 1 ? 1 : 0) | 0) != 0;
  if (HEAP32[$3 + 80 >> 2] < 1) {
   HEAP32[$3 + 80 >> 2] = 1;
  }
  label$3 : {
   if (jsvIsArray(HEAP32[$3 + 92 >> 2]) & 1) {
    jsvObjectIteratorNew($3 + 8 | 0, HEAP32[$3 + 92 >> 2]);
    while (1) {
     if (jsvObjectIteratorHasValue($3 + 8 | 0) & 1) {
      if (HEAP32[$3 + 76 >> 2] >= 8) {
       HEAP32[$3 >> 2] = 8;
       jsExceptionHere(1, 122094, $3);
       break label$1;
      }
      $0 = $3 - -64 | 0;
      $1 = $3 + 8 | 0;
      $2 = jshGetPinFromVarAndUnLock(jsvObjectIteratorGetValue($1));
      HEAP8[$0 + HEAP32[$3 + 76 >> 2] | 0] = $2;
      HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 76 >> 2] + 1;
      jsvObjectIteratorNext($1);
      continue;
     }
     break;
    }
    jsvObjectIteratorFree($3 + 8 | 0);
    break label$3;
   }
   $0 = $3 - -64 | 0;
   $1 = jshGetPinFromVar(HEAP32[$3 + 92 >> 2]);
   $2 = HEAP32[$3 + 76 >> 2];
   HEAP32[$3 + 76 >> 2] = $2 + 1;
   HEAP8[$0 + $2 | 0] = $1;
  }
  HEAP32[$3 + 4 >> 2] = 0;
  while (1) {
   if (HEAP32[$3 + 4 >> 2] < HEAP32[$3 + 76 >> 2]) {
    if (jshIsPinValid(HEAPU8[HEAP32[$3 + 4 >> 2] + ($3 - -64 | 0) | 0]) & 1) {
     if (!(jshGetPinStateIsManual(HEAPU8[HEAP32[$3 + 4 >> 2] + ($3 - -64 | 0) | 0]) & 1)) {
      jshPinSetState(HEAPU8[HEAP32[$3 + 4 >> 2] + ($3 - -64 | 0) | 0], 1);
     }
    }
    HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] + 1;
    continue;
   }
   break;
  }
  if (jshIsPinValid(HEAPU8[$3 + 72 | 0]) & 1) {
   jshPinSetState(HEAPU8[$3 + 72 | 0], 1);
  }
  jsvIterateCallback(HEAP32[$3 + 84 >> 2], 561, $3 - -64 | 0);
 }
 global$0 = $3 + 96 | 0;
}
function jswrap_arraybufferview_map($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 176 | 0;
 global$0 = $3;
 HEAP32[$3 + 168 >> 2] = $0;
 HEAP32[$3 + 164 >> 2] = $1;
 HEAP32[$3 + 160 >> 2] = $2;
 label$1 : {
  if (!(jsvIsArrayBuffer(HEAP32[$3 + 168 >> 2]) & 1)) {
   jsExceptionHere(1, 119265, 0);
   HEAP32[$3 + 172 >> 2] = 0;
   break label$1;
  }
  if (!(jsvIsFunction(HEAP32[$3 + 164 >> 2]) & 1)) {
   jsExceptionHere(1, 119326, 0);
   HEAP32[$3 + 172 >> 2] = 0;
   break label$1;
  }
  label$4 : {
   if (jsvIsUndefined(HEAP32[$3 + 160 >> 2]) & 1) {
    break label$4;
   }
   if (jsvIsObject(HEAP32[$3 + 160 >> 2]) & 1) {
    break label$4;
   }
   jsExceptionHere(1, 119384, 0);
   HEAP32[$3 + 172 >> 2] = 0;
   break label$1;
  }
  $0 = HEAP32[$3 + 168 >> 2];
  HEAP16[$3 + 158 >> 1] = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8;
  HEAP32[$3 + 152 >> 2] = jsvNewTypedArray(HEAPU16[$3 + 158 >> 1], jsvGetArrayBufferLength(HEAP32[$3 + 168 >> 2]));
  if (!HEAP32[$3 + 152 >> 2]) {
   HEAP32[$3 + 172 >> 2] = 0;
   break label$1;
  }
  $0 = $3 + 32 | 0;
  jsvIteratorNew($3 + 88 | 0, HEAP32[$3 + 168 >> 2], 1);
  jsvArrayBufferIteratorNew($0, HEAP32[$3 + 152 >> 2], 0);
  while (1) {
   if (jsvIteratorHasElement($3 + 88 | 0) & 1) {
    HEAP32[$3 + 28 >> 2] = jsvIteratorGetKey($3 + 88 | 0);
    if (jsvIsInt(HEAP32[$3 + 28 >> 2]) & 1) {
     $0 = $3 + 12 | 0;
     $1 = $3 + 88 | 0;
     HEAP32[$3 + 24 >> 2] = jsvGetInteger(HEAP32[$3 + 28 >> 2]);
     HEAP32[$3 + 12 >> 2] = jsvIteratorGetValue($1);
     HEAP32[$3 + 16 >> 2] = jsvNewFromInteger(HEAP32[$3 + 24 >> 2]);
     HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 168 >> 2];
     HEAP32[$3 + 8 >> 2] = jspeFunctionCall(HEAP32[$3 + 164 >> 2], 0, HEAP32[$3 + 160 >> 2], 0, 3, $0);
     jsvUnLockMany(2, $0);
     if (HEAP32[$3 + 8 >> 2]) {
      jsvArrayBufferIteratorSetValue($3 + 32 | 0, HEAP32[$3 + 8 >> 2]);
      jsvUnLock(HEAP32[$3 + 8 >> 2]);
     }
    }
    $0 = $3 + 32 | 0;
    $1 = $3 + 88 | 0;
    jsvUnLock(HEAP32[$3 + 28 >> 2]);
    jsvIteratorNext($1);
    jsvArrayBufferIteratorNext($0);
    continue;
   }
   break;
  }
  $0 = $3 + 32 | 0;
  jsvIteratorFree($3 + 88 | 0);
  jsvArrayBufferIteratorFree($0);
  HEAP32[$3 + 172 >> 2] = HEAP32[$3 + 152 >> 2];
 }
 global$0 = $3 + 176 | 0;
 return HEAP32[$3 + 172 >> 2];
}
function lcdGetPixel_ArrayBuffer_flat($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP32[$3 + 36 >> 2] = $2;
 HEAP32[$3 + 32 >> 2] = 0;
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 28 >> 2] = HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24);
 HEAP32[$3 + 24 >> 2] = lcdGetPixelIndex_ArrayBuffer(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 40 >> 2], HEAP32[$3 + 36 >> 2], 1);
 HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 28 >> 2] + (HEAP32[$3 + 24 >> 2] >>> 3);
 label$1 : {
  if (HEAPU8[HEAP32[$3 + 44 >> 2] + 16 | 0] & 7) {
   HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 24 >> 2] & 7;
   HEAP32[$3 + 20 >> 2] = (1 << HEAPU8[HEAP32[$3 + 44 >> 2] + 16 | 0]) - 1;
   HEAP32[$3 + 16 >> 2] = HEAPU8[HEAP32[$3 + 28 >> 2]];
   $0 = $3;
   $1 = HEAP32[$3 + 44 >> 2];
   $2 = 8 - (HEAP32[$3 + 24 >> 2] + HEAPU8[HEAP32[$3 + 44 >> 2] + 16 | 0] | 0) | 0;
   label$3 : {
    if ((HEAPU8[$1 + 8 | 0] | HEAPU8[$1 + 9 | 0] << 8 | (HEAPU8[$1 + 10 | 0] << 16 | HEAPU8[$1 + 11 | 0] << 24)) & 4) {
     break label$3;
    }
    $2 = HEAP32[$3 + 24 >> 2];
   }
   HEAP32[$0 + 12 >> 2] = $2;
   HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 20 >> 2] & HEAP32[$3 + 16 >> 2] >>> HEAP32[$3 + 12 >> 2];
   break label$1;
  }
  $0 = HEAP32[$3 + 44 >> 2];
  label$5 : {
   if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 4) {
    HEAP32[$3 + 8 >> 2] = HEAPU8[HEAP32[$3 + 44 >> 2] + 16 | 0] - 8;
    while (1) {
     if (HEAP32[$3 + 8 >> 2] >= 0) {
      HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 32 >> 2] | HEAPU8[HEAP32[$3 + 28 >> 2]] << HEAP32[$3 + 8 >> 2];
      HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 28 >> 2] + 1;
      HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 8 >> 2] - 8;
      continue;
     }
     break;
    }
    break label$5;
   }
   HEAP32[$3 + 4 >> 2] = 0;
   while (1) {
    if (HEAP32[$3 + 4 >> 2] < HEAPU8[HEAP32[$3 + 44 >> 2] + 16 | 0]) {
     HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 32 >> 2] | HEAPU8[HEAP32[$3 + 28 >> 2]] << HEAP32[$3 + 4 >> 2];
     HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 28 >> 2] + 1;
     HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] + 8;
     continue;
    }
    break;
   }
  }
 }
 global$0 = $3 + 48 | 0;
 return HEAP32[$3 + 32 >> 2];
}
function tf_create($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP32[$3 + 40 >> 2] = $0;
 HEAP32[$3 + 36 >> 2] = $1;
 HEAP32[$3 + 32 >> 2] = $2;
 HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 40 >> 2];
 $0 = HEAP32[$3 + 28 >> 2];
 HEAP32[$0 >> 2] = 0;
 tflite__EspruinoErrorReporter__EspruinoErrorReporter_28_29($0);
 HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 28 >> 2];
 HEAP32[$3 + 20 >> 2] = tflite__GetModel_28void_20const__29(HEAP32[$3 + 32 >> 2]);
 label$1 : {
  if ((tflite__Operator__opcode_index_28_29_20const(HEAP32[$3 + 20 >> 2]) | 0) != 3) {
   $0 = HEAP32[$3 + 24 >> 2];
   $1 = tflite__Operator__opcode_index_28_29_20const(HEAP32[$3 + 20 >> 2]);
   HEAP32[$3 + 4 >> 2] = 3;
   HEAP32[$3 >> 2] = $1;
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 137618, $3);
   HEAP8[$3 + 47 | 0] = 0;
   break label$1;
  }
  tflite__MicroMutableOpResolver_9u___MicroMutableOpResolver_28tflite__ErrorReporter__29(HEAP32[$3 + 28 >> 2] + 16 | 0);
  tflite__MicroMutableOpResolver_9u___AddDepthwiseConv2D_28_29(HEAP32[$3 + 28 >> 2] + 16 | 0);
  tflite__MicroMutableOpResolver_9u___AddConv2D_28_29(HEAP32[$3 + 28 >> 2] + 16 | 0);
  tflite__MicroMutableOpResolver_9u___AddAveragePool2D_28_29(HEAP32[$3 + 28 >> 2] + 16 | 0);
  tflite__MicroMutableOpResolver_9u___AddMaxPool2D_28_29(HEAP32[$3 + 28 >> 2] + 16 | 0);
  tflite__MicroMutableOpResolver_9u___AddFullyConnected_28_29(HEAP32[$3 + 28 >> 2] + 16 | 0);
  tflite__MicroMutableOpResolver_9u___AddSoftmax_28_29(HEAP32[$3 + 28 >> 2] + 16 | 0);
  tflite__MicroMutableOpResolver_9u___AddQuantize_28_29(HEAP32[$3 + 28 >> 2] + 16 | 0);
  tflite__MicroMutableOpResolver_9u___AddDequantize_28_29(HEAP32[$3 + 28 >> 2] + 16 | 0);
  tflite__MicroMutableOpResolver_9u___AddReshape_28_29(HEAP32[$3 + 28 >> 2] + 16 | 0);
  tflite__MicroInterpreter__MicroInterpreter_28tflite__Model_20const__2c_20tflite__MicroOpResolver_20const__2c_20unsigned_20char__2c_20unsigned_20long_2c_20tflite__ErrorReporter__2c_20tflite__Profiler__29(HEAP32[$3 + 28 >> 2] + 400 | 0, HEAP32[$3 + 20 >> 2], HEAP32[$3 + 28 >> 2] + 16 | 0, HEAP32[$3 + 28 >> 2] + 560 | 0, HEAP32[$3 + 36 >> 2], HEAP32[$3 + 24 >> 2]);
  tflite__MicroInterpreter__AllocateTensors_28_29(HEAP32[$3 + 28 >> 2] + 400 | 0);
  HEAP8[$3 + 47 | 0] = 1;
 }
 global$0 = $3 + 48 | 0;
 return HEAP8[$3 + 47 | 0] & 1;
}
function jsserialGetSendFunction($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP32[$3 + 40 >> 2] = $0;
 HEAP32[$3 + 36 >> 2] = $1;
 HEAP32[$3 + 32 >> 2] = $2;
 HEAP8[$3 + 31 | 0] = jsiGetDeviceFromClass(HEAP32[$3 + 40 >> 2]);
 label$1 : {
  if (!(HEAPU8[$3 + 31 | 0] < 17 | HEAPU8[$3 + 31 | 0] > 22)) {
   label$3 : {
    if (HEAPU8[$3 + 31 | 0] < 22 | HEAPU8[$3 + 31 | 0] > 22) {
     break label$3;
    }
    if (jshIsDeviceInitialised(HEAPU8[$3 + 31 | 0]) & 1) {
     break label$3;
    }
    $0 = $3 + 16 | 0;
    jshUSARTInitInfo($0);
    jshUSARTSetup(HEAPU8[$3 + 31 | 0], $0);
   }
   HEAP32[HEAP32[$3 + 36 >> 2] >> 2] = 14;
   HEAP8[HEAP32[$3 + 32 >> 2]] = HEAPU8[$3 + 31 | 0];
   HEAP8[$3 + 47 | 0] = 1;
   break label$1;
  }
  if (!HEAPU8[$3 + 31 | 0]) {
   $1 = $3 + 16 | 0;
   HEAP32[$3 + 12 >> 2] = jsvObjectGetChild(HEAP32[$3 + 40 >> 2], 83532, 0);
   HEAP32[$3 + 8 >> 2] = jsvObjectGetChild(HEAP32[$3 + 40 >> 2], 83542, 0);
   jsserialPopulateUSARTInfo($1, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
   jsvUnLock(HEAP32[$3 + 8 >> 2]);
   jsvUnLock(HEAP32[$3 + 12 >> 2]);
   HEAP32[HEAP32[$3 + 36 >> 2] >> 2] = 15;
   $4 = HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8 | (HEAPU8[$1 + 6 | 0] << 16 | HEAPU8[$1 + 7 | 0] << 24);
   $0 = HEAP32[$3 + 32 >> 2];
   $2 = $0;
   $5 = HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24);
   HEAP8[$2 | 0] = $5;
   HEAP8[$2 + 1 | 0] = $5 >>> 8;
   HEAP8[$2 + 2 | 0] = $5 >>> 16;
   HEAP8[$2 + 3 | 0] = $5 >>> 24;
   HEAP8[$2 + 4 | 0] = $4;
   HEAP8[$2 + 5 | 0] = $4 >>> 8;
   HEAP8[$2 + 6 | 0] = $4 >>> 16;
   HEAP8[$2 + 7 | 0] = $4 >>> 24;
   $2 = HEAPU8[$1 + 9 | 0] | HEAPU8[$1 + 10 | 0] << 8 | (HEAPU8[$1 + 11 | 0] << 16 | HEAPU8[$1 + 12 | 0] << 24);
   $1 = HEAPU8[$1 + 5 | 0] | HEAPU8[$1 + 6 | 0] << 8 | (HEAPU8[$1 + 7 | 0] << 16 | HEAPU8[$1 + 8 | 0] << 24);
   HEAP8[$0 + 5 | 0] = $1;
   HEAP8[$0 + 6 | 0] = $1 >>> 8;
   HEAP8[$0 + 7 | 0] = $1 >>> 16;
   HEAP8[$0 + 8 | 0] = $1 >>> 24;
   HEAP8[$0 + 9 | 0] = $2;
   HEAP8[$0 + 10 | 0] = $2 >>> 8;
   HEAP8[$0 + 11 | 0] = $2 >>> 16;
   HEAP8[$0 + 12 | 0] = $2 >>> 24;
   HEAP8[$3 + 47 | 0] = 1;
   break label$1;
  }
  HEAP8[$3 + 47 | 0] = 0;
 }
 global$0 = $3 + 48 | 0;
 return HEAP8[$3 + 47 | 0] & 1;
}
function tflite__ops__micro__fully_connected__EvalFloat_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteFusedActivation_2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0;
 $7 = global$0 - 192 | 0;
 global$0 = $7;
 $8 = $7 + 88 | 0;
 HEAP32[$7 + 188 >> 2] = $0;
 HEAP32[$7 + 184 >> 2] = $1;
 HEAP32[$7 + 180 >> 2] = $2;
 HEAP32[$7 + 176 >> 2] = $3;
 HEAP32[$7 + 172 >> 2] = $4;
 HEAP32[$7 + 168 >> 2] = $5;
 HEAP32[$7 + 164 >> 2] = $6;
 void_20tflite__CalculateActivationRange_float__28TfLiteFusedActivation_2c_20float__2c_20float__29(HEAP32[$7 + 180 >> 2], $7 + 160 | 0, $7 + 156 | 0);
 HEAPF32[$7 + 140 >> 2] = HEAPF32[$7 + 160 >> 2];
 HEAPF32[$7 + 144 >> 2] = HEAPF32[$7 + 156 >> 2];
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8, HEAP32[$7 + 176 >> 2]);
 $0 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$7 + 176 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 56 | 0, HEAP32[$7 + 172 >> 2]);
 $1 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$7 + 172 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 32 | 0, HEAP32[$7 + 168 >> 2]);
 $2 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$7 + 168 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 8 | 0, HEAP32[$7 + 164 >> 2]);
 tflite__reference_ops__FullyConnected_28tflite__FullyConnectedParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($7 + 112 | 0, $7 + 88 | 0, $0, $7 + 56 | 0, $1, $7 + 32 | 0, $2, $7 + 8 | 0, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$7 + 164 >> 2]));
 $0 = $7 + 88 | 0;
 $1 = $7 + 56 | 0;
 $2 = $7 + 32 | 0;
 tflite__RuntimeShape___RuntimeShape_28_29($7 + 8 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($2);
 tflite__RuntimeShape___RuntimeShape_28_29($1);
 tflite__RuntimeShape___RuntimeShape_28_29($0);
 global$0 = $7 + 192 | 0;
 return 0;
}
function jswrap_function_apply_or_call($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $4 = global$0 - 128 | 0;
 $3 = $4;
 global$0 = $3;
 HEAP32[$3 + 120 >> 2] = $0;
 HEAP32[$3 + 116 >> 2] = $1;
 HEAP32[$3 + 112 >> 2] = $2;
 HEAP32[$3 + 104 >> 2] = 0;
 HEAP32[$3 + 100 >> 2] = 0;
 label$1 : {
  label$2 : {
   if (jsvIsIterable(HEAP32[$3 + 112 >> 2]) & 1) {
    HEAP32[$3 + 100 >> 2] = jsvGetLength(HEAP32[$3 + 112 >> 2]);
    if (HEAPU32[$3 + 100 >> 2] > 256) {
     HEAP32[$3 >> 2] = HEAP32[$3 + 100 >> 2];
     jsExceptionHere(1, 124118, $3);
     HEAP32[$3 + 124 >> 2] = 0;
     break label$1;
    }
    $0 = $4 - ((HEAP32[$3 + 100 >> 2] << 2) + 15 & -16) | 0;
    global$0 = $0;
    HEAP32[$3 + 104 >> 2] = $0;
    HEAP32[$3 + 108 >> 2] = 0;
    while (1) {
     if (HEAPU32[$3 + 108 >> 2] < HEAPU32[$3 + 100 >> 2]) {
      HEAP32[HEAP32[$3 + 104 >> 2] + (HEAP32[$3 + 108 >> 2] << 2) >> 2] = 0;
      HEAP32[$3 + 108 >> 2] = HEAP32[$3 + 108 >> 2] + 1;
      continue;
     }
     break;
    }
    jsvIteratorNew($3 + 40 | 0, HEAP32[$3 + 112 >> 2], 1);
    while (1) {
     if (jsvIteratorHasElement($3 + 40 | 0) & 1) {
      HEAP32[$3 + 36 >> 2] = jsvIteratorGetKey($3 + 40 | 0);
      if (jsvIsIntegerish(HEAP32[$3 + 36 >> 2]) & 1) {
       HEAP32[$3 + 32 >> 2] = jsvGetInteger(HEAP32[$3 + 36 >> 2]);
       if (!(HEAP32[$3 + 32 >> 2] < 0 | HEAP32[$3 + 32 >> 2] >= HEAP32[$3 + 100 >> 2])) {
        $0 = jsvIteratorGetValue($3 + 40 | 0);
        HEAP32[HEAP32[$3 + 104 >> 2] + (HEAP32[$3 + 32 >> 2] << 2) >> 2] = $0;
       }
      }
      $0 = $3 + 40 | 0;
      jsvUnLock(HEAP32[$3 + 36 >> 2]);
      jsvIteratorNext($0);
      continue;
     }
     break;
    }
    jsvIteratorFree($3 + 40 | 0);
    break label$2;
   }
   if (!(jsvIsUndefined(HEAP32[$3 + 112 >> 2]) & 1)) {
    HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 112 >> 2];
    jsExceptionHere(1, 124191, $3 + 16 | 0);
    HEAP32[$3 + 124 >> 2] = 0;
    break label$1;
   }
  }
  HEAP32[$3 + 28 >> 2] = jspeFunctionCall(HEAP32[$3 + 120 >> 2], 0, HEAP32[$3 + 116 >> 2], 0, HEAP32[$3 + 100 >> 2], HEAP32[$3 + 104 >> 2]);
  jsvUnLockMany(HEAP32[$3 + 100 >> 2], HEAP32[$3 + 104 >> 2]);
  HEAP32[$3 + 124 >> 2] = HEAP32[$3 + 28 >> 2];
 }
 global$0 = $3 + 128 | 0;
 return HEAP32[$3 + 124 >> 2];
}
function tflite__MicroMutableOpResolver_9u___AddBuiltin_28tflite__BuiltinOperator_2c_20TfLiteRegistration_20const__2c_20TfLiteStatus_20_28__29_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29_29($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 48 | 0;
 global$0 = $4;
 HEAP32[$4 + 40 >> 2] = $0;
 HEAP32[$4 + 36 >> 2] = $1;
 HEAP32[$4 + 32 >> 2] = $2;
 HEAP32[$4 + 28 >> 2] = $3;
 $0 = HEAP32[$4 + 40 >> 2];
 label$1 : {
  if (HEAP32[$4 + 36 >> 2] == 32) {
   if (HEAP32[$0 + 372 >> 2]) {
    tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$0 + 372 >> 2], 137856, 0);
   }
   HEAP32[$4 + 44 >> 2] = 1;
   break label$1;
  }
  if (FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 20 >> 2]]($0, HEAP32[$4 + 36 >> 2])) {
   if (HEAP32[$0 + 372 >> 2]) {
    $0 = HEAP32[$0 + 372 >> 2];
    HEAP32[$4 >> 2] = HEAP32[$4 + 36 >> 2];
    tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 137925, $4);
   }
   HEAP32[$4 + 44 >> 2] = 1;
   break label$1;
  }
  if (HEAPU32[$0 + 292 >> 2] >= 9) {
   if (HEAP32[$0 + 372 >> 2]) {
    $0 = HEAP32[$0 + 372 >> 2];
    $1 = HEAP32[$4 + 36 >> 2];
    HEAP32[$4 + 20 >> 2] = 9;
    HEAP32[$4 + 16 >> 2] = $1;
    tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 138004, $4 + 16 | 0);
   }
   HEAP32[$4 + 44 >> 2] = 1;
   break label$1;
  }
  $1 = HEAP32[$4 + 32 >> 2];
  $3 = HEAP32[$1 + 4 >> 2];
  $2 = ($0 + 4 | 0) + (HEAP32[$0 + 292 >> 2] << 5) | 0;
  HEAP32[$2 >> 2] = HEAP32[$1 >> 2];
  HEAP32[$2 + 4 >> 2] = $3;
  $3 = HEAP32[$1 + 28 >> 2];
  HEAP32[$2 + 24 >> 2] = HEAP32[$1 + 24 >> 2];
  HEAP32[$2 + 28 >> 2] = $3;
  $3 = HEAP32[$1 + 20 >> 2];
  HEAP32[$2 + 16 >> 2] = HEAP32[$1 + 16 >> 2];
  HEAP32[$2 + 20 >> 2] = $3;
  $3 = HEAP32[$1 + 12 >> 2];
  HEAP32[$2 + 8 >> 2] = HEAP32[$1 + 8 >> 2];
  HEAP32[$2 + 12 >> 2] = $3;
  HEAP32[(($0 + 4 | 0) + (HEAP32[$0 + 292 >> 2] << 5) | 0) + 20 >> 2] = HEAP32[$4 + 36 >> 2];
  HEAP32[$0 + 292 >> 2] = HEAP32[$0 + 292 >> 2] + 1;
  HEAP32[($0 + 296 | 0) + (HEAP32[$0 + 368 >> 2] << 2) >> 2] = HEAP32[$4 + 36 >> 2];
  HEAP32[($0 + 332 | 0) + (HEAP32[$0 + 368 >> 2] << 2) >> 2] = HEAP32[$4 + 28 >> 2];
  HEAP32[$0 + 368 >> 2] = HEAP32[$0 + 368 >> 2] + 1;
  HEAP32[$4 + 44 >> 2] = 0;
 }
 global$0 = $4 + 48 | 0;
}
function heatshrink_encode_cb($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 848 | 0;
 global$0 = $3;
 HEAP32[$3 + 844 >> 2] = 593;
 HEAP32[$3 + 840 >> 2] = $0;
 HEAP32[$3 + 836 >> 2] = $1;
 HEAP32[$3 + 832 >> 2] = $2;
 heatshrink_encoder_reset($3 + 304 | 0);
 HEAP32[$3 + 40 >> 2] = 0;
 HEAP32[$3 + 36 >> 2] = 0;
 HEAP32[$3 + 32 >> 2] = 0;
 HEAP32[$3 + 28 >> 2] = 0;
 HEAP32[$3 + 24 >> 2] = 0;
 HEAP32[$3 + 20 >> 2] = 0;
 while (1) {
  if (HEAP32[$3 + 28 >> 2] < 0 ? HEAPU32[$3 + 24 >> 2] > 0 : 1) {
   if (!HEAP32[$3 + 24 >> 2]) {
    HEAP32[$3 + 20 >> 2] = 0;
    while (1) {
     if (HEAPU32[$3 + 24 >> 2] < 128 ? HEAP32[$3 + 28 >> 2] >= 0 : 0) {
      HEAP32[$3 + 28 >> 2] = FUNCTION_TABLE[HEAP32[$3 + 844 >> 2]](HEAP32[$3 + 840 >> 2]);
      if (HEAP32[$3 + 28 >> 2] >= 0) {
       $0 = HEAP32[$3 + 28 >> 2];
       $1 = HEAP32[$3 + 24 >> 2];
       HEAP32[$3 + 24 >> 2] = $1 + 1;
       HEAP8[$1 + ($3 + 176 | 0) | 0] = $0;
      }
      continue;
     }
     break;
    }
   }
   HEAP8[$3 + 19 | 0] = (heatshrink_encoder_sink($3 + 304 | 0, HEAP32[$3 + 20 >> 2] + ($3 + 176 | 0) | 0, HEAP32[$3 + 24 >> 2], $3 + 40 | 0) | 0) >= 0;
   HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 24 >> 2] - HEAP32[$3 + 40 >> 2];
   HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 40 >> 2] + HEAP32[$3 + 20 >> 2];
   HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 40 >> 2] + HEAP32[$3 + 36 >> 2];
   if (!(HEAP32[$3 + 24 >> 2] | HEAP32[$3 + 28 >> 2] >= 0)) {
    heatshrink_encoder_finish($3 + 304 | 0);
   }
   while (1) {
    HEAP32[$3 + 12 >> 2] = heatshrink_encoder_poll($3 + 304 | 0, $3 + 48 | 0, $3 + 40 | 0);
    if (HEAP32[$3 + 836 >> 2]) {
     HEAP32[$3 + 44 >> 2] = 0;
     while (1) {
      if (HEAPU32[$3 + 44 >> 2] < HEAPU32[$3 + 40 >> 2]) {
       FUNCTION_TABLE[HEAP32[$3 + 836 >> 2]](HEAPU8[HEAP32[$3 + 44 >> 2] + ($3 + 48 | 0) | 0], HEAP32[$3 + 832 >> 2]);
       HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 44 >> 2] + 1;
       continue;
      }
      break;
     }
    }
    HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 40 >> 2] + HEAP32[$3 + 32 >> 2];
    if (HEAP32[$3 + 12 >> 2] == 1) {
     continue;
    }
    break;
   }
   if (!(HEAP32[$3 + 24 >> 2] | HEAP32[$3 + 28 >> 2] >= 0)) {
    heatshrink_encoder_finish($3 + 304 | 0);
   }
   continue;
  }
  break;
 }
 global$0 = $3 + 848 | 0;
 return HEAP32[$3 + 32 >> 2];
}
function jsvGetArrayIndex($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP16[$2 + 18 >> 1] = jsvGetLastChild(HEAP32[$2 + 24 >> 2]);
 HEAP32[$2 + 12 >> 2] = 0;
 label$1 : {
  while (1) {
   label$3 : {
    if (!HEAPU16[$2 + 18 >> 1]) {
     break label$3;
    }
    HEAP32[$2 + 8 >> 2] = jsvLock(HEAPU16[$2 + 18 >> 1]);
    if (jsvIsInt(HEAP32[$2 + 8 >> 2]) & 1) {
     $0 = HEAP32[$2 + 8 >> 2];
     HEAP32[$2 + 12 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
     if (HEAP32[$2 + 12 >> 2] == HEAP32[$2 + 20 >> 2]) {
      HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 8 >> 2];
      break label$1;
     }
     jsvUnLock(HEAP32[$2 + 8 >> 2]);
     break label$3;
    }
    HEAP16[$2 + 18 >> 1] = jsvGetPrevSibling(HEAP32[$2 + 8 >> 2]);
    jsvUnLock(HEAP32[$2 + 8 >> 2]);
    continue;
   }
   break;
  }
  if (HEAP32[$2 + 20 >> 2] > HEAP32[$2 + 12 >> 2]) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  label$7 : {
   if (HEAP32[$2 + 20 >> 2] > (HEAP32[$2 + 12 >> 2] / 2 | 0)) {
    while (1) {
     if (HEAPU16[$2 + 18 >> 1]) {
      HEAP32[$2 + 4 >> 2] = jsvLock(HEAPU16[$2 + 18 >> 1]);
      $0 = HEAP32[$2 + 4 >> 2];
      if (HEAP32[$2 + 20 >> 2] == (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24))) {
       HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 4 >> 2];
       break label$1;
      }
      HEAP16[$2 + 18 >> 1] = jsvGetPrevSibling(HEAP32[$2 + 4 >> 2]);
      jsvUnLock(HEAP32[$2 + 4 >> 2]);
      continue;
     }
     break;
    }
    break label$7;
   }
   HEAP16[$2 + 18 >> 1] = jsvGetFirstChild(HEAP32[$2 + 24 >> 2]);
   while (1) {
    if (HEAPU16[$2 + 18 >> 1]) {
     HEAP32[$2 >> 2] = jsvLock(HEAPU16[$2 + 18 >> 1]);
     $0 = HEAP32[$2 >> 2];
     if (HEAP32[$2 + 20 >> 2] == (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24))) {
      HEAP32[$2 + 28 >> 2] = HEAP32[$2 >> 2];
      break label$1;
     }
     HEAP16[$2 + 18 >> 1] = jsvGetNextSibling(HEAP32[$2 >> 2]);
     jsvUnLock(HEAP32[$2 >> 2]);
     continue;
    }
    break;
   }
  }
  HEAP32[$2 + 28 >> 2] = 0;
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function jswrap_io_pinMode($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP8[$3 + 15 | 0] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 label$1 : {
  if (!(jshIsPinValid(HEAPU8[$3 + 15 | 0]) & 1)) {
   jsExceptionHere(1, 121944, 0);
   break label$1;
  }
  HEAP8[$3 + 6 | 0] = 0;
  if (jsvIsString(HEAP32[$3 + 8 >> 2]) & 1) {
   label$4 : {
    if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 121956) & 1) {
     HEAP8[$3 + 6 | 0] = 7;
     break label$4;
    }
    label$6 : {
     if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 121963) & 1) {
      HEAP8[$3 + 6 | 0] = 4;
      break label$6;
     }
     label$8 : {
      if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 121969) & 1) {
       HEAP8[$3 + 6 | 0] = 5;
       break label$8;
      }
      label$10 : {
       if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 121982) & 1) {
        HEAP8[$3 + 6 | 0] = 6;
        break label$10;
       }
       label$12 : {
        if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 121997) & 1) {
         HEAP8[$3 + 6 | 0] = 1;
         break label$12;
        }
        label$14 : {
         if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 122004) & 1) {
          HEAP8[$3 + 6 | 0] = 2;
          break label$14;
         }
         label$16 : {
          if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 122014) & 1) {
           HEAP8[$3 + 6 | 0] = 3;
           break label$16;
          }
          label$18 : {
           if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 122031) & 1) {
            HEAP8[$3 + 6 | 0] = 8;
            break label$18;
           }
           if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 122041) & 1) {
            HEAP8[$3 + 6 | 0] = 9;
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
  if (HEAPU8[$3 + 6 | 0]) {
   jshSetPinStateIsManual(HEAPU8[$3 + 15 | 0], (HEAPU8[$3 + 7 | 0] ^ -1) & 1);
   jshPinSetState(HEAPU8[$3 + 15 | 0], HEAPU8[$3 + 6 | 0]);
   break label$1;
  }
  jshSetPinStateIsManual(HEAPU8[$3 + 15 | 0], 0);
  label$22 : {
   if (jsvIsUndefined(HEAP32[$3 + 8 >> 2]) & 1) {
    break label$22;
   }
   if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 122054) & 1) {
    break label$22;
   }
   jsExceptionHere(1, 122059, 0);
  }
 }
 global$0 = $3 + 16 | 0;
}
function tflite__GetRegistrationFromOpCode_28tflite__OperatorCode_20const__2c_20tflite__OpResolver_20const__2c_20tflite__ErrorReporter__2c_20TfLiteRegistration_20const___29($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 + -64 | 0;
 global$0 = $4;
 HEAP32[$4 + 60 >> 2] = $0;
 HEAP32[$4 + 56 >> 2] = $1;
 HEAP32[$4 + 52 >> 2] = $2;
 HEAP32[$4 + 48 >> 2] = $3;
 HEAP32[$4 + 44 >> 2] = 0;
 HEAP32[HEAP32[$4 + 48 >> 2] >> 2] = 0;
 HEAP32[$4 + 40 >> 2] = tflite__OperatorCode__builtin_code_28_29_20const(HEAP32[$4 + 60 >> 2]);
 HEAP32[$4 + 36 >> 2] = tflite__OperatorCode__version_28_29_20const(HEAP32[$4 + 60 >> 2]);
 label$1 : {
  if (!(HEAP32[$4 + 40 >> 2] >= 0 ? HEAP32[$4 + 40 >> 2] <= 126 : 0)) {
   $0 = HEAP32[$4 + 52 >> 2];
   HEAP32[$4 >> 2] = HEAP32[$4 + 40 >> 2];
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 136915, $4);
   HEAP32[$4 + 44 >> 2] = 1;
   break label$1;
  }
  label$4 : {
   if (HEAP32[$4 + 40 >> 2] != 32) {
    $0 = HEAP32[$4 + 56 >> 2];
    $0 = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] >> 2]]($0, HEAP32[$4 + 40 >> 2], HEAP32[$4 + 36 >> 2]) | 0;
    HEAP32[HEAP32[$4 + 48 >> 2] >> 2] = $0;
    if (!HEAP32[HEAP32[$4 + 48 >> 2] >> 2]) {
     $0 = HEAP32[$4 + 52 >> 2];
     $1 = tflite__EnumNameBuiltinOperator_28tflite__BuiltinOperator_29(HEAP32[$4 + 40 >> 2]);
     HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 36 >> 2];
     HEAP32[$4 + 16 >> 2] = $1;
     tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 136999, $4 + 16 | 0);
     HEAP32[$4 + 44 >> 2] = 1;
    }
    break label$4;
   }
   label$7 : {
    if (!tflite__SubGraph__inputs_28_29_20const(HEAP32[$4 + 60 >> 2])) {
     tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$4 + 52 >> 2], 137052, 0);
     HEAP32[$4 + 44 >> 2] = 1;
     break label$7;
    }
    HEAP32[$4 + 32 >> 2] = flatbuffers__Vector_unsigned_20char___data_28_29_20const(tflite__SubGraph__inputs_28_29_20const(HEAP32[$4 + 60 >> 2]));
    $0 = HEAP32[$4 + 56 >> 2];
    $0 = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 4 >> 2]]($0, HEAP32[$4 + 32 >> 2], HEAP32[$4 + 36 >> 2]) | 0;
    HEAP32[HEAP32[$4 + 48 >> 2] >> 2] = $0;
    if (!HEAP32[HEAP32[$4 + 48 >> 2] >> 2]) {
     HEAP32[$4 + 44 >> 2] = 1;
    }
   }
  }
 }
 global$0 = $4 - -64 | 0;
 return HEAP32[$4 + 44 >> 2];
}
function heatshrink_decode_cb($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 624 | 0;
 global$0 = $4;
 HEAP32[$4 + 620 >> 2] = $0;
 HEAP32[$4 + 616 >> 2] = $1;
 HEAP32[$4 + 612 >> 2] = $2;
 HEAP32[$4 + 608 >> 2] = $3;
 heatshrink_decoder_reset($4 + 304 | 0);
 HEAP32[$4 + 40 >> 2] = 0;
 HEAP32[$4 + 36 >> 2] = 0;
 HEAP32[$4 + 32 >> 2] = 0;
 HEAP32[$4 + 28 >> 2] = 0;
 HEAP32[$4 + 24 >> 2] = 0;
 HEAP32[$4 + 20 >> 2] = 0;
 while (1) {
  if (HEAP32[$4 + 28 >> 2] < 0 ? HEAPU32[$4 + 24 >> 2] > 0 : 1) {
   if (!HEAP32[$4 + 24 >> 2]) {
    HEAP32[$4 + 20 >> 2] = 0;
    while (1) {
     if (HEAPU32[$4 + 24 >> 2] < 128 ? HEAP32[$4 + 28 >> 2] >= 0 : 0) {
      HEAP32[$4 + 28 >> 2] = FUNCTION_TABLE[HEAP32[$4 + 620 >> 2]](HEAP32[$4 + 616 >> 2]);
      if (HEAP32[$4 + 28 >> 2] >= 0) {
       $0 = HEAP32[$4 + 28 >> 2];
       $1 = HEAP32[$4 + 24 >> 2];
       HEAP32[$4 + 24 >> 2] = $1 + 1;
       HEAP8[$1 + ($4 + 176 | 0) | 0] = $0;
      }
      continue;
     }
     break;
    }
   }
   HEAP8[$4 + 19 | 0] = (heatshrink_decoder_sink($4 + 304 | 0, HEAP32[$4 + 20 >> 2] + ($4 + 176 | 0) | 0, HEAP32[$4 + 24 >> 2], $4 + 40 | 0) | 0) >= 0;
   HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 24 >> 2] - HEAP32[$4 + 40 >> 2];
   HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 40 >> 2] + HEAP32[$4 + 20 >> 2];
   HEAP32[$4 + 36 >> 2] = HEAP32[$4 + 40 >> 2] + HEAP32[$4 + 36 >> 2];
   if (!(HEAP32[$4 + 24 >> 2] | HEAP32[$4 + 28 >> 2] >= 0)) {
    heatshrink_decoder_finish($4 + 304 | 0);
   }
   while (1) {
    HEAP32[$4 + 12 >> 2] = heatshrink_decoder_poll($4 + 304 | 0, $4 + 48 | 0, $4 + 40 | 0);
    if (HEAP32[$4 + 612 >> 2]) {
     HEAP32[$4 + 44 >> 2] = 0;
     while (1) {
      if (HEAPU32[$4 + 44 >> 2] < HEAPU32[$4 + 40 >> 2]) {
       FUNCTION_TABLE[HEAP32[$4 + 612 >> 2]](HEAPU8[HEAP32[$4 + 44 >> 2] + ($4 + 48 | 0) | 0], HEAP32[$4 + 608 >> 2]);
       HEAP32[$4 + 44 >> 2] = HEAP32[$4 + 44 >> 2] + 1;
       continue;
      }
      break;
     }
    }
    HEAP32[$4 + 32 >> 2] = HEAP32[$4 + 40 >> 2] + HEAP32[$4 + 32 >> 2];
    if (HEAP32[$4 + 12 >> 2] == 1) {
     continue;
    }
    break;
   }
   if (HEAP32[$4 + 28 >> 2] < 0) {
    heatshrink_decoder_finish($4 + 304 | 0);
   }
   continue;
  }
  break;
 }
 global$0 = $4 + 624 | 0;
 return HEAP32[$4 + 32 >> 2];
}
function jspeStatementTry() {
 var $0 = 0;
 $0 = global$0 - 32 | 0;
 global$0 = $0;
 jslGetNextToken();
 HEAP8[$0 + 27 | 0] = (HEAP32[80549] & 63) == 1;
 jspeBlock();
 HEAP8[$0 + 26 | 0] = HEAP8[$0 + 27 | 0] & 1 ? (HEAP32[80549] & 32) != 0 : 0;
 HEAP8[$0 + 25 | 0] = 0;
 label$3 : {
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 178) {
   jslGetNextToken();
   HEAP8[$0 + 25 | 0] = 1;
   if (!(jslMatch(40) & 1)) {
    break label$3;
   }
   HEAP32[$0 + 20 >> 2] = 0;
   HEAP32[$0 + 16 >> 2] = 0;
   if (HEAP8[$0 + 26 | 0] & 1) {
    HEAP32[$0 + 20 >> 2] = jsvNewWithFlags(5);
    if (HEAP32[$0 + 20 >> 2]) {
     HEAP32[$0 + 16 >> 2] = jsvFindChildFromString(HEAP32[$0 + 20 >> 2], jslGetTokenValueAsString(), 1);
    }
   }
   if (!(jslMatch(128) & 1)) {
    jsvUnLock2(HEAP32[$0 + 20 >> 2], HEAP32[$0 + 16 >> 2]);
    break label$3;
   }
   if (!(jslMatch(41) & 1)) {
    jsvUnLock2(HEAP32[$0 + 20 >> 2], HEAP32[$0 + 16 >> 2]);
    break label$3;
   }
   if (HEAP32[$0 + 16 >> 2]) {
    HEAP32[$0 + 12 >> 2] = jspGetException();
    if (HEAP32[$0 + 12 >> 2]) {
     jsvSetValueOfName(HEAP32[$0 + 16 >> 2], HEAP32[$0 + 12 >> 2]);
     jsvUnLock(HEAP32[$0 + 12 >> 2]);
    }
    HEAP32[80549] = HEAP32[80549] & -161;
    jsvUnLock(HEAP32[$0 + 16 >> 2]);
   }
   label$11 : {
    if (!(!(HEAP8[$0 + 27 | 0] & 1) | HEAP8[$0 + 26 | 0] & 1)) {
     HEAP32[$0 + 8 >> 2] = HEAP32[80549];
     jspSetNoExecute();
     jspeBlock();
     HEAP32[80549] = HEAP32[80549] & -1664 | HEAP32[$0 + 8 >> 2] & 1663;
     break label$11;
    }
    label$13 : {
     if (HEAP32[$0 + 20 >> 2]) {
      if (!(jspeiAddScope(HEAP32[$0 + 20 >> 2]) & 1)) {
       break label$13;
      }
     }
     jspeBlock();
     if (HEAP32[$0 + 20 >> 2]) {
      jspeiRemoveScope();
     }
    }
   }
   jsvUnLock(HEAP32[$0 + 20 >> 2]);
  }
  if (!(HEAP8[$0 + 25 | 0] & 1 | HEAP32[80549] & 80 ? HEAP16[HEAP32[35539] + 2 >> 1] != 179 : 0)) {
   if (!(jslMatch(179) & 1)) {
    break label$3;
   }
   if (HEAP8[$0 + 26 | 0] & 1) {
    HEAP32[80549] = HEAP32[80549] & -33;
   }
   jspeBlock();
   if (!(!(HEAP8[$0 + 26 | 0] & 1) | HEAP8[$0 + 25 | 0] & 1)) {
    HEAP32[80549] = HEAP32[80549] | 32;
   }
  }
 }
 HEAP32[$0 + 28 >> 2] = 0;
 global$0 = $0 + 32 | 0;
 return HEAP32[$0 + 28 >> 2];
}
function jswrap_string_indexOf($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 48 | 0;
 global$0 = $4;
 HEAP32[$4 + 40 >> 2] = $0;
 HEAP32[$4 + 36 >> 2] = $1;
 HEAP32[$4 + 32 >> 2] = $2;
 HEAP8[$4 + 31 | 0] = $3;
 label$1 : {
  if (!(jsvIsString(HEAP32[$4 + 40 >> 2]) & 1)) {
   HEAP32[$4 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$4 + 36 >> 2] = jsvAsString(HEAP32[$4 + 36 >> 2]);
  if (!HEAP32[$4 + 36 >> 2]) {
   HEAP32[$4 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$4 + 24 >> 2] = jsvGetStringLength(HEAP32[$4 + 40 >> 2]);
  HEAP32[$4 + 20 >> 2] = jsvGetStringLength(HEAP32[$4 + 36 >> 2]);
  if (HEAP32[$4 + 20 >> 2] > HEAP32[$4 + 24 >> 2]) {
   jsvUnLock(HEAP32[$4 + 36 >> 2]);
   HEAP32[$4 + 44 >> 2] = -1;
   break label$1;
  }
  HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 24 >> 2] - HEAP32[$4 + 20 >> 2];
  label$5 : {
   if (!(HEAP8[$4 + 31 | 0] & 1)) {
    HEAP32[$4 + 8 >> 2] = 1;
    HEAP32[$4 + 4 >> 2] = HEAP32[$4 + 16 >> 2] + 1;
    HEAP32[$4 + 12 >> 2] = 0;
    if (jsvIsNumeric(HEAP32[$4 + 32 >> 2]) & 1) {
     HEAP32[$4 + 12 >> 2] = jsvGetInteger(HEAP32[$4 + 32 >> 2]);
     if (HEAP32[$4 + 12 >> 2] < 0) {
      HEAP32[$4 + 12 >> 2] = 0;
     }
     if (HEAP32[$4 + 12 >> 2] > HEAP32[$4 + 4 >> 2]) {
      HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 4 >> 2];
     }
    }
    break label$5;
   }
   HEAP32[$4 + 8 >> 2] = -1;
   HEAP32[$4 + 4 >> 2] = -1;
   HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 16 >> 2];
   if (jsvIsNumeric(HEAP32[$4 + 32 >> 2]) & 1) {
    HEAP32[$4 + 12 >> 2] = jsvGetInteger(HEAP32[$4 + 32 >> 2]);
    if (HEAP32[$4 + 12 >> 2] < 0) {
     HEAP32[$4 + 12 >> 2] = 0;
    }
    if (HEAP32[$4 + 12 >> 2] > HEAP32[$4 + 16 >> 2]) {
     HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 16 >> 2];
    }
   }
  }
  while (1) {
   if (HEAP32[$4 + 12 >> 2] != HEAP32[$4 + 4 >> 2]) {
    if (jsvCompareString(HEAP32[$4 + 40 >> 2], HEAP32[$4 + 36 >> 2], HEAP32[$4 + 12 >> 2], 1)) {
     HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 8 >> 2] + HEAP32[$4 + 12 >> 2];
     continue;
    } else {
     jsvUnLock(HEAP32[$4 + 36 >> 2]);
     HEAP32[$4 + 44 >> 2] = HEAP32[$4 + 12 >> 2];
     break label$1;
    }
   }
   break;
  }
  jsvUnLock(HEAP32[$4 + 36 >> 2]);
  HEAP32[$4 + 44 >> 2] = -1;
 }
 global$0 = $4 + 48 | 0;
 return HEAP32[$4 + 44 >> 2];
}
function _parse_time($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 $0 = stringToIntWithRadix(jslGetTokenValueAsString() + HEAP32[$2 + 20 >> 2] | 0, 10, 0, 0);
 HEAP32[HEAP32[$2 + 24 >> 2] + 16 >> 2] = $0;
 jslGetNextToken();
 label$1 : {
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 58) {
   jslGetNextToken();
   if (HEAP16[HEAP32[35539] + 2 >> 1] == 129) {
    $0 = _parse_int();
    HEAP32[HEAP32[$2 + 24 >> 2] + 12 >> 2] = $0;
    jslGetNextToken();
    if (HEAP16[HEAP32[35539] + 2 >> 1] == 58) {
     jslGetNextToken();
     if (!(HEAP16[HEAP32[35539] + 2 >> 1] != 130 ? HEAP16[HEAP32[35539] + 2 >> 1] != 129 : 0)) {
      HEAPF64[$2 + 8 >> 3] = stringToFloat(jslGetTokenValueAsString());
      $0 = HEAP32[$2 + 24 >> 2];
      $3 = HEAPF64[$2 + 8 >> 3];
      label$7 : {
       if (Math_abs($3) < 2147483648) {
        $1 = ~~$3;
        break label$7;
       }
       $1 = -2147483648;
      }
      HEAP32[$0 + 8 >> 2] = $1;
      $0 = HEAP32[$2 + 24 >> 2];
      $3 = HEAPF64[$2 + 8 >> 3] * 1e3;
      label$9 : {
       if (Math_abs($3) < 2147483648) {
        $1 = ~~$3;
        break label$9;
       }
       $1 = -2147483648;
      }
      HEAP32[$0 + 4 >> 2] = ($1 | 0) % 1e3;
      jslGetNextToken();
      label$11 : {
       if (HEAP16[HEAP32[35539] + 2 >> 1] != 128) {
        break label$11;
       }
       if (strcmp(jslGetTokenValueAsString(), 119915)) {
        break label$11;
       }
       HEAP32[HEAP32[$2 + 24 >> 2] + 20 >> 2] = 0;
       jslGetNextToken();
      }
      if (!(HEAP16[HEAP32[35539] + 2 >> 1] != 45 ? HEAP16[HEAP32[35539] + 2 >> 1] != 43 : 0)) {
       HEAP32[$2 + 4 >> 2] = HEAP16[HEAP32[35539] + 2 >> 1] == 43 ? 1 : -1;
       jslGetNextToken();
       if (HEAP16[HEAP32[35539] + 2 >> 1] == 129) {
        HEAP32[$2 >> 2] = _parse_int();
        HEAP32[$2 >> 2] = Math_imul(HEAP32[$2 >> 2] / 100 | 0, 60) + (HEAP32[$2 >> 2] % 100 | 0);
        HEAP32[HEAP32[$2 + 24 >> 2] + 20 >> 2] = Math_imul(HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]);
        jslGetNextToken();
       }
      }
      HEAP8[$2 + 31 | 0] = 1;
      break label$1;
     }
    }
   }
  }
  HEAP8[$2 + 31 | 0] = 0;
 }
 global$0 = $2 + 32 | 0;
}
function jsspiPopulateSPIInfo($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = global$0 - 128 | 0;
 global$0 = $2;
 $3 = $2 + 16 | 0;
 $4 = $2 + 116 | 0;
 $5 = $2 + 112 | 0;
 HEAP32[$2 + 124 >> 2] = $0;
 HEAP32[$2 + 120 >> 2] = $1;
 jshSPIInitInfo(HEAP32[$2 + 124 >> 2]);
 HEAP32[$2 + 116 >> 2] = 0;
 HEAP32[$2 + 112 >> 2] = HEAPU8[HEAP32[$2 + 124 >> 2] + 8 | 0];
 HEAP32[$2 + 16 >> 2] = 83658;
 HEAP16[$2 + 20 >> 1] = 12;
 HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 124 >> 2] + 5;
 HEAP32[$2 + 28 >> 2] = 83662;
 HEAP16[$2 + 32 >> 1] = 12;
 HEAP32[$2 + 36 >> 2] = HEAP32[$2 + 124 >> 2] + 6;
 HEAP32[$2 + 40 >> 2] = 83667;
 HEAP16[$2 + 44 >> 1] = 12;
 HEAP32[$2 + 48 >> 2] = HEAP32[$2 + 124 >> 2] + 7;
 HEAP32[$2 + 52 >> 2] = 83672;
 HEAP16[$2 + 56 >> 1] = 9;
 HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 124 >> 2];
 HEAP32[$2 + 64 >> 2] = 83677;
 HEAP16[$2 + 68 >> 1] = 9;
 HEAP32[$2 + 72 >> 2] = $5;
 HEAP32[$2 + 76 >> 2] = 83682;
 HEAP16[$2 + 80 >> 1] = 5;
 HEAP32[$2 + 84 >> 2] = $4;
 HEAP32[$2 + 88 >> 2] = 83688;
 HEAP16[$2 + 92 >> 1] = 9;
 HEAP32[$2 + 96 >> 2] = HEAP32[$2 + 124 >> 2] + 10;
 HEAP8[$2 + 15 | 0] = 1;
 if (jsvReadConfigObject(HEAP32[$2 + 120 >> 2], $3, 7) & 1) {
  HEAP8[HEAP32[$2 + 124 >> 2] + 8 | 0] = HEAP32[$2 + 112 >> 2] & 3;
  label$2 : {
   label$3 : {
    if (!(jsvIsString(HEAP32[$2 + 116 >> 2]) & 1)) {
     break label$3;
    }
    if (!(jsvIsStringEqual(HEAP32[$2 + 116 >> 2], 83693) & 1)) {
     break label$3;
    }
    HEAP8[HEAP32[$2 + 124 >> 2] + 9 | 0] = 1;
    break label$2;
   }
   label$4 : {
    label$5 : {
     if (!(jsvIsString(HEAP32[$2 + 116 >> 2]) & 1)) {
      break label$5;
     }
     if (!(jsvIsStringEqual(HEAP32[$2 + 116 >> 2], 83697) & 1)) {
      break label$5;
     }
     HEAP8[HEAP32[$2 + 124 >> 2] + 9 | 0] = 0;
     break label$4;
    }
    if (!(jsvIsUndefined(HEAP32[$2 + 116 >> 2]) & 1)) {
     jsExceptionHere(1, 83701, 0);
     HEAP8[$2 + 15 | 0] = 0;
    }
   }
  }
  $0 = HEAP32[$2 + 124 >> 2];
  if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) < 100) {
   jsExceptionHere(1, 83736, 0);
   HEAP8[$2 + 15 | 0] = 0;
  }
 }
 jsvUnLock(HEAP32[$2 + 116 >> 2]);
 global$0 = $2 + 128 | 0;
 return HEAP8[$2 + 15 | 0] & 1;
}
function jswrap_promise_all($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 48 | 0;
 global$0 = $1;
 HEAP32[$1 + 40 >> 2] = $0;
 label$1 : {
  if (!(jsvIsIterable(HEAP32[$1 + 40 >> 2]) & 1)) {
   HEAP32[$1 >> 2] = HEAP32[$1 + 40 >> 2];
   jsExceptionHere(3, 125180, $1);
   HEAP32[$1 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 36 >> 2] = jspNewObject(0, 125172);
  if (!HEAP32[$1 + 36 >> 2]) {
   HEAP32[$1 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 32 >> 2] = jsvNewNativeFunction(588, 32776);
  if (HEAP32[$1 + 32 >> 2]) {
   $0 = $1 + 16 | 0;
   jsvObjectSetChild(HEAP32[$1 + 32 >> 2], 125115, HEAP32[$1 + 36 >> 2]);
   HEAP32[$1 + 28 >> 2] = jsvNewWithFlags(3);
   HEAP32[$1 + 24 >> 2] = 0;
   HEAP32[$1 + 20 >> 2] = 0;
   jsvObjectIteratorNew($0, HEAP32[$1 + 40 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue($1 + 16 | 0) & 1) {
     HEAP32[$1 + 12 >> 2] = jsvObjectIteratorGetValue($1 + 16 | 0);
     label$7 : {
      if (_jswrap_promise_is_promise(HEAP32[$1 + 12 >> 2]) & 1) {
       HEAP32[$1 + 8 >> 2] = jsvNewNativeFunction(589, 32864);
       HEAP32[$1 + 4 >> 2] = jsvNewFromInteger(HEAP32[$1 + 24 >> 2]);
       jsvAddFunctionParameter(HEAP32[$1 + 8 >> 2], 0, HEAP32[$1 + 4 >> 2]);
       jsvUnLock(HEAP32[$1 + 4 >> 2]);
       jsvObjectSetChild(HEAP32[$1 + 8 >> 2], 125115, HEAP32[$1 + 36 >> 2]);
       jsvUnLock2(jswrap_promise_then(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 8 >> 2], HEAP32[$1 + 32 >> 2]), HEAP32[$1 + 8 >> 2]);
       break label$7;
      }
      jsvSetArrayItem(HEAP32[$1 + 28 >> 2], HEAP32[$1 + 24 >> 2], HEAP32[$1 + 12 >> 2]);
      HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 20 >> 2] + 1;
     }
     $0 = $1 + 16 | 0;
     jsvUnLock(HEAP32[$1 + 12 >> 2]);
     HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 24 >> 2] + 1;
     jsvObjectIteratorNext($0);
     continue;
    }
    break;
   }
   jsvObjectIteratorFree($1 + 16 | 0);
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 125161, jsvNewFromInteger(HEAP32[$1 + 24 >> 2] - HEAP32[$1 + 20 >> 2] | 0));
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 125167, HEAP32[$1 + 28 >> 2]);
  }
  jsvUnLock(HEAP32[$1 + 32 >> 2]);
  HEAP32[$1 + 44 >> 2] = HEAP32[$1 + 36 >> 2];
 }
 global$0 = $1 + 48 | 0;
 return HEAP32[$1 + 44 >> 2];
}
function jsvGetFloat($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = global$0 - 80 | 0;
 global$0 = $1;
 HEAP32[$1 + 68 >> 2] = $0;
 label$1 : {
  if (!HEAP32[$1 + 68 >> 2]) {
   HEAPF64[$1 + 72 >> 3] = nan;
   break label$1;
  }
  if (jsvIsFloat(HEAP32[$1 + 68 >> 2]) & 1) {
   $0 = HEAP32[$1 + 68 >> 2];
   $2 = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
   $0 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
   wasm2js_scratch_store_i32(0, $2 | 0);
   wasm2js_scratch_store_i32(1, $0 | 0);
   HEAPF64[$1 + 72 >> 3] = wasm2js_scratch_load_f64();
   break label$1;
  }
  if (jsvIsIntegerish(HEAP32[$1 + 68 >> 2]) & 1) {
   $0 = HEAP32[$1 + 68 >> 2];
   HEAPF64[$1 + 72 >> 3] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
   break label$1;
  }
  label$5 : {
   if (!(jsvIsArray(HEAP32[$1 + 68 >> 2]) & 1)) {
    if (!(jsvIsArrayBuffer(HEAP32[$1 + 68 >> 2]) & 1)) {
     break label$5;
    }
   }
   HEAP32[$1 + 64 >> 2] = jsvGetLength(HEAP32[$1 + 68 >> 2]);
   if (!HEAP32[$1 + 64 >> 2]) {
    HEAPF64[$1 + 72 >> 3] = 0;
    break label$1;
   }
   if (HEAP32[$1 + 64 >> 2] == 1) {
    if (jsvIsArrayBuffer(HEAP32[$1 + 68 >> 2]) & 1) {
     HEAPF64[$1 + 72 >> 3] = jsvGetFloatAndUnLock(jsvArrayBufferGet(HEAP32[$1 + 68 >> 2], 0));
     break label$1;
    }
    HEAPF64[$1 + 72 >> 3] = jsvGetFloatAndUnLock(jsvSkipNameAndUnLock(jsvGetArrayItem(HEAP32[$1 + 68 >> 2], 0)));
    break label$1;
   }
  }
  if (jsvIsString(HEAP32[$1 + 68 >> 2]) & 1) {
   label$11 : {
    if ((jsvGetString(HEAP32[$1 + 68 >> 2], $1, 64) | 0) == 64) {
     jsExceptionHere(1, 78549, 0);
     break label$11;
    }
    if (!HEAP8[$1 | 0]) {
     HEAPF64[$1 + 72 >> 3] = 0;
     break label$1;
    }
    if (!strcmp($1, 78585)) {
     HEAPF64[$1 + 72 >> 3] = infinity;
     break label$1;
    }
    if (!strcmp($1, 78594)) {
     HEAPF64[$1 + 72 >> 3] = -infinity;
     break label$1;
    }
    HEAPF64[$1 + 72 >> 3] = stringToFloat($1);
    break label$1;
   }
  }
  HEAPF64[$1 + 72 >> 3] = nan;
 }
 global$0 = $1 + 80 | 0;
 return +HEAPF64[$1 + 72 >> 3];
}
function jsvGetPathTo_int($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 128 | 0;
 global$0 = $5;
 HEAP32[$5 + 120 >> 2] = $0;
 HEAP32[$5 + 116 >> 2] = $1;
 HEAP32[$5 + 112 >> 2] = $2;
 HEAP32[$5 + 108 >> 2] = $3;
 HEAP32[$5 + 104 >> 2] = $4;
 label$1 : {
  if (HEAP32[$5 + 112 >> 2] <= 0) {
   HEAP32[$5 + 124 >> 2] = 0;
   break label$1;
  }
  HEAP32[$5 + 100 >> 2] = HEAP32[$5 + 112 >> 2] + 1;
  HEAP32[$5 + 96 >> 2] = 0;
  jsvIteratorNew($5 + 32 | 0, HEAP32[$5 + 120 >> 2], 0);
  while (1) {
   if (jsvIteratorHasElement($5 + 32 | 0) & 1) {
    HEAP32[$5 + 28 >> 2] = jsvIteratorGetValue($5 + 32 | 0);
    if (!(HEAP32[$5 + 120 >> 2] == HEAP32[$5 + 108 >> 2] | HEAP32[$5 + 28 >> 2] != HEAP32[$5 + 116 >> 2])) {
     $0 = $5 + 32 | 0;
     HEAP32[$5 + 24 >> 2] = jsvAsStringAndUnLock(jsvIteratorGetKey($0));
     jsvIteratorFree($0);
     HEAP32[$5 + 124 >> 2] = HEAP32[$5 + 24 >> 2];
     break label$1;
    }
    label$6 : {
     label$7 : {
      if (jsvIsObject(HEAP32[$5 + 28 >> 2]) & 1) {
       break label$7;
      }
      if (jsvIsArray(HEAP32[$5 + 28 >> 2]) & 1) {
       break label$7;
      }
      if (!(jsvIsFunction(HEAP32[$5 + 28 >> 2]) & 1)) {
       break label$6;
      }
     }
     HEAP32[$5 + 16 >> 2] = jsvGetPathTo_int(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 116 >> 2], HEAP32[$5 + 112 >> 2] - 1 | 0, HEAP32[$5 + 108 >> 2], $5 + 20 | 0);
     if (!(!HEAP32[$5 + 16 >> 2] | HEAP32[$5 + 20 >> 2] >= HEAP32[$5 + 100 >> 2])) {
      HEAP32[$5 + 100 >> 2] = HEAP32[$5 + 20 >> 2];
      HEAP32[$5 + 12 >> 2] = jsvIteratorGetKey($5 + 32 | 0);
      jsvUnLock(HEAP32[$5 + 96 >> 2]);
      $0 = jsvIsObject(HEAP32[$5 + 28 >> 2]);
      $1 = HEAP32[$5 + 12 >> 2];
      HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 16 >> 2];
      HEAP32[$5 >> 2] = $1;
      HEAP32[$5 + 96 >> 2] = jsvVarPrintf($0 & 1 ? 79232 : 79238, $5);
      jsvUnLock(HEAP32[$5 + 12 >> 2]);
     }
     jsvUnLock(HEAP32[$5 + 16 >> 2]);
    }
    jsvIteratorNext($5 + 32 | 0);
    continue;
   }
   break;
  }
  jsvIteratorFree($5 + 32 | 0);
  HEAP32[HEAP32[$5 + 104 >> 2] >> 2] = HEAP32[$5 + 100 >> 2];
  HEAP32[$5 + 124 >> 2] = HEAP32[$5 + 96 >> 2];
 }
 global$0 = $5 + 128 | 0;
 return HEAP32[$5 + 124 >> 2];
}
function graphicsStructResetState($0) {
 var $1 = 0, $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 label$1 : {
  label$2 : {
   $0 = HEAP32[$2 + 12 >> 2];
   if (!(HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24))) {
    break label$2;
   }
   $0 = HEAP32[$2 + 12 >> 2];
   if ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24)) == 1) {
    break label$2;
   }
   $0 = HEAP32[$2 + 12 >> 2];
   $1 = HEAPU8[324592] | HEAPU8[324593] << 8;
   HEAP8[$0 + 17 | 0] = $1;
   HEAP8[$0 + 18 | 0] = $1 >>> 8;
   HEAP8[$0 + 19 | 0] = $1 >>> 16;
   HEAP8[$0 + 20 | 0] = $1 >>> 24;
   $0 = HEAP32[$2 + 12 >> 2];
   $1 = HEAPU8[324594] | HEAPU8[324595] << 8;
   HEAP8[$0 + 21 | 0] = $1;
   HEAP8[$0 + 22 | 0] = $1 >>> 8;
   HEAP8[$0 + 23 | 0] = $1 >>> 16;
   HEAP8[$0 + 24 | 0] = $1 >>> 24;
   break label$1;
  }
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP8[$0 + 17 | 0] = -1;
  HEAP8[$0 + 18 | 0] = 16777215;
  HEAP8[$0 + 19 | 0] = 65535;
  HEAP8[$0 + 20 | 0] = 255;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP8[$0 + 21 | 0] = 0;
  HEAP8[$0 + 22 | 0] = 0;
  HEAP8[$0 + 23 | 0] = 0;
  HEAP8[$0 + 24 | 0] = 0;
 }
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP8[$0 + 25 | 0] = 8193;
 HEAP8[$0 + 26 | 0] = 32;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP8[$0 + 31 | 0] = HEAPU8[$0 + 31 | 0] | 3;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP8[$0 + 31 | 0] = HEAPU8[$0 + 31 | 0] | 12;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP8[$0 + 31 | 0] = HEAPU8[$0 + 31 | 0] & -49;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP8[$0 + 32 | 0] = 0;
 HEAP8[$0 + 33 | 0] = 0;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP8[$0 + 34 | 0] = 0;
 HEAP8[$0 + 35 | 0] = 0;
 $0 = HEAP32[$2 + 12 >> 2];
 $1 = HEAP32[$2 + 12 >> 2];
 $1 = (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) - 1 | 0;
 HEAP8[$0 + 36 | 0] = $1;
 HEAP8[$0 + 37 | 0] = $1 >>> 8;
 $0 = HEAP32[$2 + 12 >> 2];
 $1 = HEAP32[$2 + 12 >> 2];
 $1 = (HEAPU8[$1 + 14 | 0] | HEAPU8[$1 + 15 | 0] << 8) - 1 | 0;
 HEAP8[$0 + 38 | 0] = $1;
 HEAP8[$0 + 39 | 0] = $1 >>> 8;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP8[$0 + 27 | 0] = 0;
 HEAP8[$0 + 28 | 0] = 0;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP8[$0 + 29 | 0] = 0;
 HEAP8[$0 + 30 | 0] = 0;
}
function jswrap_interface_clearWatch($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 + -64 | 0;
 global$0 = $1;
 HEAP32[$1 + 60 >> 2] = $0;
 label$1 : {
  label$2 : {
   if (!(jsvIsUndefined(HEAP32[$1 + 60 >> 2]) & 1)) {
    if (jsvGetArrayLength(HEAP32[$1 + 60 >> 2])) {
     break label$2;
    }
   }
   $0 = $1 + 48 | 0;
   HEAP32[$1 + 56 >> 2] = jsvLock(HEAPU16[161111]);
   jsvObjectIteratorNew($0, HEAP32[$1 + 56 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue($1 + 48 | 0) & 1) {
     HEAP32[$1 + 44 >> 2] = jsvObjectIteratorGetValue($1 + 48 | 0);
     HEAP32[$1 + 40 >> 2] = jsvObjectGetChild(HEAP32[$1 + 44 >> 2], 122401, 0);
     HEAP8[$1 + 39 | 0] = jshGetPinFromVar(HEAP32[$1 + 40 >> 2]);
     if (!(jshGetPinShouldStayWatched(HEAPU8[$1 + 39 | 0]) & 1)) {
      jshPinWatch(HEAPU8[$1 + 39 | 0], 0);
     }
     $0 = $1 + 48 | 0;
     jsvUnLock2(HEAP32[$1 + 40 >> 2], HEAP32[$1 + 44 >> 2]);
     jsvObjectIteratorNext($0);
     continue;
    }
    break;
   }
   jsvObjectIteratorFree($1 + 48 | 0);
   jsvRemoveAllChildren(HEAP32[$1 + 56 >> 2]);
   jsvUnLock(HEAP32[$1 + 56 >> 2]);
   break label$1;
  }
  HEAP32[$1 + 32 >> 2] = jsvGetArrayItem(HEAP32[$1 + 60 >> 2], 0);
  if (jsvIsUndefined(HEAP32[$1 + 32 >> 2]) & 1) {
   jsExceptionHere(1, 122553, 0);
   break label$1;
  }
  HEAP32[$1 + 28 >> 2] = jsvLock(HEAPU16[161111]);
  HEAP32[$1 + 24 >> 2] = jsvFindChildFromVar(HEAP32[$1 + 28 >> 2], HEAP32[$1 + 32 >> 2], 0);
  jsvUnLock(HEAP32[$1 + 28 >> 2]);
  label$8 : {
   if (HEAP32[$1 + 24 >> 2]) {
    HEAP32[$1 + 20 >> 2] = jsvSkipName(HEAP32[$1 + 24 >> 2]);
    HEAP8[$1 + 19 | 0] = jshGetPinFromVarAndUnLock(jsvObjectGetChild(HEAP32[$1 + 20 >> 2], 122401, 0));
    jsvUnLock(HEAP32[$1 + 20 >> 2]);
    HEAP32[$1 + 12 >> 2] = jsvLock(HEAPU16[161111]);
    jsvRemoveChild(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 24 >> 2]);
    jsvUnLock2(HEAP32[$1 + 24 >> 2], HEAP32[$1 + 12 >> 2]);
    if (!(jsiIsWatchingPin(HEAPU8[$1 + 19 | 0]) & 1)) {
     jshPinWatch(HEAPU8[$1 + 19 | 0], 0);
    }
    break label$8;
   }
   HEAP32[$1 >> 2] = HEAP32[$1 + 32 >> 2];
   jsExceptionHere(1, 122614, $1);
  }
  jsvUnLock(HEAP32[$1 + 32 >> 2]);
 }
 global$0 = $1 - -64 | 0;
}
function jswrap_encodeURIComponent($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = global$0 - 112 | 0;
 global$0 = $1;
 HEAP32[$1 + 104 >> 2] = $0;
 HEAP32[$1 + 100 >> 2] = jsvAsString(HEAP32[$1 + 104 >> 2]);
 label$1 : {
  if (!HEAP32[$1 + 100 >> 2]) {
   HEAP32[$1 + 108 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 96 >> 2] = jsvNewWithFlags(27);
  if (HEAP32[$1 + 96 >> 2]) {
   $0 = $1 + 16 | 0;
   jsvStringIteratorNew($1 + 56 | 0, HEAP32[$1 + 100 >> 2], 0);
   jsvStringIteratorNew($0, HEAP32[$1 + 96 >> 2], 0);
   while (1) {
    if (jsvStringIteratorHasChar($1 + 56 | 0) & 1) {
     HEAP8[$1 + 15 | 0] = jsvStringIteratorGetCharAndNext($1 + 56 | 0);
     label$6 : {
      label$7 : {
       label$8 : {
        if (isAlpha(HEAP8[$1 + 15 | 0]) & 1) {
         break label$8;
        }
        if (isNumeric(HEAP8[$1 + 15 | 0]) & 1 | HEAP8[$1 + 15 | 0] == 45 | (HEAP8[$1 + 15 | 0] == 46 | HEAP8[$1 + 15 | 0] == 33)) {
         break label$8;
        }
        if (HEAP8[$1 + 15 | 0] == 126 | HEAP8[$1 + 15 | 0] == 42 | (HEAP8[$1 + 15 | 0] == 39 | HEAP8[$1 + 15 | 0] == 40)) {
         break label$8;
        }
        if (HEAP8[$1 + 15 | 0] != 41) {
         break label$7;
        }
       }
       jsvStringIteratorAppend($1 + 16 | 0, HEAP8[$1 + 15 | 0]);
       break label$6;
      }
      jsvStringIteratorAppend($1 + 16 | 0, 37);
      HEAP32[$1 + 8 >> 2] = HEAP8[$1 + 15 | 0] >>> 4;
      $0 = $1 + 16 | 0;
      if (HEAPU32[$1 + 8 >> 2] > 9) {
       $2 = HEAP32[$1 + 8 >> 2] + 55 | 0;
      } else {
       $2 = HEAP32[$1 + 8 >> 2] + 48 | 0;
      }
      jsvStringIteratorAppend($0, $2 << 24 >> 24);
      HEAP32[$1 + 8 >> 2] = HEAP8[$1 + 15 | 0] & 15;
      $0 = $1 + 16 | 0;
      if (HEAPU32[$1 + 8 >> 2] > 9) {
       $2 = HEAP32[$1 + 8 >> 2] + 55 | 0;
      } else {
       $2 = HEAP32[$1 + 8 >> 2] + 48 | 0;
      }
      jsvStringIteratorAppend($0, $2 << 24 >> 24);
     }
     continue;
    }
    break;
   }
   $0 = $1 + 56 | 0;
   jsvStringIteratorFree($1 + 16 | 0);
   jsvStringIteratorFree($0);
  }
  jsvUnLock(HEAP32[$1 + 100 >> 2]);
  HEAP32[$1 + 108 >> 2] = HEAP32[$1 + 96 >> 2];
 }
 global$0 = $1 + 112 | 0;
 return HEAP32[$1 + 108 >> 2];
}
function jsiHandleDelete($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP8[$1 + 31 | 0] = $0;
 HEAP32[$1 + 24 >> 2] = jsvGetStringLength(HEAP32[80557]);
 label$1 : {
  if (!(HEAP32[80559] | !(HEAP8[$1 + 31 | 0] & 1)) | !(HEAP8[$1 + 31 | 0] & 1 | HEAPU32[80559] < HEAPU32[$1 + 24 >> 2])) {
   break label$1;
  }
  $3 = $1;
  label$4 : {
   if (HEAP8[$1 + 31 | 0] & 1) {
    $0 = (jsvGetCharInString(HEAP32[80557], HEAP32[80559] - 1 | 0) & 255) == 10;
    $2 = 1;
    if ($0) {
     break label$4;
    }
   }
   if (HEAP8[$1 + 31 | 0] & 1) {
    $2 = 0;
   } else {
    $2 = (jsvGetCharInString(HEAP32[80557], HEAP32[80559]) & 255) == 10;
   }
  }
  HEAP8[$3 + 23 | 0] = $2 & 1;
  label$8 : {
   if (!(HEAP8[$1 + 23 | 0] & 1)) {
    break label$8;
   }
   if (!(jsiShowInputLine() & 1)) {
    break label$8;
   }
   jsiConsolePrintString(81039);
   if (HEAP8[$1 + 31 | 0] & 1) {
    jsiConsolePrintString(81571);
    jsiMoveCursorChar(HEAP32[80557], HEAP32[80559], HEAP32[80559] - 1 | 0);
    jsiInputLineCursorMoved();
   }
  }
  HEAP32[$1 + 16 >> 2] = jsvNewWithFlags(27);
  HEAP32[$1 + 12 >> 2] = HEAP32[80559];
  if (HEAP8[$1 + 31 | 0] & 1) {
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 12 >> 2] + -1;
  }
  if (HEAPU32[$1 + 12 >> 2] > 0) {
   jsvAppendStringVar(HEAP32[$1 + 16 >> 2], HEAP32[80557], 0, HEAP32[$1 + 12 >> 2]);
  }
  if (HEAP32[$1 + 12 >> 2] + 1 >>> 0 < HEAPU32[$1 + 24 >> 2]) {
   jsvAppendStringVar(HEAP32[$1 + 16 >> 2], HEAP32[80557], HEAP32[$1 + 12 >> 2] + 1 | 0, 2147483647);
  }
  jsiInputLineCursorMoved();
  jsvUnLock(HEAP32[80557]);
  HEAP32[80557] = HEAP32[$1 + 16 >> 2];
  if (HEAP8[$1 + 31 | 0] & 1) {
   HEAP32[80559] = HEAP32[80559] + -1;
  }
  if (!(jsiShowInputLine() & 1)) {
   break label$1;
  }
  label$14 : {
   if (HEAP8[$1 + 23 | 0] & 1) {
    jsiConsolePrintStringVarWithNewLineChar(HEAP32[80557], HEAP32[80559], 58);
    jsiMoveCursorChar(HEAP32[80557], jsvGetStringLength(HEAP32[80557]), HEAP32[80559]);
    break label$14;
   }
   if (HEAP8[$1 + 31 | 0] & 1) {
    jsiConsolePrintChar(8);
   }
   jsiConsolePrintStringVarUntilEOL(HEAP32[80557], HEAP32[80559]);
  }
 }
 global$0 = $1 + 32 | 0;
}
function jswrap_graphics_setTheme($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 if (jsvIsObject(HEAP32[$2 + 8 >> 2]) & 1) {
  HEAP32[$2 + 4 >> 2] = jsvObjectGetChild(HEAP32[$2 + 8 >> 2], 128156, 0);
  if (HEAP32[$2 + 4 >> 2]) {
   $0 = jswrap_graphics_toColor(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2], 0, 0);
   HEAP8[324592] = $0;
   HEAP8[324593] = $0 >>> 8;
   jsvUnLock(HEAP32[$2 + 4 >> 2]);
  }
  HEAP32[$2 + 4 >> 2] = jsvObjectGetChild(HEAP32[$2 + 8 >> 2], 128159, 0);
  if (HEAP32[$2 + 4 >> 2]) {
   $0 = jswrap_graphics_toColor(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2], 0, 0);
   HEAP8[324594] = $0;
   HEAP8[324595] = $0 >>> 8;
   jsvUnLock(HEAP32[$2 + 4 >> 2]);
  }
  HEAP32[$2 + 4 >> 2] = jsvObjectGetChild(HEAP32[$2 + 8 >> 2], 128162, 0);
  if (HEAP32[$2 + 4 >> 2]) {
   $0 = jswrap_graphics_toColor(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2], 0, 0);
   HEAP8[324596] = $0;
   HEAP8[324597] = $0 >>> 8;
   jsvUnLock(HEAP32[$2 + 4 >> 2]);
  }
  HEAP32[$2 + 4 >> 2] = jsvObjectGetChild(HEAP32[$2 + 8 >> 2], 128166, 0);
  if (HEAP32[$2 + 4 >> 2]) {
   $0 = jswrap_graphics_toColor(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2], 0, 0);
   HEAP8[324598] = $0;
   HEAP8[324599] = $0 >>> 8;
   jsvUnLock(HEAP32[$2 + 4 >> 2]);
  }
  HEAP32[$2 + 4 >> 2] = jsvObjectGetChild(HEAP32[$2 + 8 >> 2], 128170, 0);
  if (HEAP32[$2 + 4 >> 2]) {
   $0 = jswrap_graphics_toColor(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2], 0, 0);
   HEAP8[324600] = $0;
   HEAP8[324601] = $0 >>> 8;
   jsvUnLock(HEAP32[$2 + 4 >> 2]);
  }
  HEAP32[$2 + 4 >> 2] = jsvObjectGetChild(HEAP32[$2 + 8 >> 2], 128174, 0);
  if (HEAP32[$2 + 4 >> 2]) {
   $0 = jswrap_graphics_toColor(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2], 0, 0);
   HEAP8[324602] = $0;
   HEAP8[324603] = $0 >>> 8;
   jsvUnLock(HEAP32[$2 + 4 >> 2]);
  }
  HEAP32[$2 + 4 >> 2] = jsvObjectGetChild(HEAP32[$2 + 8 >> 2], 128178, 0);
  if (HEAP32[$2 + 4 >> 2]) {
   HEAP8[324604] = jsvGetBoolAndUnLock(HEAP32[$2 + 4 >> 2]) & 1;
  }
 }
 $0 = jsvLockAgain(HEAP32[$2 + 12 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0 | 0;
}
function jsfFindFile($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 112 | 0;
 global$0 = $2;
 HEAP32[$2 + 104 >> 2] = $1;
 HEAP8[$2 + 103 | 0] = jsfStripDriveFromName($0);
 $1 = HEAP32[$2 + 104 >> 2];
 HEAP32[$2 + 56 >> 2] = HEAP32[$0 + 24 >> 2];
 $3 = HEAP32[$0 + 20 >> 2];
 HEAP32[$2 + 48 >> 2] = HEAP32[$0 + 16 >> 2];
 HEAP32[$2 + 52 >> 2] = $3;
 $3 = HEAP32[$0 + 12 >> 2];
 HEAP32[$2 + 40 >> 2] = HEAP32[$0 + 8 >> 2];
 HEAP32[$2 + 44 >> 2] = $3;
 $3 = HEAP32[$0 + 4 >> 2];
 HEAP32[$2 + 32 >> 2] = HEAP32[$0 >> 2];
 HEAP32[$2 + 36 >> 2] = $3;
 HEAP32[(global$0 - 16 | 0) + 12 >> 2] = $1;
 HEAP32[$2 + 96 >> 2] = -1;
 if (HEAP32[$2 + 96 >> 2] == -1) {
  HEAP32[$2 + 24 >> 2] = HEAP32[$0 + 24 >> 2];
  $1 = HEAP32[$0 + 20 >> 2];
  HEAP32[$2 + 16 >> 2] = HEAP32[$0 + 16 >> 2];
  HEAP32[$2 + 20 >> 2] = $1;
  $1 = HEAP32[$0 + 12 >> 2];
  HEAP32[$2 + 8 >> 2] = HEAP32[$0 + 8 >> 2];
  HEAP32[$2 + 12 >> 2] = $1;
  $1 = HEAP32[$0 + 4 >> 2];
  HEAP32[$2 >> 2] = HEAP32[$0 >> 2];
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 + 96 >> 2] = jsfBankFindFile($2, $2 - -64 | 0);
  if (!HEAP32[$2 + 96 >> 2]) {
   $3 = HEAP32[$0 + 4 >> 2];
   $1 = $2 - -64 | 0;
   HEAP32[$1 + 4 >> 2] = HEAP32[$0 >> 2];
   HEAP32[$1 + 8 >> 2] = $3;
   HEAP32[$1 + 28 >> 2] = HEAP32[$0 + 24 >> 2];
   $3 = HEAP32[$0 + 20 >> 2];
   HEAP32[$1 + 20 >> 2] = HEAP32[$0 + 16 >> 2];
   HEAP32[$1 + 24 >> 2] = $3;
   $3 = HEAP32[$0 + 12 >> 2];
   HEAP32[$1 + 12 >> 2] = HEAP32[$0 + 8 >> 2];
   HEAP32[$1 + 16 >> 2] = $3;
  }
  jsfCachePut($2 - -64 | 0, HEAP32[$2 + 96 >> 2]);
  if (HEAP32[$2 + 104 >> 2]) {
   $0 = $2 - -64 | 0;
   $3 = HEAP32[$0 + 4 >> 2];
   $1 = HEAP32[$2 + 104 >> 2];
   HEAP32[$1 >> 2] = HEAP32[$0 >> 2];
   HEAP32[$1 + 4 >> 2] = $3;
   $3 = HEAP32[$0 + 28 >> 2];
   HEAP32[$1 + 24 >> 2] = HEAP32[$0 + 24 >> 2];
   HEAP32[$1 + 28 >> 2] = $3;
   $3 = HEAP32[$0 + 20 >> 2];
   HEAP32[$1 + 16 >> 2] = HEAP32[$0 + 16 >> 2];
   HEAP32[$1 + 20 >> 2] = $3;
   $3 = HEAP32[$0 + 12 >> 2];
   HEAP32[$1 + 8 >> 2] = HEAP32[$0 + 8 >> 2];
   HEAP32[$1 + 12 >> 2] = $3;
  }
 }
 HEAP32[$2 + 108 >> 2] = HEAP32[$2 + 96 >> 2];
 global$0 = $2 + 112 | 0;
 return HEAP32[$2 + 108 >> 2];
}
function jsiSoftInit($0) {
 var $1 = 0;
 $1 = global$0 - 48 | 0;
 global$0 = $1;
 HEAP8[$1 + 47 | 0] = $0;
 HEAP8[322179] = 0;
 HEAP8[322243] = 0;
 HEAP32[80554] = jsvNewWithFlags(3);
 HEAP32[80557] = jsvNewWithFlags(27);
 HEAP32[80559] = 0;
 HEAP16[161124] = 0;
 jsiInputLineCursorMoved();
 HEAP32[80566] = 0;
 jsfSetFlag(1, 0);
 HEAP8[141673] = 255;
 HEAP8[141674] = 255;
 HEAP16[161110] = _jsiInitNamedArray(81074);
 HEAP16[161111] = _jsiInitNamedArray(81081);
 HEAP32[80572] = jshGetSystemTime();
 HEAP32[80573] = i64toi32_i32$HIGH_BITS;
 HEAP32[80574] = -1;
 HEAP32[$1 + 40 >> 2] = jsvObjectGetChild(HEAP32[80546], 81089, 0);
 if (HEAP32[$1 + 40 >> 2]) {
  HEAP8[142160] = jsvGetIntegerAndUnLock(HEAP32[$1 + 40 >> 2]);
  jsvObjectRemoveChild(HEAP32[80546], 81089);
 }
 jswrap_graphics_init();
 jswrap_banglejs_init();
 terminalControlCharsReset();
 HEAP8[336938] = 0;
 HEAP8[141724] = 21;
 jsfLoadBootCodeFromFlash(HEAP8[$1 + 47 | 0] & 1);
 HEAP32[$1 + 36 >> 2] = jsvObjectGetChild(HEAP32[80546], 81095, 0);
 if (HEAP32[$1 + 36 >> 2]) {
  jsvUnLock2(jspEvaluateVar(HEAP32[$1 + 36 >> 2], 0, 0), HEAP32[$1 + 36 >> 2]);
  jsvObjectRemoveChild(HEAP32[80546], 81095);
 }
 if (HEAPU16[161111]) {
  $0 = $1 + 24 | 0;
  HEAP32[$1 + 32 >> 2] = jsvLock(HEAPU16[161111]);
  jsvObjectIteratorNew($0, HEAP32[$1 + 32 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue($1 + 24 | 0) & 1) {
    $0 = $1 + 24 | 0;
    HEAP32[$1 + 20 >> 2] = jsvObjectIteratorGetValue($0);
    HEAP32[$1 + 16 >> 2] = jsvObjectGetChild(HEAP32[$1 + 20 >> 2], 81100, 0);
    jshPinWatch(jshGetPinFromVar(HEAP32[$1 + 16 >> 2]) & 255, 1);
    jsvUnLock2(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 20 >> 2]);
    jsvObjectIteratorNext($0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree($1 + 24 | 0);
  jsvUnLock(HEAP32[$1 + 32 >> 2]);
 }
 jsiExecuteEventCallbackOn(81104, 81106, 0, 0);
 HEAP32[$1 + 12 >> 2] = jsvObjectGetChild(HEAP32[80545], 81114, 0);
 if (HEAP32[$1 + 12 >> 2]) {
  if (jsiEcho() & 1) {
   jsiConsolePrintString(81121);
  }
  jsiExecuteEventCallback(0, HEAP32[$1 + 12 >> 2], 0, 0);
  jsvUnLock(HEAP32[$1 + 12 >> 2]);
 }
 global$0 = $1 + 48 | 0;
}
function lcdScroll_ArrayBuffer_flat8($0, $1, $2, $3, $4, $5, $6) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 var $7 = 0;
 $7 = global$0 - 48 | 0;
 global$0 = $7;
 HEAP32[$7 + 44 >> 2] = $0;
 HEAP32[$7 + 40 >> 2] = $1;
 HEAP32[$7 + 36 >> 2] = $2;
 HEAP32[$7 + 32 >> 2] = $3;
 HEAP32[$7 + 28 >> 2] = $4;
 HEAP32[$7 + 24 >> 2] = $5;
 HEAP32[$7 + 20 >> 2] = $6;
 HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 24 >> 2] - HEAP32[$7 + 32 >> 2];
 HEAP32[$7 + 12 >> 2] = HEAP32[$7 + 20 >> 2] - HEAP32[$7 + 28 >> 2];
 HEAP32[$7 + 8 >> 2] = 0 - (HEAP32[$7 + 40 >> 2] + Math_imul(HEAP32[$7 + 36 >> 2], HEAP32[$7 + 16 >> 2]) | 0);
 $0 = HEAP32[$7 + 44 >> 2];
 HEAP32[$7 + 4 >> 2] = HEAP32[$7 + 32 >> 2] + Math_imul(HEAP32[$7 + 28 >> 2] - HEAP32[$7 + 36 >> 2] | 0, HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
 HEAP32[$7 >> 2] = 0;
 while (1) {
  if (HEAP32[$7 >> 2] < (HEAP32[$7 + 12 >> 2] + HEAP32[$7 + 36 >> 2] | 0)) {
   label$3 : {
    if (HEAP32[$7 + 8 >> 2] < 0) {
     $0 = HEAP32[$7 + 44 >> 2];
     $1 = (HEAP32[$7 + 4 >> 2] - HEAP32[$7 + 8 >> 2] | 0) + (HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24)) | 0;
     $0 = HEAP32[$7 + 44 >> 2];
     memcpy($1, HEAP32[$7 + 4 >> 2] + (HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24)) | 0, HEAP32[$7 + 16 >> 2] + HEAP32[$7 + 40 >> 2] | 0);
     break label$3;
    }
    $0 = HEAP32[$7 + 44 >> 2];
    $1 = HEAP32[$7 + 4 >> 2] + (HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24)) | 0;
    $0 = HEAP32[$7 + 44 >> 2];
    memcpy($1, (HEAP32[$7 + 4 >> 2] + HEAP32[$7 + 8 >> 2] | 0) + (HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24)) | 0, HEAP32[$7 + 16 >> 2] - HEAP32[$7 + 40 >> 2] | 0);
   }
   $0 = HEAP32[$7 + 44 >> 2];
   HEAP32[$7 + 4 >> 2] = HEAP32[$7 + 4 >> 2] + (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
   HEAP32[$7 >> 2] = HEAP32[$7 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $7 + 48 | 0;
}
function touchHandlerInternal($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 if (!(HEAP32[84152] & 131072)) {
  HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 28 >> 2] - HEAPU8[336650];
  HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 24 >> 2] - HEAPU8[336651];
  HEAP8[336650] = HEAP32[$4 + 28 >> 2];
  HEAP8[336651] = HEAP32[$4 + 24 >> 2];
  HEAP8[336652] = HEAP32[$4 + 20 >> 2] != 0;
  if (HEAP32[$4 + 16 >> 2] != HEAP32[84164]) {
   $0 = HEAP32[$4 + 16 >> 2];
   label$3 : {
    if ($0 >>> 0 > 12) {
     break label$3;
    }
    label$4 : {
     switch ($0 - 1 | 0) {
     case 0:
      HEAP32[84165] = 4;
      HEAP32[84158] = HEAP32[84158] | 524288;
      break label$3;
     case 1:
      HEAP32[84165] = 3;
      HEAP32[84158] = HEAP32[84158] | 524288;
      break label$3;
     case 2:
      HEAP32[84165] = 1;
      HEAP32[84158] = HEAP32[84158] | 524288;
      break label$3;
     case 3:
      HEAP32[84165] = 2;
      HEAP32[84158] = HEAP32[84158] | 524288;
      break label$3;
     case 4:
      label$11 : {
       if (HEAPU8[336650] < 80) {
        HEAP32[84158] = HEAP32[84158] | 1048576;
        break label$11;
       }
       HEAP32[84158] = HEAP32[84158] | 2097152;
      }
      HEAP8[336664] = 0;
      break label$3;
     case 10:
      label$13 : {
       if (HEAPU8[336650] < 80) {
        HEAP32[84158] = HEAP32[84158] | 1048576;
        break label$13;
       }
       HEAP32[84158] = HEAP32[84158] | 2097152;
      }
      HEAP8[336664] = 1;
      break label$3;
     case 11:
      break label$4;
     default:
      break label$3;
     }
    }
    label$15 : {
     if (HEAPU8[336650] < 80) {
      HEAP32[84158] = HEAP32[84158] | 1048576;
      break label$15;
     }
     HEAP32[84158] = HEAP32[84158] | 2097152;
    }
    HEAP8[336664] = 2;
   }
  }
  if (!(HEAPU8[336667] == HEAPU8[336651] ? !((HEAP8[336652] & 1) != (HEAP8[336665] & 1) | HEAPU8[336666] != HEAPU8[336650]) : 0)) {
   HEAP32[84158] = HEAP32[84158] | 4194304;
   HEAP16[168314] = 0;
  }
  HEAP32[84164] = HEAP32[$4 + 16 >> 2];
 }
}
function tflite___28anonymous_20namespace_29__AllocationInfoBuilder__GetOfflinePlannedOffsets_28tflite__Model_20const__2c_20int_20const___29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 + -64 | 0;
 global$0 = $3;
 HEAP32[$3 + 56 >> 2] = $0;
 HEAP32[$3 + 52 >> 2] = $1;
 HEAP32[$3 + 48 >> 2] = $2;
 $0 = HEAP32[$3 + 56 >> 2];
 label$1 : {
  if (tflite__Model__metadata_28_29_20const(HEAP32[$3 + 52 >> 2])) {
   HEAP32[$3 + 44 >> 2] = 0;
   while (1) {
    if (HEAPU32[$3 + 44 >> 2] < flatbuffers__Vector_int___size_28_29_20const(tflite__Model__metadata_28_29_20const(HEAP32[$3 + 52 >> 2])) >>> 0) {
     HEAP32[$3 + 40 >> 2] = flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph__20___Get_28unsigned_20int_29_20const(tflite__Model__metadata_28_29_20const(HEAP32[$3 + 52 >> 2]), HEAP32[$3 + 44 >> 2]);
     if (!strncmp(flatbuffers__Vector_unsigned_20char___data_28_29_20const(tflite__Tensor__shape_28_29_20const(HEAP32[$3 + 40 >> 2])))) {
      HEAP32[$3 + 36 >> 2] = tflite__Tensor__quantization_28_29_20const(HEAP32[$3 + 52 >> 2]);
      HEAP32[$3 + 32 >> 2] = flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph__20___operator_5b_5d_28unsigned_20int_29_20const(HEAP32[$3 + 36 >> 2], tflite__Metadata__buffer_28_29_20const(HEAP32[$3 + 40 >> 2]));
      HEAP32[$3 + 28 >> 2] = tflite__Tensor__shape_28_29_20const(HEAP32[$3 + 32 >> 2]);
      HEAP32[$3 + 24 >> 2] = flatbuffers__Vector_unsigned_20char___data_28_29_20const(HEAP32[$3 + 28 >> 2]);
      HEAP32[$3 + 20 >> 2] = HEAP32[HEAP32[$3 + 24 >> 2] + 8 >> 2];
      HEAP32[HEAP32[$3 + 48 >> 2] >> 2] = HEAP32[$3 + 24 >> 2] + 12;
      if (HEAP32[$0 + 8 >> 2] != HEAP32[$3 + 20 >> 2]) {
       $1 = HEAP32[$0 >> 2];
       $2 = HEAP32[$3 + 20 >> 2];
       HEAP32[$3 + 4 >> 2] = HEAP32[$0 + 8 >> 2];
       HEAP32[$3 >> 2] = $2;
       tflite__ErrorReporter__Report_28char_20const__2c_20____29($1, 133080, $3);
       HEAP32[$3 + 60 >> 2] = 1;
       break label$1;
      }
     }
     HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 44 >> 2] + 1;
     continue;
    }
    break;
   }
  }
  HEAP32[$3 + 60 >> 2] = 0;
 }
 global$0 = $3 - -64 | 0;
 return HEAP32[$3 + 60 >> 2];
}
function jsfStripDriveFromName($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $3 = global$0 - 16 | 0;
 HEAP32[$3 + 8 >> 2] = $0;
 label$1 : {
  if (HEAP8[HEAP32[$3 + 8 >> 2] + 1 | 0] == 58) {
   HEAP8[$3 + 7 | 0] = HEAPU8[HEAP32[$3 + 8 >> 2]];
   $1 = HEAP32[$3 + 8 >> 2];
   $4 = HEAPU8[$1 + 10 | 0] | HEAPU8[$1 + 11 | 0] << 8 | (HEAPU8[$1 + 12 | 0] << 16 | HEAPU8[$1 + 13 | 0] << 24);
   $5 = HEAPU8[$1 + 14 | 0] | HEAPU8[$1 + 15 | 0] << 8 | (HEAPU8[$1 + 16 | 0] << 16 | HEAPU8[$1 + 17 | 0] << 24);
   $6 = HEAPU8[$1 + 18 | 0] | HEAPU8[$1 + 19 | 0] << 8 | (HEAPU8[$1 + 20 | 0] << 16 | HEAPU8[$1 + 21 | 0] << 24);
   $7 = HEAPU8[$1 + 22 | 0] | HEAPU8[$1 + 23 | 0] << 8 | (HEAPU8[$1 + 24 | 0] << 16 | HEAPU8[$1 + 25 | 0] << 24);
   $8 = HEAPU8[$1 + 2 | 0] | HEAPU8[$1 + 3 | 0] << 8 | (HEAPU8[$1 + 4 | 0] << 16 | HEAPU8[$1 + 5 | 0] << 24);
   $0 = HEAPU8[$1 + 6 | 0] | HEAPU8[$1 + 7 | 0] << 8 | (HEAPU8[$1 + 8 | 0] << 16 | HEAPU8[$1 + 9 | 0] << 24);
   $2 = HEAP32[$3 + 8 >> 2];
   $1 = HEAPU8[$1 + 26 | 0] | HEAPU8[$1 + 27 | 0] << 8;
   HEAP8[$2 + 24 | 0] = $1;
   HEAP8[$2 + 25 | 0] = $1 >>> 8;
   HEAP8[$2 + 16 | 0] = $6;
   HEAP8[$2 + 17 | 0] = $6 >>> 8;
   HEAP8[$2 + 18 | 0] = $6 >>> 16;
   HEAP8[$2 + 19 | 0] = $6 >>> 24;
   HEAP8[$2 + 20 | 0] = $7;
   HEAP8[$2 + 21 | 0] = $7 >>> 8;
   HEAP8[$2 + 22 | 0] = $7 >>> 16;
   HEAP8[$2 + 23 | 0] = $7 >>> 24;
   HEAP8[$2 + 8 | 0] = $4;
   HEAP8[$2 + 9 | 0] = $4 >>> 8;
   HEAP8[$2 + 10 | 0] = $4 >>> 16;
   HEAP8[$2 + 11 | 0] = $4 >>> 24;
   HEAP8[$2 + 12 | 0] = $5;
   HEAP8[$2 + 13 | 0] = $5 >>> 8;
   HEAP8[$2 + 14 | 0] = $5 >>> 16;
   HEAP8[$2 + 15 | 0] = $5 >>> 24;
   HEAP8[$2 | 0] = $8;
   HEAP8[$2 + 1 | 0] = $8 >>> 8;
   HEAP8[$2 + 2 | 0] = $8 >>> 16;
   HEAP8[$2 + 3 | 0] = $8 >>> 24;
   HEAP8[$2 + 4 | 0] = $0;
   HEAP8[$2 + 5 | 0] = $0 >>> 8;
   HEAP8[$2 + 6 | 0] = $0 >>> 16;
   HEAP8[$2 + 7 | 0] = $0 >>> 24;
   HEAP8[HEAP32[$3 + 8 >> 2] + 26 | 0] = 0;
   HEAP8[HEAP32[$3 + 8 >> 2] + 27 | 0] = 0;
   HEAP8[$3 + 15 | 0] = HEAPU8[$3 + 7 | 0];
   break label$1;
  }
  HEAP8[$3 + 15 | 0] = 0;
 }
 return HEAP8[$3 + 15 | 0];
}
function tflite__ops__micro__fully_connected___28anonymous_20namespace_29__CalculateOpData_28TfLiteContext__2c_20TfLiteFusedActivation_2c_20TfLiteType_2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor__2c_20tflite__ops__micro__fully_connected___28anonymous_20namespace_29__OpData__29($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0;
 $8 = global$0 + -64 | 0;
 global$0 = $8;
 HEAP32[$8 + 56 >> 2] = $0;
 HEAP32[$8 + 52 >> 2] = $1;
 HEAP32[$8 + 48 >> 2] = $2;
 HEAP32[$8 + 44 >> 2] = $3;
 HEAP32[$8 + 40 >> 2] = $4;
 HEAP32[$8 + 36 >> 2] = $5;
 HEAP32[$8 + 32 >> 2] = $6;
 HEAP32[$8 + 28 >> 2] = $7;
 HEAP32[$8 + 24 >> 2] = 0;
 label$1 : {
  if (HEAP32[$8 + 48 >> 2] != 1) {
   HEAPF64[$8 + 16 >> 3] = 0;
   HEAP32[$8 + 12 >> 2] = tflite__GetQuantizedConvolutionMultipler_28TfLiteContext__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor__2c_20double__29(HEAP32[$8 + 56 >> 2], HEAP32[$8 + 44 >> 2], HEAP32[$8 + 40 >> 2], HEAP32[$8 + 36 >> 2], HEAP32[$8 + 32 >> 2], $8 + 16 | 0);
   if (HEAP32[$8 + 12 >> 2]) {
    HEAP32[$8 + 60 >> 2] = HEAP32[$8 + 12 >> 2];
    break label$1;
   }
   tflite__QuantizeMultiplier_28double_2c_20int__2c_20int__29(HEAPF64[$8 + 16 >> 3], HEAP32[$8 + 28 >> 2], $8 + 8 | 0);
   HEAP32[HEAP32[$8 + 28 >> 2] + 4 >> 2] = 0 - HEAP32[$8 + 8 >> 2];
   HEAP32[$8 + 4 >> 2] = tflite__CalculateActivationRangeQuantized_28TfLiteContext__2c_20TfLiteFusedActivation_2c_20TfLiteTensor__2c_20int__2c_20int__29(HEAP32[$8 + 56 >> 2], HEAP32[$8 + 52 >> 2], HEAP32[$8 + 32 >> 2], HEAP32[$8 + 28 >> 2] + 8 | 0, HEAP32[$8 + 28 >> 2] + 12 | 0);
   if (HEAP32[$8 + 4 >> 2]) {
    HEAP32[$8 + 60 >> 2] = HEAP32[$8 + 4 >> 2];
    break label$1;
   }
   HEAP32[HEAP32[$8 + 28 >> 2] + 20 >> 2] = HEAP32[HEAP32[$8 + 44 >> 2] + 12 >> 2];
   HEAP32[HEAP32[$8 + 28 >> 2] + 24 >> 2] = HEAP32[HEAP32[$8 + 40 >> 2] + 12 >> 2];
   HEAP32[HEAP32[$8 + 28 >> 2] + 28 >> 2] = HEAP32[HEAP32[$8 + 32 >> 2] + 12 >> 2];
  }
  HEAP32[$8 + 60 >> 2] = HEAP32[$8 + 24 >> 2];
 }
 global$0 = $8 - -64 | 0;
 return HEAP32[$8 + 60 >> 2];
}
function atan2($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 wasm2js_scratch_store_f64(+$1);
 $2 = wasm2js_scratch_load_i32(1) | 0;
 $3 = wasm2js_scratch_load_i32(0) | 0;
 label$1 : {
  $5 = $2 & 2147483647;
  if (($5 | 0) == 2146435072 & $3 >>> 0 <= 0 | $5 >>> 0 < 2146435072) {
   wasm2js_scratch_store_f64(+$0);
   $5 = wasm2js_scratch_load_i32(1) | 0;
   $6 = wasm2js_scratch_load_i32(0) | 0;
   $4 = $5 & 2147483647;
   if (($4 | 0) == 2146435072 & $6 >>> 0 < 1 | $4 >>> 0 < 2146435072) {
    break label$1;
   }
  }
  return $0 + $1;
 }
 $9 = $3;
 $4 = $2;
 if (!($3 | $2 + -1072693248)) {
  return atan($0);
 }
 $8 = $2 >>> 30 & 2;
 $2 = $5;
 $3 = $8 | $2 >>> 31;
 label$4 : {
  label$5 : {
   label$6 : {
    $2 = $2 & 2147483647;
    if (!($6 | $2)) {
     label$8 : {
      switch ($3 - 2 | 0) {
      case 0:
       break label$6;
      case 1:
       break label$8;
      default:
       break label$5;
      }
     }
     return -3.141592653589793;
    }
    $4 = $4 & 2147483647;
    if (!($4 | $9)) {
     break label$4;
    }
    label$9 : {
     if (($4 | 0) == 2146435072) {
      if (($2 | 0) != 2146435072) {
       break label$9;
      }
      return HEAPF64[($3 << 3) + 141568 >> 3];
     }
     if (!($4 + 67108864 >>> 0 >= $2 >>> 0 ? ($2 | 0) != 2146435072 : 0)) {
      break label$4;
     }
     label$11 : {
      if ($8) {
       $7 = 0;
       if ($2 + 67108864 >>> 0 < $4 >>> 0) {
        break label$11;
       }
      }
      $7 = atan(Math_abs($0 / $1));
     }
     $0 = $7;
     if ($3 >>> 0 <= 2) {
      label$14 : {
       switch ($3 - 1 | 0) {
       case 0:
        return -$0;
       case 1:
        break label$14;
       default:
        break label$5;
       }
      }
      return 3.141592653589793 - ($0 + -1.2246467991473532e-16);
     }
     return $0 + -1.2246467991473532e-16 + -3.141592653589793;
    }
    return HEAPF64[($3 << 3) + 141600 >> 3];
   }
   $0 = 3.141592653589793;
  }
  return $0;
 }
 return (($5 | 0) < 0 ? 1 : ($5 | 0) <= 0 ? $6 >>> 0 >= 0 ? 0 : 1 : 0) ? -1.5707963267948966 : 1.5707963267948966;
}
function jswrap_number_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 label$1 : {
  if (!jsvGetArrayLength(HEAP32[$1 + 24 >> 2])) {
   HEAP32[$1 + 28 >> 2] = jsvNewFromInteger(0);
   break label$1;
  }
  HEAP32[$1 + 20 >> 2] = jsvGetArrayItem(HEAP32[$1 + 24 >> 2], 0);
  HEAP32[$1 + 16 >> 2] = 0;
  label$3 : {
   if (jsvIsArray(HEAP32[$1 + 20 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = jsvGetArrayLength(HEAP32[$1 + 20 >> 2]);
    label$5 : {
     if (!HEAP32[$1 + 12 >> 2]) {
      HEAP32[$1 + 16 >> 2] = jsvNewFromInteger(0);
      break label$5;
     }
     if (HEAP32[$1 + 12 >> 2] == 1) {
      HEAP32[$1 + 8 >> 2] = jsvGetArrayItem(HEAP32[$1 + 20 >> 2], 0);
      label$8 : {
       label$9 : {
        if (!(jsvIsString(HEAP32[$1 + 8 >> 2]) & 1)) {
         break label$9;
        }
        if (!(jsvIsEmptyString(HEAP32[$1 + 8 >> 2]) & 1)) {
         break label$9;
        }
        HEAP32[$1 + 16 >> 2] = jsvNewFromInteger(0);
        break label$8;
       }
       if (!(jsvIsBoolean(HEAP32[$1 + 8 >> 2]) & 1)) {
        HEAP32[$1 + 16 >> 2] = jsvAsNumber(HEAP32[$1 + 8 >> 2]);
       }
      }
      jsvUnLock(HEAP32[$1 + 8 >> 2]);
     }
    }
    break label$3;
   }
   label$11 : {
    label$12 : {
     if (!(jsvIsUndefined(HEAP32[$1 + 20 >> 2]) & 1)) {
      if (!(jsvIsObject(HEAP32[$1 + 20 >> 2]) & 1)) {
       break label$12;
      }
     }
     HEAP32[$1 + 16 >> 2] = 0;
     break label$11;
    }
    label$14 : {
     label$15 : {
      if (!(jsvIsString(HEAP32[$1 + 20 >> 2]) & 1)) {
       break label$15;
      }
      if (!(jsvIsEmptyString(HEAP32[$1 + 20 >> 2]) & 1)) {
       break label$15;
      }
      HEAP32[$1 + 16 >> 2] = jsvNewFromInteger(0);
      break label$14;
     }
     HEAP32[$1 + 16 >> 2] = jsvAsNumber(HEAP32[$1 + 20 >> 2]);
    }
   }
  }
  jsvUnLock(HEAP32[$1 + 20 >> 2]);
  if (HEAP32[$1 + 16 >> 2]) {
   HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 16 >> 2];
   break label$1;
  }
  HEAP32[$1 + 28 >> 2] = jsvNewFromFloat(nan);
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function mbedtls_sha512_starts($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$0 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
 label$1 : {
  if (!HEAP32[$2 + 8 >> 2]) {
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 + 16 >> 2] = -205731576;
   HEAP32[$0 + 20 >> 2] = 1779033703;
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 + 24 >> 2] = -2067093701;
   HEAP32[$0 + 28 >> 2] = -1150833019;
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 + 32 >> 2] = -23791573;
   HEAP32[$0 + 36 >> 2] = 1013904242;
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 + 40 >> 2] = 1595750129;
   HEAP32[$0 + 44 >> 2] = -1521486534;
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 + 48 >> 2] = -1377402159;
   HEAP32[$0 + 52 >> 2] = 1359893119;
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 + 56 >> 2] = 725511199;
   HEAP32[$0 + 60 >> 2] = -1694144372;
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 + 64 >> 2] = -79577749;
   HEAP32[$0 + 68 >> 2] = 528734635;
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 + 72 >> 2] = 327033209;
   HEAP32[$0 + 76 >> 2] = 1541459225;
   break label$1;
  }
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP32[$0 + 16 >> 2] = -1056596264;
  HEAP32[$0 + 20 >> 2] = -876896931;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP32[$0 + 24 >> 2] = 914150663;
  HEAP32[$0 + 28 >> 2] = 1654270250;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP32[$0 + 32 >> 2] = 812702999;
  HEAP32[$0 + 36 >> 2] = -1856437926;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP32[$0 + 40 >> 2] = -150054599;
  HEAP32[$0 + 44 >> 2] = 355462360;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP32[$0 + 48 >> 2] = -4191439;
  HEAP32[$0 + 52 >> 2] = 1731405415;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP32[$0 + 56 >> 2] = 1750603025;
  HEAP32[$0 + 60 >> 2] = -1900787065;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP32[$0 + 64 >> 2] = 1694076839;
  HEAP32[$0 + 68 >> 2] = -619958771;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP32[$0 + 72 >> 2] = -1090891868;
  HEAP32[$0 + 76 >> 2] = 1203062813;
 }
 HEAP32[HEAP32[$2 + 12 >> 2] + 208 >> 2] = HEAP32[$2 + 8 >> 2];
}
function jswrap_regexp_exec($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $3 = global$0 - 48 | 0;
 $2 = $3;
 global$0 = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 HEAP32[$2 + 32 >> 2] = jsvAsString(HEAP32[$2 + 36 >> 2]);
 HEAP32[$2 + 28 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$2 + 40 >> 2], 125384, 0));
 HEAP32[$2 + 24 >> 2] = jsvObjectGetChild(HEAP32[$2 + 40 >> 2], 125371, 0);
 label$1 : {
  label$2 : {
   if (jsvIsString(HEAP32[$2 + 24 >> 2]) & 1) {
    if (HEAPU32[$2 + 28 >> 2] <= jsvGetStringLength(HEAP32[$2 + 32 >> 2]) >>> 0) {
     break label$2;
    }
   }
   jsvUnLock2(HEAP32[$2 + 32 >> 2], HEAP32[$2 + 24 >> 2]);
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 20 >> 2] = jsvGetStringLength(HEAP32[$2 + 24 >> 2]);
  $0 = $3 - (HEAP32[$2 + 20 >> 2] + 16 & -16) | 0;
  global$0 = $0;
  HEAP32[$2 + 16 >> 2] = $0;
  if (!HEAP32[$2 + 16 >> 2]) {
   jsvUnLock2(HEAP32[$2 + 32 >> 2], HEAP32[$2 + 24 >> 2]);
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  jsvGetString(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 20 >> 2] + 1 | 0);
  jsvUnLock(HEAP32[$2 + 24 >> 2]);
  HEAP32[$2 + 12 >> 2] = match(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 32 >> 2], HEAP32[$2 + 28 >> 2], jswrap_regexp_hasFlag(HEAP32[$2 + 40 >> 2], 105) & 1);
  jsvUnLock(HEAP32[$2 + 32 >> 2]);
  label$5 : {
   if (!HEAP32[$2 + 12 >> 2]) {
    HEAP32[$2 + 12 >> 2] = jsvNewWithFlags(2);
    HEAP32[$2 + 28 >> 2] = 0;
    break label$5;
   }
   label$7 : {
    if (jswrap_regexp_hasFlag(HEAP32[$2 + 40 >> 2], 103) & 1) {
     HEAP32[$2 + 8 >> 2] = jsvGetArrayItem(HEAP32[$2 + 12 >> 2], 0);
     HEAP32[$2 + 28 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$2 + 12 >> 2], 125394, 0)) + jsvGetStringLength(HEAP32[$2 + 8 >> 2]);
     jsvUnLock(HEAP32[$2 + 8 >> 2]);
     break label$7;
    }
    HEAP32[$2 + 28 >> 2] = 0;
   }
  }
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 40 >> 2], 125384, jsvNewFromInteger(HEAP32[$2 + 28 >> 2]));
  HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 12 >> 2];
 }
 global$0 = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}
function jswrap_crypto_SHAx($0, $1) {
 var $2 = 0, $3 = 0;
 $3 = global$0 - 32 | 0;
 $2 = $3;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = 0;
 HEAP32[$2 + 12 >> 2] = jsvGetDataPointer(HEAP32[$2 + 24 >> 2], $2 + 16 | 0);
 if (!(HEAP32[$2 + 12 >> 2] | !HEAP32[$2 + 24 >> 2])) {
  HEAP32[$2 + 16 >> 2] = jsvIterateCallbackCount(HEAP32[$2 + 24 >> 2]);
  label$2 : {
   if (HEAP32[$2 + 16 >> 2] + 256 >>> 0 > 1e6) {
    jsExceptionHere(1, 128416, 0);
    break label$2;
   }
   $0 = $3 - (HEAP32[$2 + 16 >> 2] + 15 & -16) | 0;
   global$0 = $0;
   HEAP32[$2 + 12 >> 2] = $0;
   jsvIterateCallbackToBytes(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 16 >> 2]);
  }
 }
 label$4 : {
  if (!HEAP32[$2 + 12 >> 2]) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$4;
  }
  HEAP32[$2 + 8 >> 2] = 20;
  if (HEAP32[$2 + 20 >> 2] > 1) {
   HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 20 >> 2] / 8;
  }
  HEAP32[$2 + 4 >> 2] = 0;
  HEAP32[$2 >> 2] = jsvNewArrayBufferWithPtr(HEAP32[$2 + 8 >> 2], $2 + 4 | 0);
  if (!HEAP32[$2 + 4 >> 2]) {
   jsError(128455, 0);
   HEAP32[$2 + 28 >> 2] = 0;
   break label$4;
  }
  label$8 : {
   if (HEAP32[$2 + 20 >> 2] == 1) {
    mbedtls_sha1(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 4 >> 2]);
    break label$8;
   }
   label$10 : {
    if (HEAP32[$2 + 20 >> 2] == 224) {
     mbedtls_sha256(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 4 >> 2], 1);
     break label$10;
    }
    label$12 : {
     if (HEAP32[$2 + 20 >> 2] == 256) {
      mbedtls_sha256(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 4 >> 2], 0);
      break label$12;
     }
     label$14 : {
      if (HEAP32[$2 + 20 >> 2] == 384) {
       mbedtls_sha512(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 4 >> 2], 1);
       break label$14;
      }
      if (HEAP32[$2 + 20 >> 2] == 512) {
       mbedtls_sha512(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 4 >> 2], 0);
      }
     }
    }
   }
  }
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 >> 2];
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function jswrap_spi_send8bit($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0;
 $5 = global$0 - 112 | 0;
 global$0 = $5;
 HEAP32[$5 + 108 >> 2] = $0;
 HEAP32[$5 + 104 >> 2] = $1;
 HEAP32[$5 + 100 >> 2] = $2;
 HEAP32[$5 + 96 >> 2] = $3;
 HEAP8[$5 + 95 | 0] = $4;
 HEAP8[$5 + 94 | 0] = jsiGetDeviceFromClass(HEAP32[$5 + 108 >> 2]);
 label$1 : {
  if (!(HEAPU8[$5 + 94 | 0] <= 24 ? HEAPU8[$5 + 94 | 0] >= 24 : 0)) {
   jsExceptionHere(1, 125778, 0);
   break label$1;
  }
  jshPinSetState(HEAPU8[$5 + 94 | 0], 1);
  if (!(HEAP32[$5 + 100 >> 2] | HEAP32[$5 + 96 >> 2])) {
   HEAP32[$5 + 100 >> 2] = 3;
   HEAP32[$5 + 96 >> 2] = 15;
  }
  HEAP32[$5 + 100 >> 2] = HEAP32[$5 + 100 >> 2] & 255;
  HEAP32[$5 + 96 >> 2] = HEAP32[$5 + 96 >> 2] & 255;
  if (!(jshIsDeviceInitialised(HEAPU8[$5 + 94 | 0]) & 1)) {
   $0 = $5 + 80 | 0;
   jshSPIInitInfo($0);
   jshUSARTSetup(HEAPU8[$5 + 94 | 0], $0);
  }
  jshPinSetState(HEAPU8[$5 + 94 | 0], 0);
  if (HEAPU8[$5 + 95 | 0] != 255) {
   jshPinOutput(HEAPU8[$5 + 95 | 0], 0);
  }
  label$7 : {
   if (jsvIsNumeric(HEAP32[$5 + 104 >> 2]) & 1) {
    jsspiSend8bit(HEAPU8[$5 + 94 | 0], jsvGetInteger(HEAP32[$5 + 104 >> 2]) & 255, HEAP32[$5 + 100 >> 2], HEAP32[$5 + 96 >> 2]);
    break label$7;
   }
   label$9 : {
    if (jsvIsIterable(HEAP32[$5 + 104 >> 2]) & 1) {
     jsvIteratorNew($5 + 16 | 0, HEAP32[$5 + 104 >> 2], 1);
     while (1) {
      if (jsvIteratorHasElement($5 + 16 | 0) & 1) {
       $0 = $5 + 16 | 0;
       HEAP8[$5 + 15 | 0] = jsvIteratorGetIntegerValue($0);
       jsspiSend8bit(HEAPU8[$5 + 94 | 0], HEAPU8[$5 + 15 | 0], HEAP32[$5 + 100 >> 2], HEAP32[$5 + 96 >> 2]);
       jsvIteratorNext($0);
       continue;
      }
      break;
     }
     jsvIteratorFree($5 + 16 | 0);
     break label$9;
    }
    HEAP32[$5 >> 2] = HEAP32[$5 + 104 >> 2];
    jsExceptionHere(1, 125728, $5);
   }
  }
  jshUSARTUnSetup(HEAPU8[$5 + 94 | 0]);
  if (HEAPU8[$5 + 95 | 0] != 255) {
   jshPinOutput(HEAPU8[$5 + 95 | 0], 1);
  }
  jshPinSetState(HEAPU8[$5 + 94 | 0], 0);
 }
 global$0 = $5 + 112 | 0;
}
function jswrap_spi_send4bit($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0;
 $5 = global$0 - 112 | 0;
 global$0 = $5;
 HEAP32[$5 + 108 >> 2] = $0;
 HEAP32[$5 + 104 >> 2] = $1;
 HEAP32[$5 + 100 >> 2] = $2;
 HEAP32[$5 + 96 >> 2] = $3;
 HEAP8[$5 + 95 | 0] = $4;
 HEAP8[$5 + 94 | 0] = jsiGetDeviceFromClass(HEAP32[$5 + 108 >> 2]);
 label$1 : {
  if (!(HEAPU8[$5 + 94 | 0] <= 24 ? HEAPU8[$5 + 94 | 0] >= 24 : 0)) {
   jsExceptionHere(1, 125688, 0);
   break label$1;
  }
  jshPinSetState(HEAPU8[$5 + 94 | 0], 1);
  if (!(HEAP32[$5 + 100 >> 2] | HEAP32[$5 + 96 >> 2])) {
   HEAP32[$5 + 100 >> 2] = 1;
   HEAP32[$5 + 96 >> 2] = 3;
  }
  HEAP32[$5 + 100 >> 2] = HEAP32[$5 + 100 >> 2] & 15;
  HEAP32[$5 + 96 >> 2] = HEAP32[$5 + 96 >> 2] & 15;
  if (!(jshIsDeviceInitialised(HEAPU8[$5 + 94 | 0]) & 1)) {
   $0 = $5 + 80 | 0;
   jshSPIInitInfo($0);
   jshUSARTSetup(HEAPU8[$5 + 94 | 0], $0);
  }
  jshPinSetState(HEAPU8[$5 + 94 | 0], 0);
  if (HEAPU8[$5 + 95 | 0] != 255) {
   jshPinOutput(HEAPU8[$5 + 95 | 0], 0);
  }
  label$7 : {
   if (jsvIsNumeric(HEAP32[$5 + 104 >> 2]) & 1) {
    jsspiSend4bit(HEAPU8[$5 + 94 | 0], jsvGetInteger(HEAP32[$5 + 104 >> 2]) & 255, HEAP32[$5 + 100 >> 2], HEAP32[$5 + 96 >> 2]);
    break label$7;
   }
   label$9 : {
    if (jsvIsIterable(HEAP32[$5 + 104 >> 2]) & 1) {
     jsvIteratorNew($5 + 16 | 0, HEAP32[$5 + 104 >> 2], 1);
     while (1) {
      if (jsvIteratorHasElement($5 + 16 | 0) & 1) {
       $0 = $5 + 16 | 0;
       HEAP8[$5 + 15 | 0] = jsvIteratorGetIntegerValue($0);
       jsspiSend4bit(HEAPU8[$5 + 94 | 0], HEAPU8[$5 + 15 | 0], HEAP32[$5 + 100 >> 2], HEAP32[$5 + 96 >> 2]);
       jsvIteratorNext($0);
       continue;
      }
      break;
     }
     jsvIteratorFree($5 + 16 | 0);
     break label$9;
    }
    HEAP32[$5 >> 2] = HEAP32[$5 + 104 >> 2];
    jsExceptionHere(1, 125728, $5);
   }
  }
  jshUSARTUnSetup(HEAPU8[$5 + 94 | 0]);
  if (HEAPU8[$5 + 95 | 0] != 255) {
   jshPinOutput(HEAPU8[$5 + 95 | 0], 1);
  }
  jshPinSetState(HEAPU8[$5 + 94 | 0], 0);
 }
 global$0 = $5 + 112 | 0;
}
function tflite__ops__micro__pooling__Prepare_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1 : {
  if (!HEAP32[HEAP32[$2 + 20 >> 2] + 12 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$2 + 16 >> 2] = HEAP32[HEAP32[$2 + 20 >> 2] + 12 >> 2];
 label$2 : {
  if (!HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2]) {
   break label$2;
  }
 }
 HEAP32[$2 + 12 >> 2] = HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2];
 HEAP32[$2 + 8 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], 0);
 HEAP32[$2 + 4 >> 2] = tflite__GetOutput_28TfLiteContext__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2]);
 HEAP32[$2 >> 2] = tflite__ops__micro__pooling___28anonymous_20namespace_29__CalculateOpData_28TfLiteContext_20const__2c_20TfLitePoolParams_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20tflite__ops__micro__pooling___28anonymous_20namespace_29__OpData__29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2], HEAP32[$2 + 12 >> 2]);
 label$3 : {
  if (HEAP32[$2 >> 2]) {
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 >> 2];
   break label$3;
  }
  label$5 : {
   if (HEAP32[HEAP32[$2 + 8 >> 2] + 28 >> 2] == 1) {
    void_20tflite__CalculateActivationRange_float__28TfLiteFusedActivation_2c_20float__2c_20float__29(HEAP32[HEAP32[$2 + 16 >> 2] + 20 >> 2], HEAP32[$2 + 12 >> 2] + 24 | 0, HEAP32[$2 + 12 >> 2] + 28 | 0);
    break label$5;
   }
   if (!(HEAP32[HEAP32[$2 + 8 >> 2] + 28 >> 2] != 3 ? HEAP32[HEAP32[$2 + 8 >> 2] + 28 >> 2] != 9 : 0)) {
    tflite__CalculateActivationRangeQuantized_28TfLiteContext__2c_20TfLiteFusedActivation_2c_20TfLiteTensor__2c_20int__2c_20int__29(HEAP32[$2 + 24 >> 2], HEAP32[HEAP32[$2 + 16 >> 2] + 20 >> 2], HEAP32[$2 + 4 >> 2], HEAP32[$2 + 12 >> 2] + 16 | 0, HEAP32[$2 + 12 >> 2] + 20 | 0);
   }
  }
  HEAP32[$2 + 28 >> 2] = 0;
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function _jsvTraceGetLowestLevel($0, $1) {
 var $2 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 label$1 : {
  if (HEAP32[$2 + 40 >> 2] == HEAP32[$2 + 36 >> 2]) {
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 32 >> 2] = -1;
  $0 = HEAP32[$2 + 40 >> 2];
  if ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 256) {
   HEAP32[$2 + 44 >> 2] = -1;
   break label$1;
  }
  $0 = HEAP32[$2 + 40 >> 2];
  $1 = HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8 | 256;
  HEAP8[$0 + 13 | 0] = $1;
  HEAP8[$0 + 14 | 0] = $1 >>> 8;
  label$4 : {
   if (!(jsvHasSingleChild(HEAP32[$2 + 40 >> 2]) & 1)) {
    break label$4;
   }
   if (!(jsvGetFirstChild(HEAP32[$2 + 40 >> 2]) & 65535)) {
    break label$4;
   }
   HEAP32[$2 + 28 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$2 + 40 >> 2]) & 65535);
   HEAP32[$2 + 24 >> 2] = _jsvTraceGetLowestLevel(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 36 >> 2]);
   jsvUnLock(HEAP32[$2 + 28 >> 2]);
   if (!(HEAP32[$2 + 24 >> 2] < 0 | (HEAP32[$2 + 24 >> 2] >= HEAP32[$2 + 32 >> 2] ? HEAP32[$2 + 32 >> 2] >= 0 : 0))) {
    HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 24 >> 2] + 1;
   }
  }
  if (jsvHasChildren(HEAP32[$2 + 40 >> 2]) & 1) {
   HEAP16[$2 + 22 >> 1] = jsvGetFirstChild(HEAP32[$2 + 40 >> 2]);
   while (1) {
    if (HEAPU16[$2 + 22 >> 1]) {
     HEAP32[$2 + 16 >> 2] = jsvLock(HEAPU16[$2 + 22 >> 1]);
     HEAP32[$2 + 12 >> 2] = _jsvTraceGetLowestLevel(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 36 >> 2]);
     if (!(HEAP32[$2 + 12 >> 2] < 0 | (HEAP32[$2 + 12 >> 2] >= HEAP32[$2 + 32 >> 2] ? HEAP32[$2 + 32 >> 2] >= 0 : 0))) {
      HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
     }
     HEAP16[$2 + 22 >> 1] = jsvGetNextSibling(HEAP32[$2 + 16 >> 2]);
     jsvUnLock(HEAP32[$2 + 16 >> 2]);
     continue;
    }
    break;
   }
  }
  $0 = HEAP32[$2 + 40 >> 2];
  $1 = (HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & -257;
  HEAP8[$0 + 13 | 0] = $1;
  HEAP8[$0 + 14 | 0] = $1 >>> 8;
  HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
 }
 global$0 = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}
function jslPrintPosition($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = global$0 - 128 | 0;
 global$0 = $2;
 HEAP32[$2 + 124 >> 2] = 2;
 HEAP32[$2 + 120 >> 2] = $0;
 HEAP32[$2 + 116 >> 2] = $1;
 label$1 : {
  label$2 : {
   if (!(jsvIsNativeString(HEAP32[HEAP32[35539] + 84 >> 2]) & 1)) {
    if (!(jsvIsFlashString(HEAP32[HEAP32[35539] + 84 >> 2]) & 1)) {
     break label$2;
    }
   }
   $0 = HEAP32[HEAP32[35539] + 84 >> 2];
   HEAP32[$2 + 104 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
   HEAP32[$2 + 68 >> 2] = jsfFindFileFromAddr(HEAP32[$2 + 104 >> 2], $2 + 72 | 0);
   if (HEAP32[$2 + 68 >> 2]) {
    $0 = $2 + 112 | 0;
    $1 = $2 + 108 | 0;
    HEAP32[$2 + 64 >> 2] = jsvAddressToVar(HEAP32[$2 + 68 >> 2], jsfGetFileSize($2 + 72 | 0));
    jsvGetLineAndCol(HEAP32[$2 + 64 >> 2], (HEAP32[$2 + 116 >> 2] + HEAP32[$2 + 104 >> 2] | 0) - HEAP32[$2 + 68 >> 2] | 0, $0, $1);
    HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 100 >> 2];
    $0 = HEAP32[$2 + 96 >> 2];
    HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 92 >> 2];
    HEAP32[$2 + 20 >> 2] = $0;
    $0 = HEAP32[$2 + 88 >> 2];
    HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 84 >> 2];
    HEAP32[$2 + 12 >> 2] = $0;
    $0 = HEAP32[$2 + 80 >> 2];
    HEAP32[$2 >> 2] = HEAP32[$2 + 76 >> 2];
    HEAP32[$2 + 4 >> 2] = $0;
    HEAP32[$2 + 60 >> 2] = jsfVarFromName($2);
    $0 = HEAP32[$2 + 124 >> 2];
    $1 = HEAP32[$2 + 120 >> 2];
    $3 = HEAP32[$2 + 112 >> 2];
    $4 = HEAP32[$2 + 108 >> 2];
    HEAP32[$2 + 40 >> 2] = HEAP32[$2 + 60 >> 2];
    HEAP32[$2 + 36 >> 2] = $4;
    HEAP32[$2 + 32 >> 2] = $3;
    cbprintf($0, $1, 77920, $2 + 32 | 0);
    jsvUnLock2(HEAP32[$2 + 64 >> 2], HEAP32[$2 + 60 >> 2]);
    break label$1;
   }
  }
  jsvGetLineAndCol(HEAP32[HEAP32[35539] + 84 >> 2], HEAP32[$2 + 116 >> 2], $2 + 112 | 0, $2 + 108 | 0);
  $0 = HEAP32[$2 + 124 >> 2];
  $1 = HEAP32[$2 + 120 >> 2];
  $3 = HEAP32[$2 + 112 >> 2];
  HEAP32[$2 + 52 >> 2] = HEAP32[$2 + 108 >> 2];
  HEAP32[$2 + 48 >> 2] = $3;
  cbprintf($0, $1, 77942, $2 + 48 | 0);
 }
 global$0 = $2 + 128 | 0;
}
function jsvCreateConfigObject($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP32[$1 + 20 >> 2] = 19;
 HEAP32[$1 + 16 >> 2] = jsvNewWithFlags(5);
 label$1 : {
  if (!HEAP32[$1 + 16 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
  while (1) {
   if (HEAP32[$1 + 12 >> 2] < HEAP32[$1 + 20 >> 2]) {
    if (HEAP32[(HEAP32[$1 + 24 >> 2] + Math_imul(HEAP32[$1 + 12 >> 2], 12) | 0) + 8 >> 2]) {
     HEAP32[$1 + 8 >> 2] = 0;
     $0 = HEAPU16[(HEAP32[$1 + 24 >> 2] + Math_imul(HEAP32[$1 + 12 >> 2], 12) | 0) + 4 >> 1];
     label$6 : {
      if ($0 >>> 0 > 27) {
       break label$6;
      }
      label$7 : {
       switch ($0 + -3 | 0) {
       case 0:
       case 2:
       case 4:
       case 24:
        HEAP32[$1 + 8 >> 2] = jsvLockAgain(HEAP32[HEAP32[(HEAP32[$1 + 24 >> 2] + Math_imul(HEAP32[$1 + 12 >> 2], 12) | 0) + 8 >> 2] >> 2]);
        break label$6;
       case 9:
        HEAP32[$1 + 8 >> 2] = jsvNewFromPin(HEAPU8[HEAP32[(HEAP32[$1 + 24 >> 2] + Math_imul(HEAP32[$1 + 12 >> 2], 12) | 0) + 8 >> 2]]);
        break label$6;
       case 8:
        HEAP32[$1 + 8 >> 2] = jsvNewFromBool(HEAP8[HEAP32[(HEAP32[$1 + 24 >> 2] + Math_imul(HEAP32[$1 + 12 >> 2], 12) | 0) + 8 >> 2]] & 1);
        break label$6;
       case 6:
        HEAP32[$1 + 8 >> 2] = jsvNewFromInteger(HEAP32[HEAP32[(HEAP32[$1 + 24 >> 2] + Math_imul(HEAP32[$1 + 12 >> 2], 12) | 0) + 8 >> 2] >> 2]);
        break label$6;
       case 7:
        break label$7;
       default:
        break label$6;
       }
      }
      HEAP32[$1 + 8 >> 2] = jsvNewFromFloat(HEAPF64[HEAP32[(HEAP32[$1 + 24 >> 2] + Math_imul(HEAP32[$1 + 12 >> 2], 12) | 0) + 8 >> 2] >> 3]);
     }
     jsvObjectSetChildAndUnLock(HEAP32[$1 + 16 >> 2], HEAP32[HEAP32[$1 + 24 >> 2] + Math_imul(HEAP32[$1 + 12 >> 2], 12) >> 2], HEAP32[$1 + 8 >> 2]);
    }
    HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 12 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 16 >> 2];
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function _jswrap_drawImageSimple($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 48 | 0;
 global$0 = $5;
 HEAP32[$5 + 44 >> 2] = $0;
 HEAP32[$5 + 40 >> 2] = $1;
 HEAP32[$5 + 36 >> 2] = $2;
 HEAP32[$5 + 32 >> 2] = $3;
 HEAP32[$5 + 28 >> 2] = $4;
 HEAP32[$5 + 24 >> 2] = 0;
 HEAP32[$5 + 20 >> 2] = 0;
 HEAP32[$5 + 16 >> 2] = graphicsGetSetPixelUnclippedFn(HEAP32[$5 + 44 >> 2], HEAP32[$5 + 40 >> 2], HEAP32[$5 + 36 >> 2], (HEAP32[$5 + 40 >> 2] + HEAP32[HEAP32[$5 + 32 >> 2] >> 2] | 0) - 1 | 0, (HEAP32[$5 + 36 >> 2] + HEAP32[HEAP32[$5 + 32 >> 2] + 4 >> 2] | 0) - 1 | 0);
 HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 36 >> 2];
 while (1) {
  if (HEAP32[$5 + 12 >> 2] < (HEAP32[$5 + 36 >> 2] + HEAP32[HEAP32[$5 + 32 >> 2] + 4 >> 2] | 0)) {
   HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 40 >> 2];
   while (1) {
    if (HEAP32[$5 + 8 >> 2] < (HEAP32[$5 + 40 >> 2] + HEAP32[HEAP32[$5 + 32 >> 2] >> 2] | 0)) {
     while (1) {
      if (HEAP32[$5 + 24 >> 2] < HEAP32[HEAP32[$5 + 32 >> 2] + 8 >> 2]) {
       HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 20 >> 2] << 8 | jsvStringIteratorGetCharAndNext(HEAP32[$5 + 28 >> 2]) & 255;
       HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 24 >> 2] + 8;
       continue;
      }
      break;
     }
     HEAP32[$5 + 4 >> 2] = HEAP32[HEAP32[$5 + 32 >> 2] + 36 >> 2] & HEAP32[$5 + 20 >> 2] >> HEAP32[$5 + 24 >> 2] - HEAP32[HEAP32[$5 + 32 >> 2] + 8 >> 2];
     HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 24 >> 2] - HEAP32[HEAP32[$5 + 32 >> 2] + 8 >> 2];
     if (HEAP32[HEAP32[$5 + 32 >> 2] + 16 >> 2] != HEAP32[$5 + 4 >> 2]) {
      if (HEAP32[HEAP32[$5 + 32 >> 2] + 28 >> 2]) {
       HEAP32[$5 + 4 >> 2] = HEAPU16[HEAP32[HEAP32[$5 + 32 >> 2] + 28 >> 2] + ((HEAP32[$5 + 4 >> 2] & HEAP32[HEAP32[$5 + 32 >> 2] + 32 >> 2]) << 1) >> 1];
      }
      FUNCTION_TABLE[HEAP32[$5 + 16 >> 2]](HEAP32[$5 + 44 >> 2], HEAP32[$5 + 8 >> 2], HEAP32[$5 + 12 >> 2], HEAP32[$5 + 4 >> 2]);
     }
     HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 8 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $5 + 48 | 0;
}
function jspeiFindChildFromStringInParents($0, $1) {
 var $2 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 label$1 : {
  label$2 : {
   if (jsvIsObject(HEAP32[$2 + 40 >> 2]) & 1) {
    HEAP32[$2 + 32 >> 2] = jsvObjectGetChild(HEAP32[$2 + 40 >> 2], 79526, 0);
    if (!HEAP32[$2 + 32 >> 2]) {
     HEAP32[$2 + 32 >> 2] = jspFindPrototypeFor(79536);
    }
    label$5 : {
     if (!(!HEAP32[$2 + 32 >> 2] | HEAP32[$2 + 32 >> 2] == HEAP32[$2 + 40 >> 2])) {
      HEAP32[$2 + 28 >> 2] = jsvFindChildFromString(HEAP32[$2 + 32 >> 2], HEAP32[$2 + 36 >> 2], 0);
      if (!HEAP32[$2 + 28 >> 2]) {
       HEAP32[$2 + 28 >> 2] = jspeiFindChildFromStringInParents(HEAP32[$2 + 32 >> 2], HEAP32[$2 + 36 >> 2]);
      }
      jsvUnLock(HEAP32[$2 + 32 >> 2]);
      if (HEAP32[$2 + 28 >> 2]) {
       HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 28 >> 2];
       break label$1;
      }
      break label$5;
     }
     jsvUnLock(HEAP32[$2 + 32 >> 2]);
    }
    break label$2;
   }
   HEAP32[$2 + 24 >> 2] = jswGetBasicObjectName(HEAP32[$2 + 40 >> 2]);
   while (1) {
    if (HEAP32[$2 + 24 >> 2]) {
     HEAP32[$2 + 20 >> 2] = jsvFindChildFromString(HEAP32[80545], HEAP32[$2 + 24 >> 2], 0);
     if (HEAP32[$2 + 20 >> 2]) {
      HEAP32[$2 + 16 >> 2] = 0;
      HEAP32[$2 + 12 >> 2] = jsvSkipNameAndUnLock(HEAP32[$2 + 20 >> 2]);
      if (jsvHasChildren(HEAP32[$2 + 12 >> 2]) & 1) {
       HEAP32[$2 + 8 >> 2] = jsvObjectGetChild(HEAP32[$2 + 12 >> 2], 79516, 0);
       if (HEAP32[$2 + 8 >> 2]) {
        HEAP32[$2 + 16 >> 2] = jsvFindChildFromString(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 36 >> 2], 0);
        jsvUnLock(HEAP32[$2 + 8 >> 2]);
       }
      }
      jsvUnLock(HEAP32[$2 + 12 >> 2]);
      if (HEAP32[$2 + 16 >> 2]) {
       HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 16 >> 2];
       break label$1;
      }
     }
     HEAP32[$2 + 24 >> 2] = jswGetBasicObjectPrototypeName(HEAP32[$2 + 24 >> 2]);
     continue;
    }
    break;
   }
  }
  HEAP32[$2 + 44 >> 2] = 0;
 }
 global$0 = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}
function jswrap_object_on($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP32[$3 + 36 >> 2] = $2;
 label$1 : {
  if (!(jsvHasChildren(HEAP32[$3 + 44 >> 2]) & 1)) {
   jsExceptionHere(3, 123613, 0);
   break label$1;
  }
  if (!(jsvIsString(HEAP32[$3 + 40 >> 2]) & 1)) {
   jsExceptionHere(3, 123668, 0);
   break label$1;
  }
  label$4 : {
   if (jsvIsFunction(HEAP32[$3 + 36 >> 2]) & 1) {
    break label$4;
   }
   if (jsvIsString(HEAP32[$3 + 36 >> 2]) & 1) {
    break label$4;
   }
   jsExceptionHere(3, 123723, 0);
   break label$1;
  }
  HEAP32[$3 >> 2] = HEAP32[$3 + 40 >> 2];
  HEAP32[$3 + 32 >> 2] = jsvVarPrintf(123811, $3);
  if (!HEAP32[$3 + 32 >> 2]) {
   break label$1;
  }
  HEAP32[$3 + 28 >> 2] = jsvFindChildFromVar(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 32 >> 2], 1);
  jsvUnLock(HEAP32[$3 + 32 >> 2]);
  HEAP32[$3 + 24 >> 2] = jsvSkipName(HEAP32[$3 + 28 >> 2]);
  label$5 : {
   if (jsvIsUndefined(HEAP32[$3 + 24 >> 2]) & 1) {
    jsvSetValueOfName(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 36 >> 2]);
    break label$5;
   }
   label$7 : {
    if (jsvIsArray(HEAP32[$3 + 24 >> 2]) & 1) {
     jsvArrayPush(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 36 >> 2]);
     break label$7;
    }
    HEAP32[$3 + 20 >> 2] = jsvNewWithFlags(3);
    jsvArrayPush(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 24 >> 2]);
    jsvArrayPush(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 36 >> 2]);
    jsvSetValueOfName(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 20 >> 2]);
    jsvUnLock(HEAP32[$3 + 20 >> 2]);
   }
  }
  jsvUnLock2(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 28 >> 2]);
  if (!(jsvIsStringEqual(HEAP32[$3 + 40 >> 2], 123817) & 1)) {
   break label$1;
  }
  HEAP32[$3 + 16 >> 2] = jsvObjectGetChild(HEAP32[$3 + 44 >> 2], 123822, 0);
  if (jsvIsString(HEAP32[$3 + 16 >> 2]) & 1) {
   jsiQueueObjectCallbacks(HEAP32[$3 + 44 >> 2], 123827, $3 + 16 | 0, 1);
   jsvObjectRemoveChild(HEAP32[$3 + 44 >> 2], 123822);
  }
  jsvUnLock(HEAP32[$3 + 16 >> 2]);
 }
 global$0 = $3 + 48 | 0;
}
function jsvReplaceWith($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP32[$2 + 44 >> 2] = $0;
 HEAP32[$2 + 40 >> 2] = $1;
 label$1 : {
  if (jsvIsArrayBufferName(HEAP32[$2 + 44 >> 2]) & 1) {
   HEAP32[$2 + 36 >> 2] = jsvGetInteger(HEAP32[$2 + 44 >> 2]);
   HEAP32[$2 + 32 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$2 + 44 >> 2]) & 65535);
   jsvArrayBufferSet(HEAP32[$2 + 32 >> 2], HEAP32[$2 + 36 >> 2], HEAP32[$2 + 40 >> 2]);
   jsvUnLock(HEAP32[$2 + 32 >> 2]);
   break label$1;
  }
  if (!(jsvIsName(HEAP32[$2 + 44 >> 2]) & 1)) {
   HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 44 >> 2];
   jsExceptionHere(1, 78612, $2 + 16 | 0);
   break label$1;
  }
  HEAP32[$2 + 28 >> 2] = jsvGetValueOfName(HEAP32[$2 + 44 >> 2]);
  if (jsvIsGetterOrSetter(HEAP32[$2 + 28 >> 2]) & 1) {
   $0 = $2;
   label$5 : {
    if (jsvIsNewChild(HEAP32[$2 + 44 >> 2]) & 1) {
     $1 = jsvLock(jsvGetNextSibling(HEAP32[$2 + 44 >> 2]) & 65535);
     break label$5;
    }
    $1 = 0;
   }
   HEAP32[$0 + 24 >> 2] = $1;
   jsvExecuteSetter(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 40 >> 2]);
   jsvUnLock2(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2]);
   break label$1;
  }
  jsvUnLock(HEAP32[$2 + 28 >> 2]);
  jsvSetValueOfName(HEAP32[$2 + 44 >> 2], HEAP32[$2 + 40 >> 2]);
  if (!(jsvIsNewChild(HEAP32[$2 + 44 >> 2]) & 1)) {
   break label$1;
  }
  HEAP32[$2 + 20 >> 2] = jsvLock(jsvGetNextSibling(HEAP32[$2 + 44 >> 2]) & 65535);
  if (!(jsvIsString(HEAP32[$2 + 20 >> 2]) & 1)) {
   label$8 : {
    if (!(jsvHasChildren(HEAP32[$2 + 20 >> 2]) & 1)) {
     $0 = HEAP32[$2 + 44 >> 2];
     HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 20 >> 2];
     HEAP32[$2 >> 2] = $0;
     jsExceptionHere(1, 78655, $2);
     break label$8;
    }
    jsvUnRef(HEAP32[$2 + 20 >> 2]);
    jsvSetNextSibling(HEAP32[$2 + 44 >> 2], 0);
    jsvUnRef(HEAP32[$2 + 20 >> 2]);
    jsvSetPrevSibling(HEAP32[$2 + 44 >> 2], 0);
    jsvAddName(HEAP32[$2 + 20 >> 2], HEAP32[$2 + 44 >> 2]);
   }
  }
  jsvUnLock(HEAP32[$2 + 20 >> 2]);
 }
 global$0 = $2 + 48 | 0;
}
function graphicsSetPixelDevice($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 global$0 = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 $0 = HEAP32[$4 + 12 >> 2];
 label$1 : {
  if (HEAP32[$4 + 8 >> 2] < (HEAPU8[$0 + 32 | 0] | HEAPU8[$0 + 33 | 0] << 8)) {
   break label$1;
  }
  $0 = HEAP32[$4 + 12 >> 2];
  if (HEAP32[$4 + 4 >> 2] < (HEAPU8[$0 + 34 | 0] | HEAPU8[$0 + 35 | 0] << 8)) {
   break label$1;
  }
  $0 = HEAP32[$4 + 12 >> 2];
  if (HEAP32[$4 + 8 >> 2] > (HEAPU8[$0 + 36 | 0] | HEAPU8[$0 + 37 | 0] << 8)) {
   break label$1;
  }
  $0 = HEAP32[$4 + 12 >> 2];
  if (HEAP32[$4 + 4 >> 2] > (HEAPU8[$0 + 38 | 0] | HEAPU8[$0 + 39 | 0] << 8)) {
   break label$1;
  }
  $0 = HEAP32[$4 + 12 >> 2];
  if (HEAP32[$4 + 8 >> 2] < (HEAPU8[$0 + 40 | 0] | HEAPU8[$0 + 41 | 0] << 8) << 16 >> 16) {
   $0 = HEAP32[$4 + 12 >> 2];
   $1 = HEAP32[$4 + 8 >> 2];
   HEAP8[$0 + 40 | 0] = $1;
   HEAP8[$0 + 41 | 0] = $1 >>> 8;
  }
  $0 = HEAP32[$4 + 12 >> 2];
  if (HEAP32[$4 + 8 >> 2] > (HEAPU8[$0 + 44 | 0] | HEAPU8[$0 + 45 | 0] << 8) << 16 >> 16) {
   $0 = HEAP32[$4 + 12 >> 2];
   $1 = HEAP32[$4 + 8 >> 2];
   HEAP8[$0 + 44 | 0] = $1;
   HEAP8[$0 + 45 | 0] = $1 >>> 8;
  }
  $0 = HEAP32[$4 + 12 >> 2];
  if (HEAP32[$4 + 4 >> 2] < (HEAPU8[$0 + 42 | 0] | HEAPU8[$0 + 43 | 0] << 8) << 16 >> 16) {
   $0 = HEAP32[$4 + 12 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   HEAP8[$0 + 42 | 0] = $1;
   HEAP8[$0 + 43 | 0] = $1 >>> 8;
  }
  $0 = HEAP32[$4 + 12 >> 2];
  if (HEAP32[$4 + 4 >> 2] > (HEAPU8[$0 + 46 | 0] | HEAPU8[$0 + 47 | 0] << 8) << 16 >> 16) {
   $0 = HEAP32[$4 + 12 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   HEAP8[$0 + 46 | 0] = $1;
   HEAP8[$0 + 47 | 0] = $1 >>> 8;
  }
  $0 = HEAP32[$4 + 12 >> 2];
  FUNCTION_TABLE[HEAPU8[$0 + 52 | 0] | HEAPU8[$0 + 53 | 0] << 8 | (HEAPU8[$0 + 54 | 0] << 16 | HEAPU8[$0 + 55 | 0] << 24)](HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2] & (1 << HEAPU8[HEAP32[$4 + 12 >> 2] + 16 | 0]) - 1);
 }
 global$0 = $4 + 16 | 0;
}
function tflite__internal__InitializeTfLiteEvalTensorFromFlatbuffer_28tflite__SimpleMemoryAllocator__2c_20tflite__Tensor_20const__2c_20flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer__20__20const__2c_20tflite__ErrorReporter__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 48 | 0;
 global$0 = $5;
 HEAP32[$5 + 40 >> 2] = $0;
 HEAP32[$5 + 36 >> 2] = $1;
 HEAP32[$5 + 32 >> 2] = $2;
 HEAP32[$5 + 28 >> 2] = $3;
 HEAP32[$5 + 24 >> 2] = $4;
 HEAP32[$5 + 8 >> 2] = 0;
 HEAP32[$5 + 12 >> 2] = 0;
 HEAP32[$5 + 16 >> 2] = 0;
 $1 = $5 + 8 | 0;
 $2 = HEAP32[$1 + 4 >> 2];
 $0 = HEAP32[$5 + 24 >> 2];
 HEAP32[$0 >> 2] = HEAP32[$1 >> 2];
 HEAP32[$0 + 4 >> 2] = $2;
 HEAP32[$0 + 8 >> 2] = HEAP32[$1 + 8 >> 2];
 HEAP32[$5 + 4 >> 2] = tflite__ConvertTensorType_28tflite__TensorType_2c_20TfLiteType__2c_20tflite__ErrorReporter__29(tflite__Tensor__type_28_29_20const(HEAP32[$5 + 36 >> 2]), HEAP32[$5 + 24 >> 2] + 8 | 0, HEAP32[$5 + 28 >> 2]);
 label$1 : {
  if (HEAP32[$5 + 4 >> 2]) {
   HEAP32[$5 + 44 >> 2] = HEAP32[$5 + 4 >> 2];
   break label$1;
  }
  $0 = tflite__internal__GetFlatbufferTensorBuffer_28tflite__Tensor_20const__2c_20flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer__20__20const__29(HEAP32[$5 + 36 >> 2], HEAP32[$5 + 32 >> 2]);
  HEAP32[HEAP32[$5 + 24 >> 2] >> 2] = $0;
  label$3 : {
   if (!tflite__Tensor__shape_28_29_20const(HEAP32[$5 + 36 >> 2])) {
    HEAP32[HEAP32[$5 + 24 >> 2] + 4 >> 2] = 131504;
    break label$3;
   }
   HEAP32[$5 >> 2] = TfLiteStatus_20tflite__internal__FlatBufferVectorToTfLiteTypeArray_int_2c_20TfLiteIntArray__28tflite__SimpleMemoryAllocator__2c_20tflite__ErrorReporter__2c_20flatbuffers__Vector_int__20const__2c_20TfLiteIntArray___29(HEAP32[$5 + 40 >> 2], HEAP32[$5 + 28 >> 2], tflite__Tensor__shape_28_29_20const(HEAP32[$5 + 36 >> 2]), HEAP32[$5 + 24 >> 2] + 4 | 0);
   if (HEAP32[$5 >> 2]) {
    HEAP32[$5 + 44 >> 2] = HEAP32[$5 >> 2];
    break label$1;
   }
  }
  HEAP32[$5 + 44 >> 2] = 0;
 }
 global$0 = $5 + 48 | 0;
 return HEAP32[$5 + 44 >> 2];
}
function jswrap_espruino_FFT($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $4 = global$0 - 48 | 0;
 $3 = $4;
 global$0 = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP8[$3 + 39 | 0] = $2;
 label$1 : {
  label$2 : {
   if (jsvIsIterable(HEAP32[$3 + 44 >> 2]) & 1) {
    if (jsvIsUndefined(HEAP32[$3 + 40 >> 2]) & 1) {
     break label$2;
    }
    if (jsvIsIterable(HEAP32[$3 + 40 >> 2]) & 1) {
     break label$2;
    }
   }
   $0 = HEAP32[$3 + 44 >> 2];
   HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 40 >> 2];
   HEAP32[$3 >> 2] = $0;
   jsExceptionHere(1, 120245, $3);
   break label$1;
  }
  HEAP32[$3 + 32 >> 2] = jsvGetLength(HEAP32[$3 + 44 >> 2]);
  HEAP32[$3 + 28 >> 2] = 1;
  HEAP32[$3 + 24 >> 2] = 0;
  while (1) {
   if (HEAPU32[$3 + 28 >> 2] < HEAPU32[$3 + 32 >> 2]) {
    HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 28 >> 2] << 1;
    HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 24 >> 2] + 1;
    continue;
   }
   break;
  }
  if (1e6 < (HEAP32[$3 + 28 >> 2] << 4) + 256 >>> 0) {
   jsExceptionHere(1, 120316, 0);
   break label$1;
  }
  $0 = $4 - (HEAP32[$3 + 28 >> 2] << 4) | 0;
  global$0 = $0;
  HEAP32[$3 + 20 >> 2] = $0;
  HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 20 >> 2] + (HEAP32[$3 + 28 >> 2] << 3);
  _jswrap_espruino_FFT_getData(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 44 >> 2], HEAP32[$3 + 28 >> 2]);
  _jswrap_espruino_FFT_getData(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 40 >> 2], HEAP32[$3 + 28 >> 2]);
  FFT((HEAP8[$3 + 39 | 0] & 1 ? -1 : 1) << 16 >> 16, HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 16 >> 2]);
  HEAP8[$3 + 15 | 0] = jsvIsIterable(HEAP32[$3 + 40 >> 2]) & 1;
  $2 = HEAP32[$3 + 44 >> 2];
  $1 = HEAP32[$3 + 20 >> 2];
  if (HEAP8[$3 + 15 | 0] & 1) {
   $0 = 0;
  } else {
   $0 = HEAP32[$3 + 16 >> 2];
  }
  _jswrap_espruino_FFT_setData($2, $1, $0, HEAP32[$3 + 28 >> 2]);
  if (!(HEAP8[$3 + 15 | 0] & 1)) {
   break label$1;
  }
  _jswrap_espruino_FFT_setData(HEAP32[$3 + 40 >> 2], HEAP32[$3 + 16 >> 2], 0, HEAP32[$3 + 28 >> 2]);
 }
 global$0 = $3 + 48 | 0;
}
function jsiExecuteEventCallback($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 48 | 0;
 global$0 = $4;
 HEAP32[$4 + 40 >> 2] = $0;
 HEAP32[$4 + 36 >> 2] = $1;
 HEAP32[$4 + 32 >> 2] = $2;
 HEAP32[$4 + 28 >> 2] = $3;
 HEAP32[$4 + 24 >> 2] = jsvSkipName(HEAP32[$4 + 36 >> 2]);
 HEAP8[$4 + 23 | 0] = 1;
 if (HEAP32[$4 + 24 >> 2]) {
  label$2 : {
   if (jsvIsArray(HEAP32[$4 + 24 >> 2]) & 1) {
    jsvObjectIteratorNew($4 + 16 | 0, HEAP32[$4 + 24 >> 2]);
    while (1) {
     if (HEAP8[$4 + 23 | 0] & 1) {
      $0 = jsvObjectIteratorHasValue($4 + 16 | 0);
     } else {
      $0 = 0;
     }
     if ($0 & 1) {
      $0 = $4 + 16 | 0;
      HEAP32[$4 + 12 >> 2] = jsvObjectIteratorGetValue($0);
      HEAP8[$4 + 23 | 0] = (jsiExecuteEventCallback(HEAP32[$4 + 40 >> 2], HEAP32[$4 + 12 >> 2], HEAP32[$4 + 32 >> 2], HEAP32[$4 + 28 >> 2]) & 1 & (HEAP8[$4 + 23 | 0] & 1)) != 0;
      jsvUnLock(HEAP32[$4 + 12 >> 2]);
      jsvObjectIteratorNext($0);
      continue;
     }
     break;
    }
    jsvObjectIteratorFree($4 + 16 | 0);
    break label$2;
   }
   label$8 : {
    if (jsvIsFunction(HEAP32[$4 + 24 >> 2]) & 1) {
     jsvUnLock(jspExecuteFunction(HEAP32[$4 + 24 >> 2], HEAP32[$4 + 40 >> 2], HEAP32[$4 + 32 >> 2], HEAP32[$4 + 28 >> 2]));
     break label$8;
    }
    label$10 : {
     if (jsvIsString(HEAP32[$4 + 24 >> 2]) & 1) {
      jsvUnLock(jspEvaluateVar(HEAP32[$4 + 24 >> 2], 0, 0));
      break label$10;
     }
     jsError(81808, 0);
    }
   }
  }
  jsvUnLock(HEAP32[$4 + 24 >> 2]);
 }
 label$12 : {
  label$13 : {
   label$14 : {
    if (!(HEAP8[$4 + 23 | 0] & 1)) {
     break label$14;
    }
    if (jspIsInterrupted() & 1) {
     break label$14;
    }
    $1 = HEAPU32[80574] < jshGetTimeFromMilliseconds(100) >>> 0 ? 0 : 1;
    $0 = i64toi32_i32$HIGH_BITS;
    if (0 > ($0 | 0) ? 1 : 0 >= ($0 | 0) ? $1 : 0) {
     break label$13;
    }
   }
   HEAP8[322300] = 1;
   HEAP8[$4 + 47 | 0] = 0;
   break label$12;
  }
  HEAP8[$4 + 47 | 0] = 1;
 }
 global$0 = $4 + 48 | 0;
 return HEAP8[$4 + 47 | 0] & 1;
}
function jsvSkipNameWithParent($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP8[$3 + 23 | 0] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 label$1 : {
  if (!HEAP32[$3 + 24 >> 2]) {
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  if (jsvIsArrayBufferName(HEAP32[$3 + 24 >> 2]) & 1) {
   HEAP32[$3 + 28 >> 2] = jsvArrayBufferGetFromName(HEAP32[$3 + 24 >> 2]);
   break label$1;
  }
  if (jsvIsNameInt(HEAP32[$3 + 24 >> 2]) & 1) {
   HEAP32[$3 + 28 >> 2] = jsvNewFromInteger(jsvGetFirstChildSigned(HEAP32[$3 + 24 >> 2]) << 16 >> 16);
   break label$1;
  }
  if (jsvIsNameIntBool(HEAP32[$3 + 24 >> 2]) & 1) {
   HEAP32[$3 + 28 >> 2] = jsvNewFromBool((jsvGetFirstChild(HEAP32[$3 + 24 >> 2]) & 65535) != 0);
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = jsvLockAgain(HEAP32[$3 + 24 >> 2]);
  while (1) {
   if (jsvIsName(HEAP32[$3 + 12 >> 2]) & 1) {
    HEAP16[$3 + 10 >> 1] = jsvGetFirstChild(HEAP32[$3 + 12 >> 2]);
    jsvUnLock(HEAP32[$3 + 12 >> 2]);
    if (!HEAPU16[$3 + 10 >> 1]) {
     if (HEAP32[$3 + 12 >> 2] == HEAP32[$3 + 24 >> 2]) {
      jsvCheckReferenceError(HEAP32[$3 + 24 >> 2]);
     }
     HEAP32[$3 + 28 >> 2] = 0;
     break label$1;
    }
    HEAP32[$3 + 12 >> 2] = jsvLock(HEAPU16[$3 + 10 >> 1]);
    if (HEAP8[$3 + 23 | 0] & 1) {
     continue;
    }
   }
   break;
  }
  if (jsvIsGetterOrSetter(HEAP32[$3 + 12 >> 2]) & 1) {
   $0 = $3;
   label$11 : {
    if (jsvIsNewChild(HEAP32[$3 + 24 >> 2]) & 1) {
     $1 = jsvLock(jsvGetNextSibling(HEAP32[$3 + 24 >> 2]) & 65535);
     break label$11;
    }
    $1 = 0;
   }
   HEAP32[$0 + 4 >> 2] = $1;
   $0 = $3;
   if (HEAP32[$3 + 4 >> 2]) {
    $1 = HEAP32[$3 + 4 >> 2];
   } else {
    $1 = HEAP32[$3 + 16 >> 2];
   }
   HEAP32[$0 >> 2] = jsvExecuteGetter($1, HEAP32[$3 + 12 >> 2]);
   jsvUnLock2(HEAP32[$3 + 4 >> 2], HEAP32[$3 + 12 >> 2]);
   HEAP32[$3 + 12 >> 2] = HEAP32[$3 >> 2];
  }
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2];
 }
 global$0 = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}
function tflite__MicroInterpreter__Invoke_28_29($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = global$0 - 48 | 0;
 global$0 = $1;
 HEAP32[$1 + 40 >> 2] = $0;
 $0 = HEAP32[$1 + 40 >> 2];
 label$1 : {
  if (HEAP32[$0 + 112 >> 2]) {
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$0 + 12 >> 2], 129242, 0);
   HEAP32[$1 + 44 >> 2] = 1;
   break label$1;
  }
  if (!(HEAP8[$0 + 108 | 0] & 1)) {
   HEAP32[$1 + 36 >> 2] = tflite__MicroInterpreter__AllocateTensors_28_29($0);
   if (HEAP32[$1 + 36 >> 2]) {
    HEAP32[$1 + 44 >> 2] = HEAP32[$1 + 36 >> 2];
    break label$1;
   }
  }
  HEAP32[$1 + 32 >> 2] = 0;
  while (1) {
   if (HEAPU32[$1 + 32 >> 2] < flatbuffers__Vector_int___size_28_29_20const(tflite__SubGraph__operators_28_29_20const(HEAP32[$0 + 116 >> 2])) >>> 0) {
    HEAP32[$1 + 28 >> 2] = HEAP32[$0 >> 2] + Math_imul(HEAP32[$1 + 32 >> 2], 28);
    HEAP32[$1 + 24 >> 2] = HEAP32[(HEAP32[$0 >> 2] + Math_imul(HEAP32[$1 + 32 >> 2], 28) | 0) + 24 >> 2];
    if (HEAP32[HEAP32[$1 + 24 >> 2] + 12 >> 2]) {
     HEAP32[$1 + 20 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$1 + 24 >> 2] + 12 >> 2]]($0 + 16 | 0, HEAP32[$1 + 28 >> 2]);
     $2 = HEAP32[$0 + 104 >> 2];
     FUNCTION_TABLE[HEAP32[HEAP32[$2 >> 2] + 8 >> 2]]($2);
     if (HEAP32[$1 + 20 >> 2] == 1) {
      $0 = HEAP32[$0 + 12 >> 2];
      $2 = tflite___28anonymous_20namespace_29__OpNameFromRegistration_28TfLiteRegistration_20const__29(HEAP32[$1 + 24 >> 2]);
      $3 = HEAP32[$1 + 32 >> 2];
      HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 20 >> 2];
      HEAP32[$1 + 4 >> 2] = $3;
      HEAP32[$1 >> 2] = $2;
      tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 129287, $1);
      HEAP32[$1 + 44 >> 2] = 1;
      break label$1;
     }
     if (HEAP32[$1 + 20 >> 2]) {
      HEAP32[$1 + 44 >> 2] = HEAP32[$1 + 20 >> 2];
      break label$1;
     }
    }
    HEAP32[$1 + 32 >> 2] = HEAP32[$1 + 32 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$1 + 44 >> 2] = 0;
 }
 global$0 = $1 + 48 | 0;
 return HEAP32[$1 + 44 >> 2];
}
function jswrap_object_getOwnPropertyDescriptor($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 label$1 : {
  if (!(jswrap_object_hasOwnProperty(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]) & 1)) {
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 32 >> 2] = jsvAsArrayIndex(HEAP32[$2 + 36 >> 2]);
  HEAP32[$2 + 28 >> 2] = jspGetVarNamedField(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 32 >> 2], 1);
  jsvUnLock(HEAP32[$2 + 32 >> 2]);
  if (!HEAP32[$2 + 28 >> 2]) {
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 24 >> 2] = jsvNewWithFlags(5);
  if (!HEAP32[$2 + 24 >> 2]) {
   jsvUnLock(HEAP32[$2 + 28 >> 2]);
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP8[$2 + 23 | 0] = jsvIsNewChild(HEAP32[$2 + 28 >> 2]) & 1;
  HEAP32[$2 + 16 >> 2] = jsvGetInternalFunctionCheckerFor(HEAP32[$2 + 40 >> 2]);
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 123350, jsvNewFromBool(1));
  $0 = HEAP32[$2 + 24 >> 2];
  if (HEAP32[$2 + 16 >> 2]) {
   $1 = FUNCTION_TABLE[HEAP32[$2 + 16 >> 2]](HEAP32[$2 + 28 >> 2]) ^ -1;
  } else {
   $1 = 1;
  }
  jsvObjectSetChildAndUnLock($0, 123359, jsvNewFromBool($1 & 1));
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 123370, jsvNewFromBool((HEAPU8[$2 + 23 | 0] ^ -1) & 1));
  HEAP32[$2 + 12 >> 2] = jsvGetValueOfName(HEAP32[$2 + 28 >> 2]);
  label$7 : {
   if (jsvIsGetterOrSetter(HEAP32[$2 + 12 >> 2]) & 1) {
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 123383, jsvObjectGetChild(HEAP32[$2 + 12 >> 2], 123383, 0));
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 123387, jsvObjectGetChild(HEAP32[$2 + 12 >> 2], 123387, 0));
    break label$7;
   }
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 123391, jsvSkipName(HEAP32[$2 + 28 >> 2]));
  }
  jsvUnLock(HEAP32[$2 + 12 >> 2]);
  jsvUnLock(HEAP32[$2 + 28 >> 2]);
  HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 24 >> 2];
 }
 global$0 = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}
function _jswrap_interface_setTimeoutOrInterval($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $4 = global$0 + -64 | 0;
 global$0 = $4;
 HEAP32[$4 + 56 >> 2] = $0;
 HEAPF64[$4 + 48 >> 3] = $1;
 HEAP32[$4 + 44 >> 2] = $2;
 HEAP8[$4 + 43 | 0] = $3;
 label$1 : {
  label$2 : {
   if (jsvIsFunction(HEAP32[$4 + 56 >> 2]) & 1) {
    break label$2;
   }
   if (jsvIsString(HEAP32[$4 + 56 >> 2]) & 1) {
    break label$2;
   }
   jsExceptionHere(1, 121608, 0);
   HEAP32[$4 + 60 >> 2] = 0;
   break label$1;
  }
  $0 = __DOUBLE_BITS(HEAPF64[$4 + 48 >> 3]);
  $2 = i64toi32_i32$HIGH_BITS & 2147483647;
  if (!(HEAPF64[$4 + 48 >> 3] < .1 ? 0 : ($2 | 0) == 2146435072 & $0 >>> 0 <= 0 | $2 >>> 0 < 2146435072)) {
   HEAPF64[$4 + 48 >> 3] = .1;
  }
  if (HEAPF64[$4 + 48 >> 3] > 31536000001e3) {
   jsExceptionHere(1, 121641, 0);
   HEAP32[$4 + 60 >> 2] = 0;
   break label$1;
  }
  HEAP32[$4 + 36 >> 2] = jsvNewWithFlags(5);
  HEAP32[$4 + 24 >> 2] = jshGetTimeFromMilliseconds(HEAPF64[$4 + 48 >> 3]);
  HEAP32[$4 + 28 >> 2] = i64toi32_i32$HIGH_BITS;
  $6 = HEAP32[$4 + 36 >> 2];
  $0 = jshGetSystemTime();
  $3 = HEAP32[80572];
  $5 = HEAP32[$4 + 24 >> 2];
  $2 = ($0 - $3 | 0) + $5 | 0;
  $0 = HEAP32[$4 + 28 >> 2] + (i64toi32_i32$HIGH_BITS - (HEAP32[80573] + ($0 >>> 0 < $3 >>> 0) | 0) | 0) | 0;
  jsvObjectSetChildAndUnLock($6, 121675, jsvNewFromLongInteger($2, $2 >>> 0 < $5 >>> 0 ? $0 + 1 | 0 : $0));
  if (!(HEAP8[$4 + 43 | 0] & 1)) {
   jsvObjectSetChildAndUnLock(HEAP32[$4 + 36 >> 2], 121680, jsvNewFromLongInteger(HEAP32[$4 + 24 >> 2], HEAP32[$4 + 28 >> 2]));
  }
  jsvObjectSetChild(HEAP32[$4 + 36 >> 2], 121689, HEAP32[$4 + 56 >> 2]);
  if (jsvGetArrayLength(HEAP32[$4 + 44 >> 2])) {
   jsvObjectSetChild(HEAP32[$4 + 36 >> 2], 121698, HEAP32[$4 + 44 >> 2]);
  }
  HEAP32[$4 + 20 >> 2] = jsvNewFromInteger(jsiTimerAdd(HEAP32[$4 + 36 >> 2]));
  jsvUnLock(HEAP32[$4 + 36 >> 2]);
  jsiTimersChanged();
  HEAP32[$4 + 60 >> 2] = HEAP32[$4 + 20 >> 2];
 }
 global$0 = $4 - -64 | 0;
 return HEAP32[$4 + 60 >> 2];
}
function expf($0) {
 var $1 = 0, $2 = Math_fround(0), $3 = Math_fround(0), $4 = 0, $5 = 0, $6 = Math_fround(0), $7 = Math_fround(0);
 $4 = (wasm2js_scratch_store_f32($0), wasm2js_scratch_load_i32(0));
 $5 = $4 >>> 31;
 label$1 : {
  label$2 : {
   label$3 : {
    label$4 : {
     $3 = $0;
     label$5 : {
      label$6 : {
       $1 = $4 & 2147483647;
       label$7 : {
        if ($1 >>> 0 >= 1118743632) {
         if ($1 >>> 0 > 2139095040) {
          return $0;
         }
         if (!(($4 | 0) < 0 | $1 >>> 0 < 1118925336)) {
          return Math_fround($0 * Math_fround(1.7014118346046923e+38));
         }
         if ($1 >>> 0 <= 1120924084 | ($4 | 0) > -1) {
          break label$7;
         }
         break label$2;
        }
        if ($1 >>> 0 < 1051816473) {
         break label$4;
        }
        if ($1 >>> 0 < 1065686419) {
         break label$6;
        }
       }
       $0 = Math_fround(Math_fround($0 * Math_fround(1.4426950216293335)) + HEAPF32[($5 << 2) + 141648 >> 2]);
       if (Math_fround(Math_abs($0)) < Math_fround(2147483648)) {
        $1 = ~~$0;
        break label$5;
       }
       $1 = -2147483648;
       break label$5;
      }
      $1 = ($5 ^ 1) - $5 | 0;
     }
     $2 = Math_fround($1 | 0);
     $0 = Math_fround($3 + Math_fround($2 * Math_fround(-.693145751953125)));
     $6 = Math_fround($2 * Math_fround(1428606765330187e-21));
     $3 = Math_fround($0 - $6);
     break label$3;
    }
    if ($1 >>> 0 <= 956301312) {
     break label$1;
    }
    $1 = 0;
    $3 = $0;
   }
   $2 = $3;
   $7 = $0;
   $2 = Math_fround($2 * $2);
   $0 = Math_fround($3 - Math_fround($2 * Math_fround(Math_fround($2 * Math_fround(-.0027667332906275988)) + Math_fround(.16666625440120697))));
   $2 = Math_fround(Math_fround($7 + Math_fround(Math_fround(Math_fround($3 * $0) / Math_fround(Math_fround(2) - $0)) - $6)) + Math_fround(1));
   if (!$1) {
    break label$2;
   }
   $2 = scalbnf($2, $1);
  }
  return $2;
 }
 return Math_fround($0 + Math_fround(1));
}
function jsvFindChildFromString($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP8[$3 + 19 | 0] = $2;
 HEAP8[$3 + 15 | 0] = HEAPU8[HEAP32[$3 + 20 >> 2]];
 label$1 : {
  if (HEAPU8[HEAP32[$3 + 20 >> 2]]) {
   HEAP8[$3 + 16 | 0] = HEAPU8[HEAP32[$3 + 20 >> 2] + 1 | 0];
   label$3 : {
    if (HEAPU8[HEAP32[$3 + 20 >> 2] + 1 | 0]) {
     HEAP8[$3 + 17 | 0] = HEAPU8[HEAP32[$3 + 20 >> 2] + 2 | 0];
     label$5 : {
      if (HEAPU8[HEAP32[$3 + 20 >> 2] + 2 | 0]) {
       HEAP8[$3 + 18 | 0] = HEAPU8[HEAP32[$3 + 20 >> 2] + 3 | 0];
       break label$5;
      }
      HEAP8[$3 + 18 | 0] = 0;
     }
     break label$3;
    }
    HEAP8[$3 + 17 | 0] = 0;
    HEAP8[$3 + 18 | 0] = 0;
   }
   break label$1;
  }
  HEAP8[$3 + 16 | 0] = 0;
  HEAP8[$3 + 17 | 0] = 0;
  HEAP8[$3 + 18 | 0] = 0;
 }
 HEAP16[$3 + 12 >> 1] = jsvGetFirstChild(HEAP32[$3 + 24 >> 2]);
 label$7 : {
  while (1) {
   if (HEAPU16[$3 + 12 >> 1]) {
    HEAP32[$3 + 8 >> 2] = jsvGetAddressOf(HEAPU16[$3 + 12 >> 1]);
    label$10 : {
     $0 = HEAP32[$3 + 8 >> 2];
     if ((HEAPU8[$3 + 15 | 0] | HEAPU8[$3 + 16 | 0] << 8 | (HEAPU8[$3 + 17 | 0] << 16 | HEAPU8[$3 + 18 | 0] << 24)) != (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24))) {
      break label$10;
     }
     if (!(jsvIsStringEqual(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 20 >> 2]) & 1)) {
      break label$10;
     }
     HEAP32[$3 + 28 >> 2] = jsvLockAgain(HEAP32[$3 + 8 >> 2]);
     break label$7;
    }
    HEAP16[$3 + 12 >> 1] = jsvGetNextSibling(HEAP32[$3 + 8 >> 2]);
    continue;
   }
   break;
  }
  HEAP32[$3 + 4 >> 2] = 0;
  if (HEAP8[$3 + 19 | 0] & 1) {
   HEAP32[$3 + 4 >> 2] = jsvMakeIntoVariableName(jsvNewFromString(HEAP32[$3 + 20 >> 2]), 0);
   if (HEAP32[$3 + 4 >> 2]) {
    jsvAddName(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 4 >> 2]);
   }
  }
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 4 >> 2];
 }
 global$0 = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}
function jstStartSignal($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0;
 $8 = global$0 + -64 | 0;
 global$0 = $8;
 HEAP32[$8 + 48 >> 2] = $0;
 HEAP32[$8 + 52 >> 2] = $1;
 HEAP32[$8 + 40 >> 2] = $2;
 HEAP32[$8 + 44 >> 2] = $3;
 HEAP8[$8 + 39 | 0] = $4;
 HEAP32[$8 + 32 >> 2] = $5;
 HEAP32[$8 + 28 >> 2] = $6;
 HEAP8[$8 + 27 | 0] = $7;
 label$1 : {
  if (!(jshIsPinValid(HEAPU8[$8 + 39 | 0]) & 1)) {
   HEAP8[$8 + 63 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$8 + 40 >> 2];
  HEAP8[$8 + 4 | 0] = $0;
  HEAP8[$8 + 5 | 0] = $0 >>> 8;
  HEAP8[$8 + 6 | 0] = $0 >>> 16;
  HEAP8[$8 + 7 | 0] = $0 >>> 24;
  $2 = HEAP32[$8 + 48 >> 2] + HEAP32[$8 + 40 >> 2] | 0;
  $1 = $2;
  HEAP8[$8 | 0] = $1;
  HEAP8[$8 + 1 | 0] = $1 >>> 8;
  HEAP8[$8 + 2 | 0] = $1 >>> 16;
  HEAP8[$8 + 3 | 0] = $1 >>> 24;
  HEAP8[$8 + 24 | 0] = HEAPU8[$8 + 27 | 0];
  label$3 : {
   if (!(HEAPU8[$8 + 27 | 0] != 5 ? HEAPU8[$8 + 27 | 0] != 3 : 0)) {
    HEAP8[(global$0 - 16 | 0) + 15 | 0] = HEAPU8[$8 + 39 | 0];
    HEAP8[$8 + 22 | 0] = 0;
    HEAP8[$8 + 23 | 0] = 0;
    if (!(HEAPU8[$8 + 22 | 0] | HEAPU8[$8 + 23 | 0] << 8)) {
     HEAP8[$8 + 63 | 0] = 0;
     break label$1;
    }
    break label$3;
   }
   label$7 : {
    if (!(HEAPU8[$8 + 27 | 0] != 6 ? HEAPU8[$8 + 27 | 0] != 4 : 0)) {
     if (!HEAPU8[(Math_imul(HEAPU8[$8 + 39 | 0], 3) + 109872 | 0) + 2 | 0]) {
      HEAP8[$8 + 63 | 0] = 0;
      break label$1;
     }
     HEAP8[$8 + 22 | 0] = HEAPU8[$8 + 39 | 0];
     break label$7;
    }
    HEAP8[$8 + 63 | 0] = 0;
    break label$1;
   }
  }
  $0 = jsvGetRef(HEAP32[$8 + 32 >> 2]);
  HEAP8[$8 + 12 | 0] = $0;
  HEAP8[$8 + 13 | 0] = $0 >>> 8;
  label$11 : {
   if (HEAP32[$8 + 28 >> 2]) {
    $0 = jsvGetRef(HEAP32[$8 + 28 >> 2]);
    HEAP8[$8 + 14 | 0] = $0;
    HEAP8[$8 + 15 | 0] = $0 >>> 8;
    break label$11;
   }
   HEAP8[$8 + 14 | 0] = 0;
   HEAP8[$8 + 15 | 0] = 0;
  }
  jstUtilTimerSetupBuffer($8);
  HEAP8[$8 + 63 | 0] = utilTimerInsertTask($8) & 1;
 }
 global$0 = $8 - -64 | 0;
 return HEAP8[$8 + 63 | 0] & 1;
}
function tflite__ops__micro__reshape__Prepare_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = global$0 - 96 | 0;
 global$0 = $2;
 HEAP32[$2 + 88 >> 2] = $0;
 HEAP32[$2 + 84 >> 2] = $1;
 label$1 : {
  label$2 : {
   if ((tflite__NumInputs_28TfLiteNode_20const__29(HEAP32[$2 + 84 >> 2]) | 0) == 1) {
    break label$2;
   }
   if ((tflite__NumInputs_28TfLiteNode_20const__29(HEAP32[$2 + 84 >> 2]) | 0) == 2) {
    break label$2;
   }
   $0 = HEAP32[HEAP32[$2 + 88 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 88 >> 2];
   HEAP32[$2 + 72 >> 2] = 136343;
   HEAP32[$2 + 68 >> 2] = 73;
   HEAP32[$2 + 64 >> 2] = 136130;
   FUNCTION_TABLE[$0]($1, 136320, $2 - -64 | 0);
   HEAP32[$2 + 92 >> 2] = 1;
   break label$1;
  }
  if ((tflite__NumOutputs_28TfLiteNode_20const__29(HEAP32[$2 + 84 >> 2]) | 0) != 1) {
   $0 = HEAP32[HEAP32[$2 + 88 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 88 >> 2];
   $3 = tflite__NumOutputs_28TfLiteNode_20const__29(HEAP32[$2 + 84 >> 2]);
   HEAP32[$2 + 20 >> 2] = 1;
   HEAP32[$2 + 16 >> 2] = $3;
   HEAP32[$2 + 12 >> 2] = 136405;
   HEAP32[$2 + 8 >> 2] = 136388;
   HEAP32[$2 + 4 >> 2] = 74;
   HEAP32[$2 >> 2] = 136130;
   FUNCTION_TABLE[$0]($1, 136104, $2);
   HEAP32[$2 + 92 >> 2] = 1;
   break label$1;
  }
  if (tflite__ops__micro__reshape__ReshapeOutput_28TfLiteContext__2c_20TfLiteNode__29(HEAP32[$2 + 88 >> 2], HEAP32[$2 + 84 >> 2])) {
   $0 = HEAP32[HEAP32[$2 + 88 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 88 >> 2];
   $3 = tflite__ops__micro__reshape__ReshapeOutput_28TfLiteContext__2c_20TfLiteNode__29(HEAP32[$2 + 88 >> 2], HEAP32[$2 + 84 >> 2]);
   HEAP32[$2 + 52 >> 2] = 0;
   HEAP32[$2 + 48 >> 2] = $3;
   HEAP32[$2 + 44 >> 2] = 136436;
   HEAP32[$2 + 40 >> 2] = 136407;
   HEAP32[$2 + 36 >> 2] = 75;
   HEAP32[$2 + 32 >> 2] = 136130;
   FUNCTION_TABLE[$0]($1, 136104, $2 + 32 | 0);
   HEAP32[$2 + 92 >> 2] = 1;
   break label$1;
  }
  HEAP32[$2 + 92 >> 2] = 0;
 }
 global$0 = $2 + 96 | 0;
 return HEAP32[$2 + 92 >> 2];
}
function jswrap_banglejs_buzz($0, $1) {
 $0 = $0 | 0;
 $1 = +$1;
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAPF64[$2 + 32 >> 3] = $1;
 $3 = __DOUBLE_BITS(HEAPF64[$2 + 32 >> 3]);
 $0 = i64toi32_i32$HIGH_BITS & 2147483647;
 if (!(HEAPF64[$2 + 32 >> 3] > 1 ? 0 : !(($0 | 0) == 2146435072 & $3 >>> 0 >= 0 | $0 >>> 0 > 2146435072))) {
  HEAPF64[$2 + 32 >> 3] = 1;
 }
 if (HEAPF64[$2 + 32 >> 3] < 0) {
  HEAPF64[$2 + 32 >> 3] = 0;
 }
 if (HEAP32[$2 + 40 >> 2] <= 0) {
  HEAP32[$2 + 40 >> 2] = 200;
 }
 if (HEAP32[$2 + 40 >> 2] > 5e3) {
  HEAP32[$2 + 40 >> 2] = 5e3;
 }
 label$7 : {
  if (HEAP32[84191]) {
   HEAP32[$2 + 28 >> 2] = jsvNewNativeFunction(138, 417);
   HEAP32[$2 + 24 >> 2] = jsvNewFromInteger(HEAP32[$2 + 40 >> 2]);
   jsvAddFunctionParameter(HEAP32[$2 + 28 >> 2], 0, HEAP32[$2 + 24 >> 2]);
   jsvUnLock(HEAP32[$2 + 24 >> 2]);
   HEAP32[$2 + 24 >> 2] = jsvNewFromFloat(HEAPF64[$2 + 32 >> 3]);
   jsvAddFunctionParameter(HEAP32[$2 + 28 >> 2], 0, HEAP32[$2 + 24 >> 2]);
   jsvUnLock(HEAP32[$2 + 24 >> 2]);
   HEAP32[$2 + 20 >> 2] = jswrap_promise_then(HEAP32[84191], HEAP32[$2 + 28 >> 2], 0);
   jsvUnLock(HEAP32[$2 + 28 >> 2]);
   HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 20 >> 2];
   break label$7;
  }
  HEAP32[84191] = jspromise_create();
  if (!HEAP32[84191]) {
   HEAP32[$2 + 44 >> 2] = 0;
   break label$7;
  }
  if (HEAP32[84152] & 256) {
   $1 = HEAPF64[$2 + 32 >> 3] * 255;
   label$11 : {
    if ($1 < 4294967296 & $1 >= 0) {
     $0 = ~~$1 >>> 0;
     break label$11;
    }
    $0 = 0;
   }
   HEAP8[336740] = $0;
   _jswrap_banglejs_setVibration();
  }
  $0 = jshGetSystemTime();
  $3 = i64toi32_i32$HIGH_BITS;
  $4 = $0;
  $0 = jshGetTimeFromMilliseconds(+HEAP32[$2 + 40 >> 2]);
  $4 = $4 + $0 | 0;
  $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
  jstExecuteFn(556, $4, $4 >>> 0 < $0 >>> 0 ? $3 + 1 | 0 : $3);
  HEAP32[$2 + 44 >> 2] = jsvLockAgain(HEAP32[84191]);
 }
 global$0 = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}
function jswrap_interface_edit($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 HEAP32[$1 + 24 >> 2] = 0;
 label$1 : {
  if (jsvIsString(HEAP32[$1 + 28 >> 2]) & 1) {
   HEAP32[$1 + 28 >> 2] = jsvLockAgain(HEAP32[$1 + 28 >> 2]);
   HEAP32[$1 + 24 >> 2] = jsvSkipNameAndUnLock(jsvFindChildFromVar(HEAP32[80545], HEAP32[$1 + 28 >> 2], 0));
   break label$1;
  }
  HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 28 >> 2];
  HEAP32[$1 + 28 >> 2] = jsvGetPathTo(HEAP32[80545], HEAP32[$1 + 24 >> 2], 0);
 }
 label$3 : {
  if (jsvIsString(HEAP32[$1 + 28 >> 2]) & 1) {
   if (jsvIsFunction(HEAP32[$1 + 24 >> 2]) & 1) {
    HEAP32[$1 + 20 >> 2] = jsvFindChildFromString(HEAP32[$1 + 24 >> 2], 121462, 0);
    HEAP32[$1 + 16 >> 2] = jsvGetIndexOf(HEAP32[80545], HEAP32[$1 + 24 >> 2], 1);
    HEAP8[$1 + 15 | 0] = HEAP32[$1 + 20 >> 2] ? 0 : HEAP32[$1 + 16 >> 2] != 0;
    jsvUnLock2(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 20 >> 2]);
    HEAP32[$1 + 8 >> 2] = jsvNewWithFlags(27);
    if (HEAP32[$1 + 8 >> 2]) {
     HEAP32[$1 + 4 >> 2] = jsvAsString(HEAP32[$1 + 24 >> 2]);
     label$9 : {
      if (HEAP8[$1 + 15 | 0] & 1) {
       jsvAppendString(HEAP32[$1 + 8 >> 2], 121467);
       jsvAppendStringVarComplete(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 28 >> 2]);
       jsvAppendStringVar(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 4 >> 2], 9, 2147483647);
       break label$9;
      }
      jsvAppendStringVarComplete(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 28 >> 2]);
      jsvAppendString(HEAP32[$1 + 8 >> 2], 121477);
      jsvAppendStringVarComplete(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 4 >> 2]);
      jsvAppendString(HEAP32[$1 + 8 >> 2], 121491);
     }
     jsvUnLock(HEAP32[$1 + 4 >> 2]);
     jsiReplaceInputLine(HEAP32[$1 + 8 >> 2]);
     jsvUnLock(HEAP32[$1 + 8 >> 2]);
    }
    break label$3;
   }
   jsExceptionHere(1, 121494, 0);
   break label$3;
  }
  jsExceptionHere(1, 121544, 0);
 }
 jsvUnLock2(HEAP32[$1 + 24 >> 2], HEAP32[$1 + 28 >> 2]);
 global$0 = $1 + 32 | 0;
}
function _jswrap_array_sort($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 160 | 0;
 global$0 = $3;
 HEAP32[$3 + 156 >> 2] = $0;
 HEAP32[$3 + 152 >> 2] = $1;
 HEAP32[$3 + 148 >> 2] = $2;
 label$1 : {
  if (HEAP32[$3 + 152 >> 2] < 2) {
   break label$1;
  }
  $0 = $3 + 8 | 0;
  $1 = $3 + 88 | 0;
  jsvIteratorClone($1, HEAP32[$3 + 156 >> 2]);
  HEAP8[$3 + 87 | 0] = 1;
  HEAP32[$3 + 80 >> 2] = jsvIteratorGetValue($1);
  HEAP32[$3 + 76 >> 2] = 0;
  HEAP32[$3 + 72 >> 2] = 0;
  jsvIteratorClone($0, HEAP32[$3 + 156 >> 2]);
  jsvIteratorNext($0);
  while (1) {
   $0 = HEAP32[$3 + 152 >> 2] + -1 | 0;
   HEAP32[$3 + 152 >> 2] = $0;
   if ($0) {
    $0 = jspIsInterrupted() ^ -1;
   } else {
    $0 = 0;
   }
   if ($0 & 1) {
    HEAP32[$3 + 4 >> 2] = jsvIteratorGetValue($3 + 8 | 0);
    HEAP32[$3 >> 2] = _jswrap_array_sort_compare(HEAP32[$3 + 4 >> 2], HEAP32[$3 + 80 >> 2], HEAP32[$3 + 148 >> 2]);
    label$6 : {
     if (HEAP32[$3 >> 2] <= 0) {
      if (HEAP32[$3 >> 2] < 0) {
       HEAP8[$3 + 87 | 0] = 0;
      }
      $1 = $3 + 8 | 0;
      HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 76 >> 2] + 1;
      $0 = $3 + 88 | 0;
      jsvIteratorSetValue($0, HEAP32[$3 + 4 >> 2]);
      jsvIteratorNext($0);
      jsvUnLock(jsvIteratorSetValue($1, jsvIteratorGetValue($0)));
      jsvIteratorSetValue($0, HEAP32[$3 + 80 >> 2]);
      break label$6;
     }
     HEAP32[$3 + 72 >> 2] = HEAP32[$3 + 72 >> 2] + 1;
    }
    $0 = $3 + 8 | 0;
    jsvUnLock(HEAP32[$3 + 4 >> 2]);
    jsvIteratorNext($0);
    continue;
   }
   break;
  }
  jsvIteratorFree($3 + 8 | 0);
  jsvUnLock(HEAP32[$3 + 80 >> 2]);
  if (jspIsInterrupted() & 1) {
   jsvIteratorFree($3 + 88 | 0);
   break label$1;
  }
  $0 = $3 + 88 | 0;
  jsvIteratorNext($0);
  _jswrap_array_sort($0, HEAP32[$3 + 72 >> 2], HEAP32[$3 + 148 >> 2]);
  jsvIteratorFree($0);
  if (HEAP8[$3 + 87 | 0] & 1) {
   break label$1;
  }
  _jswrap_array_sort(HEAP32[$3 + 156 >> 2], HEAP32[$3 + 76 >> 2], HEAP32[$3 + 148 >> 2]);
 }
 global$0 = $3 + 160 | 0;
}
function jsvIsStringNumericInt($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 80 | 0;
 global$0 = $2;
 HEAP32[$2 + 72 >> 2] = $0;
 HEAP8[$2 + 71 | 0] = $1;
 jsvStringIteratorNew($2 + 32 | 0, HEAP32[$2 + 72 >> 2], 0);
 while (1) {
  if (jsvStringIteratorHasChar($2 + 32 | 0) & 1) {
   $0 = isWhitespace(jsvStringIteratorGetChar($2 + 32 | 0) << 24 >> 24);
  } else {
   $0 = 0;
  }
  if ($0 & 1) {
   jsvStringIteratorNext($2 + 32 | 0);
   continue;
  }
  break;
 }
 label$5 : {
  if ((jsvStringIteratorGetChar($2 + 32 | 0) & 255) != 45) {
   if ((jsvStringIteratorGetChar($2 + 32 | 0) & 255) != 43) {
    break label$5;
   }
  }
  jsvStringIteratorNext($2 + 32 | 0);
 }
 HEAP32[$2 + 28 >> 2] = 0;
 if ((jsvStringIteratorGetChar($2 + 32 | 0) & 255) == 48) {
  $0 = $2 + 25 | 0;
  $1 = $2 + 20 | 0;
  $3 = $2 + 32 | 0;
  jsvStringIteratorNext($3);
  HEAP8[$2 + 25 | 0] = 48;
  HEAP8[$2 + 26 | 0] = jsvStringIteratorGetChar($3);
  HEAP8[$2 + 27 | 0] = 0;
  HEAP32[$2 + 20 >> 2] = $0;
  HEAP32[$2 + 28 >> 2] = getRadix($1, 0);
  if (HEAPU32[$2 + 20 >> 2] > $0 + 1 >>> 0) {
   jsvStringIteratorNext($2 + 32 | 0);
  }
 }
 if (!HEAP32[$2 + 28 >> 2]) {
  HEAP32[$2 + 28 >> 2] = 10;
 }
 HEAP32[$2 + 16 >> 2] = 0;
 label$10 : {
  while (1) {
   if (jsvStringIteratorHasChar($2 + 32 | 0) & 1) {
    HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 16 >> 2] + 1;
    HEAP8[$2 + 15 | 0] = jsvStringIteratorGetCharAndNext($2 + 32 | 0);
    label$13 : {
     if (!(!(HEAP8[$2 + 71 | 0] & 1) | HEAP8[$2 + 15 | 0] != 46)) {
      HEAP8[$2 + 71 | 0] = 0;
      break label$13;
     }
     HEAP32[$2 + 8 >> 2] = chtod(HEAP8[$2 + 15 | 0]);
     if (!(HEAP32[$2 + 8 >> 2] < HEAP32[$2 + 28 >> 2] ? HEAP32[$2 + 8 >> 2] >= 0 : 0)) {
      jsvStringIteratorFree($2 + 32 | 0);
      HEAP8[$2 + 79 | 0] = 0;
      break label$10;
     }
    }
    continue;
   }
   break;
  }
  jsvStringIteratorFree($2 + 32 | 0);
  HEAP8[$2 + 79 | 0] = HEAP32[$2 + 16 >> 2] > 0;
 }
 global$0 = $2 + 80 | 0;
 return HEAP8[$2 + 79 | 0] & 1;
}
function jswrap_waveform_constructor($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 label$1 : {
  if (HEAP32[$2 + 40 >> 2] <= 0) {
   jsExceptionHere(1, 126142, 0);
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP8[$2 + 35 | 0] = 0;
  HEAP8[$2 + 34 | 0] = 0;
  label$3 : {
   if (jsvIsObject(HEAP32[$2 + 36 >> 2]) & 1) {
    HEAP8[$2 + 35 | 0] = jsvGetBoolAndUnLock(jsvObjectGetChild(HEAP32[$2 + 36 >> 2], 126173, 0)) & 1;
    HEAP32[$2 + 28 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$2 + 36 >> 2], 126186, 0));
    if (!(!HEAP32[$2 + 28 >> 2] | HEAP32[$2 + 28 >> 2] == 8 | HEAP32[$2 + 28 >> 2] == 16)) {
     jsExceptionHere(1, 126191, 0);
     HEAP32[$2 + 44 >> 2] = 0;
     break label$1;
    }
    if (HEAP32[$2 + 28 >> 2] == 16) {
     HEAP8[$2 + 34 | 0] = 1;
    }
    break label$3;
   }
   if (!(jsvIsUndefined(HEAP32[$2 + 36 >> 2]) & 1)) {
    HEAP32[$2 >> 2] = HEAP32[$2 + 36 >> 2];
    jsExceptionHere(1, 126214, $2);
   }
  }
  HEAP16[$2 + 26 >> 1] = HEAP8[$2 + 34 | 0] & 1 ? 2 : 1;
  HEAP32[$2 + 20 >> 2] = jsvNewTypedArray(HEAPU16[$2 + 26 >> 1], HEAP32[$2 + 40 >> 2]);
  HEAP32[$2 + 16 >> 2] = 0;
  if (HEAP8[$2 + 35 | 0] & 1) {
   HEAP32[$2 + 16 >> 2] = jsvNewTypedArray(HEAPU16[$2 + 26 >> 1], HEAP32[$2 + 40 >> 2]);
  }
  HEAP32[$2 + 12 >> 2] = jspNewObject(0, 126269);
  if (!(HEAP32[$2 + 16 >> 2] | !(HEAP8[$2 + 35 | 0] & 1) ? !(!HEAP32[$2 + 12 >> 2] | !HEAP32[$2 + 20 >> 2]) : 0)) {
   jsvUnLock3(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2]);
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 12 >> 2], 126064, HEAP32[$2 + 20 >> 2]);
  if (HEAP32[$2 + 16 >> 2]) {
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 12 >> 2], 126095, HEAP32[$2 + 16 >> 2]);
  }
  HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 12 >> 2];
 }
 global$0 = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}
function jswBinarySearch($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP32[$3 + 40 >> 2] = $0;
 HEAP32[$3 + 36 >> 2] = $1;
 HEAP32[$3 + 32 >> 2] = $2;
 HEAP8[$3 + 31 | 0] = HEAPU8[HEAP32[$3 + 40 >> 2] + 8 | 0];
 HEAP32[$3 + 24 >> 2] = 0;
 HEAP32[$3 + 20 >> 2] = HEAPU8[$3 + 31 | 0] - 1;
 label$1 : {
  while (1) {
   if (HEAP32[$3 + 24 >> 2] <= HEAP32[$3 + 20 >> 2]) {
    HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 24 >> 2] + HEAP32[$3 + 20 >> 2] >> 1;
    $0 = HEAP32[$3 + 40 >> 2];
    HEAP32[$3 + 12 >> 2] = (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) + (HEAP32[$3 + 16 >> 2] << 3);
    $0 = HEAP32[$3 + 12 >> 2];
    HEAP16[$3 + 10 >> 1] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8;
    $0 = HEAP32[$3 + 40 >> 2];
    HEAP32[$3 + 4 >> 2] = strcmp(HEAP32[$3 + 32 >> 2], HEAPU16[$3 + 10 >> 1] + (HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24)) | 0);
    if (HEAP32[$3 + 4 >> 2]) {
     if (HEAP32[$3 + 4 >> 2] < 0) {
      HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 16 >> 2] - 1;
      continue;
     }
     HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 16 >> 2] + 1;
     continue;
    } else {
     $0 = HEAP32[$3 + 12 >> 2];
     HEAP16[$3 + 2 >> 1] = HEAPU8[$0 + 2 | 0] | HEAPU8[$0 + 3 | 0] << 8;
     if ((HEAPU16[$3 + 2 >> 1] & 32256) == 28672) {
      $0 = HEAP32[$3 + 12 >> 2];
      HEAP32[$3 + 44 >> 2] = jsnCallFunction(HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24), HEAPU16[$3 + 2 >> 1], HEAP32[$3 + 36 >> 2], 0, 0);
      break label$1;
     }
     $0 = HEAP32[$3 + 12 >> 2];
     HEAP32[$3 + 44 >> 2] = jsvNewNativeFunction(HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24), HEAPU16[$3 + 2 >> 1]);
     break label$1;
    }
   }
   break;
  }
  HEAP32[$3 + 44 >> 2] = 0;
 }
 global$0 = $3 + 48 | 0;
 return HEAP32[$3 + 44 >> 2];
}
function jsfCompactWriteBuffer($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = global$0 - 48 | 0;
 global$0 = $6;
 HEAP32[$6 + 44 >> 2] = $0;
 HEAP32[$6 + 40 >> 2] = $1;
 HEAP32[$6 + 36 >> 2] = $2;
 HEAP32[$6 + 32 >> 2] = $3;
 HEAP32[$6 + 28 >> 2] = $4;
 HEAP32[$6 + 24 >> 2] = $5;
 HEAP32[$6 + 20 >> 2] = jsfGetBankEndAddress(HEAP32[HEAP32[$6 + 44 >> 2] >> 2]);
 HEAP32[$6 + 16 >> 2] = jsfGetAddressOfNextPage(HEAP32[HEAP32[$6 + 44 >> 2] >> 2]);
 if (!HEAP32[$6 + 16 >> 2]) {
  HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 20 >> 2];
 }
 while (1) {
  label$3 : {
   if (!HEAP32[HEAP32[$6 + 28 >> 2] >> 2]) {
    break label$3;
   }
   HEAP32[$6 + 12 >> 2] = HEAP32[HEAP32[$6 + 28 >> 2] >> 2];
   if (HEAP32[$6 + 12 >> 2] + HEAP32[HEAP32[$6 + 24 >> 2] >> 2] >>> 0 > HEAPU32[$6 + 32 >> 2]) {
    HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 32 >> 2] - HEAP32[HEAP32[$6 + 24 >> 2] >> 2];
   }
   if (HEAP32[$6 + 12 >> 2] + HEAP32[HEAP32[$6 + 44 >> 2] >> 2] >>> 0 > HEAPU32[$6 + 16 >> 2]) {
    HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 16 >> 2] - HEAP32[HEAP32[$6 + 44 >> 2] >> 2];
   }
   if (HEAPU32[$6 + 40 >> 2] < HEAPU32[$6 + 16 >> 2]) {
    break label$3;
   }
   if (!(jsfIsErased(HEAP32[HEAP32[$6 + 44 >> 2] >> 2], HEAP32[$6 + 12 >> 2]) & 1)) {
    jshFlashErasePage(HEAP32[HEAP32[$6 + 44 >> 2] >> 2]);
   }
   jshFlashWrite(HEAP32[$6 + 36 >> 2] + HEAP32[HEAP32[$6 + 24 >> 2] >> 2] | 0, HEAP32[HEAP32[$6 + 44 >> 2] >> 2], HEAP32[$6 + 12 >> 2]);
   $0 = HEAP32[$6 + 44 >> 2];
   HEAP32[$0 >> 2] = HEAP32[$6 + 12 >> 2] + HEAP32[$0 >> 2];
   HEAP32[$6 + 16 >> 2] = jsfGetAddressOfNextPage(HEAP32[HEAP32[$6 + 44 >> 2] >> 2]);
   if (!HEAP32[$6 + 16 >> 2]) {
    HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 20 >> 2];
   }
   HEAP32[HEAP32[$6 + 24 >> 2] >> 2] = (HEAP32[HEAP32[$6 + 24 >> 2] >> 2] + HEAP32[$6 + 12 >> 2] >>> 0) % HEAPU32[$6 + 32 >> 2];
   $0 = HEAP32[$6 + 28 >> 2];
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2] - HEAP32[$6 + 12 >> 2];
   continue;
  }
  break;
 }
 global$0 = $6 + 48 | 0;
}
function tflite__ConvertTensorType_28tflite__TensorType_2c_20TfLiteType__2c_20tflite__ErrorReporter__29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 $0 = HEAP32[$3 + 24 >> 2];
 label$1 : {
  if ($0 >>> 0 <= 11) {
   label$3 : {
    switch ($0 - 1 | 0) {
    case 0:
     HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 10;
     HEAP32[$3 + 28 >> 2] = 0;
     break label$1;
    default:
     HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 1;
     HEAP32[$3 + 28 >> 2] = 0;
     break label$1;
    case 9:
     HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 11;
     HEAP32[$3 + 28 >> 2] = 0;
     break label$1;
    case 6:
     HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 7;
     HEAP32[$3 + 28 >> 2] = 0;
     break label$1;
    case 1:
     HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 2;
     HEAP32[$3 + 28 >> 2] = 0;
     break label$1;
    case 2:
     HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 3;
     HEAP32[$3 + 28 >> 2] = 0;
     break label$1;
    case 8:
     HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 9;
     HEAP32[$3 + 28 >> 2] = 0;
     break label$1;
    case 3:
     HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 4;
     HEAP32[$3 + 28 >> 2] = 0;
     break label$1;
    case 4:
     HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 5;
     HEAP32[$3 + 28 >> 2] = 0;
     break label$1;
    case 5:
     HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 6;
     HEAP32[$3 + 28 >> 2] = 0;
     break label$1;
    case 7:
     HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 8;
     HEAP32[$3 + 28 >> 2] = 0;
     break label$1;
    case 10:
     break label$3;
    }
   }
   HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 12;
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 0;
  $0 = HEAP32[$3 + 16 >> 2];
  HEAP32[$3 >> 2] = HEAP32[$3 + 24 >> 2];
  tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 136582, $3);
  HEAP32[$3 + 28 >> 2] = 1;
 }
 global$0 = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}
function mbedtls_sha512_update($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 label$1 : {
  if (!HEAP32[$3 + 20 >> 2]) {
   break label$1;
  }
  $0 = HEAP32[$3 + 28 >> 2];
  $0;
  HEAP32[$3 + 12 >> 2] = HEAP32[$0 >> 2] & 127;
  HEAP32[$3 + 16 >> 2] = 128 - HEAP32[$3 + 12 >> 2];
  $1 = HEAP32[$3 + 28 >> 2];
  $2 = $1;
  $5 = $1;
  $0 = HEAP32[$1 + 4 >> 2];
  $4 = HEAP32[$1 >> 2];
  $1 = HEAP32[$3 + 20 >> 2];
  $4 = $4 + $1 | 0;
  if ($4 >>> 0 < $1 >>> 0) {
   $0 = $0 + 1 | 0;
  }
  HEAP32[$5 >> 2] = $4;
  HEAP32[$2 + 4 >> 2] = $0;
  $0 = HEAP32[$3 + 28 >> 2];
  $1 = HEAP32[$0 >> 2];
  $0 = HEAP32[$0 + 4 >> 2];
  if (!$0 & $1 >>> 0 < HEAPU32[$3 + 20 >> 2] | $0 >>> 0 < 0) {
   $1 = HEAP32[$3 + 28 >> 2];
   $2 = $1;
   $5 = $1;
   $0 = HEAP32[$1 + 12 >> 2];
   $1 = HEAP32[$1 + 8 >> 2] + 1 | 0;
   if ($1 >>> 0 < 1) {
    $0 = $0 + 1 | 0;
   }
   HEAP32[$5 + 8 >> 2] = $1;
   HEAP32[$2 + 12 >> 2] = $0;
  }
  if (!(!HEAP32[$3 + 12 >> 2] | HEAPU32[$3 + 20 >> 2] < HEAPU32[$3 + 16 >> 2])) {
   memcpy(HEAP32[$3 + 12 >> 2] + (HEAP32[$3 + 28 >> 2] + 80 | 0) | 0, HEAP32[$3 + 24 >> 2], HEAP32[$3 + 16 >> 2]);
   mbedtls_sha512_process(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 28 >> 2] + 80 | 0);
   HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 16 >> 2] + HEAP32[$3 + 24 >> 2];
   HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] - HEAP32[$3 + 16 >> 2];
   HEAP32[$3 + 12 >> 2] = 0;
  }
  while (1) {
   if (HEAPU32[$3 + 20 >> 2] >= 128) {
    mbedtls_sha512_process(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2]);
    HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 24 >> 2] + 128;
    HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] - 128;
    continue;
   }
   break;
  }
  if (HEAPU32[$3 + 20 >> 2] <= 0) {
   break label$1;
  }
  memcpy(HEAP32[$3 + 12 >> 2] + (HEAP32[$3 + 28 >> 2] + 80 | 0) | 0, HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
 }
 global$0 = $3 + 32 | 0;
}
function _jswrap_array_reverse_block($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 176 | 0;
 global$0 = $3;
 HEAP32[$3 + 172 >> 2] = $0;
 HEAP32[$3 + 168 >> 2] = $1;
 HEAP32[$3 + 164 >> 2] = $2;
 $0 = $3 + 40 | 0;
 jsvIteratorClone($3 + 104 | 0, HEAP32[$3 + 168 >> 2]);
 jsvIteratorClone($0, HEAP32[$3 + 168 >> 2]);
 HEAP32[$3 + 36 >> 2] = (HEAP32[$3 + 164 >> 2] + 1 | 0) / 2;
 while (1) {
  if (HEAP32[$3 + 36 >> 2] > 0) {
   jsvIteratorNext($3 + 40 | 0);
   HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 36 >> 2] + -1;
   continue;
  }
  break;
 }
 if (HEAP32[$3 + 164 >> 2] > 3) {
  $0 = $3 + 40 | 0;
  _jswrap_array_reverse_block(HEAP32[$3 + 172 >> 2], $3 + 104 | 0, HEAP32[$3 + 164 >> 2] / 2 | 0);
  _jswrap_array_reverse_block(HEAP32[$3 + 172 >> 2], $0, HEAP32[$3 + 164 >> 2] / 2 | 0);
 }
 HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 164 >> 2] / 2;
 while (1) {
  if (HEAP32[$3 + 36 >> 2] > 0) {
   $0 = $3 + 40 | 0;
   $1 = $3 + 104 | 0;
   HEAP32[$3 + 32 >> 2] = jsvIteratorGetValue($1);
   HEAP32[$3 + 28 >> 2] = jsvIteratorGetValue($0);
   jsvIteratorSetValue($1, HEAP32[$3 + 28 >> 2]);
   jsvIteratorSetValue($0, HEAP32[$3 + 32 >> 2]);
   jsvUnLock2(HEAP32[$3 + 32 >> 2], HEAP32[$3 + 28 >> 2]);
   if (jsvIsArray(HEAP32[$3 + 172 >> 2]) & 1) {
    $0 = $3 + 40 | 0;
    HEAP32[$3 + 24 >> 2] = jsvIteratorGetKey($3 + 104 | 0);
    HEAP32[$3 + 20 >> 2] = jsvIteratorGetKey($0);
    HEAP32[$3 + 16 >> 2] = jsvGetInteger(HEAP32[$3 + 24 >> 2]);
    HEAP32[$3 + 12 >> 2] = jsvGetInteger(HEAP32[$3 + 20 >> 2]);
    jsvSetInteger(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 12 >> 2]);
    jsvSetInteger(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 16 >> 2]);
    jsvUnLock2(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
   }
   $0 = $3 + 40 | 0;
   jsvIteratorNext($3 + 104 | 0);
   jsvIteratorNext($0);
   HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 36 >> 2] + -1;
   continue;
  }
  break;
 }
 $0 = $3 + 40 | 0;
 jsvIteratorFree($3 + 104 | 0);
 jsvIteratorFree($0);
 global$0 = $3 + 176 | 0;
}
function jsiDebuggerLoop() {
 var $0 = 0, $1 = 0, $2 = 0;
 $0 = global$0 - 32 | 0;
 global$0 = $0;
 if (!(HEAPU16[161112] & 10)) {
  HEAP32[80549] = HEAP32[80549] & -63489;
  jsiClearInputLine(1);
  jsiConsoleRemoveInputLine();
  HEAP16[161112] = HEAPU16[161112] & -4 | 8;
  if (HEAP32[35539]) {
   HEAP8[$0 + 23 | 0] = 0;
   HEAP32[$0 + 16 >> 2] = strlen($0 + 23 | 0);
   while (1) {
    if (HEAPU32[$0 + 16 >> 2] < 8) {
     $2 = HEAP32[$0 + 16 >> 2];
     HEAP32[$0 + 16 >> 2] = $2 + 1;
     HEAP8[$2 + ($0 + 23 | 0) | 0] = 32;
     continue;
    }
    break;
   }
   $2 = $0 + 23 | 0;
   HEAP8[$2 + HEAP32[$0 + 16 >> 2] | 0] = 0;
   jslPrintTokenLineMarker(7, 0, HEAP32[HEAP32[35539] + 8 >> 2], $2);
  }
  while (1) {
   if ((HEAPU16[161112] & 16 ? 0 : (HEAP32[80549] & 6144) != 0 ^ -1) & 1) {
    jsiConsoleReturnInputLine();
    jshIdle();
    while (1) {
     $2 = (jshGetEventsUsed() | 0) <= 127;
     $1 = 0;
     label$10 : {
      if ($2) {
       break label$10;
      }
      $1 = 0;
      if (HEAPU16[161112] & 16) {
       break label$10;
      }
      $1 = (HEAP32[80549] & 6144) != 0 ^ -1;
     }
     if ($1 & 1) {
      if (!(jshPopIOEvent($0 + 8 | 0) & 1) | HEAPU8[141672] != (HEAPU8[$0 + 8 | 0] & 31)) {
       continue;
      }
      jsiHandleIOEventForConsole($0 + 8 | 0);
      continue;
     }
     break;
    }
    while (1) {
     $2 = !(jshPopIOEventOfType(HEAPU8[141672], $0 + 8 | 0) & 1);
     $1 = 0;
     label$13 : {
      if ($2) {
       break label$13;
      }
      $1 = 0;
      if (HEAPU16[161112] & 16) {
       break label$13;
      }
      $1 = (HEAP32[80549] & 6144) != 0 ^ -1;
     }
     if ($1 & 1) {
      jsiHandleIOEventForConsole($0 + 8 | 0);
      continue;
     }
     break;
    }
    continue;
   }
   break;
  }
  jsiConsoleRemoveInputLine();
  if (HEAP32[80549] & 6144) {
   HEAP32[80549] = HEAP32[80549] | 16;
  }
  HEAP16[161112] = HEAPU16[161112] & -25;
 }
 global$0 = $0 + 32 | 0;
}
function tflite__MicroInterpreter__output_28unsigned_20long_29($0) {
 var $1 = 0, $2 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0, wasm2js_i32$3 = 0, wasm2js_i32$4 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP32[$1 + 20 >> 2] = 0;
 $0 = HEAP32[$1 + 24 >> 2];
 HEAP32[$1 + 16 >> 2] = tflite__MicroInterpreter__outputs_size_28_29_20const($0);
 label$1 : {
  if (HEAPU32[$1 + 20 >> 2] >= HEAPU32[$1 + 16 >> 2]) {
   $0 = HEAP32[$0 + 12 >> 2];
   $2 = HEAP32[$1 + 20 >> 2];
   HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 16 >> 2];
   HEAP32[$1 >> 2] = $2;
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 129502, $1);
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$1 + 20 >> 2]) {
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$0 + 12 >> 2], 129546, 0);
   $2 = HEAP32[$0 + 104 >> 2];
   HEAP32[$1 + 28 >> 2] = (wasm2js_i32$1 = $2, wasm2js_i32$2 = HEAP32[$0 + 4 >> 2], wasm2js_i32$3 = HEAP32[$0 + 120 >> 2], wasm2js_i32$4 = flatbuffers__Vector_int___Get_28unsigned_20int_29_20const(tflite__MicroInterpreter__outputs_28_29_20const($0), HEAP32[$1 + 20 >> 2]), wasm2js_i32$0 = HEAP32[HEAP32[$2 >> 2] >> 2], FUNCTION_TABLE[wasm2js_i32$0](wasm2js_i32$1 | 0, wasm2js_i32$2 | 0, wasm2js_i32$3 | 0, wasm2js_i32$4 | 0) | 0);
   break label$1;
  }
  if (!HEAP32[$0 + 148 >> 2]) {
   $2 = HEAP32[$0 + 104 >> 2];
   HEAP32[$0 + 148 >> 2] = (wasm2js_i32$4 = $2, wasm2js_i32$3 = HEAP32[$0 + 4 >> 2], wasm2js_i32$2 = HEAP32[$0 + 120 >> 2], wasm2js_i32$1 = flatbuffers__Vector_int___Get_28unsigned_20int_29_20const(tflite__MicroInterpreter__outputs_28_29_20const($0), HEAP32[$1 + 20 >> 2]), wasm2js_i32$0 = HEAP32[HEAP32[$2 >> 2] >> 2], FUNCTION_TABLE[wasm2js_i32$0](wasm2js_i32$4 | 0, wasm2js_i32$3 | 0, wasm2js_i32$2 | 0, wasm2js_i32$1 | 0) | 0);
  }
  HEAP32[$1 + 28 >> 2] = HEAP32[$0 + 148 >> 2];
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function jsvIsStringEqualOrStartsWithOffset($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 80 | 0;
 global$0 = $4;
 HEAP32[$4 + 72 >> 2] = $0;
 HEAP32[$4 + 68 >> 2] = $1;
 HEAP8[$4 + 67 | 0] = $2;
 HEAP32[$4 + 60 >> 2] = 0;
 HEAP8[$4 + 59 | 0] = $3;
 label$1 : {
  if (!(jsvHasCharacterData(HEAP32[$4 + 72 >> 2]) & 1)) {
   HEAP8[$4 + 79 | 0] = 0;
   break label$1;
  }
  jsvStringIteratorNew($4 + 16 | 0, HEAP32[$4 + 72 >> 2], HEAP32[$4 + 60 >> 2]);
  label$3 : {
   if (HEAP8[$4 + 59 | 0] & 1) {
    while (1) {
     $1 = !(jsvStringIteratorHasChar($4 + 16 | 0) & 1);
     $0 = 0;
     label$6 : {
      if ($1) {
       break label$6;
      }
      $0 = 0;
      if (!HEAP8[HEAP32[$4 + 68 >> 2]]) {
       break label$6;
      }
      $0 = (charToLowerCase(jsvStringIteratorGetChar($4 + 16 | 0) << 24 >> 24) & 255) == (charToLowerCase(HEAP8[HEAP32[$4 + 68 >> 2]]) & 255);
     }
     if ($0) {
      HEAP32[$4 + 68 >> 2] = HEAP32[$4 + 68 >> 2] + 1;
      jsvStringIteratorNext($4 + 16 | 0);
      continue;
     }
     break;
    }
    break label$3;
   }
   while (1) {
    $1 = !(jsvStringIteratorHasChar($4 + 16 | 0) & 1);
    $0 = 0;
    label$9 : {
     if ($1) {
      break label$9;
     }
     $0 = 0;
     if (!HEAP8[HEAP32[$4 + 68 >> 2]]) {
      break label$9;
     }
     $0 = (jsvStringIteratorGetChar($4 + 16 | 0) & 255) == HEAPU8[HEAP32[$4 + 68 >> 2]];
    }
    if ($0) {
     HEAP32[$4 + 68 >> 2] = HEAP32[$4 + 68 >> 2] + 1;
     jsvStringIteratorNext($4 + 16 | 0);
     continue;
    }
    break;
   }
  }
  $0 = $4;
  label$11 : {
   if (HEAP8[$4 + 67 | 0] & 1) {
    $1 = 1;
    if (!HEAPU8[HEAP32[$4 + 68 >> 2]]) {
     break label$11;
    }
   }
   $1 = (jsvStringIteratorGetChar($4 + 16 | 0) & 255) == HEAPU8[HEAP32[$4 + 68 >> 2]];
  }
  HEAP8[$0 + 15 | 0] = $1;
  jsvStringIteratorFree($4 + 16 | 0);
  HEAP8[$4 + 79 | 0] = HEAP8[$4 + 15 | 0] & 1;
 }
 global$0 = $4 + 80 | 0;
 return HEAP8[$4 + 79 | 0] & 1;
}
function tflite__MicroInterpreter__input_28unsigned_20long_29($0) {
 var $1 = 0, $2 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0, wasm2js_i32$3 = 0, wasm2js_i32$4 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP32[$1 + 20 >> 2] = 0;
 $0 = HEAP32[$1 + 24 >> 2];
 HEAP32[$1 + 16 >> 2] = tflite__MicroInterpreter__inputs_size_28_29_20const($0);
 label$1 : {
  if (HEAPU32[$1 + 20 >> 2] >= HEAPU32[$1 + 16 >> 2]) {
   $0 = HEAP32[$0 + 12 >> 2];
   $2 = HEAP32[$1 + 20 >> 2];
   HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 16 >> 2];
   HEAP32[$1 >> 2] = $2;
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 129339, $1);
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$1 + 20 >> 2]) {
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$0 + 12 >> 2], 129382, 0);
   $2 = HEAP32[$0 + 104 >> 2];
   HEAP32[$1 + 28 >> 2] = (wasm2js_i32$1 = $2, wasm2js_i32$2 = HEAP32[$0 + 4 >> 2], wasm2js_i32$3 = HEAP32[$0 + 120 >> 2], wasm2js_i32$4 = flatbuffers__Vector_int___Get_28unsigned_20int_29_20const(tflite__MicroInterpreter__inputs_28_29_20const($0), HEAP32[$1 + 20 >> 2]), wasm2js_i32$0 = HEAP32[HEAP32[$2 >> 2] >> 2], FUNCTION_TABLE[wasm2js_i32$0](wasm2js_i32$1 | 0, wasm2js_i32$2 | 0, wasm2js_i32$3 | 0, wasm2js_i32$4 | 0) | 0);
   break label$1;
  }
  if (!HEAP32[$0 + 144 >> 2]) {
   $2 = HEAP32[$0 + 104 >> 2];
   HEAP32[$0 + 144 >> 2] = (wasm2js_i32$4 = $2, wasm2js_i32$3 = HEAP32[$0 + 4 >> 2], wasm2js_i32$2 = HEAP32[$0 + 120 >> 2], wasm2js_i32$1 = flatbuffers__Vector_int___Get_28unsigned_20int_29_20const(tflite__MicroInterpreter__inputs_28_29_20const($0), HEAP32[$1 + 20 >> 2]), wasm2js_i32$0 = HEAP32[HEAP32[$2 >> 2] >> 2], FUNCTION_TABLE[wasm2js_i32$0](wasm2js_i32$4 | 0, wasm2js_i32$3 | 0, wasm2js_i32$2 | 0, wasm2js_i32$1 | 0) | 0);
  }
  HEAP32[$1 + 28 >> 2] = HEAP32[$0 + 144 >> 2];
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function memmove($0, $1, $2) {
 var $3 = 0, $4 = 0;
 label$1 : {
  if (($0 | 0) == ($1 | 0)) {
   break label$1;
  }
  label$2 : {
   if ($1 + $2 >>> 0 > $0 >>> 0) {
    $4 = $0 + $2 | 0;
    if ($4 >>> 0 > $1 >>> 0) {
     break label$2;
    }
   }
   memcpy($0, $1, $2);
   return;
  }
  $3 = ($0 ^ $1) & 3;
  label$4 : {
   label$5 : {
    if ($0 >>> 0 < $1 >>> 0) {
     if ($3) {
      break label$4;
     }
     if (!($0 & 3)) {
      break label$5;
     }
     while (1) {
      if (!$2) {
       break label$1;
      }
      HEAP8[$0 | 0] = HEAPU8[$1 | 0];
      $1 = $1 + 1 | 0;
      $2 = $2 + -1 | 0;
      $0 = $0 + 1 | 0;
      if ($0 & 3) {
       continue;
      }
      break;
     }
     break label$5;
    }
    label$8 : {
     if ($3) {
      break label$8;
     }
     if ($4 & 3) {
      while (1) {
       if (!$2) {
        break label$1;
       }
       $2 = $2 + -1 | 0;
       $3 = $2 + $0 | 0;
       HEAP8[$3 | 0] = HEAPU8[$1 + $2 | 0];
       if ($3 & 3) {
        continue;
       }
       break;
      }
     }
     if ($2 >>> 0 <= 3) {
      break label$8;
     }
     while (1) {
      $2 = $2 + -4 | 0;
      HEAP32[$2 + $0 >> 2] = HEAP32[$1 + $2 >> 2];
      if ($2 >>> 0 > 3) {
       continue;
      }
      break;
     }
    }
    if (!$2) {
     break label$1;
    }
    while (1) {
     $2 = $2 + -1 | 0;
     HEAP8[$2 + $0 | 0] = HEAPU8[$1 + $2 | 0];
     if ($2) {
      continue;
     }
     break;
    }
    break label$1;
   }
   if ($2 >>> 0 <= 3) {
    break label$4;
   }
   $3 = $2;
   while (1) {
    HEAP32[$0 >> 2] = HEAP32[$1 >> 2];
    $1 = $1 + 4 | 0;
    $0 = $0 + 4 | 0;
    $3 = $3 + -4 | 0;
    if ($3 >>> 0 > 3) {
     continue;
    }
    break;
   }
   $2 = $2 & 3;
  }
  if (!$2) {
   break label$1;
  }
  while (1) {
   HEAP8[$0 | 0] = HEAPU8[$1 | 0];
   $0 = $0 + 1 | 0;
   $1 = $1 + 1 | 0;
   $2 = $2 + -1 | 0;
   if ($2) {
    continue;
   }
   break;
  }
 }
}
function tflite__ops__micro__activations__SoftmaxEval_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], 0);
 HEAP32[$2 + 12 >> 2] = tflite__micro__GetEvalOutput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2]);
 label$1 : {
  if (!HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$2 + 8 >> 2] = HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2];
 label$2 : {
  label$3 : {
   $0 = HEAP32[HEAP32[$2 + 16 >> 2] + 8 >> 2] + -1 | 0;
   if ($0 >>> 0 > 8) {
    break label$3;
   }
   label$4 : {
    switch ($0 - 1 | 0) {
    default:
     tflite__ops__micro__activations__SoftmaxFloat_28TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__2c_20tflite__SoftmaxParams_20const__29(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
     HEAP32[$2 + 28 >> 2] = 0;
     break label$2;
    case 0:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
     break label$3;
    case 1:
    case 7:
     break label$4;
    }
   }
   tflite__ops__micro__activations__SoftmaxQuantized_28TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__2c_20tflite__SoftmaxParams_20const__29(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
   HEAP32[$2 + 28 >> 2] = 0;
   break label$2;
  }
  $0 = HEAP32[HEAP32[$2 + 24 >> 2] + 20 >> 2];
  $1 = HEAP32[$2 + 24 >> 2];
  $3 = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 16 >> 2] + 8 >> 2]);
  HEAP32[$2 + 4 >> 2] = HEAP32[HEAP32[$2 + 16 >> 2] + 8 >> 2];
  HEAP32[$2 >> 2] = $3;
  FUNCTION_TABLE[$0]($1, 134622, $2);
  HEAP32[$2 + 28 >> 2] = 1;
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function jsserialEventCallback($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP8[$2 + 47 | 0] = $0;
 HEAP8[$2 + 46 | 0] = $1;
 HEAP32[$2 + 40 >> 2] = jsserialGetSerialList(0);
 label$1 : {
  if (!HEAP32[$2 + 40 >> 2]) {
   break label$1;
  }
  HEAP32[$2 + 36 >> 2] = jsvGetArrayItem(HEAP32[$2 + 40 >> 2], HEAPU8[$2 + 46 | 0]);
  if (!HEAP32[$2 + 36 >> 2]) {
   break label$1;
  }
  HEAP32[$2 + 32 >> 2] = jsvObjectGetChild(HEAP32[$2 + 36 >> 2], 83598, 0);
  HEAP32[$2 + 28 >> 2] = jsvGetFlatStringPointer(HEAP32[$2 + 32 >> 2]);
  if (!HEAP32[$2 + 28 >> 2]) {
   break label$1;
  }
  HEAP32[$2 + 16 >> 2] = jshGetSystemTime();
  HEAP32[$2 + 20 >> 2] = i64toi32_i32$HIGH_BITS;
  $0 = HEAP32[$2 + 16 >> 2];
  $1 = HEAP32[$2 + 28 >> 2];
  $3 = HEAP32[$1 + 72 >> 2];
  $1 = HEAP32[$2 + 20 >> 2] - (($0 >>> 0 < $3 >>> 0) + HEAP32[$1 + 76 >> 2] | 0) | 0;
  HEAP32[$2 + 8 >> 2] = $0 - $3;
  HEAP32[$2 + 12 >> 2] = $1;
  $1 = HEAP32[$2 + 20 >> 2];
  $0 = HEAP32[$2 + 28 >> 2];
  HEAP32[$0 + 72 >> 2] = HEAP32[$2 + 16 >> 2];
  HEAP32[$0 + 76 >> 2] = $1;
  HEAP8[$2 + 7 | 0] = (HEAPU8[$2 + 47 | 0] ^ -1) & 1;
  $0 = $2;
  $4 = jshGetMillisecondsFromTime(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 12 >> 2]) * +HEAP32[HEAP32[$2 + 28 >> 2] + 80 >> 2] / 1e3 + .5;
  label$2 : {
   if (Math_abs($4) < 2147483648) {
    $1 = ~~$4;
    break label$2;
   }
   $1 = -2147483648;
  }
  HEAP32[$0 >> 2] = $1;
  if (!(HEAPU8[HEAP32[$2 + 28 >> 2] + 88 | 0] | !(HEAP8[$2 + 7 | 0] & 1)) | HEAP32[$2 >> 2] > 12) {
   break label$1;
  }
  if (HEAP8[$2 + 7 | 0] & 1) {
   $0 = HEAP32[$2 + 28 >> 2];
   HEAP32[$0 + 84 >> 2] = HEAP32[$0 + 84 >> 2] | (1 << HEAP32[$2 >> 2]) - 1 << HEAPU8[HEAP32[$2 + 28 >> 2] + 88 | 0];
  }
  $0 = HEAP32[$2 + 28 >> 2];
  HEAP8[$0 + 88 | 0] = HEAP32[$2 >> 2] + HEAPU8[$0 + 88 | 0];
  jsserialCheckForCharacter(HEAP32[$2 + 28 >> 2]);
 }
 global$0 = $2 + 48 | 0;
}
function lcdGetPixelIndex_ArrayBuffer($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 HEAP32[$4 + 24 >> 2] = $0;
 HEAP32[$4 + 20 >> 2] = $1;
 HEAP32[$4 + 16 >> 2] = $2;
 HEAP32[$4 + 12 >> 2] = $3;
 $0 = HEAP32[$4 + 24 >> 2];
 if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 1) {
  if (HEAP32[$4 + 16 >> 2] & 1) {
   $0 = HEAP32[$4 + 24 >> 2];
   HEAP32[$4 + 20 >> 2] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) - (HEAP32[$4 + 20 >> 2] + HEAP32[$4 + 12 >> 2] | 0);
  }
 }
 $0 = HEAP32[$4 + 24 >> 2];
 label$3 : {
  if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 8) {
   $0 = HEAP32[$4 + 24 >> 2];
   HEAP32[$4 + 8 >> 2] = (HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8) >> 1;
   HEAP32[$4 + 4 >> 2] = 0;
   if (HEAP32[$4 + 16 >> 2] >= HEAP32[$4 + 8 >> 2]) {
    HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 16 >> 2] - HEAP32[$4 + 8 >> 2];
    HEAP32[$4 + 4 >> 2] = HEAPU8[HEAP32[$4 + 24 >> 2] + 16 | 0];
   }
   $0 = HEAP32[$4 + 24 >> 2];
   HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 4 >> 2] + Math_imul(HEAP32[$4 + 20 >> 2] + Math_imul(HEAP32[$4 + 16 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) | 0, HEAPU8[HEAP32[$4 + 24 >> 2] + 16 | 0] << 1);
   break label$3;
  }
  $0 = HEAP32[$4 + 24 >> 2];
  if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 2) {
   $0 = HEAP32[$4 + 24 >> 2];
   HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 16 >> 2] & 7 | HEAP32[$4 + 20 >> 2] + Math_imul(HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8, HEAP32[$4 + 16 >> 2] >> 3) << 3;
   break label$3;
  }
  $0 = HEAP32[$4 + 24 >> 2];
  HEAP32[$4 + 28 >> 2] = Math_imul(HEAPU8[HEAP32[$4 + 24 >> 2] + 16 | 0], HEAP32[$4 + 20 >> 2] + Math_imul(HEAP32[$4 + 16 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) | 0);
 }
 return HEAP32[$4 + 28 >> 2];
}
function jswrap_espruino_toString($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = global$0 + -64 | 0;
 global$0 = $1;
 HEAP32[$1 + 56 >> 2] = $0;
 label$1 : {
  if ((jsvGetArrayLength(HEAP32[$1 + 56 >> 2]) | 0) == 1) {
   HEAP32[$1 + 52 >> 2] = jsvGetArrayItem(HEAP32[$1 + 56 >> 2], 0);
   if (jsvIsFlatString(HEAP32[$1 + 52 >> 2]) & 1) {
    HEAP32[$1 + 60 >> 2] = HEAP32[$1 + 52 >> 2];
    break label$1;
   }
   label$4 : {
    if (!(jsvIsArrayBuffer(HEAP32[$1 + 52 >> 2]) & 1)) {
     break label$4;
    }
    $0 = HEAP32[$1 + 52 >> 2];
    if (((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8) & 15) != 1) {
     break label$4;
    }
    $0 = HEAP32[$1 + 52 >> 2];
    if (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8) {
     break label$4;
    }
    HEAP32[$1 + 48 >> 2] = jsvGetArrayBufferBackingString(HEAP32[$1 + 52 >> 2], 0);
    label$5 : {
     if (!(jsvIsFlatString(HEAP32[$1 + 48 >> 2]) & 1)) {
      break label$5;
     }
     $2 = jsvGetCharactersInVar(HEAP32[$1 + 48 >> 2]);
     $0 = HEAP32[$1 + 52 >> 2];
     if (($2 | 0) != (HEAPU8[$0 + 2 | 0] | HEAPU8[$0 + 3 | 0] << 8)) {
      break label$5;
     }
     jsvUnLock(HEAP32[$1 + 52 >> 2]);
     HEAP32[$1 + 60 >> 2] = HEAP32[$1 + 48 >> 2];
     break label$1;
    }
    jsvUnLock(HEAP32[$1 + 48 >> 2]);
   }
   jsvUnLock(HEAP32[$1 + 52 >> 2]);
  }
  HEAP32[$1 + 44 >> 2] = jsvIterateCallbackCount(HEAP32[$1 + 56 >> 2]);
  HEAP32[$1 + 40 >> 2] = jsvNewFlatStringOfLength(HEAP32[$1 + 44 >> 2]);
  if (!HEAP32[$1 + 40 >> 2]) {
   jsvGarbageCollect();
   HEAP32[$1 + 40 >> 2] = jsvNewFlatStringOfLength(HEAP32[$1 + 44 >> 2]);
  }
  if (!HEAP32[$1 + 40 >> 2]) {
   HEAP32[$1 + 60 >> 2] = 0;
   break label$1;
  }
  jsvStringIteratorNew($1, HEAP32[$1 + 40 >> 2], 0);
  jsvIterateCallback(HEAP32[$1 + 56 >> 2], 559, $1);
  jsvStringIteratorFree($1);
  HEAP32[$1 + 60 >> 2] = HEAP32[$1 + 40 >> 2];
 }
 global$0 = $1 - -64 | 0;
 return HEAP32[$1 + 60 >> 2];
}
function jsiCheckErrors() {
 var $0 = 0, $1 = 0;
 $0 = global$0 - 48 | 0;
 global$0 = $0;
 if (HEAP8[322300] & 1) {
  jspSetInterrupted(0);
  HEAP8[322300] = 0;
  jsiConsoleRemoveInputLine();
  jsiConsolePrintString(81574);
 }
 HEAP8[$0 + 47 | 0] = 0;
 HEAP32[$0 + 40 >> 2] = jspGetException();
 if (HEAP32[$0 + 40 >> 2]) {
  if (jsiExecuteEventCallbackOn(81622, 81630, 1, $0 + 40 | 0) & 1) {
   jsvUnLock(HEAP32[$0 + 40 >> 2]);
   HEAP32[$0 + 40 >> 2] = 0;
  }
 }
 if (HEAP32[$0 + 40 >> 2]) {
  jsiConsoleRemoveInputLine();
  HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 40 >> 2];
  jsiConsolePrintf(81651, $0 + 16 | 0);
  HEAP8[$0 + 47 | 0] = 1;
  if (jsvIsObject(HEAP32[$0 + 40 >> 2]) & 1) {
   HEAP32[$0 + 36 >> 2] = jsvObjectGetChild(HEAP32[$0 + 40 >> 2], 81664, 0);
   if (HEAP32[$0 + 36 >> 2]) {
    jsiConsolePrintStringVar(HEAP32[$0 + 36 >> 2]);
    jsvUnLock(HEAP32[$0 + 36 >> 2]);
   }
  }
  jsvUnLock(HEAP32[$0 + 40 >> 2]);
 }
 if (!(!(jspIsInterrupted() & 1) | HEAPU16[161112] & 16)) {
  jsiConsoleRemoveInputLine();
  jsiConsolePrintString(81670);
  jspSetInterrupted(0);
  HEAP8[$0 + 47 | 0] = 1;
 }
 HEAP32[$0 + 32 >> 2] = jspGetStackTrace();
 if (HEAP32[$0 + 32 >> 2]) {
  if (HEAP8[$0 + 47 | 0] & 1) {
   jsiConsolePrintStringVar(HEAP32[$0 + 32 >> 2]);
  }
  jsvUnLock(HEAP32[$0 + 32 >> 2]);
 }
 if (jspHasError() & 1) {
  HEAP32[80549] = HEAP32[80549] & -113;
 }
 if (HEAPU8[322243] != HEAPU8[322179]) {
  HEAP8[$0 + 31 | 0] = HEAPU8[322179] & (HEAPU8[322243] ^ -1);
  if (HEAPU8[$0 + 31 | 0] & -9) {
   $1 = $0 + 24 | 0;
   HEAP32[$0 + 24 >> 2] = jswrap_espruino_getErrorFlagArray(HEAPU8[$0 + 31 | 0]);
   jsiExecuteEventCallbackOn(81104, 81693, 1, $1);
   if (HEAP32[$0 + 24 >> 2]) {
    jsiConsoleRemoveInputLine();
    HEAP32[$0 >> 2] = HEAP32[$0 + 24 >> 2];
    jsiConsolePrintf(81706, $0);
    jsvUnLock(HEAP32[$0 + 24 >> 2]);
   }
  }
  HEAP8[322243] = HEAPU8[322179];
 }
 global$0 = $0 + 48 | 0;
}
function lcdMemLCD_scroll($0, $1, $2, $3, $4, $5, $6) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 var $7 = 0;
 $7 = global$0 - 128 | 0;
 global$0 = $7;
 HEAP32[$7 + 124 >> 2] = $0;
 HEAP32[$7 + 120 >> 2] = $1;
 HEAP32[$7 + 116 >> 2] = $2;
 HEAP32[$7 + 112 >> 2] = $3;
 HEAP32[$7 + 108 >> 2] = $4;
 HEAP32[$7 + 104 >> 2] = $5;
 HEAP32[$7 + 100 >> 2] = $6;
 HEAP8[324605] = 1;
 label$1 : {
  if (!(HEAP32[$7 + 104 >> 2] == 175 ? !HEAP32[$7 + 112 >> 2] : 0)) {
   graphicsFallbackScroll(HEAP32[$7 + 124 >> 2], HEAP32[$7 + 120 >> 2], HEAP32[$7 + 116 >> 2], HEAP32[$7 + 112 >> 2], HEAP32[$7 + 108 >> 2], HEAP32[$7 + 104 >> 2], HEAP32[$7 + 100 >> 2]);
   break label$1;
  }
  if (HEAP32[$7 + 116 >> 2] <= 0) {
   HEAP32[$7 + 12 >> 2] = HEAP32[$7 + 108 >> 2];
   while (1) {
    if (HEAP32[$7 + 12 >> 2] <= (HEAP32[$7 + 100 >> 2] + HEAP32[$7 + 116 >> 2] | 0)) {
     HEAP32[$7 + 8 >> 2] = HEAP32[$7 + 12 >> 2] - HEAP32[$7 + 116 >> 2];
     $0 = $7 + 16 | 0;
     lcdMemLCD_scrollX(HEAP32[$7 + 124 >> 2], $0, Math_imul(HEAP32[$7 + 8 >> 2], 68) + 324608 | 0, HEAP32[$7 + 120 >> 2]);
     memcpy(Math_imul(HEAP32[$7 + 12 >> 2], 68) + 324610 | 0, $0 + 2 | 0, 66);
     HEAP32[$7 + 12 >> 2] = HEAP32[$7 + 12 >> 2] + 1;
     continue;
    }
    break;
   }
   break label$1;
  }
  if (HEAP32[$7 + 116 >> 2] > 0) {
   HEAP32[$7 + 4 >> 2] = HEAP32[$7 + 100 >> 2] - HEAP32[$7 + 116 >> 2];
   while (1) {
    if (HEAP32[$7 + 4 >> 2] >= HEAP32[$7 + 108 >> 2]) {
     HEAP32[$7 >> 2] = HEAP32[$7 + 4 >> 2] + HEAP32[$7 + 116 >> 2];
     $0 = $7 + 16 | 0;
     lcdMemLCD_scrollX(HEAP32[$7 + 124 >> 2], $0, Math_imul(HEAP32[$7 + 4 >> 2], 68) + 324608 | 0, HEAP32[$7 + 120 >> 2]);
     memcpy(Math_imul(HEAP32[$7 >> 2], 68) + 324610 | 0, $0 + 2 | 0, 66);
     HEAP32[$7 + 4 >> 2] = HEAP32[$7 + 4 >> 2] + -1;
     continue;
    }
    break;
   }
  }
 }
 global$0 = $7 + 128 | 0;
}
function jspeStatementIf() {
 var $0 = 0, $1 = 0, $2 = 0;
 $0 = global$0 - 48 | 0;
 global$0 = $0;
 HEAP32[$0 + 32 >> 2] = 0;
 jslGetNextToken();
 label$1 : {
  if (!(jslMatch(40) & 1)) {
   HEAP32[$0 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$0 + 36 >> 2] = jspeExpression();
  if (HEAP32[80549] & 80) {
   HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 36 >> 2];
   break label$1;
  }
  if (!(jslMatch(41) & 1)) {
   HEAP32[$0 + 44 >> 2] = 0;
   break label$1;
  }
  $2 = $0;
  if ((HEAP32[80549] & 63) == 1) {
   $1 = jsvGetBoolAndUnLock(jsvSkipName(HEAP32[$0 + 36 >> 2]));
  } else {
   $1 = 0;
  }
  HEAP8[$2 + 43 | 0] = $1 & 1;
  jsvUnLock(HEAP32[$0 + 36 >> 2]);
  HEAP32[$0 + 28 >> 2] = HEAP32[80549];
  if (!(HEAP8[$0 + 43 | 0] & 1)) {
   jspSetNoExecute();
  }
  HEAP32[$0 + 24 >> 2] = 0;
  HEAP32[$0 + 20 >> 2] = jspeBlockOrStatement();
  HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 24 >> 2] | HEAP32[80549] & 112;
  label$8 : {
   if (!(HEAP8[$0 + 43 | 0] & 1)) {
    jsvUnLock(HEAP32[$0 + 20 >> 2]);
    HEAP32[80549] = HEAP32[80549] & -1664 | HEAP32[$0 + 28 >> 2] & 1663;
    HEAP32[80549] = HEAP32[$0 + 24 >> 2] | HEAP32[80549];
    break label$8;
   }
   HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 20 >> 2];
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 164) {
   jslGetNextToken();
   HEAP32[$0 + 16 >> 2] = HEAP32[80549];
   if (HEAP8[$0 + 43 | 0] & 1) {
    jspSetNoExecute();
   }
   HEAP32[$0 + 12 >> 2] = jspeBlockOrStatement();
   HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 24 >> 2] | HEAP32[80549] & 112;
   label$12 : {
    if (HEAP8[$0 + 43 | 0] & 1) {
     jsvUnLock(HEAP32[$0 + 12 >> 2]);
     HEAP32[80549] = HEAP32[80549] & -1664 | HEAP32[$0 + 16 >> 2] & 1663;
     HEAP32[80549] = HEAP32[$0 + 24 >> 2] | HEAP32[80549];
     break label$12;
    }
    HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 12 >> 2];
   }
  }
  HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 32 >> 2];
 }
 global$0 = $0 + 48 | 0;
 return HEAP32[$0 + 44 >> 2];
}
function jswrap_i2c_writeTo($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $4 = global$0 - 48 | 0;
 $3 = $4;
 global$0 = $3;
 $5 = $3 + 24 | 0;
 $6 = $3 + 34 | 0;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP32[$3 + 36 >> 2] = $2;
 HEAP8[$3 + 35 | 0] = jsiGetDeviceFromClass(HEAP32[$3 + 44 >> 2]);
 HEAP8[$3 + 34 | 0] = 1;
 HEAP32[$3 + 28 >> 2] = i2c_get_address(HEAP32[$3 + 40 >> 2], $6);
 HEAP32[$3 + 24 >> 2] = 0;
 HEAP32[$3 + 20 >> 2] = jsvGetDataPointer(HEAP32[$3 + 36 >> 2], $5);
 if (!(HEAP32[$3 + 20 >> 2] | !HEAP32[$3 + 36 >> 2])) {
  HEAP32[$3 + 24 >> 2] = jsvIterateCallbackCount(HEAP32[$3 + 36 >> 2]);
  label$2 : {
   if (HEAP32[$3 + 24 >> 2] + 256 >>> 0 > 1e6) {
    jsExceptionHere(1, 125822, 0);
    break label$2;
   }
   $0 = $4 - (HEAP32[$3 + 24 >> 2] + 15 & -16) | 0;
   global$0 = $0;
   HEAP32[$3 + 20 >> 2] = $0;
   jsvIterateCallbackToBytes(HEAP32[$3 + 36 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 24 >> 2]);
  }
 }
 if (!(!HEAP32[$3 + 20 >> 2] | !HEAP32[$3 + 24 >> 2])) {
  label$5 : {
   if (!(HEAPU8[$3 + 35 | 0] < 25 | HEAPU8[$3 + 35 | 0] > 25)) {
    jshI2CWrite(HEAPU8[$3 + 35 | 0], HEAP32[$3 + 28 >> 2] & 255, HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP8[$3 + 34 | 0] & 1);
    break label$5;
   }
   if (!HEAPU8[$3 + 35 | 0]) {
    $0 = $3 + 8 | 0;
    HEAP32[$3 + 4 >> 2] = jsvObjectGetChild(HEAP32[$3 + 44 >> 2], 125679, 0);
    if (jsi2cPopulateI2CInfo($0, HEAP32[$3 + 4 >> 2]) & 1) {
     $0 = $3 + 8 | 0;
     HEAP8[$3 + 14 | 0] = jsvGetBoolAndUnLock(jsvObjectGetChild(HEAP32[$3 + 44 >> 2], 125861, 0)) & 1;
     jsi2cWrite($0, HEAP32[$3 + 28 >> 2] & 255, HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP8[$3 + 34 | 0] & 1);
    }
    jsvUnLock2(jsvObjectSetChild(HEAP32[$3 + 44 >> 2], 125861, jsvNewFromBool(HEAP8[$3 + 14 | 0] & 1)), HEAP32[$3 + 4 >> 2]);
   }
  }
 }
 global$0 = $3 + 48 | 0;
}
function jsvGarbageCollectMarkUsed($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 $0 = HEAP32[$1 + 8 >> 2];
 $2 = (HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 65407;
 HEAP8[$0 + 13 | 0] = $2;
 HEAP8[$0 + 14 | 0] = $2 >>> 8;
 if (jsvHasCharacterData(HEAP32[$1 + 8 >> 2]) & 1) {
  HEAP16[$1 + 6 >> 1] = jsvGetLastChild(HEAP32[$1 + 8 >> 2]);
  while (1) {
   if (HEAPU16[$1 + 6 >> 1]) {
    HEAP32[$1 >> 2] = jsvGetAddressOf(HEAPU16[$1 + 6 >> 1]);
    $0 = HEAP32[$1 >> 2];
    $2 = (HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 65407;
    HEAP8[$0 + 13 | 0] = $2;
    HEAP8[$0 + 14 | 0] = $2 >>> 8;
    HEAP16[$1 + 6 >> 1] = jsvGetLastChild(HEAP32[$1 >> 2]);
    continue;
   }
   break;
  }
 }
 label$4 : {
  label$5 : {
   if (jsvHasSingleChild(HEAP32[$1 + 8 >> 2]) & 1) {
    if (jsvGetFirstChild(HEAP32[$1 + 8 >> 2]) & 65535) {
     HEAP32[$1 >> 2] = jsvGetAddressOf(jsvGetFirstChild(HEAP32[$1 + 8 >> 2]) & 65535);
     $0 = HEAP32[$1 >> 2];
     if ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 128) {
      if (!(jsvGarbageCollectMarkUsed(HEAP32[$1 >> 2]) & 1)) {
       HEAP8[$1 + 15 | 0] = 0;
       break label$4;
      }
     }
    }
    break label$5;
   }
   if (jsvHasChildren(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP16[$1 + 6 >> 1] = jsvGetFirstChild(HEAP32[$1 + 8 >> 2]);
    while (1) {
     if (HEAPU16[$1 + 6 >> 1]) {
      HEAP32[$1 >> 2] = jsvGetAddressOf(HEAPU16[$1 + 6 >> 1]);
      $0 = HEAP32[$1 >> 2];
      if ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 128) {
       if (!(jsvGarbageCollectMarkUsed(HEAP32[$1 >> 2]) & 1)) {
        HEAP8[$1 + 15 | 0] = 0;
        break label$4;
       }
      }
      HEAP16[$1 + 6 >> 1] = jsvGetNextSibling(HEAP32[$1 >> 2]);
      continue;
     }
     break;
    }
   }
  }
  HEAP8[$1 + 15 | 0] = 1;
 }
 global$0 = $1 + 16 | 0;
 return HEAP8[$1 + 15 | 0] & 1;
}
function jsfLoadBootCodeFromFlash($0) {
 var $1 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 $1 = global$0 - 80 | 0;
 global$0 = $1;
 HEAP8[$1 + 78 | 0] = $0;
 if (!(wasm2js_i32$0 = (jshPinGetValue(17) & 1) == 1, wasm2js_i32$1 = 0, wasm2js_i32$2 = HEAPU16[161112] & 4096, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1)) {
  $0 = HEAPU8[78233] | HEAPU8[78234] << 8 | (HEAPU8[78235] << 16 | HEAPU8[78236] << 24);
  HEAP8[$1 + 74 | 0] = $0;
  HEAP8[$1 + 75 | 0] = $0 >>> 8;
  HEAP8[$1 + 76 | 0] = $0 >>> 16;
  HEAP8[$1 + 77 | 0] = $0 >>> 24;
  $0 = HEAPU8[78230] | HEAPU8[78231] << 8 | (HEAPU8[78232] << 16 | HEAPU8[78233] << 24);
  HEAP8[$1 + 71 | 0] = $0;
  HEAP8[$1 + 72 | 0] = $0 >>> 8;
  HEAP8[$1 + 73 | 0] = $0 >>> 16;
  HEAP8[$1 + 74 | 0] = $0 >>> 24;
  HEAP32[$1 + 64 >> 2] = 0;
  while (1) {
   if (HEAP32[$1 + 64 >> 2] < 4) {
    HEAP8[$1 + 76 | 0] = HEAP32[$1 + 64 >> 2] + 48;
    jsfNameFromString($1 + 32 | 0, $1 + 71 | 0);
    HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 56 >> 2];
    $0 = HEAP32[$1 + 52 >> 2];
    HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 48 >> 2];
    HEAP32[$1 + 20 >> 2] = $0;
    $0 = HEAP32[$1 + 44 >> 2];
    HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 40 >> 2];
    HEAP32[$1 + 12 >> 2] = $0;
    $0 = HEAP32[$1 + 36 >> 2];
    HEAP32[$1 >> 2] = HEAP32[$1 + 32 >> 2];
    HEAP32[$1 + 4 >> 2] = $0;
    HEAP32[$1 + 60 >> 2] = jsfReadFile($1, 0, 0);
    if (HEAP32[$1 + 60 >> 2]) {
     jsvUnLock2(jspEvaluateVar(HEAP32[$1 + 60 >> 2], 0, 0), HEAP32[$1 + 60 >> 2]);
    }
    HEAP32[$1 + 64 >> 2] = HEAP32[$1 + 64 >> 2] + 1;
    continue;
   }
   break;
  }
 }
 HEAP32[$1 + 28 >> 2] = jsfGetBootCodeFromFlash(HEAP8[$1 + 78 | 0] & 1);
 label$6 : {
  if (!HEAP32[$1 + 28 >> 2]) {
   HEAP8[$1 + 79 | 0] = 0;
   break label$6;
  }
  jsvUnLock2(jspEvaluateVar(HEAP32[$1 + 28 >> 2], 0, 0), HEAP32[$1 + 28 >> 2]);
  HEAP8[$1 + 79 | 0] = 1;
 }
 global$0 = $1 + 80 | 0;
}
function _jswrap_interface_clearTimeoutOrInterval($0, $1) {
 var $2 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP32[$2 + 44 >> 2] = $0;
 HEAP8[$2 + 43 | 0] = $1;
 HEAP32[$2 + 36 >> 2] = jsvLock(HEAPU16[161110]);
 label$1 : {
  label$2 : {
   if (!(jsvIsUndefined(HEAP32[$2 + 44 >> 2]) & 1)) {
    if (jsvGetArrayLength(HEAP32[$2 + 44 >> 2])) {
     break label$2;
    }
   }
   jsvObjectIteratorNew($2 + 32 | 0, HEAP32[$2 + 36 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue($2 + 32 | 0) & 1) {
     HEAP32[$2 + 28 >> 2] = jsvObjectIteratorGetValue($2 + 32 | 0);
     HEAP32[$2 + 24 >> 2] = jsvObjectGetChild(HEAP32[$2 + 28 >> 2], 121703, 0);
     label$6 : {
      if (!HEAP32[$2 + 24 >> 2]) {
       jsvObjectIteratorRemoveAndGotoNext($2 + 32 | 0, HEAP32[$2 + 36 >> 2]);
       break label$6;
      }
      jsvObjectIteratorNext($2 + 32 | 0);
     }
     jsvUnLock2(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 28 >> 2]);
     continue;
    }
    break;
   }
   jsvObjectIteratorFree($2 + 32 | 0);
   break label$1;
  }
  HEAP32[$2 + 20 >> 2] = jsvGetArrayItem(HEAP32[$2 + 44 >> 2], 0);
  label$8 : {
   if (jsvIsUndefined(HEAP32[$2 + 20 >> 2]) & 1) {
    HEAP32[$2 + 16 >> 2] = HEAP8[$2 + 43 | 0] & 1 ? 121709 : 121717;
    $0 = HEAP32[$2 + 16 >> 2];
    HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 16 >> 2];
    HEAP32[$2 >> 2] = $0;
    jsExceptionHere(1, 121726, $2);
    break label$8;
   }
   $0 = $2;
   label$10 : {
    if (jsvIsBasic(HEAP32[$2 + 20 >> 2]) & 1) {
     $1 = jsvFindChildFromVar(HEAP32[$2 + 36 >> 2], HEAP32[$2 + 20 >> 2], 0);
     break label$10;
    }
    $1 = 0;
   }
   HEAP32[$0 + 12 >> 2] = $1;
   if (HEAP32[$2 + 12 >> 2]) {
    jsvRemoveChild(HEAP32[$2 + 36 >> 2], HEAP32[$2 + 12 >> 2]);
    jsvUnLock(HEAP32[$2 + 12 >> 2]);
   }
   jsvUnLock(HEAP32[$2 + 20 >> 2]);
  }
 }
 jsvUnLock(HEAP32[$2 + 36 >> 2]);
 jsiTimersChanged();
 global$0 = $2 + 48 | 0;
}
function jswrap_tfmicrointerpreter_tensorToArrayBuffer($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 + -64 | 0;
 global$0 = $2;
 $3 = $2 + 32 | 0;
 HEAP32[$2 + 56 >> 2] = $0;
 HEAP8[$2 + 55 | 0] = $1;
 HEAP32[$2 + 48 >> 2] = jswrap_tfmicrointerpreter_getTFMI(HEAP32[$2 + 56 >> 2]);
 HEAP32[$2 + 44 >> 2] = jsvObjectGetChild(HEAP32[$2 + 56 >> 2], 128484, 0);
 tf_get($3, HEAP32[$2 + 48 >> 2], HEAP8[$2 + 55 | 0] & 1);
 label$1 : {
  if (!(HEAP32[$2 + 44 >> 2] ? HEAP32[$2 + 32 >> 2] : 0)) {
   jsExceptionHere(1, 128687, 0);
   HEAP32[$2 + 60 >> 2] = 0;
   break label$1;
  }
  HEAP16[$2 + 30 >> 1] = 0;
  label$4 : {
   label$5 : {
    $0 = HEAP32[$2 + 36 >> 2] + -1 | 0;
    if ($0 >>> 0 > 8) {
     break label$5;
    }
    label$6 : {
     switch ($0 - 1 | 0) {
     default:
      HEAP16[$2 + 30 >> 1] = 36;
      break label$4;
     case 0:
      HEAP16[$2 + 30 >> 1] = 20;
      break label$4;
     case 1:
      HEAP16[$2 + 30 >> 1] = 1;
      break label$4;
     case 5:
      HEAP16[$2 + 30 >> 1] = 18;
      break label$4;
     case 2:
     case 3:
     case 4:
     case 6:
      break label$5;
     case 7:
      break label$6;
     }
    }
    HEAP16[$2 + 30 >> 1] = 17;
    break label$4;
   }
   HEAP32[$2 >> 2] = HEAP32[$2 + 36 >> 2];
   jsExceptionHere(3, 128708, $2);
   HEAP32[$2 + 60 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 20 >> 2] = jsvGetDataPointer(HEAP32[$2 + 44 >> 2], $2 + 24 | 0);
  HEAP32[$2 + 16 >> 2] = jsvNewArrayBufferFromString(HEAP32[$2 + 44 >> 2], 0);
  HEAP32[$2 + 12 >> 2] = jswrap_typedarray_constructor(HEAPU16[$2 + 30 >> 1], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 32 >> 2] - HEAP32[$2 + 20 >> 2] | 0, HEAPU32[$2 + 40 >> 2] / ((HEAPU16[$2 + 30 >> 1] & 15) >>> 0) | 0);
  jsvUnLock2(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 44 >> 2]);
  HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 12 >> 2];
 }
 global$0 = $2 - -64 | 0;
 return HEAP32[$2 + 60 >> 2];
}
function jswrap_espruino_convolve($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $3 = global$0 - 176 | 0;
 global$0 = $3;
 HEAP32[$3 + 164 >> 2] = $0;
 HEAP32[$3 + 160 >> 2] = $1;
 HEAP32[$3 + 156 >> 2] = $2;
 label$1 : {
  label$2 : {
   if (jsvIsIterable(HEAP32[$3 + 164 >> 2]) & 1) {
    if (jsvIsIterable(HEAP32[$3 + 160 >> 2]) & 1) {
     break label$2;
    }
   }
   $0 = HEAP32[$3 + 164 >> 2];
   HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 160 >> 2];
   HEAP32[$3 >> 2] = $0;
   jsExceptionHere(1, 120187, $3);
   HEAPF64[$3 + 168 >> 3] = nan;
   break label$1;
  }
  $0 = $3 + 16 | 0;
  HEAPF64[$3 + 144 >> 3] = 0;
  jsvIteratorNew($3 + 80 | 0, HEAP32[$3 + 164 >> 2], 1);
  jsvIteratorNew($0, HEAP32[$3 + 160 >> 2], 1);
  HEAP32[$3 + 12 >> 2] = jsvGetLength(HEAP32[$3 + 160 >> 2]);
  HEAP32[$3 + 156 >> 2] = HEAP32[$3 + 156 >> 2] % HEAP32[$3 + 12 >> 2];
  if (HEAP32[$3 + 156 >> 2] < 0) {
   HEAP32[$3 + 156 >> 2] = HEAP32[$3 + 12 >> 2] + HEAP32[$3 + 156 >> 2];
  }
  while (1) {
   label$6 : {
    $0 = HEAP32[$3 + 156 >> 2];
    HEAP32[$3 + 156 >> 2] = $0 + -1;
    if (($0 | 0) <= 0) {
     break label$6;
    }
    jsvIteratorNext($3 + 16 | 0);
    continue;
   }
   break;
  }
  while (1) {
   if (jsvIteratorHasElement($3 + 80 | 0) & 1) {
    $0 = $3 + 16 | 0;
    $1 = $3 + 80 | 0;
    $4 = jsvIteratorGetFloatValue($1) * jsvIteratorGetFloatValue($0);
    HEAPF64[$3 + 144 >> 3] = HEAPF64[$3 + 144 >> 3] + $4;
    jsvIteratorNext($1);
    jsvIteratorNext($0);
    if (!(jsvIteratorHasElement($0) & 1)) {
     $0 = $3 + 16 | 0;
     jsvIteratorFree($0);
     jsvIteratorNew($0, HEAP32[$3 + 160 >> 2], 1);
    }
    continue;
   }
   break;
  }
  $0 = $3 + 16 | 0;
  jsvIteratorFree($3 + 80 | 0);
  jsvIteratorFree($0);
  HEAPF64[$3 + 168 >> 3] = HEAPF64[$3 + 144 >> 3];
 }
 global$0 = $3 + 176 | 0;
 return +HEAPF64[$3 + 168 >> 3];
}
function jswGetSymbolListForConstructorProto($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 $0 = HEAP32[$1 + 8 >> 2];
 HEAP32[$1 + 4 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
 label$1 : {
  if (HEAP32[$1 + 4 >> 2] == 20) {
   HEAP32[$1 + 12 >> 2] = 93211;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 21) {
   HEAP32[$1 + 12 >> 2] = 93274;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 22) {
   HEAP32[$1 + 12 >> 2] = 93292;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 23) {
   HEAP32[$1 + 12 >> 2] = 93301;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 24) {
   HEAP32[$1 + 12 >> 2] = 93310;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 25) {
   HEAP32[$1 + 12 >> 2] = 93319;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 26) {
   HEAP32[$1 + 12 >> 2] = 93328;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 27) {
   HEAP32[$1 + 12 >> 2] = 93337;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 28) {
   HEAP32[$1 + 12 >> 2] = 93436;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 29) {
   HEAP32[$1 + 12 >> 2] = 93472;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 30) {
   HEAP32[$1 + 12 >> 2] = 93481;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 31) {
   HEAP32[$1 + 12 >> 2] = 93499;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 32) {
   HEAP32[$1 + 12 >> 2] = 93517;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 33) {
   HEAP32[$1 + 12 >> 2] = 93535;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 34) {
   HEAP32[$1 + 12 >> 2] = 93553;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 35) {
   HEAP32[$1 + 12 >> 2] = 93580;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 36) {
   HEAP32[$1 + 12 >> 2] = 93634;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 return HEAP32[$1 + 12 >> 2];
}
function jswrap_date_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = global$0 - 80 | 0;
 global$0 = $1;
 HEAP32[$1 + 76 >> 2] = $0;
 HEAPF64[$1 + 64 >> 3] = 0;
 label$1 : {
  if (!jsvGetArrayLength(HEAP32[$1 + 76 >> 2])) {
   HEAPF64[$1 + 64 >> 3] = jswrap_date_now();
   break label$1;
  }
  label$3 : {
   if ((jsvGetArrayLength(HEAP32[$1 + 76 >> 2]) | 0) == 1) {
    HEAP32[$1 + 60 >> 2] = jsvGetArrayItem(HEAP32[$1 + 76 >> 2], 0);
    label$5 : {
     if (jsvIsNumeric(HEAP32[$1 + 60 >> 2]) & 1) {
      HEAPF64[$1 + 64 >> 3] = jsvGetFloat(HEAP32[$1 + 60 >> 2]);
      break label$5;
     }
     label$7 : {
      if (jsvIsString(HEAP32[$1 + 60 >> 2]) & 1) {
       HEAPF64[$1 + 64 >> 3] = jswrap_date_parse(HEAP32[$1 + 60 >> 2]);
       break label$7;
      }
      HEAP32[$1 >> 2] = HEAP32[$1 + 60 >> 2];
      jsExceptionHere(3, 119750, $1);
     }
    }
    jsvUnLock(HEAP32[$1 + 60 >> 2]);
    break label$3;
   }
   $0 = $1 + 16 | 0;
   $2 = $1 + 40 | 0;
   HEAP32[$1 + 52 >> 2] = jsvGetIntegerAndUnLock(jsvGetArrayItem(HEAP32[$1 + 76 >> 2], 0));
   HEAP32[$1 + 48 >> 2] = jsvGetIntegerAndUnLock(jsvGetArrayItem(HEAP32[$1 + 76 >> 2], 1));
   HEAP32[$1 + 44 >> 2] = jsvGetIntegerAndUnLock(jsvGetArrayItem(HEAP32[$1 + 76 >> 2], 2));
   HEAP32[$1 + 16 >> 2] = fromCalenderDate($2);
   HEAP32[$1 + 32 >> 2] = jsvGetIntegerAndUnLock(jsvGetArrayItem(HEAP32[$1 + 76 >> 2], 3));
   HEAP32[$1 + 28 >> 2] = jsvGetIntegerAndUnLock(jsvGetArrayItem(HEAP32[$1 + 76 >> 2], 4));
   HEAP32[$1 + 24 >> 2] = jsvGetIntegerAndUnLock(jsvGetArrayItem(HEAP32[$1 + 76 >> 2], 5));
   HEAP32[$1 + 20 >> 2] = jsvGetIntegerAndUnLock(jsvGetArrayItem(HEAP32[$1 + 76 >> 2], 6));
   HEAP32[$1 + 36 >> 2] = jsdGetTimeZone();
   HEAPF64[$1 + 64 >> 3] = fromTimeInDay($0);
  }
 }
 $0 = jswrap_date_from_milliseconds(HEAPF64[$1 + 64 >> 3]);
 global$0 = $1 + 80 | 0;
 return $0 | 0;
}
function jshPopIOEventOfType($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP8[$2 + 14 | 0] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 label$1 : {
  if (HEAPU8[$2 + 14 | 0] == (HEAPU8[Math_imul(HEAPU8[322307], 5) + 322896 | 0] & 31)) {
   HEAP8[$2 + 15 | 0] = jshPopIOEvent(HEAP32[$2 + 8 >> 2]) & 1;
   break label$1;
  }
  HEAP8[$2 + 7 | 0] = HEAPU8[322307];
  while (1) {
   if (HEAPU8[322306] != HEAPU8[$2 + 7 | 0]) {
    if (HEAPU8[$2 + 14 | 0] == (HEAPU8[Math_imul(HEAPU8[$2 + 7 | 0], 5) + 322896 | 0] & 31)) {
     $0 = HEAP32[$2 + 8 >> 2];
     $1 = Math_imul(HEAPU8[$2 + 7 | 0], 5) + 322896 | 0;
     $3 = HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24);
     HEAP8[$0 | 0] = $3;
     HEAP8[$0 + 1 | 0] = $3 >>> 8;
     HEAP8[$0 + 2 | 0] = $3 >>> 16;
     HEAP8[$0 + 3 | 0] = $3 >>> 24;
     HEAP8[$0 + 4 | 0] = HEAPU8[$1 + 4 | 0];
     HEAP8[$2 + 6 | 0] = HEAPU8[$2 + 7 | 0] + 255;
     while (1) {
      if (HEAPU8[$2 + 6 | 0] != HEAPU8[322307]) {
       $0 = Math_imul(HEAPU8[$2 + 7 | 0], 5) + 322896 | 0;
       $1 = Math_imul(HEAPU8[$2 + 6 | 0], 5) + 322896 | 0;
       $3 = HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24);
       HEAP8[$0 | 0] = $3;
       HEAP8[$0 + 1 | 0] = $3 >>> 8;
       HEAP8[$0 + 2 | 0] = $3 >>> 16;
       HEAP8[$0 + 3 | 0] = $3 >>> 24;
       HEAP8[$0 + 4 | 0] = HEAPU8[$1 + 4 | 0];
       HEAP8[$2 + 7 | 0] = HEAPU8[$2 + 6 | 0];
       HEAP8[$2 + 6 | 0] = HEAPU8[$2 + 6 | 0] + 255;
       continue;
      }
      break;
     }
     HEAP8[322307] = HEAPU8[322307] + 1;
     HEAP8[$2 + 15 | 0] = 1;
     break label$1;
    } else {
     HEAP8[$2 + 7 | 0] = HEAPU8[$2 + 7 | 0] + 1;
     continue;
    }
   }
   break;
  }
  HEAP8[$2 + 15 | 0] = 0;
 }
 global$0 = $2 + 16 | 0;
 return HEAP8[$2 + 15 | 0] & 1;
}
function jswrap_io_digitalPulse($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 128 | 0;
 global$0 = $3;
 HEAP8[$3 + 127 | 0] = $0;
 HEAP8[$3 + 126 | 0] = $1;
 HEAP32[$3 + 120 >> 2] = $2;
 label$1 : {
  if (jsvIsNumeric(HEAP32[$3 + 120 >> 2]) & 1) {
   HEAPF64[$3 + 112 >> 3] = jsvGetFloat(HEAP32[$3 + 120 >> 2]);
   label$3 : {
    label$4 : {
     label$5 : {
      if (HEAPF64[$3 + 112 >> 3] < 0) {
       break label$5;
      }
      $0 = __DOUBLE_BITS(HEAPF64[$3 + 112 >> 3]);
      $1 = i64toi32_i32$HIGH_BITS & 2147483647;
      if (($1 | 0) == 2146435072 & $0 >>> 0 > 0 | $1 >>> 0 > 2146435072) {
       break label$5;
      }
      break label$4;
     }
     jsExceptionHere(1, 121818, 0);
     break label$3;
    }
    jshPinPulse(HEAPU8[$3 + 127 | 0], HEAP8[$3 + 126 | 0] & 1, HEAPF64[$3 + 112 >> 3]);
   }
   break label$1;
  }
  label$6 : {
   if (jsvIsIterable(HEAP32[$3 + 120 >> 2]) & 1) {
    jsvIteratorNew($3 + 48 | 0, HEAP32[$3 + 120 >> 2], 1);
    while (1) {
     if (jsvIteratorHasElement($3 + 48 | 0) & 1) {
      HEAPF64[$3 + 40 >> 3] = jsvIteratorGetFloatValue($3 + 48 | 0);
      label$10 : {
       if (!(HEAPF64[$3 + 40 >> 3] >= 0)) {
        break label$10;
       }
       $0 = __DOUBLE_BITS(HEAPF64[$3 + 40 >> 3]);
       $1 = i64toi32_i32$HIGH_BITS & 2147483647;
       if (($1 | 0) == 2146435072 & $0 >>> 0 > 0 | $1 >>> 0 > 2146435072) {
        break label$10;
       }
       jshPinPulse(HEAPU8[$3 + 127 | 0], HEAP8[$3 + 126 | 0] & 1, HEAPF64[$3 + 40 >> 3]);
      }
      HEAP8[$3 + 126 | 0] = (HEAPU8[$3 + 126 | 0] ^ -1) & 1;
      jsvIteratorNext($3 + 48 | 0);
      continue;
     }
     break;
    }
    jsvIteratorFree($3 + 48 | 0);
    break label$6;
   }
   HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 120 >> 2];
   jsExceptionHere(1, 121884, $3 + 32 | 0);
  }
 }
 global$0 = $3 + 128 | 0;
}
function jswrap_espruino_getSizeOf($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 label$1 : {
  label$2 : {
   if (HEAP32[$2 + 36 >> 2] <= 0) {
    break label$2;
   }
   if (!(jsvHasChildren(HEAP32[$2 + 40 >> 2]) & 1)) {
    break label$2;
   }
   HEAP32[$2 + 32 >> 2] = jsvNewWithFlags(3);
   if (!HEAP32[$2 + 32 >> 2]) {
    HEAP32[$2 + 44 >> 2] = 0;
    break label$1;
   }
   jsvObjectIteratorNew($2 + 24 | 0, HEAP32[$2 + 40 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue($2 + 24 | 0) & 1) {
     HEAP32[$2 + 20 >> 2] = jsvObjectIteratorGetKey($2 + 24 | 0);
     HEAP32[$2 + 16 >> 2] = jsvSkipName(HEAP32[$2 + 20 >> 2]);
     HEAP32[$2 + 12 >> 2] = jsvNewWithFlags(5);
     if (HEAP32[$2 + 12 >> 2]) {
      jsvObjectSetChildAndUnLock(HEAP32[$2 + 12 >> 2], 120565, jsvAsString(HEAP32[$2 + 20 >> 2]));
      jsvObjectSetChildAndUnLock(HEAP32[$2 + 12 >> 2], 120570, jswrap_espruino_getSizeOf(HEAP32[$2 + 20 >> 2], 0));
      label$7 : {
       if (HEAP32[$2 + 36 >> 2] <= 1) {
        break label$7;
       }
       if (!(jsvHasChildren(HEAP32[$2 + 16 >> 2]) & 1)) {
        break label$7;
       }
       jsvObjectSetChildAndUnLock(HEAP32[$2 + 12 >> 2], 120575, jswrap_espruino_getSizeOf(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 36 >> 2] - 1 | 0));
      }
      jsvArrayPushAndUnLock(HEAP32[$2 + 32 >> 2], HEAP32[$2 + 12 >> 2]);
     }
     $0 = $2 + 24 | 0;
     jsvUnLock2(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 20 >> 2]);
     jsvObjectIteratorNext($0);
     continue;
    }
    break;
   }
   jsvObjectIteratorFree($2 + 24 | 0);
   HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
   break label$1;
  }
  HEAP32[$2 + 44 >> 2] = jsvNewFromInteger(jsvCountJsVarsUsed(HEAP32[$2 + 40 >> 2]));
 }
 global$0 = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}
function jsserialEventCallbackInit($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = jsvNewFlatStringOfLength(96);
 label$1 : {
  if (!HEAP32[$2 + 16 >> 2]) {
   jsExceptionHere(1, 83560, 0);
   HEAP8[$2 + 31 | 0] = 0;
   break label$1;
  }
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 83598, HEAP32[$2 + 16 >> 2]);
  HEAP32[$2 + 12 >> 2] = jsvGetFlatStringPointer(HEAP32[$2 + 16 >> 2]);
  HEAP8[HEAP32[$2 + 12 >> 2] + 64 | 0] = 0;
  $0 = jshGetSystemTime();
  $1 = HEAP32[$2 + 12 >> 2];
  HEAP32[$1 + 72 >> 2] = $0;
  HEAP32[$1 + 76 >> 2] = i64toi32_i32$HIGH_BITS;
  $0 = HEAP32[$2 + 20 >> 2];
  HEAP32[HEAP32[$2 + 12 >> 2] + 80 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
  HEAP32[HEAP32[$2 + 12 >> 2] + 84 >> 2] = 0;
  HEAP8[HEAP32[$2 + 12 >> 2] + 88 | 0] = 0;
  HEAP8[HEAP32[$2 + 12 >> 2] + 89 | 0] = (HEAPU8[HEAP32[$2 + 20 >> 2] + 8 | 0] + HEAPU8[HEAP32[$2 + 20 >> 2] + 10 | 0] | 0) + (HEAPU8[HEAP32[$2 + 20 >> 2] + 9 | 0] ? 1 : 0);
  HEAP8[$2 + 11 | 0] = jshPinWatch(HEAPU8[HEAP32[$2 + 20 >> 2] + 4 | 0], 1);
  label$3 : {
   if (HEAPU8[$2 + 11 | 0]) {
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 83606, jsvNewFromInteger(HEAPU8[$2 + 11 | 0]));
    HEAP32[$2 + 4 >> 2] = jsserialGetSerialList(1);
    if (!HEAP32[$2 + 4 >> 2]) {
     HEAP8[$2 + 31 | 0] = 0;
     break label$1;
    }
    jsvSetArrayItem(HEAP32[$2 + 4 >> 2], HEAPU8[$2 + 11 | 0], HEAP32[$2 + 24 >> 2]);
    jsvUnLock(HEAP32[$2 + 4 >> 2]);
    jshSetEventCallback(HEAPU8[$2 + 11 | 0], 16);
    break label$3;
   }
   HEAP32[$2 >> 2] = HEAPU8[HEAP32[$2 + 20 >> 2] + 4 | 0];
   jsExceptionHere(1, 83611, $2);
   HEAP8[$2 + 31 | 0] = 0;
   break label$1;
  }
  HEAP8[$2 + 31 | 0] = 1;
 }
 global$0 = $2 + 32 | 0;
}
function tflite___28anonymous_20namespace_29__CreatePlan_28tflite__ErrorReporter__2c_20tflite__GreedyMemoryPlanner__2c_20tflite___28anonymous_20namespace_29__AllocationInfo_20const__2c_20unsigned_20long_29($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 48 | 0;
 global$0 = $4;
 HEAP32[$4 + 40 >> 2] = $0;
 HEAP32[$4 + 36 >> 2] = $1;
 HEAP32[$4 + 32 >> 2] = $2;
 HEAP32[$4 + 28 >> 2] = $3;
 HEAP32[$4 + 24 >> 2] = 0;
 label$1 : {
  while (1) {
   if (HEAPU32[$4 + 24 >> 2] < HEAPU32[$4 + 28 >> 2]) {
    HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 32 >> 2] + Math_imul(HEAP32[$4 + 24 >> 2], 24);
    if (HEAP8[HEAP32[$4 + 20 >> 2] + 20 | 0] & 1) {
     HEAP32[$4 + 16 >> 2] = tflite__AlignSizeUp_28unsigned_20long_2c_20unsigned_20long_29(HEAP32[HEAP32[$4 + 20 >> 2] >> 2]);
     label$5 : {
      if (HEAP32[HEAP32[$4 + 20 >> 2] + 16 >> 2] == -1) {
       $0 = HEAP32[$4 + 36 >> 2];
       HEAP32[$4 + 12 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 8 >> 2]]($0, HEAP32[$4 + 40 >> 2], HEAP32[$4 + 16 >> 2], HEAP32[HEAP32[$4 + 20 >> 2] + 8 >> 2], HEAP32[HEAP32[$4 + 20 >> 2] + 12 >> 2]);
       if (HEAP32[$4 + 12 >> 2]) {
        HEAP32[$4 + 44 >> 2] = HEAP32[$4 + 12 >> 2];
        break label$1;
       }
       break label$5;
      }
      HEAP32[$4 + 8 >> 2] = tflite__GreedyMemoryPlanner__AddBuffer_28tflite__ErrorReporter__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$4 + 36 >> 2], HEAP32[$4 + 40 >> 2], HEAP32[$4 + 16 >> 2], HEAP32[HEAP32[$4 + 20 >> 2] + 8 >> 2], HEAP32[HEAP32[$4 + 20 >> 2] + 12 >> 2], HEAP32[HEAP32[$4 + 20 >> 2] + 16 >> 2]);
      if (HEAP32[$4 + 8 >> 2]) {
       HEAP32[$4 + 44 >> 2] = HEAP32[$4 + 8 >> 2];
       break label$1;
      }
     }
    }
    HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 24 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$4 + 44 >> 2] = 0;
 }
 global$0 = $4 + 48 | 0;
 return HEAP32[$4 + 44 >> 2];
}
function heatshrink_decoder_poll($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP32[$3 + 40 >> 2] = $0;
 HEAP32[$3 + 36 >> 2] = $1;
 HEAP32[$3 + 32 >> 2] = 128;
 HEAP32[$3 + 28 >> 2] = $2;
 label$1 : {
  if (!(HEAP32[$3 + 28 >> 2] ? !(!HEAP32[$3 + 40 >> 2] | !HEAP32[$3 + 36 >> 2]) : 0)) {
   HEAP32[$3 + 44 >> 2] = -1;
   break label$1;
  }
  HEAP32[HEAP32[$3 + 28 >> 2] >> 2] = 0;
  HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 36 >> 2];
  HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 32 >> 2];
  HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 28 >> 2];
  while (1) {
   HEAP8[$3 + 15 | 0] = HEAPU8[HEAP32[$3 + 40 >> 2] + 10 | 0];
   label$5 : {
    $0 = HEAPU8[$3 + 15 | 0];
    if ($0 >>> 0 <= 6) {
     label$7 : {
      switch ($0 - 1 | 0) {
      default:
       $0 = st_tag_bit(HEAP32[$3 + 40 >> 2]);
       break label$5;
      case 0:
       $0 = st_yield_literal_1(HEAP32[$3 + 40 >> 2], $3 + 16 | 0);
       break label$5;
      case 1:
       $0 = st_backref_index_msb(HEAP32[$3 + 40 >> 2]);
       break label$5;
      case 2:
       $0 = st_backref_index_lsb(HEAP32[$3 + 40 >> 2]);
       break label$5;
      case 3:
       $0 = st_backref_count_msb(HEAP32[$3 + 40 >> 2]);
       break label$5;
      case 4:
       $0 = st_backref_count_lsb(HEAP32[$3 + 40 >> 2]);
       break label$5;
      case 5:
       break label$7;
      }
     }
     $0 = st_yield_backref(HEAP32[$3 + 40 >> 2], $3 + 16 | 0);
     break label$5;
    }
    HEAP32[$3 + 44 >> 2] = -2;
    break label$1;
   }
   HEAP8[HEAP32[$3 + 40 >> 2] + 10 | 0] = $0;
   if (HEAPU8[HEAP32[$3 + 40 >> 2] + 10 | 0] != HEAPU8[$3 + 15 | 0]) {
    continue;
   }
   break;
  }
  if (HEAP32[HEAP32[$3 + 28 >> 2] >> 2] == HEAP32[$3 + 32 >> 2]) {
   HEAP32[$3 + 44 >> 2] = 1;
   break label$1;
  }
  HEAP32[$3 + 44 >> 2] = 0;
 }
 global$0 = $3 + 48 | 0;
 return HEAP32[$3 + 44 >> 2];
}
function graphicsFallbackScrollX($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = global$0 - 32 | 0;
 global$0 = $6;
 HEAP32[$6 + 28 >> 2] = $0;
 HEAP32[$6 + 24 >> 2] = $1;
 HEAP32[$6 + 20 >> 2] = $2;
 HEAP32[$6 + 16 >> 2] = $3;
 HEAP32[$6 + 12 >> 2] = $4;
 HEAP32[$6 + 8 >> 2] = $5;
 label$1 : {
  if (HEAP32[$6 + 24 >> 2] <= 0) {
   HEAP32[$6 >> 2] = HEAP32[$6 + 8 >> 2] + HEAP32[$6 + 24 >> 2];
   HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 12 >> 2];
   while (1) {
    if (HEAP32[$6 + 4 >> 2] <= HEAP32[$6 >> 2]) {
     $0 = HEAP32[$6 + 28 >> 2];
     $1 = HEAPU8[$0 + 52 | 0] | HEAPU8[$0 + 53 | 0] << 8 | (HEAPU8[$0 + 54 | 0] << 16 | HEAPU8[$0 + 55 | 0] << 24);
     $0 = HEAP32[$6 + 28 >> 2];
     FUNCTION_TABLE[$1](HEAP32[$6 + 28 >> 2], HEAP32[$6 + 4 >> 2], HEAP32[$6 + 16 >> 2], FUNCTION_TABLE[HEAPU8[$0 + 60 | 0] | HEAPU8[$0 + 61 | 0] << 8 | (HEAPU8[$0 + 62 | 0] << 16 | HEAPU8[$0 + 63 | 0] << 24)](HEAP32[$6 + 28 >> 2], HEAP32[$6 + 4 >> 2] - HEAP32[$6 + 24 >> 2] | 0, HEAP32[$6 + 20 >> 2]) | 0);
     HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 4 >> 2] + 1;
     continue;
    }
    break;
   }
   break label$1;
  }
  HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 8 >> 2] - HEAP32[$6 + 24 >> 2];
  while (1) {
   if (HEAP32[$6 + 4 >> 2] >= HEAP32[$6 + 12 >> 2]) {
    $0 = HEAP32[$6 + 28 >> 2];
    $1 = HEAPU8[$0 + 52 | 0] | HEAPU8[$0 + 53 | 0] << 8 | (HEAPU8[$0 + 54 | 0] << 16 | HEAPU8[$0 + 55 | 0] << 24);
    $0 = HEAP32[$6 + 28 >> 2];
    FUNCTION_TABLE[$1](HEAP32[$6 + 28 >> 2], HEAP32[$6 + 4 >> 2] + HEAP32[$6 + 24 >> 2] | 0, HEAP32[$6 + 16 >> 2], FUNCTION_TABLE[HEAPU8[$0 + 60 | 0] | HEAPU8[$0 + 61 | 0] << 8 | (HEAPU8[$0 + 62 | 0] << 16 | HEAPU8[$0 + 63 | 0] << 24)](HEAP32[$6 + 28 >> 2], HEAP32[$6 + 4 >> 2], HEAP32[$6 + 20 >> 2]) | 0);
    HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 4 >> 2] + -1;
    continue;
   }
   break;
  }
 }
 global$0 = $6 + 32 | 0;
}
function jshFlashWriteAligned($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 label$1 : {
  if (!(HEAPU32[$3 + 24 >> 2] < 134217728 | HEAPU32[$3 + 24 >> 2] >= 142606336)) {
   jshFlashWrite(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
   break label$1;
  }
  HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 28 >> 2];
  HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 24 >> 2] & 3;
  if (HEAP32[$3 + 12 >> 2]) {
   jshFlashRead($3 + 8 | 0, HEAP32[$3 + 24 >> 2] - HEAP32[$3 + 12 >> 2] | 0, 4);
   HEAP32[$3 + 4 >> 2] = 4 - HEAP32[$3 + 12 >> 2];
   if (HEAPU32[$3 + 4 >> 2] > HEAPU32[$3 + 20 >> 2]) {
    HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 20 >> 2];
   }
   $0 = $3 + 8 | 0;
   memcpy($0 + HEAP32[$3 + 12 >> 2] | 0, HEAP32[$3 + 16 >> 2], HEAP32[$3 + 4 >> 2]);
   HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 4 >> 2] + HEAP32[$3 + 16 >> 2];
   jshFlashWrite($0, HEAP32[$3 + 24 >> 2] - HEAP32[$3 + 12 >> 2] | 0, 4);
   HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 4 >> 2] + HEAP32[$3 + 24 >> 2];
   if (HEAPU32[$3 + 4 >> 2] >= HEAPU32[$3 + 20 >> 2]) {
    break label$1;
   }
   HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] - HEAP32[$3 + 4 >> 2];
  }
  HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 20 >> 2] & 3;
  HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] - HEAP32[$3 + 12 >> 2];
  if (HEAP32[$3 + 20 >> 2]) {
   jshFlashWrite(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
  }
  HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 20 >> 2] + HEAP32[$3 + 24 >> 2];
  HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 20 >> 2] + HEAP32[$3 + 16 >> 2];
  if (!HEAP32[$3 + 12 >> 2]) {
   break label$1;
  }
  jshFlashRead($3, HEAP32[$3 + 24 >> 2], 4);
  memcpy($3, HEAP32[$3 + 16 >> 2], HEAP32[$3 + 12 >> 2]);
  jshFlashWrite($3, HEAP32[$3 + 24 >> 2], 4);
 }
 global$0 = $3 + 32 | 0;
}
function jsfBankFindFile($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 + -64 | 0;
 global$0 = $2;
 HEAP32[$2 + 56 >> 2] = 134217728;
 HEAP32[$2 + 52 >> 2] = 142606336;
 HEAP32[$2 + 48 >> 2] = $1;
 HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 56 >> 2];
 $1 = $2 + 8 | 0;
 HEAP32[$1 >> 2] = 0;
 HEAP32[$1 + 4 >> 2] = 0;
 HEAP32[$1 + 24 >> 2] = 0;
 HEAP32[$1 + 28 >> 2] = 0;
 HEAP32[$1 + 16 >> 2] = 0;
 HEAP32[$1 + 20 >> 2] = 0;
 HEAP32[$1 + 8 >> 2] = 0;
 HEAP32[$1 + 12 >> 2] = 0;
 label$1 : {
  if (jsfGetFileHeader(HEAP32[$2 + 44 >> 2], $1, 0) & 1) {
   while (1) {
    if (HEAP32[$2 + 12 >> 2] == HEAP32[$0 >> 2]) {
     $1 = $2 + 8 | 0;
     jsfGetFileHeader(HEAP32[$2 + 44 >> 2], $1, 1);
     if (!memcmp($1 + 4 | 0, $0, 28)) {
      HEAP32[$2 + 4 >> 2] = (HEAP32[$2 + 44 >> 2] + 32 | 0) + jsfGetFileSize($2 + 8 | 0);
      if (!(HEAPU32[$2 + 4 >> 2] <= HEAPU32[$2 + 52 >> 2] ? HEAPU32[$2 + 4 >> 2] >= HEAPU32[$2 + 44 >> 2] : 0)) {
       HEAP32[$2 + 60 >> 2] = 0;
       break label$1;
      }
      if (HEAP32[$2 + 48 >> 2]) {
       $3 = HEAP32[$2 + 12 >> 2];
       $0 = HEAP32[$2 + 48 >> 2];
       $1 = $0;
       HEAP32[$1 >> 2] = HEAP32[$2 + 8 >> 2];
       HEAP32[$1 + 4 >> 2] = $3;
       $1 = HEAP32[$2 + 36 >> 2];
       HEAP32[$0 + 24 >> 2] = HEAP32[$2 + 32 >> 2];
       HEAP32[$0 + 28 >> 2] = $1;
       $1 = HEAP32[$2 + 28 >> 2];
       HEAP32[$0 + 16 >> 2] = HEAP32[$2 + 24 >> 2];
       HEAP32[$0 + 20 >> 2] = $1;
       $1 = HEAP32[$2 + 20 >> 2];
       HEAP32[$0 + 8 >> 2] = HEAP32[$2 + 16 >> 2];
       HEAP32[$0 + 12 >> 2] = $1;
      }
      HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 44 >> 2] + 32;
      break label$1;
     }
    }
    if (jsfGetNextFileHeader($2 + 44 | 0, $2 + 8 | 0, 3) & 1) {
     continue;
    }
    break;
   }
  }
  HEAP32[$2 + 60 >> 2] = 0;
 }
 global$0 = $2 - -64 | 0;
 return HEAP32[$2 + 60 >> 2];
}
function jsvGetDataPointer($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1 : {
  if (jsvIsArrayBuffer(HEAP32[$2 + 24 >> 2]) & 1) {
   HEAP32[$2 + 16 >> 2] = jsvGetArrayBufferBackingString(HEAP32[$2 + 24 >> 2], 0);
   HEAP32[$2 + 12 >> 2] = jsvGetDataPointer(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 20 >> 2]);
   jsvUnLock(HEAP32[$2 + 16 >> 2]);
   if (HEAP32[$2 + 12 >> 2]) {
    $0 = HEAP32[$2 + 24 >> 2];
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8);
    $0 = HEAP32[$2 + 24 >> 2];
    HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = HEAPU8[$0 + 2 | 0] | HEAPU8[$0 + 3 | 0] << 8;
   }
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
   break label$1;
  }
  if (jsvIsNativeString(HEAP32[$2 + 24 >> 2]) & 1) {
   $0 = HEAP32[$2 + 24 >> 2];
   HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
   $0 = HEAP32[$2 + 24 >> 2];
   HEAP32[$2 + 28 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
   break label$1;
  }
  if (jsvIsFlatString(HEAP32[$2 + 24 >> 2]) & 1) {
   $0 = jsvGetStringLength(HEAP32[$2 + 24 >> 2]);
   HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = $0;
   HEAP32[$2 + 28 >> 2] = jsvGetFlatStringPointer(HEAP32[$2 + 24 >> 2]);
   break label$1;
  }
  label$6 : {
   if (!(jsvIsBasicString(HEAP32[$2 + 24 >> 2]) & 1)) {
    break label$6;
   }
   if (jsvGetLastChild(HEAP32[$2 + 24 >> 2]) & 65535) {
    break label$6;
   }
   $0 = jsvGetCharactersInVar(HEAP32[$2 + 24 >> 2]);
   HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = $0;
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 24 >> 2];
   break label$1;
  }
  HEAP32[$2 + 28 >> 2] = 0;
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function jsvNewStringOfLength($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1 : {
  if (HEAPU32[$2 + 24 >> 2] > 21) {
   HEAP32[$2 + 16 >> 2] = jsvNewFlatStringOfLength(HEAP32[$2 + 24 >> 2]);
   if (HEAP32[$2 + 16 >> 2]) {
    if (HEAP32[$2 + 20 >> 2]) {
     jsvSetString(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 24 >> 2]);
    }
    HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 16 >> 2];
    break label$1;
   }
  }
  HEAP32[$2 + 12 >> 2] = jsvNewWithFlags(27);
  if (!HEAP32[$2 + 12 >> 2]) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 8 >> 2] = jsvLockAgain(HEAP32[$2 + 12 >> 2]);
  while (1) {
   label$7 : {
    HEAP32[$2 + 4 >> 2] = jsvGetMaxCharactersInVar(HEAP32[$2 + 8 >> 2]);
    if (HEAPU32[$2 + 4 >> 2] >= HEAPU32[$2 + 24 >> 2]) {
     if (HEAP32[$2 + 20 >> 2]) {
      memcpy(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 24 >> 2]);
     }
     jsvSetCharactersInVar(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 24 >> 2]);
     break label$7;
    }
    if (HEAP32[$2 + 20 >> 2]) {
     memcpy(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 4 >> 2]);
     HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 4 >> 2] + HEAP32[$2 + 20 >> 2];
    }
    jsvSetCharactersInVar(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
    HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 24 >> 2] - HEAP32[$2 + 4 >> 2];
    HEAP32[$2 >> 2] = jsvNewWithFlags(41);
    if (!HEAP32[$2 >> 2]) {
     break label$7;
    }
    jsvSetLastChild(HEAP32[$2 + 8 >> 2], jsvGetRef(HEAP32[$2 >> 2]) & 65535);
    jsvUnLock(HEAP32[$2 + 8 >> 2]);
    HEAP32[$2 + 8 >> 2] = HEAP32[$2 >> 2];
    continue;
   }
   break;
  }
  jsvUnLock(HEAP32[$2 + 8 >> 2]);
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function jswrap_math_mod($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = global$0 - 80 | 0;
 global$0 = $2;
 HEAPF64[$2 + 64 >> 3] = $0;
 HEAPF64[$2 + 56 >> 3] = $1;
 HEAPF64[$2 + 32 >> 3] = HEAPF64[$2 + 64 >> 3];
 $4 = __DOUBLE_BITS(HEAPF64[$2 + 64 >> 3]);
 label$1 : {
  label$2 : {
   label$3 : {
    $3 = i64toi32_i32$HIGH_BITS & 2147483647;
    if (($3 | 0) == 2146435072 & $4 >>> 0 >= 0 | $3 >>> 0 > 2146435072) {
     break label$3;
    }
    $4 = __DOUBLE_BITS(HEAPF64[$2 + 56 >> 3]);
    $3 = i64toi32_i32$HIGH_BITS & 2147483647;
    if (($3 | 0) == 2146435072 & $4 >>> 0 > 0 | $3 >>> 0 > 2146435072) {
     break label$3;
    }
    break label$2;
   }
   HEAPF64[$2 + 72 >> 3] = nan;
   break label$1;
  }
  if (0 > HEAPF64[$2 + 32 >> 3]) {
   HEAPF64[$2 + 64 >> 3] = -HEAPF64[$2 + 64 >> 3];
  }
  if (0 > HEAPF64[$2 + 56 >> 3]) {
   HEAPF64[$2 + 56 >> 3] = -HEAPF64[$2 + 56 >> 3];
  }
  label$7 : {
   if (!(!(1.7976931348623157e+308 >= HEAPF64[$2 + 64 >> 3]) | (!(1.7976931348623157e+308 >= HEAPF64[$2 + 56 >> 3]) | HEAPF64[$2 + 56 >> 3] == 0))) {
    while (1) {
     if (HEAPF64[$2 + 64 >> 3] >= HEAPF64[$2 + 56 >> 3]) {
      HEAPF64[$2 + 48 >> 3] = HEAPF64[$2 + 64 >> 3] / 2;
      HEAPF64[$2 + 40 >> 3] = HEAPF64[$2 + 56 >> 3];
      while (1) {
       if (HEAPF64[$2 + 48 >> 3] >= HEAPF64[$2 + 40 >> 3]) {
        HEAPF64[$2 + 40 >> 3] = HEAPF64[$2 + 40 >> 3] * 2;
        continue;
       }
       break;
      }
      HEAPF64[$2 + 64 >> 3] = HEAPF64[$2 + 64 >> 3] - HEAPF64[$2 + 40 >> 3];
      continue;
     }
     break;
    }
    break label$7;
   }
   HEAPF64[$2 + 64 >> 3] = 0;
  }
  $3 = $2;
  if (0 > HEAPF64[$2 + 32 >> 3]) {
   $0 = -HEAPF64[$2 + 64 >> 3];
  } else {
   $0 = HEAPF64[$2 + 64 >> 3];
  }
  HEAPF64[$3 + 72 >> 3] = $0;
 }
 global$0 = $2 + 80 | 0;
 return HEAPF64[$2 + 72 >> 3];
}
function find_longest_match($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 48 | 0;
 HEAP32[$5 + 40 >> 2] = $0;
 HEAP16[$5 + 38 >> 1] = $1;
 HEAP16[$5 + 36 >> 1] = $2;
 HEAP16[$5 + 34 >> 1] = $3;
 HEAP32[$5 + 28 >> 2] = $4;
 HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 40 >> 2] + 15;
 HEAP16[$5 + 22 >> 1] = 0;
 HEAP16[$5 + 20 >> 1] = 65535;
 HEAP16[$5 + 18 >> 1] = 0;
 HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 24 >> 2] + HEAPU16[$5 + 36 >> 1];
 HEAP16[$5 + 10 >> 1] = HEAPU16[$5 + 36 >> 1] - 1;
 while (1) {
  label$2 : {
   if ((HEAP16[$5 + 10 >> 1] - HEAP16[$5 + 38 >> 1] | 0) < 0) {
    break label$2;
   }
   HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 24 >> 2] + HEAP16[$5 + 10 >> 1];
   if (!(HEAPU8[HEAP32[$5 + 4 >> 2] + HEAPU16[$5 + 22 >> 1] | 0] != HEAPU8[HEAP32[$5 + 12 >> 2] + HEAPU16[$5 + 22 >> 1] | 0] | HEAPU8[HEAP32[$5 + 4 >> 2]] != HEAPU8[HEAP32[$5 + 12 >> 2]])) {
    HEAP16[$5 + 18 >> 1] = 1;
    while (1) {
     if (!(HEAPU8[HEAP32[$5 + 4 >> 2] + HEAPU16[$5 + 18 >> 1] | 0] != HEAPU8[HEAP32[$5 + 12 >> 2] + HEAPU16[$5 + 18 >> 1] | 0] | HEAPU16[$5 + 18 >> 1] >= HEAPU16[$5 + 34 >> 1])) {
      HEAP16[$5 + 18 >> 1] = HEAPU16[$5 + 18 >> 1] + 1;
      continue;
     }
     break;
    }
    if (HEAPU16[$5 + 18 >> 1] > HEAPU16[$5 + 22 >> 1]) {
     HEAP16[$5 + 22 >> 1] = HEAPU16[$5 + 18 >> 1];
     HEAP16[$5 + 20 >> 1] = HEAPU16[$5 + 10 >> 1];
     if (HEAPU16[$5 + 18 >> 1] == HEAPU16[$5 + 34 >> 1]) {
      break label$2;
     }
    }
   }
   HEAP16[$5 + 10 >> 1] = HEAPU16[$5 + 10 >> 1] + -1;
   continue;
  }
  break;
 }
 HEAP32[$5 >> 2] = 15;
 label$7 : {
  if (HEAPU16[$5 + 22 >> 1] > 1) {
   HEAP16[HEAP32[$5 + 28 >> 2] >> 1] = HEAPU16[$5 + 22 >> 1];
   HEAP16[$5 + 46 >> 1] = HEAPU16[$5 + 36 >> 1] - HEAPU16[$5 + 20 >> 1];
   break label$7;
  }
  HEAP16[$5 + 46 >> 1] = 65535;
 }
 return HEAPU16[$5 + 46 >> 1];
}
function tflite__ops__micro__pooling___28anonymous_20namespace_29__AverageEvalFloat_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20TfLitePoolParams_20const__2c_20tflite__ops__micro__pooling___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = global$0 - 128 | 0;
 global$0 = $6;
 HEAP32[$6 + 124 >> 2] = $0;
 HEAP32[$6 + 120 >> 2] = $1;
 HEAP32[$6 + 116 >> 2] = $2;
 HEAP32[$6 + 112 >> 2] = $3;
 HEAP32[$6 + 108 >> 2] = $4;
 HEAP32[$6 + 104 >> 2] = $5;
 HEAP32[$6 + 68 >> 2] = HEAP32[HEAP32[$6 + 116 >> 2] + 8 >> 2];
 HEAP32[$6 + 72 >> 2] = HEAP32[HEAP32[$6 + 116 >> 2] + 4 >> 2];
 HEAP32[$6 + 76 >> 2] = HEAP32[HEAP32[$6 + 116 >> 2] + 16 >> 2];
 HEAP32[$6 + 80 >> 2] = HEAP32[HEAP32[$6 + 116 >> 2] + 12 >> 2];
 HEAP16[$6 + 60 >> 1] = HEAP32[HEAP32[$6 + 112 >> 2] + 4 >> 2];
 HEAP16[$6 + 58 >> 1] = HEAP32[HEAP32[$6 + 112 >> 2] >> 2];
 HEAPF32[$6 + 92 >> 2] = HEAPF32[HEAP32[$6 + 112 >> 2] + 24 >> 2];
 HEAPF32[$6 + 96 >> 2] = HEAPF32[HEAP32[$6 + 112 >> 2] + 28 >> 2];
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($6 + 32 | 0, HEAP32[$6 + 108 >> 2]);
 $0 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$6 + 108 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($6, HEAP32[$6 + 104 >> 2]);
 tflite__reference_ops__AveragePool_28tflite__PoolParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($6 + 56 | 0, $6 + 32 | 0, $0, $6, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$6 + 104 >> 2]));
 $0 = $6 + 32 | 0;
 tflite__RuntimeShape___RuntimeShape_28_29($6);
 tflite__RuntimeShape___RuntimeShape_28_29($0);
 global$0 = $6 + 128 | 0;
}
function jswrap_onewire_select($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $2 = global$0 - 80 | 0;
 global$0 = $2;
 HEAP32[$2 + 76 >> 2] = $0;
 HEAP32[$2 + 72 >> 2] = $1;
 HEAP8[$2 + 71 | 0] = onewire_getpin(HEAP32[$2 + 76 >> 2]);
 label$1 : {
  if (!(jshIsPinValid(HEAPU8[$2 + 71 | 0]) & 1)) {
   break label$1;
  }
  label$2 : {
   if (jsvIsString(HEAP32[$2 + 72 >> 2]) & 1) {
    if ((jsvGetStringLength(HEAP32[$2 + 72 >> 2]) | 0) == 16) {
     break label$2;
    }
   }
   HEAP32[$2 >> 2] = HEAP32[$2 + 72 >> 2];
   jsExceptionHere(3, 124322, $2);
   break label$1;
  }
  $0 = $2 + 16 | 0;
  OneWireReset(HEAPU8[$2 + 71 | 0]);
  HEAP32[$2 + 56 >> 2] = 0;
  HEAP32[$2 + 60 >> 2] = 0;
  jsvStringIteratorNew($0, HEAP32[$2 + 72 >> 2], 0);
  HEAP32[$2 + 12 >> 2] = 0;
  while (1) {
   if (HEAP32[$2 + 12 >> 2] < 8) {
    $0 = $2 + 9 | 0;
    $1 = $2 + 16 | 0;
    HEAP8[$2 + 9 | 0] = jsvStringIteratorGetCharAndNext($1);
    HEAP8[$2 + 10 | 0] = jsvStringIteratorGetCharAndNext($1);
    HEAP8[$2 + 11 | 0] = 0;
    $1 = HEAP32[$2 + 56 >> 2];
    $6 = HEAP32[$2 + 60 >> 2];
    $4 = stringToIntWithRadix($0, 16, 0, 0);
    $0 = $2;
    $7 = $2;
    $8 = $1;
    $3 = i64toi32_i32$HIGH_BITS;
    $5 = HEAP32[$2 + 12 >> 2] << 3;
    $1 = $5 & 31;
    if (32 <= ($5 & 63) >>> 0) {
     $3 = $4 << $1;
     $1 = 0;
    } else {
     $3 = (1 << $1) - 1 & $4 >>> 32 - $1 | $3 << $1;
     $1 = $4 << $1;
    }
    HEAP32[$7 + 56 >> 2] = $8 | $1;
    HEAP32[$0 + 60 >> 2] = $3 | $6;
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
    continue;
   }
   break;
  }
  jsvStringIteratorFree($2 + 16 | 0);
  OneWireWrite(HEAPU8[$2 + 71 | 0], 8, 85, 0);
  OneWireWrite(HEAPU8[$2 + 71 | 0], 64, HEAP32[$2 + 56 >> 2], HEAP32[$2 + 60 >> 2]);
 }
 global$0 = $2 + 80 | 0;
}
function jsvIteratorGetIntegerValue($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 $0 = HEAP32[HEAP32[$1 + 8 >> 2] >> 2] + -1 | 0;
 label$1 : {
  if ($0 >>> 0 <= 3) {
   label$3 : {
    switch ($0 - 1 | 0) {
    case 2:
     label$7 : {
      if (!(jsvIsNameInt(HEAP32[HEAP32[$1 + 8 >> 2] + 4 >> 2]) & 1)) {
       break label$7;
      }
      if ((jsvGetInteger(HEAP32[HEAP32[$1 + 8 >> 2] + 4 >> 2]) | 0) != HEAP32[HEAP32[$1 + 8 >> 2] + 12 >> 2]) {
       break label$7;
      }
      HEAP32[$1 + 12 >> 2] = jsvGetFirstChildSigned(HEAP32[HEAP32[$1 + 8 >> 2] + 4 >> 2]) << 16 >> 16;
      break label$1;
     }
     label$8 : {
      if (!(jsvIsIntegerish(HEAP32[HEAP32[$1 + 8 >> 2] + 4 >> 2]) & 1)) {
       break label$8;
      }
      if ((jsvGetInteger(HEAP32[HEAP32[$1 + 8 >> 2] + 4 >> 2]) | 0) != HEAP32[HEAP32[$1 + 8 >> 2] + 12 >> 2]) {
       break label$8;
      }
      HEAP32[$1 + 12 >> 2] = jsvGetIntegerAndUnLock(jsvObjectIteratorGetValue(HEAP32[$1 + 8 >> 2] + 4 | 0));
      break label$1;
     }
     HEAP32[$1 + 12 >> 2] = 0;
     break label$1;
    case 0:
     if (jsvIsNameInt(HEAP32[HEAP32[$1 + 8 >> 2] + 4 >> 2]) & 1) {
      HEAP32[$1 + 12 >> 2] = jsvGetFirstChildSigned(HEAP32[HEAP32[$1 + 8 >> 2] + 4 >> 2]) << 16 >> 16;
      break label$1;
     }
     HEAP32[$1 + 12 >> 2] = jsvGetIntegerAndUnLock(jsvObjectIteratorGetValue(HEAP32[$1 + 8 >> 2] + 4 | 0));
     break label$1;
    default:
     HEAP32[$1 + 12 >> 2] = jsvStringIteratorGetChar(HEAP32[$1 + 8 >> 2] + 4 | 0) << 24 >> 24;
     break label$1;
    case 1:
     break label$3;
    }
   }
   HEAP32[$1 + 12 >> 2] = jsvArrayBufferIteratorGetIntegerValue(HEAP32[$1 + 8 >> 2] + 4 | 0);
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function exp($0) {
 $0 = +$0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 wasm2js_scratch_store_f64(+$0);
 $3 = wasm2js_scratch_load_i32(1) | 0;
 $7 = wasm2js_scratch_load_i32(0) | 0;
 $5 = $3 >>> 31;
 label$1 : {
  label$2 : {
   label$3 : {
    label$4 : {
     $4 = $0;
     label$5 : {
      label$6 : {
       $2 = $3;
       $3 = $2 & 2147483647;
       label$7 : {
        if ($3 >>> 0 >= 1082532651) {
         $2 = $2 & 2147483647;
         if (($2 | 0) == 2146435072 & $7 >>> 0 > 0 | $2 >>> 0 > 2146435072) {
          return +$0;
         }
         if (!!($0 > 709.782712893384)) {
          return +($0 * 8.98846567431158e+307);
         }
         if (!($0 < -745.1332191019411) | $0 < -708.3964185322641 ^ 1) {
          break label$7;
         }
         break label$2;
        }
        if ($3 >>> 0 < 1071001155) {
         break label$4;
        }
        if ($3 >>> 0 < 1072734898) {
         break label$6;
        }
       }
       $0 = $0 * 1.4426950408889634 + HEAPF64[($5 << 3) + 141632 >> 3];
       if (Math_abs($0) < 2147483648) {
        $2 = ~~$0;
        break label$5;
       }
       $2 = -2147483648;
       break label$5;
      }
      $2 = ($5 ^ 1) - $5 | 0;
     }
     $1 = +($2 | 0);
     $0 = $4 + $1 * -.6931471803691238;
     $6 = $1 * 1.9082149292705877e-10;
     $4 = $0 - $6;
     break label$3;
    }
    if ($3 >>> 0 <= 1043333120) {
     break label$1;
    }
    $2 = 0;
    $4 = $0;
   }
   $1 = $4;
   $8 = $0;
   $1 = $1 * $1;
   $0 = $4 - $1 * ($1 * ($1 * ($1 * ($1 * 4.1381367970572385e-8 + -16533902205465252e-22) + 6613756321437934e-20) + -.0027777777777015593) + .16666666666666602);
   $1 = $8 + ($4 * $0 / (2 - $0) - $6) + 1;
   if (!$2) {
    break label$2;
   }
   $1 = scalbn($1, $2);
  }
  return +$1;
 }
 return +($0 + 1);
}
function jslLexRegex() {
 var $0 = 0, $1 = 0;
 $1 = global$0 - 48 | 0;
 global$0 = $1;
 $0 = jsvNewWithFlags(27);
 HEAP32[HEAP32[35539] + 76 >> 2] = $0;
 label$1 : {
  if (!HEAP32[HEAP32[35539] + 76 >> 2]) {
   HEAP16[HEAP32[35539] + 2 >> 1] = 0;
   break label$1;
  }
  $0 = $1 + 8 | 0;
  jsvStringIteratorNew($0, HEAP32[HEAP32[35539] + 76 >> 2], 0);
  jsvStringIteratorAppend($0, 47);
  jslGetNextCh();
  while (1) {
   label$4 : {
    if (!(HEAP8[HEAP32[35539]] ? HEAP8[HEAP32[35539]] != 47 : 0)) {
     break label$4;
    }
    label$7 : {
     if (HEAP8[HEAP32[35539]] == 92) {
      jsvStringIteratorAppend($1 + 8 | 0, HEAP8[HEAP32[35539]]);
      jslGetNextCh();
      break label$7;
     }
     if (HEAP8[HEAP32[35539]] == 10) {
      break label$4;
     }
    }
    jsvStringIteratorAppend($1 + 8 | 0, HEAP8[HEAP32[35539]]);
    jslGetNextCh();
    continue;
   }
   break;
  }
  HEAP16[HEAP32[35539] + 2 >> 1] = 135;
  label$9 : {
   if (HEAP8[HEAP32[35539]] != 47) {
    $0 = HEAP32[35539];
    HEAP16[$0 + 2 >> 1] = HEAPU16[$0 + 2 >> 1] + 1;
    break label$9;
   }
   jsvStringIteratorAppend($1 + 8 | 0, 47);
   jslGetNextCh();
   while (1) {
    $0 = 1;
    label$12 : {
     if (HEAP8[HEAP32[35539]] == 103) {
      break label$12;
     }
     $0 = 1;
     if (HEAP8[HEAP32[35539]] == 105) {
      break label$12;
     }
     $0 = 1;
     if (HEAP8[HEAP32[35539]] == 109) {
      break label$12;
     }
     $0 = 1;
     if (HEAP8[HEAP32[35539]] == 121) {
      break label$12;
     }
     $0 = HEAP8[HEAP32[35539]] == 117;
    }
    if ($0) {
     $0 = $1 + 8 | 0;
     jslTokenAppendChar(HEAP8[HEAP32[35539]]);
     jsvStringIteratorAppend($0, HEAP8[HEAP32[35539]]);
     jslGetNextCh();
     continue;
    }
    break;
   }
  }
  jsvStringIteratorFree($1 + 8 | 0);
 }
 global$0 = $1 + 48 | 0;
}
function jspGetNamedFieldInParents($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP8[$3 + 39 | 0] = $2;
 HEAP32[$3 + 32 >> 2] = jspeiFindChildFromStringInParents(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 40 >> 2]);
 if (!HEAP32[$3 + 32 >> 2]) {
  HEAP32[$3 + 32 >> 2] = jswFindBuiltInFunction(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 40 >> 2]);
 }
 if (!(!HEAP32[$3 + 32 >> 2] | !(HEAP8[$3 + 39 | 0] & 1))) {
  if (jsvIsName(HEAP32[$3 + 32 >> 2]) & 1) {
   HEAP32[$3 + 28 >> 2] = jsvGetValueOfName(HEAP32[$3 + 32 >> 2]);
   jsvUnLock(HEAP32[$3 + 32 >> 2]);
   HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 28 >> 2];
  }
  HEAP32[$3 + 24 >> 2] = jsvNewFromString(HEAP32[$3 + 40 >> 2]);
  HEAP32[$3 + 20 >> 2] = jsvCreateNewChild(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 32 >> 2]);
  jsvUnLock2(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 32 >> 2]);
  HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 20 >> 2];
 }
 if (!HEAP32[$3 + 32 >> 2]) {
  label$5 : {
   label$6 : {
    if (!(jsvIsFunction(HEAP32[$3 + 44 >> 2]) & 1)) {
     break label$6;
    }
    if (strcmp(HEAP32[$3 + 40 >> 2], 79516)) {
     break label$6;
    }
    HEAP32[$3 + 16 >> 2] = jsvNewWithFlags(5);
    jsvObjectSetChild(HEAP32[$3 + 16 >> 2], 80199, HEAP32[$3 + 44 >> 2]);
    HEAP32[$3 + 32 >> 2] = jsvAddNamedChild(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 16 >> 2], 79516);
    jspEnsureIsPrototype(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 32 >> 2]);
    jsvUnLock(HEAP32[$3 + 16 >> 2]);
    break label$5;
   }
   if (!strcmp(HEAP32[$3 + 40 >> 2], 79526)) {
    HEAP32[$3 + 12 >> 2] = jswGetBasicObjectName(HEAP32[$3 + 44 >> 2]);
    if (HEAP32[$3 + 12 >> 2]) {
     HEAP32[$3 + 32 >> 2] = jspNewPrototype(HEAP32[$3 + 12 >> 2]);
    }
   }
  }
 }
 global$0 = $3 + 48 | 0;
 return HEAP32[$3 + 32 >> 2];
}
function tflite__MicroInterpreter__MicroInterpreter_28tflite__Model_20const__2c_20tflite__MicroOpResolver_20const__2c_20unsigned_20char__2c_20unsigned_20long_2c_20tflite__ErrorReporter__2c_20tflite__Profiler__29($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = global$0 - 32 | 0;
 global$0 = $6;
 HEAP32[$6 + 28 >> 2] = $0;
 HEAP32[$6 + 24 >> 2] = $1;
 HEAP32[$6 + 20 >> 2] = $2;
 HEAP32[$6 + 16 >> 2] = $3;
 HEAP32[$6 + 12 >> 2] = $4;
 HEAP32[$6 + 8 >> 2] = $5;
 HEAP32[$6 + 4 >> 2] = 0;
 $0 = HEAP32[$6 + 28 >> 2];
 HEAP32[$0 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = HEAP32[$6 + 24 >> 2];
 HEAP32[$0 + 8 >> 2] = HEAP32[$6 + 20 >> 2];
 HEAP32[$0 + 12 >> 2] = HEAP32[$6 + 8 >> 2];
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
 HEAP32[$0 + 32 >> 2] = 0;
 HEAP32[$0 + 36 >> 2] = 0;
 HEAP32[$0 + 40 >> 2] = 0;
 HEAP32[$0 + 44 >> 2] = 0;
 HEAP32[$0 + 48 >> 2] = 0;
 HEAP32[$0 + 52 >> 2] = 0;
 HEAP32[$0 + 56 >> 2] = 0;
 HEAP32[$0 + 60 >> 2] = 0;
 HEAP8[$0 + 64 | 0] = 0;
 HEAP32[$0 + 68 >> 2] = 0;
 HEAP32[$0 + 72 >> 2] = 0;
 HEAP32[$0 + 76 >> 2] = 0;
 HEAP32[$0 + 80 >> 2] = 0;
 HEAP32[$0 + 84 >> 2] = 0;
 HEAP32[$0 + 88 >> 2] = 0;
 HEAP32[$0 + 92 >> 2] = 0;
 HEAP32[$0 + 96 >> 2] = 0;
 HEAP32[$0 + 100 >> 2] = 0;
 HEAP32[$0 + 104 >> 2] = tflite__MicroAllocator__Create_28unsigned_20char__2c_20unsigned_20long_2c_20tflite__ErrorReporter__29(HEAP32[$6 + 16 >> 2], HEAP32[$6 + 12 >> 2], HEAP32[$6 + 8 >> 2]);
 HEAP8[$0 + 108 | 0] = 0;
 HEAP32[$0 + 112 >> 2] = 1;
 HEAP32[$0 + 120 >> 2] = 0;
 FUNCTION_TABLE[604]($0 + 124 | 0, HEAP32[$0 + 12 >> 2], HEAP32[$0 + 104 >> 2], HEAP32[$6 + 24 >> 2]) | 0;
 HEAP32[$0 + 144 >> 2] = 0;
 HEAP32[$0 + 148 >> 2] = 0;
 tflite__MicroInterpreter__Init_28tflite__Profiler__29($0, HEAP32[$6 + 4 >> 2]);
 global$0 = $6 + 32 | 0;
}
function tflite__MicroAllocator__AllocateVariables_28tflite__SubGraph_20const__2c_20TfLiteEvalTensor__29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP32[$3 + 40 >> 2] = $0;
 HEAP32[$3 + 36 >> 2] = $1;
 HEAP32[$3 + 32 >> 2] = $2;
 $0 = HEAP32[$3 + 40 >> 2];
 HEAP32[$3 + 28 >> 2] = 0;
 label$1 : {
  while (1) {
   if (HEAPU32[$3 + 28 >> 2] < flatbuffers__Vector_int___size_28_29_20const(tflite__Tensor__shape_28_29_20const(HEAP32[$3 + 36 >> 2])) >>> 0) {
    HEAP32[$3 + 24 >> 2] = flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph__20___Get_28unsigned_20int_29_20const(tflite__Tensor__shape_28_29_20const(HEAP32[$3 + 36 >> 2]), HEAP32[$3 + 28 >> 2]);
    if (tflite__Tensor__is_variable_28_29_20const(HEAP32[$3 + 24 >> 2]) & 1) {
     HEAP32[$3 + 16 >> 2] = tflite__TfLiteEvalTensorByteLength_28TfLiteEvalTensor_20const__2c_20unsigned_20long__29(HEAP32[$3 + 32 >> 2] + Math_imul(HEAP32[$3 + 28 >> 2], 12) | 0, $3 + 20 | 0);
     if (HEAP32[$3 + 16 >> 2]) {
      HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 16 >> 2];
      break label$1;
     }
     $1 = HEAP32[$0 + 4 >> 2];
     $1 = FUNCTION_TABLE[HEAP32[HEAP32[$1 >> 2] + 12 >> 2]]($1, HEAP32[$3 + 20 >> 2], 16) | 0;
     HEAP32[HEAP32[$3 + 32 >> 2] + Math_imul(HEAP32[$3 + 28 >> 2], 12) >> 2] = $1;
     if (!HEAP32[HEAP32[$3 + 32 >> 2] + Math_imul(HEAP32[$3 + 28 >> 2], 12) >> 2]) {
      $0 = HEAP32[$0 + 8 >> 2];
      HEAP32[$3 >> 2] = HEAP32[$3 + 20 >> 2];
      tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 132634, $3);
      HEAP32[$3 + 44 >> 2] = 1;
      break label$1;
     }
    }
    HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 28 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$3 + 44 >> 2] = 0;
 }
 global$0 = $3 + 48 | 0;
 return HEAP32[$3 + 44 >> 2];
}
function vfDrawCharPtr($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0;
 $7 = global$0 - 240 | 0;
 global$0 = $7;
 HEAP32[$7 + 236 >> 2] = $0;
 HEAP32[$7 + 232 >> 2] = $1;
 HEAP32[$7 + 228 >> 2] = $2;
 HEAP32[$7 + 224 >> 2] = $3;
 HEAP32[$7 + 220 >> 2] = $4;
 HEAP32[$7 + 216 >> 2] = $5;
 HEAP32[$7 + 212 >> 2] = $6;
 HEAP32[$7 + 232 >> 2] = (HEAP32[$7 + 232 >> 2] << 4) - 8;
 HEAP32[$7 + 228 >> 2] = (HEAP32[$7 + 228 >> 2] << 4) - 8;
 HEAP32[$7 + 208 >> 2] = 0;
 HEAP32[$7 + 204 >> 2] = 0;
 while (1) {
  if (HEAP32[$7 + 204 >> 2] < HEAP32[$7 + 212 >> 2]) {
   HEAP32[$7 + 24 >> 2] = vfGetPolyPtr(HEAPU8[HEAP32[$7 + 216 >> 2] + HEAP32[$7 + 204 >> 2] | 0], $7 + 28 | 0);
   HEAP32[$7 + 20 >> 2] = 0;
   while (1) {
    if (HEAP32[$7 + 20 >> 2] < HEAP32[$7 + 28 >> 2]) {
     HEAP8[$7 + 19 | 0] = HEAPU8[HEAP32[$7 + 24 >> 2] + HEAP32[$7 + 20 >> 2] | 0];
     HEAP32[$7 + 12 >> 2] = HEAPU8[$7 + 19 | 0] % 13;
     HEAP32[$7 + 8 >> 2] = HEAPU8[$7 + 19 | 0] / 13;
     if (HEAP32[$7 + 12 >> 2] > HEAP32[$7 + 208 >> 2]) {
      HEAP32[$7 + 208 >> 2] = HEAP32[$7 + 12 >> 2];
     }
     $0 = $7 + 32 | 0;
     HEAP16[$0 + (HEAP32[$7 + 20 >> 2] << 2) >> 1] = HEAP32[$7 + 232 >> 2] + ((Math_imul(HEAP32[$7 + 12 >> 2], HEAP32[$7 + 224 >> 2]) << 4) / 16 | 0);
     HEAP16[$0 + ((HEAP32[$7 + 20 >> 2] << 1) + 1 << 1) >> 1] = HEAP32[$7 + 228 >> 2] + ((Math_imul(HEAP32[$7 + 220 >> 2], HEAP32[$7 + 8 >> 2] + -2 | 0) << 4) / 16 | 0);
     HEAP32[$7 + 20 >> 2] = HEAP32[$7 + 20 >> 2] + 1;
     continue;
    }
    break;
   }
   graphicsFillPoly(HEAP32[$7 + 236 >> 2], HEAP32[$7 + 28 >> 2], $7 + 32 | 0);
   HEAP32[$7 + 204 >> 2] = HEAP32[$7 + 204 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $7 + 240 | 0;
 return ((Math_imul(HEAP32[$7 + 224 >> 2], HEAP32[$7 + 208 >> 2] + 2 | 0) << 4) / 16 | 0) + 7 >> 4;
}
function jsiSoftKill() {
 var $0 = 0, $1 = 0;
 $0 = global$0 + -64 | 0;
 global$0 = $0;
 jsiExecuteEventCallbackOn(81104, 81358, 0, 0);
 HEAP32[80559] = 0;
 jsiInputLineCursorMoved();
 jsvUnLock(HEAP32[80557]);
 HEAP32[80557] = 0;
 jswrap_banglejs_kill();
 jswrap_pipe_kill();
 jswrap_waveform_kill();
 HEAP8[324177] = 0;
 HEAP8[324178] = 0;
 HEAP32[81047] = jshGetSystemTime();
 HEAP32[81046] = 0;
 if (HEAP32[80554]) {
  jsvUnLock(HEAP32[80554]);
  HEAP32[80554] = 0;
 }
 if (HEAPU16[161110]) {
  jsvUnRefRef(HEAPU16[161110]);
  HEAP16[161110] = 0;
 }
 if (HEAPU16[161111]) {
  $1 = $0 + 56 | 0;
  HEAP32[$0 + 60 >> 2] = jsvLock(HEAPU16[161111]);
  jsvObjectIteratorNew($1, HEAP32[$0 + 60 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue($0 + 56 | 0) & 1) {
    $1 = $0 + 56 | 0;
    HEAP32[$0 + 52 >> 2] = jsvObjectIteratorGetValue($1);
    HEAP32[$0 + 48 >> 2] = jsvObjectGetChild(HEAP32[$0 + 52 >> 2], 81100, 0);
    jshPinWatch(jshGetPinFromVar(HEAP32[$0 + 48 >> 2]) & 255, 0);
    jsvUnLock2(HEAP32[$0 + 48 >> 2], HEAP32[$0 + 52 >> 2]);
    jsvObjectIteratorNext($1);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree($0 + 56 | 0);
  jsvUnRef(HEAP32[$0 + 60 >> 2]);
  jsvUnLock(HEAP32[$0 + 60 >> 2]);
  HEAP16[161111] = 0;
 }
 if (HEAPU8[142160]) {
  jsvObjectSetChildAndUnLock(HEAP32[80546], 81089, jsvNewFromInteger(HEAPU8[142160]));
 }
 HEAP32[$0 + 44 >> 2] = jsvNewWithFlags(27);
 if (HEAP32[$0 + 44 >> 2]) {
  $1 = $0 + 8 | 0;
  jsvStringIteratorNew($1, HEAP32[$0 + 44 >> 2], 0);
  jsiDumpHardwareInitialisation(2, $1, 0);
  jsvStringIteratorFree($1);
  jsvObjectSetChild(HEAP32[80546], 81095, HEAP32[$0 + 44 >> 2]);
  jsvUnLock(HEAP32[$0 + 44 >> 2]);
 }
 HEAP16[161112] = HEAPU16[161112] & -2049;
 HEAP16[161112] = HEAPU16[161112] & -4097;
 global$0 = $0 - -64 | 0;
}
function tflite__ops__micro__pooling___28anonymous_20namespace_29__MaxEvalFloat_28TfLiteContext__2c_20TfLiteNode__2c_20TfLitePoolParams__2c_20tflite__ops__micro__pooling___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = global$0 - 128 | 0;
 global$0 = $6;
 HEAP32[$6 + 124 >> 2] = $0;
 HEAP32[$6 + 120 >> 2] = $1;
 HEAP32[$6 + 116 >> 2] = $2;
 HEAP32[$6 + 112 >> 2] = $3;
 HEAP32[$6 + 108 >> 2] = $4;
 HEAP32[$6 + 104 >> 2] = $5;
 HEAP32[$6 + 68 >> 2] = HEAP32[HEAP32[$6 + 116 >> 2] + 8 >> 2];
 HEAP32[$6 + 72 >> 2] = HEAP32[HEAP32[$6 + 116 >> 2] + 4 >> 2];
 HEAP32[$6 + 76 >> 2] = HEAP32[HEAP32[$6 + 116 >> 2] + 16 >> 2];
 HEAP32[$6 + 80 >> 2] = HEAP32[HEAP32[$6 + 116 >> 2] + 12 >> 2];
 HEAP16[$6 + 60 >> 1] = HEAP32[HEAP32[$6 + 112 >> 2] + 4 >> 2];
 HEAP16[$6 + 58 >> 1] = HEAP32[HEAP32[$6 + 112 >> 2] >> 2];
 HEAPF32[$6 + 92 >> 2] = HEAPF32[HEAP32[$6 + 112 >> 2] + 24 >> 2];
 HEAPF32[$6 + 96 >> 2] = HEAPF32[HEAP32[$6 + 112 >> 2] + 28 >> 2];
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($6 + 32 | 0, HEAP32[$6 + 108 >> 2]);
 $0 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$6 + 108 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($6, HEAP32[$6 + 104 >> 2]);
 tflite__reference_ops__MaxPool_28tflite__PoolParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($6 + 56 | 0, $6 + 32 | 0, $0, $6, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$6 + 104 >> 2]));
 $0 = $6 + 32 | 0;
 tflite__RuntimeShape___RuntimeShape_28_29($6);
 tflite__RuntimeShape___RuntimeShape_28_29($0);
 global$0 = $6 + 128 | 0;
}
function jswrap_array_reverse($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 144 | 0;
 global$0 = $1;
 HEAP32[$1 + 136 >> 2] = $0;
 label$1 : {
  label$2 : {
   if (jsvIsIterable(HEAP32[$1 + 136 >> 2]) & 1) {
    if (!(jsvIsObject(HEAP32[$1 + 136 >> 2]) & 1)) {
     break label$2;
    }
   }
   HEAP32[$1 + 140 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 132 >> 2] = 0;
  label$4 : {
   if (jsvIsArray(HEAP32[$1 + 136 >> 2]) & 1) {
    jsvIteratorNew($1 + 72 | 0, HEAP32[$1 + 136 >> 2], 0);
    while (1) {
     if (jsvIteratorHasElement($1 + 72 | 0) & 1) {
      HEAP32[$1 + 68 >> 2] = jsvIteratorGetKey($1 + 72 | 0);
      if (jsvIsInt(HEAP32[$1 + 68 >> 2]) & 1) {
       HEAP32[$1 + 132 >> 2] = HEAP32[$1 + 132 >> 2] + 1;
      }
      $0 = $1 + 72 | 0;
      jsvUnLock(HEAP32[$1 + 68 >> 2]);
      jsvIteratorNext($0);
      continue;
     }
     break;
    }
    jsvIteratorFree($1 + 72 | 0);
    break label$4;
   }
   HEAP32[$1 + 132 >> 2] = jsvGetLength(HEAP32[$1 + 136 >> 2]);
  }
  jsvIteratorNew($1 + 8 | 0, HEAP32[$1 + 136 >> 2], 0);
  if (HEAP32[$1 + 132 >> 2] > 1) {
   _jswrap_array_reverse_block(HEAP32[$1 + 136 >> 2], $1 + 8 | 0, HEAP32[$1 + 132 >> 2]);
  }
  if (jsvIsArray(HEAP32[$1 + 136 >> 2]) & 1) {
   HEAP32[$1 + 4 >> 2] = jsvGetArrayLength(HEAP32[$1 + 136 >> 2]) - 1;
   while (1) {
    if (jsvIteratorHasElement($1 + 8 | 0) & 1) {
     $0 = $1 + 8 | 0;
     HEAP32[$1 >> 2] = jsvIteratorGetKey($0);
     jsvSetInteger(HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2] - jsvGetInteger(HEAP32[$1 >> 2]) | 0);
     jsvUnLock(HEAP32[$1 >> 2]);
     jsvIteratorNext($0);
     continue;
    }
    break;
   }
  }
  jsvIteratorFree($1 + 8 | 0);
  HEAP32[$1 + 140 >> 2] = jsvLockAgain(HEAP32[$1 + 136 >> 2]);
 }
 global$0 = $1 + 144 | 0;
 return HEAP32[$1 + 140 >> 2];
}
function jspeFactorArray() {
 var $0 = 0;
 $0 = global$0 - 32 | 0;
 global$0 = $0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 label$1 : {
  if ((HEAP32[80549] & 63) == 1) {
   HEAP32[$0 + 20 >> 2] = jsvNewWithFlags(3);
   if (!HEAP32[$0 + 20 >> 2]) {
    jspSetError();
    HEAP32[$0 + 28 >> 2] = 0;
    break label$1;
   }
  }
  if (!(jslMatch(91) & 1)) {
   HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 20 >> 2];
   break label$1;
  }
  while (1) {
   if (HEAP32[80549] & 80 ? 0 : HEAP16[HEAP32[35539] + 2 >> 1] != 93) {
    label$9 : {
     if ((HEAP32[80549] & 63) == 1) {
      HEAP32[$0 + 16 >> 2] = 0;
      HEAP32[$0 + 12 >> 2] = 0;
      if (HEAP16[HEAP32[35539] + 2 >> 1] != 44) {
       HEAP32[$0 + 16 >> 2] = jsvSkipNameAndUnLock(__jspeAssignmentExpression(jspeConditionalExpression()));
       HEAP32[$0 + 12 >> 2] = jsvMakeIntoVariableName(jsvNewFromInteger(HEAP32[$0 + 24 >> 2]), HEAP32[$0 + 16 >> 2]);
      }
      if (HEAP32[$0 + 12 >> 2]) {
       jsvAddName(HEAP32[$0 + 20 >> 2], HEAP32[$0 + 12 >> 2]);
       jsvUnLock(HEAP32[$0 + 12 >> 2]);
      }
      jsvUnLock(HEAP32[$0 + 16 >> 2]);
      break label$9;
     }
     jsvUnLock(__jspeAssignmentExpression(jspeConditionalExpression()));
    }
    if (HEAP16[HEAP32[35539] + 2 >> 1] != 93) {
     if (!(jslMatch(44) & 1)) {
      HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 20 >> 2];
      break label$1;
     }
    }
    HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 24 >> 2] + 1;
    continue;
   }
   break;
  }
  if (HEAP32[$0 + 20 >> 2]) {
   jsvSetArrayLength(HEAP32[$0 + 20 >> 2], HEAP32[$0 + 24 >> 2]);
  }
  if (!(jslMatch(93) & 1)) {
   HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 20 >> 2];
   break label$1;
  }
  HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 20 >> 2];
 }
 global$0 = $0 + 32 | 0;
 return HEAP32[$0 + 28 >> 2];
}
function jswrap_arraybufferview_subarray($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 label$1 : {
  if (!(jsvIsArrayBuffer(HEAP32[$3 + 24 >> 2]) & 1)) {
   jsExceptionHere(1, 119456, 0);
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = jsvGetInteger(HEAP32[$3 + 16 >> 2]);
  if (!(jsvIsNumeric(HEAP32[$3 + 16 >> 2]) & 1)) {
   HEAP32[$3 + 12 >> 2] = jsvGetArrayBufferLength(HEAP32[$3 + 24 >> 2]);
  }
  if (HEAP32[$3 + 20 >> 2] < 0) {
   HEAP32[$3 + 20 >> 2] = jsvGetArrayBufferLength(HEAP32[$3 + 24 >> 2]) + HEAP32[$3 + 20 >> 2];
  }
  if (HEAP32[$3 + 12 >> 2] < 0) {
   HEAP32[$3 + 12 >> 2] = jsvGetArrayBufferLength(HEAP32[$3 + 24 >> 2]) + HEAP32[$3 + 12 >> 2];
  }
  if (HEAP32[$3 + 12 >> 2] < 0) {
   HEAP32[$3 + 12 >> 2] = 0;
  }
  if (HEAP32[$3 + 20 >> 2] > HEAP32[$3 + 12 >> 2]) {
   HEAP32[$3 + 20 >> 2] = 0;
   HEAP32[$3 + 12 >> 2] = 0;
  }
  $0 = HEAP32[$3 + 24 >> 2];
  HEAP16[$3 + 10 >> 1] = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8;
  if (HEAP32[$3 + 20 >> 2] == HEAP32[$3 + 12 >> 2]) {
   HEAP32[$3 + 28 >> 2] = jsvNewTypedArray(HEAPU16[$3 + 10 >> 1], 0);
   break label$1;
  }
  HEAP32[$3 + 4 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$3 + 24 >> 2]) & 65535);
  $0 = HEAP32[$3 + 24 >> 2];
  HEAP32[$3 >> 2] = jswrap_typedarray_constructor(HEAPU16[$3 + 10 >> 1], HEAP32[$3 + 4 >> 2], Math_imul(HEAP32[$3 + 20 >> 2], HEAPU16[$3 + 10 >> 1] & 15) + (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8) | 0, HEAP32[$3 + 12 >> 2] - HEAP32[$3 + 20 >> 2] | 0);
  jsvUnLock(HEAP32[$3 + 4 >> 2]);
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 >> 2];
 }
 global$0 = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}
function jswrap_tensorflow_create($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 label$1 : {
  if (HEAP32[$2 + 40 >> 2] < 512) {
   jsExceptionHere(1, 128526, 0);
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 32 >> 2] = 0;
  HEAP32[$2 + 28 >> 2] = jsvGetDataPointer(HEAP32[$2 + 36 >> 2], $2 + 32 | 0);
  if (!HEAP32[$2 + 28 >> 2]) {
   jsExceptionHere(3, 128545, 0);
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 24 >> 2] = jspNewObject(0, 128584);
  if (!HEAP32[$2 + 24 >> 2]) {
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  $1 = HEAP32[$2 + 28 >> 2];
  $0 = global$0 - 16 | 0;
  HEAP32[$0 + 12 >> 2] = HEAP32[$2 + 40 >> 2];
  HEAP32[$0 + 8 >> 2] = $1;
  HEAP32[$2 + 20 >> 2] = HEAP32[$0 + 12 >> 2] + 560;
  HEAP32[$2 + 16 >> 2] = jsvNewFlatStringOfLength(HEAP32[$2 + 20 >> 2] + 15 | 0);
  if (!HEAP32[$2 + 16 >> 2]) {
   jsExceptionHere(1, 128603, 0);
   jsvUnLock(HEAP32[$2 + 24 >> 2]);
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  if (!jsvGetDataPointer(HEAP32[$2 + 16 >> 2], $2 + 20 | 0)) {
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  jsvObjectSetChild(HEAP32[$2 + 24 >> 2], 128648, HEAP32[$2 + 36 >> 2]);
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 128484, HEAP32[$2 + 16 >> 2]);
  HEAP32[$2 + 12 >> 2] = jswrap_tfmicrointerpreter_getTFMI(HEAP32[$2 + 24 >> 2]);
  if (!(tf_create(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 40 >> 2], HEAP32[$2 + 28 >> 2]) & 1)) {
   jsExceptionHere(1, 128654, 0);
   jsvUnLock(HEAP32[$2 + 24 >> 2]);
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 24 >> 2];
 }
 global$0 = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}
function jswrap_math_pow($0, $1) {
 $0 = +$0;
 $1 = +$1;
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAPF64[$2 + 32 >> 3] = $0;
 HEAPF64[$2 + 24 >> 3] = $1;
 $4 = $2;
 $0 = HEAPF64[$2 + 24 >> 3];
 label$1 : {
  if (Math_abs($0) < 2147483648) {
   $3 = ~~$0;
   break label$1;
  }
  $3 = -2147483648;
 }
 HEAP32[$4 + 12 >> 2] = $3;
 label$3 : {
  if (!(HEAP32[$2 + 12 >> 2] < 0 | HEAP32[$2 + 12 >> 2] >= 10 | +HEAP32[$2 + 12 >> 2] != HEAPF64[$2 + 24 >> 3])) {
   if (!HEAP32[$2 + 12 >> 2]) {
    HEAPF64[$2 + 40 >> 3] = 1;
    break label$3;
   }
   HEAPF64[$2 + 16 >> 3] = HEAPF64[$2 + 32 >> 3];
   while (1) {
    if (HEAP32[$2 + 12 >> 2] > 1) {
     HEAPF64[$2 + 16 >> 3] = HEAPF64[$2 + 16 >> 3] * HEAPF64[$2 + 32 >> 3];
     HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + -1;
     continue;
    }
    break;
   }
   HEAPF64[$2 + 40 >> 3] = HEAPF64[$2 + 16 >> 3];
   break label$3;
  }
  label$8 : {
   label$9 : {
    if (!(HEAPF64[$2 + 32 >> 3] < 0)) {
     break label$9;
    }
    if (jswrap_math_mod(HEAPF64[$2 + 24 >> 3], 1) != 0) {
     break label$9;
    }
    label$10 : {
     if (jswrap_math_mod(HEAPF64[$2 + 24 >> 3], 2) == 0) {
      HEAPF64[$2 + 16 >> 3] = exp(log(-HEAPF64[$2 + 32 >> 3]) * HEAPF64[$2 + 24 >> 3]);
      break label$10;
     }
     HEAPF64[$2 + 16 >> 3] = -exp(log(-HEAPF64[$2 + 32 >> 3]) * HEAPF64[$2 + 24 >> 3]);
    }
    break label$8;
   }
   label$12 : {
    if (!(0 >= HEAPF64[$2 + 24 >> 3] ? 0 : HEAPF64[$2 + 32 >> 3] == 0)) {
     HEAPF64[$2 + 16 >> 3] = exp(log(HEAPF64[$2 + 32 >> 3]) * HEAPF64[$2 + 24 >> 3]);
     break label$12;
    }
    HEAPF64[$2 + 16 >> 3] = 0;
   }
  }
  HEAPF64[$2 + 40 >> 3] = HEAPF64[$2 + 16 >> 3];
 }
 global$0 = $2 + 48 | 0;
 return +HEAPF64[$2 + 40 >> 3];
}
function st_step_search($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP16[$1 + 22 >> 1] = get_input_buffer_size(HEAP32[$1 + 24 >> 2]);
 HEAP32[(global$0 - 16 | 0) + 12 >> 2] = HEAP32[$1 + 24 >> 2];
 HEAP16[$1 + 20 >> 1] = 64;
 HEAP16[$1 + 18 >> 1] = HEAPU16[HEAP32[$1 + 24 >> 2] + 2 >> 1];
 HEAP8[$1 + 17 | 0] = (is_finishing(HEAP32[$1 + 24 >> 2]) | 0) != 0;
 $0 = HEAPU16[$1 + 18 >> 1];
 $3 = HEAPU16[HEAP32[$1 + 24 >> 2] >> 1];
 if (HEAP8[$1 + 17 | 0] & 1) {
  $2 = 1;
 } else {
  $2 = HEAPU16[$1 + 20 >> 1];
 }
 label$1 : {
  if (($0 | 0) > ($3 - $2 | 0)) {
   HEAP32[$1 + 28 >> 2] = HEAP8[$1 + 17 | 0] & 1 ? 8 : 7;
   break label$1;
  }
  HEAP16[$1 + 14 >> 1] = get_input_offset(HEAP32[$1 + 24 >> 2]);
  HEAP16[$1 + 12 >> 1] = HEAPU16[$1 + 14 >> 1] + HEAPU16[$1 + 18 >> 1];
  HEAP16[$1 + 10 >> 1] = HEAPU16[$1 + 12 >> 1] - HEAPU16[$1 + 22 >> 1];
  HEAP16[$1 + 8 >> 1] = HEAPU16[$1 + 20 >> 1];
  if ((HEAPU16[HEAP32[$1 + 24 >> 2] >> 1] - HEAPU16[$1 + 18 >> 1] | 0) < HEAPU16[$1 + 20 >> 1]) {
   HEAP16[$1 + 8 >> 1] = HEAPU16[HEAP32[$1 + 24 >> 2] >> 1] - HEAPU16[$1 + 18 >> 1];
  }
  HEAP16[$1 + 6 >> 1] = 0;
  HEAP16[$1 + 4 >> 1] = find_longest_match(HEAP32[$1 + 24 >> 2], HEAPU16[$1 + 10 >> 1], HEAPU16[$1 + 12 >> 1], HEAPU16[$1 + 8 >> 1], $1 + 6 | 0);
  if (HEAPU16[$1 + 4 >> 1] == 65535) {
   $0 = HEAP32[$1 + 24 >> 2];
   HEAP16[$0 + 2 >> 1] = HEAPU16[$0 + 2 >> 1] + 1;
   HEAP16[HEAP32[$1 + 24 >> 2] + 4 >> 1] = 0;
   HEAP32[$1 + 28 >> 2] = 3;
   break label$1;
  }
  HEAP16[HEAP32[$1 + 24 >> 2] + 6 >> 1] = HEAPU16[$1 + 4 >> 1];
  HEAP16[HEAP32[$1 + 24 >> 2] + 4 >> 1] = HEAPU16[$1 + 6 >> 1];
  HEAP32[$1 + 28 >> 2] = 3;
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function jswrap_serial_setup($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP32[$3 + 36 >> 2] = $2;
 HEAP8[$3 + 35 | 0] = jsiGetDeviceFromClass(HEAP32[$3 + 44 >> 2]);
 label$1 : {
  if (jsvIsUndefined(HEAP32[$3 + 36 >> 2]) & 1) {
   HEAP32[$3 + 36 >> 2] = jsvObjectGetChild(HEAP32[$3 + 44 >> 2], 125456, 0);
   break label$1;
  }
  jsvLockAgain(HEAP32[$3 + 36 >> 2]);
 }
 HEAP8[$3 + 15 | 0] = jsserialPopulateUSARTInfo($3 + 16 | 0, HEAP32[$3 + 40 >> 2], HEAP32[$3 + 36 >> 2]) & 1;
 label$3 : {
  if (!(HEAP8[$3 + 15 | 0] & 1)) {
   jsvUnLock(HEAP32[$3 + 36 >> 2]);
   break label$3;
  }
  jsvObjectSetChildAndUnLock(HEAP32[$3 + 44 >> 2], 125465, jsvNewFromInteger(HEAPU8[$3 + 16 | 0] | HEAPU8[$3 + 17 | 0] << 8 | (HEAPU8[$3 + 18 | 0] << 16 | HEAPU8[$3 + 19 | 0] << 24)));
  label$5 : {
   if (HEAP32[$3 + 36 >> 2]) {
    jsvObjectSetChildAndUnLock(HEAP32[$3 + 44 >> 2], 125456, HEAP32[$3 + 36 >> 2]);
    break label$5;
   }
   jsvObjectRemoveChild(HEAP32[$3 + 44 >> 2], 125456);
  }
  if (!(HEAPU8[$3 + 35 | 0] < 17 | HEAPU8[$3 + 35 | 0] > 22)) {
   if (!(HEAPU8[$3 + 35 | 0] < 22 | HEAPU8[$3 + 35 | 0] > 22)) {
    jshUSARTSetup(HEAPU8[$3 + 35 | 0], $3 + 16 | 0);
   }
   break label$3;
  }
  if (!HEAPU8[$3 + 35 | 0]) {
   if (HEAPU8[$3 + 21 | 0] != 255) {
    jshPinSetState(HEAPU8[$3 + 21 | 0], 1);
    jshPinOutput(HEAPU8[$3 + 21 | 0], 1);
   }
   if (HEAPU8[$3 + 20 | 0] != 255) {
    $0 = $3 + 16 | 0;
    jshPinSetState(HEAPU8[$3 + 20 | 0], 5);
    jsserialEventCallbackInit(HEAP32[$3 + 44 >> 2], $0);
   }
   if (HEAPU8[$3 + 22 | 0] != 255) {
    jsExceptionHere(1, 125475, 0);
   }
  }
 }
 global$0 = $3 + 48 | 0;
}
function jswrap_string_padX($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 global$0 = $4;
 HEAP32[$4 + 24 >> 2] = $0;
 HEAP32[$4 + 20 >> 2] = $1;
 HEAP32[$4 + 16 >> 2] = $2;
 HEAP8[$4 + 15 | 0] = $3;
 label$1 : {
  label$2 : {
   if (jsvIsString(HEAP32[$4 + 24 >> 2]) & 1) {
    if ((jsvGetStringLength(HEAP32[$4 + 24 >> 2]) | 0) < HEAP32[$4 + 20 >> 2]) {
     break label$2;
    }
   }
   HEAP32[$4 + 28 >> 2] = jsvLockAgain(HEAP32[$4 + 24 >> 2]);
   break label$1;
  }
  HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 20 >> 2] - jsvGetStringLength(HEAP32[$4 + 24 >> 2]);
  $0 = $4;
  label$4 : {
   if (HEAP8[$4 + 15 | 0] & 1) {
    $1 = jsvNewWithFlags(27);
    break label$4;
   }
   $1 = jsvNewFromStringVar(HEAP32[$4 + 24 >> 2], 0, 2147483647);
  }
  HEAP32[$0 + 4 >> 2] = $1;
  if (!HEAP32[$4 + 4 >> 2]) {
   HEAP32[$4 + 28 >> 2] = 0;
   break label$1;
  }
  $0 = $4;
  label$7 : {
   if (HEAP32[$4 + 16 >> 2]) {
    $1 = jsvAsString(HEAP32[$4 + 16 >> 2]);
    break label$7;
   }
   $1 = jsvNewFromString(126049);
  }
  HEAP32[$0 + 16 >> 2] = $1;
  HEAP32[$4 >> 2] = jsvGetStringLength(HEAP32[$4 + 16 >> 2]);
  while (1) {
   if (HEAP32[$4 + 8 >> 2] > 0) {
    $0 = HEAP32[$4 + 4 >> 2];
    $1 = HEAP32[$4 + 16 >> 2];
    if (HEAP32[$4 >> 2] > HEAP32[$4 + 8 >> 2]) {
     $2 = HEAP32[$4 + 8 >> 2];
    } else {
     $2 = HEAP32[$4 >> 2];
    }
    jsvAppendStringVar($0, $1, 0, $2);
    HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 8 >> 2] - HEAP32[$4 >> 2];
    continue;
   }
   break;
  }
  if (HEAP8[$4 + 15 | 0] & 1) {
   jsvAppendStringVarComplete(HEAP32[$4 + 4 >> 2], HEAP32[$4 + 24 >> 2]);
  }
  jsvUnLock(HEAP32[$4 + 16 >> 2]);
  HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 4 >> 2];
 }
 global$0 = $4 + 32 | 0;
 return HEAP32[$4 + 28 >> 2];
}
function jsvArrayBufferIteratorSetValue($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 label$1 : {
  if (!HEAPU16[HEAP32[$2 + 28 >> 2] + 36 >> 1]) {
   break label$1;
  }
  HEAP32[$2 + 8 >> 2] = HEAPU16[HEAP32[$2 + 28 >> 2] + 36 >> 1] & 15;
  label$2 : {
   if (HEAPU16[HEAP32[$2 + 28 >> 2] + 36 >> 1] & 32) {
    jsvArrayBufferIteratorFloatToData($2 + 16 | 0, HEAP32[$2 + 8 >> 2], HEAPU16[HEAP32[$2 + 28 >> 2] + 36 >> 1], jsvGetFloat(HEAP32[$2 + 24 >> 2]));
    break label$2;
   }
   jsvArrayBufferIteratorIntToData($2 + 16 | 0, HEAP32[$2 + 8 >> 2], HEAPU16[HEAP32[$2 + 28 >> 2] + 36 >> 1], jsvGetInteger(HEAP32[$2 + 24 >> 2]));
  }
  label$4 : {
   if (HEAPU16[HEAP32[$2 + 28 >> 2] + 36 >> 1] & 256) {
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 8 >> 2] - 1;
    while (1) {
     if (HEAP32[$2 + 12 >> 2] >= 0) {
      jsvStringIteratorSetChar(HEAP32[$2 + 28 >> 2], HEAP8[HEAP32[$2 + 12 >> 2] + ($2 + 16 | 0) | 0]);
      if (HEAP32[$2 + 8 >> 2] != 1) {
       jsvStringIteratorNext(HEAP32[$2 + 28 >> 2]);
      }
      HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + -1;
      continue;
     }
     break;
    }
    break label$4;
   }
   HEAP32[$2 + 12 >> 2] = 0;
   while (1) {
    if (HEAP32[$2 + 12 >> 2] < HEAP32[$2 + 8 >> 2]) {
     jsvStringIteratorSetChar(HEAP32[$2 + 28 >> 2], HEAP8[HEAP32[$2 + 12 >> 2] + ($2 + 16 | 0) | 0]);
     if (HEAP32[$2 + 8 >> 2] != 1) {
      jsvStringIteratorNext(HEAP32[$2 + 28 >> 2]);
     }
     HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
     continue;
    }
    break;
   }
  }
  if (HEAP32[$2 + 8 >> 2] == 1) {
   break label$1;
  }
  HEAP8[HEAP32[$2 + 28 >> 2] + 52 | 0] = 1;
 }
 global$0 = $2 + 32 | 0;
}
function jswrap_e_dumpFragmentation() {
 var $0 = 0, $1 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 0;
 while (1) {
  if (HEAPU32[$0 + 8 >> 2] < HEAPU32[35415]) {
   HEAP32[$0 + 4 >> 2] = _jsvGetAddressOf(HEAP32[$0 + 8 >> 2] + 1 & 65535);
   $1 = HEAP32[$0 + 4 >> 2];
   label$3 : {
    if (!((HEAPU8[$1 + 13 | 0] | HEAPU8[$1 + 14 | 0] << 8) & 63)) {
     jsiConsolePrintString(120514);
     $1 = HEAP32[$0 + 12 >> 2];
     HEAP32[$0 + 12 >> 2] = $1 + 1;
     if (($1 | 0) > 80) {
      jsiConsolePrintString(120516);
      HEAP32[$0 + 12 >> 2] = 0;
     }
     break label$3;
    }
    label$6 : {
     if (jsvGetLocks(HEAP32[$0 + 4 >> 2]) & 255) {
      jsiConsolePrintString(120518);
      break label$6;
     }
     jsiConsolePrintString(120520);
    }
    $1 = HEAP32[$0 + 12 >> 2];
    HEAP32[$0 + 12 >> 2] = $1 + 1;
    if (($1 | 0) > 80) {
     jsiConsolePrintString(120516);
     HEAP32[$0 + 12 >> 2] = 0;
    }
    if (jsvIsFlatString(HEAP32[$0 + 4 >> 2]) & 1) {
     HEAP32[$0 >> 2] = jsvGetFlatStringBlocks(HEAP32[$0 + 4 >> 2]);
     HEAP32[$0 + 8 >> 2] = HEAP32[$0 >> 2] + HEAP32[$0 + 8 >> 2];
     while (1) {
      label$11 : {
       $1 = HEAP32[$0 >> 2];
       HEAP32[$0 >> 2] = $1 + -1;
       if (!$1) {
        break label$11;
       }
       jsiConsolePrintString(120522);
       $1 = HEAP32[$0 + 12 >> 2];
       HEAP32[$0 + 12 >> 2] = $1 + 1;
       if (($1 | 0) > 80) {
        jsiConsolePrintString(120516);
        HEAP32[$0 + 12 >> 2] = 0;
       }
       continue;
      }
      break;
     }
    }
   }
   HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 8 >> 2] + 1;
   continue;
  }
  break;
 }
 jsiConsolePrintString(120516);
 global$0 = $0 + 16 | 0;
}
function _jswrap_graphics_getRect($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 128 | 0;
 global$0 = $5;
 HEAP32[$5 + 124 >> 2] = $0;
 HEAP32[$5 + 120 >> 2] = $1;
 HEAP32[$5 + 116 >> 2] = $2;
 HEAP32[$5 + 112 >> 2] = $3;
 HEAP32[$5 + 108 >> 2] = $4;
 label$1 : {
  if (jsvIsObject(HEAP32[$5 + 124 >> 2]) & 1) {
   HEAP32[$5 + 104 >> 2] = -1;
   HEAP32[$5 + 100 >> 2] = -1;
   HEAP32[$5 >> 2] = 127462;
   HEAP16[$5 + 4 >> 1] = 9;
   HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 120 >> 2];
   HEAP32[$5 + 12 >> 2] = 127464;
   HEAP16[$5 + 16 >> 1] = 9;
   HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 116 >> 2];
   HEAP32[$5 + 24 >> 2] = 127466;
   HEAP16[$5 + 28 >> 1] = 9;
   HEAP32[$5 + 32 >> 2] = HEAP32[$5 + 120 >> 2];
   HEAP32[$5 + 36 >> 2] = 127469;
   HEAP16[$5 + 40 >> 1] = 9;
   HEAP32[$5 + 44 >> 2] = HEAP32[$5 + 116 >> 2];
   HEAP32[$5 + 48 >> 2] = 127472;
   HEAP16[$5 + 52 >> 1] = 9;
   HEAP32[$5 + 56 >> 2] = HEAP32[$5 + 112 >> 2];
   HEAP32[$5 + 60 >> 2] = 127475;
   HEAP16[$5 + 64 >> 1] = 9;
   HEAP32[$5 + 68 >> 2] = HEAP32[$5 + 108 >> 2];
   HEAP32[$5 + 72 >> 2] = 127478;
   HEAP16[$5 + 76 >> 1] = 9;
   HEAP32[$5 + 80 >> 2] = $5 + 104;
   HEAP32[$5 + 84 >> 2] = 127480;
   HEAP16[$5 + 88 >> 1] = 9;
   HEAP32[$5 + 92 >> 2] = $5 + 100;
   jsvReadConfigObject(HEAP32[$5 + 124 >> 2], $5, 8);
   if (HEAP32[$5 + 104 >> 2] >= 0) {
    HEAP32[HEAP32[$5 + 112 >> 2] >> 2] = HEAP32[HEAP32[$5 + 120 >> 2] >> 2] + HEAP32[$5 + 104 >> 2];
   }
   if (HEAP32[$5 + 100 >> 2] >= 0) {
    HEAP32[HEAP32[$5 + 108 >> 2] >> 2] = HEAP32[HEAP32[$5 + 116 >> 2] >> 2] + HEAP32[$5 + 104 >> 2];
   }
   break label$1;
  }
  $0 = jsvGetInteger(HEAP32[$5 + 124 >> 2]);
  HEAP32[HEAP32[$5 + 120 >> 2] >> 2] = $0;
 }
 global$0 = $5 + 128 | 0;
}
function tflite__QuantizeMultiplier_28double_2c_20int__2c_20int__29($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAPF64[$3 + 24 >> 3] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 label$1 : {
  if (HEAPF64[$3 + 24 >> 3] == 0) {
   HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 0;
   HEAP32[HEAP32[$3 + 16 >> 2] >> 2] = 0;
   break label$1;
  }
  HEAPF64[$3 + 8 >> 3] = frexp(HEAPF64[$3 + 24 >> 3], HEAP32[$3 + 16 >> 2]);
  $1 = $3;
  $5 = $3;
  $0 = double_20tflite__TfLiteRound_double__28double_29(HEAPF64[$3 + 8 >> 3] * 2147483648);
  label$3 : {
   if (Math_abs($0) < 0x8000000000000000) {
    $2 = Math_abs($0) >= 1 ? $0 > 0 ? ~~Math_min(Math_floor($0 / 4294967296), 4294967295) >>> 0 : ~~Math_ceil(($0 - +(~~$0 >>> 0 >>> 0)) / 4294967296) >>> 0 : 0;
    $4 = ~~$0 >>> 0;
    break label$3;
   }
   $2 = -2147483648;
   $4 = 0;
  }
  HEAP32[$5 >> 2] = $4;
  HEAP32[$1 + 4 >> 2] = $2;
  $1 = HEAP32[$3 + 4 >> 2];
  if (($1 | 0) > 0 ? 1 : ($1 | 0) >= 0 ? HEAPU32[$3 >> 2] <= 2147483648 ? 0 : 1 : 0) {
   abort();
   abort();
  }
  if (!HEAP32[$3 + 4 >> 2] & HEAP32[$3 >> 2] == -2147483648) {
   HEAP32[$3 >> 2] = __wasm_i64_sdiv(HEAP32[$3 >> 2], HEAP32[$3 + 4 >> 2], 2);
   HEAP32[$3 + 4 >> 2] = i64toi32_i32$HIGH_BITS;
   $1 = HEAP32[$3 + 16 >> 2];
   HEAP32[$1 >> 2] = HEAP32[$1 >> 2] + 1;
  }
  $1 = HEAP32[$3 + 4 >> 2];
  if (($1 | 0) > 0 ? 1 : ($1 | 0) >= 0 ? HEAPU32[$3 >> 2] <= 2147483647 ? 0 : 1 : 0) {
   abort();
   abort();
  }
  if (HEAP32[HEAP32[$3 + 16 >> 2] >> 2] < -31) {
   HEAP32[HEAP32[$3 + 16 >> 2] >> 2] = 0;
   HEAP32[$3 >> 2] = 0;
   HEAP32[$3 + 4 >> 2] = 0;
  }
  HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = HEAP32[$3 >> 2];
 }
 global$0 = $3 + 32 | 0;
}
function jswrap_banglejs_beep($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 if (HEAP32[$2 + 20 >> 2] <= 0) {
  HEAP32[$2 + 20 >> 2] = 4e3;
 }
 if (HEAP32[$2 + 20 >> 2] > 6e4) {
  HEAP32[$2 + 20 >> 2] = 6e4;
 }
 if (HEAP32[$2 + 24 >> 2] <= 0) {
  HEAP32[$2 + 24 >> 2] = 200;
 }
 if (HEAP32[$2 + 24 >> 2] > 5e3) {
  HEAP32[$2 + 24 >> 2] = 5e3;
 }
 label$5 : {
  if (HEAP32[84190]) {
   HEAP32[$2 + 16 >> 2] = jsvNewNativeFunction(137, 289);
   HEAP32[$2 + 12 >> 2] = jsvNewFromInteger(HEAP32[$2 + 24 >> 2]);
   jsvAddFunctionParameter(HEAP32[$2 + 16 >> 2], 0, HEAP32[$2 + 12 >> 2]);
   jsvUnLock(HEAP32[$2 + 12 >> 2]);
   HEAP32[$2 + 12 >> 2] = jsvNewFromInteger(HEAP32[$2 + 20 >> 2]);
   jsvAddFunctionParameter(HEAP32[$2 + 16 >> 2], 0, HEAP32[$2 + 12 >> 2]);
   jsvUnLock(HEAP32[$2 + 12 >> 2]);
   HEAP32[$2 + 8 >> 2] = jswrap_promise_then(HEAP32[84190], HEAP32[$2 + 16 >> 2], 0);
   jsvUnLock(HEAP32[$2 + 16 >> 2]);
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 8 >> 2];
   break label$5;
  }
  HEAP32[84190] = jspromise_create();
  if (!HEAP32[84190]) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$5;
  }
  if (HEAP32[84152] & 128) {
   HEAP16[168371] = HEAP32[$2 + 20 >> 2];
   if (HEAP32[84152] & 64) {
    _jswrap_banglejs_setVibration();
   }
  }
  $0 = jshGetSystemTime();
  $1 = i64toi32_i32$HIGH_BITS;
  $3 = $0;
  $0 = jshGetTimeFromMilliseconds(+HEAP32[$2 + 24 >> 2]);
  $3 = $3 + $0 | 0;
  $1 = i64toi32_i32$HIGH_BITS + $1 | 0;
  jstExecuteFn(555, $3, $3 >>> 0 < $0 >>> 0 ? $1 + 1 | 0 : $1);
  HEAP32[$2 + 28 >> 2] = jsvLockAgain(HEAP32[84190]);
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function jsvRemoveChild($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP16[$2 + 22 >> 1] = jsvGetRef(HEAP32[$2 + 24 >> 2]);
 HEAP8[$2 + 21 | 0] = 0;
 if ((jsvGetFirstChild(HEAP32[$2 + 28 >> 2]) & 65535) == HEAPU16[$2 + 22 >> 1]) {
  jsvSetFirstChild(HEAP32[$2 + 28 >> 2], jsvGetNextSibling(HEAP32[$2 + 24 >> 2]) & 65535);
  HEAP8[$2 + 21 | 0] = 1;
 }
 if ((jsvGetLastChild(HEAP32[$2 + 28 >> 2]) & 65535) == HEAPU16[$2 + 22 >> 1]) {
  jsvSetLastChild(HEAP32[$2 + 28 >> 2], jsvGetPrevSibling(HEAP32[$2 + 24 >> 2]) & 65535);
  HEAP8[$2 + 21 | 0] = 1;
  if (jsvIsArray(HEAP32[$2 + 28 >> 2]) & 1) {
   HEAP32[$2 + 16 >> 2] = 0;
   if (jsvGetLastChild(HEAP32[$2 + 28 >> 2]) & 65535) {
    HEAP32[$2 + 16 >> 2] = jsvGetIntegerAndUnLock(jsvLock(jsvGetLastChild(HEAP32[$2 + 28 >> 2]) & 65535)) + 1;
   }
   jsvSetArrayLength(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 16 >> 2]);
  }
 }
 if (jsvGetPrevSibling(HEAP32[$2 + 24 >> 2]) & 65535) {
  HEAP32[$2 + 12 >> 2] = jsvLock(jsvGetPrevSibling(HEAP32[$2 + 24 >> 2]) & 65535);
  jsvSetNextSibling(HEAP32[$2 + 12 >> 2], jsvGetNextSibling(HEAP32[$2 + 24 >> 2]) & 65535);
  jsvUnLock(HEAP32[$2 + 12 >> 2]);
  HEAP8[$2 + 21 | 0] = 1;
 }
 if (jsvGetNextSibling(HEAP32[$2 + 24 >> 2]) & 65535) {
  HEAP32[$2 + 8 >> 2] = jsvLock(jsvGetNextSibling(HEAP32[$2 + 24 >> 2]) & 65535);
  jsvSetPrevSibling(HEAP32[$2 + 8 >> 2], jsvGetPrevSibling(HEAP32[$2 + 24 >> 2]) & 65535);
  jsvUnLock(HEAP32[$2 + 8 >> 2]);
  HEAP8[$2 + 21 | 0] = 1;
 }
 jsvSetPrevSibling(HEAP32[$2 + 24 >> 2], 0);
 jsvSetNextSibling(HEAP32[$2 + 24 >> 2], 0);
 if (HEAP8[$2 + 21 | 0] & 1) {
  jsvUnRef(HEAP32[$2 + 24 >> 2]);
 }
 global$0 = $2 + 32 | 0;
}
function getRadix($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = 10;
 if (HEAP8[HEAP32[HEAP32[$2 + 12 >> 2] >> 2]] == 48) {
  HEAP32[$2 + 4 >> 2] = 8;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
  label$2 : {
   if (!(HEAP8[HEAP32[HEAP32[$2 + 12 >> 2] >> 2]] != 79 ? HEAP8[HEAP32[HEAP32[$2 + 12 >> 2] >> 2]] != 111 : 0)) {
    HEAP32[$2 + 4 >> 2] = 8;
    $0 = HEAP32[$2 + 12 >> 2];
    HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
    break label$2;
   }
   label$5 : {
    if (!(HEAP8[HEAP32[HEAP32[$2 + 12 >> 2] >> 2]] != 88 ? HEAP8[HEAP32[HEAP32[$2 + 12 >> 2] >> 2]] != 120 : 0)) {
     HEAP32[$2 + 4 >> 2] = 16;
     $0 = HEAP32[$2 + 12 >> 2];
     HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
     break label$5;
    }
    label$8 : {
     if (!(HEAP8[HEAP32[HEAP32[$2 + 12 >> 2] >> 2]] != 66 ? HEAP8[HEAP32[HEAP32[$2 + 12 >> 2] >> 2]] != 98 : 0)) {
      HEAP32[$2 + 4 >> 2] = 2;
      $0 = HEAP32[$2 + 12 >> 2];
      HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
      break label$8;
     }
     HEAP32[$2 >> 2] = HEAP32[HEAP32[$2 + 12 >> 2] >> 2];
     while (1) {
      label$12 : {
       if (!HEAPU8[HEAP32[$2 >> 2]]) {
        break label$12;
       }
       label$13 : {
        if (!(HEAP8[HEAP32[$2 >> 2]] != 57 ? !(HEAP8[HEAP32[$2 >> 2]] == 46 | HEAP8[HEAP32[$2 >> 2]] == 56) : 0)) {
         HEAP32[$2 + 4 >> 2] = 10;
         break label$13;
        }
        if (HEAP8[HEAP32[$2 >> 2]] < 48 | HEAP8[HEAP32[$2 >> 2]] > 57) {
         break label$12;
        }
       }
       HEAP32[$2 >> 2] = HEAP32[$2 >> 2] + 1;
       continue;
      }
      break;
     }
    }
   }
  }
 }
 return HEAP32[$2 + 4 >> 2];
}
function jsfSaveBootCodeToFlash($0, $1) {
 var $2 = 0;
 $2 = global$0 - 208 | 0;
 global$0 = $2;
 HEAP32[$2 + 204 >> 2] = $0;
 HEAP8[$2 + 203 | 0] = $1;
 jsfNameFromString($2 + 168 | 0, 78212);
 HEAP32[$2 + 64 >> 2] = HEAP32[$2 + 192 >> 2];
 $0 = HEAP32[$2 + 188 >> 2];
 HEAP32[$2 + 56 >> 2] = HEAP32[$2 + 184 >> 2];
 HEAP32[$2 + 60 >> 2] = $0;
 $0 = HEAP32[$2 + 180 >> 2];
 HEAP32[$2 + 48 >> 2] = HEAP32[$2 + 176 >> 2];
 HEAP32[$2 + 52 >> 2] = $0;
 $0 = HEAP32[$2 + 172 >> 2];
 HEAP32[$2 + 40 >> 2] = HEAP32[$2 + 168 >> 2];
 HEAP32[$2 + 44 >> 2] = $0;
 jsfEraseFile($2 + 40 | 0);
 jsfNameFromString($2 + 136 | 0, 78221);
 HEAP32[$2 + 96 >> 2] = HEAP32[$2 + 160 >> 2];
 $0 = HEAP32[$2 + 156 >> 2];
 HEAP32[$2 + 88 >> 2] = HEAP32[$2 + 152 >> 2];
 HEAP32[$2 + 92 >> 2] = $0;
 $0 = HEAP32[$2 + 148 >> 2];
 HEAP32[$2 + 80 >> 2] = HEAP32[$2 + 144 >> 2];
 HEAP32[$2 + 84 >> 2] = $0;
 $0 = HEAP32[$2 + 140 >> 2];
 HEAP32[$2 + 72 >> 2] = HEAP32[$2 + 136 >> 2];
 HEAP32[$2 + 76 >> 2] = $0;
 jsfEraseFile($2 + 72 | 0);
 label$1 : {
  if (jsvIsUndefined(HEAP32[$2 + 204 >> 2]) & 1) {
   break label$1;
  }
  if (!jsvGetLength(HEAP32[$2 + 204 >> 2])) {
   break label$1;
  }
  jsfNameFromString($2 + 104 | 0, HEAP8[$2 + 203 | 0] & 1 ? 78221 : 78212);
  $0 = HEAP32[$2 + 204 >> 2];
  HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 128 >> 2];
  $1 = HEAP32[$2 + 124 >> 2];
  HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 120 >> 2];
  HEAP32[$2 + 28 >> 2] = $1;
  $1 = HEAP32[$2 + 116 >> 2];
  HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 112 >> 2];
  HEAP32[$2 + 20 >> 2] = $1;
  $1 = HEAP32[$2 + 108 >> 2];
  HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 104 >> 2];
  HEAP32[$2 + 12 >> 2] = $1;
  jsfWriteFile($2 + 8 | 0, $0, 0, 0, 0);
 }
 global$0 = $2 + 208 | 0;
}
function jsExceptionHere($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 + -64 | 0;
 global$0 = $3;
 HEAP32[$3 + 60 >> 2] = $0;
 HEAP32[$3 + 56 >> 2] = $1;
 label$1 : {
  if (jspHasError() & 1) {
   break label$1;
  }
  jsiConsoleRemoveInputLine();
  HEAP32[$3 + 52 >> 2] = jsvNewWithFlags(27);
  if (!HEAP32[$3 + 52 >> 2]) {
   jspSetError();
   break label$1;
  }
  $0 = $3 + 16 | 0;
  jsvStringIteratorNew($0, HEAP32[$3 + 52 >> 2], 0);
  jsvStringIteratorGotoEnd($0);
  HEAP32[$3 + 12 >> 2] = 2;
  HEAP32[$3 + 8 >> 2] = $2;
  vcbprintf(HEAP32[$3 + 12 >> 2], $0, HEAP32[$3 + 56 >> 2], HEAP32[$3 + 8 >> 2]);
  jsvStringIteratorFree($0);
  if (HEAP32[$3 + 60 >> 2]) {
   HEAP32[$3 + 4 >> 2] = 0;
   label$4 : {
    if (HEAP32[$3 + 60 >> 2] == 1) {
     HEAP32[$3 + 4 >> 2] = jswrap_error_constructor(HEAP32[$3 + 52 >> 2]);
     break label$4;
    }
    label$6 : {
     if (HEAP32[$3 + 60 >> 2] == 2) {
      HEAP32[$3 + 4 >> 2] = jswrap_syntaxerror_constructor(HEAP32[$3 + 52 >> 2]);
      break label$6;
     }
     label$8 : {
      if (HEAP32[$3 + 60 >> 2] == 3) {
       HEAP32[$3 + 4 >> 2] = jswrap_typeerror_constructor(HEAP32[$3 + 52 >> 2]);
       break label$8;
      }
      label$10 : {
       if (HEAP32[$3 + 60 >> 2] == 4) {
        HEAP32[$3 + 4 >> 2] = jswrap_internalerror_constructor(HEAP32[$3 + 52 >> 2]);
        break label$10;
       }
       if (HEAP32[$3 + 60 >> 2] == 5) {
        HEAP32[$3 + 4 >> 2] = jswrap_referenceerror_constructor(HEAP32[$3 + 52 >> 2]);
       }
      }
     }
    }
   }
   jsvUnLock(HEAP32[$3 + 52 >> 2]);
   HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 4 >> 2];
  }
  jspSetException(HEAP32[$3 + 52 >> 2]);
  jsvUnLock(HEAP32[$3 + 52 >> 2]);
 }
 global$0 = $3 - -64 | 0;
}
function jswrap_parseInt($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 144 | 0;
 global$0 = $2;
 HEAP32[$2 + 136 >> 2] = $0;
 HEAP32[$2 + 132 >> 2] = $1;
 HEAP32[$2 + 128 >> 2] = 0;
 if (jsvIsNumeric(HEAP32[$2 + 132 >> 2]) & 1) {
  HEAP32[$2 + 128 >> 2] = jsvGetInteger(HEAP32[$2 + 132 >> 2]);
 }
 label$2 : {
  label$3 : {
   if (!(jsvIsFloat(HEAP32[$2 + 136 >> 2]) & 1)) {
    break label$3;
   }
   $0 = __DOUBLE_BITS(jsvGetFloat(HEAP32[$2 + 136 >> 2]));
   $1 = i64toi32_i32$HIGH_BITS & 2147483647;
   if (($1 | 0) == 2146435072 & $0 >>> 0 < 0 | $1 >>> 0 < 2146435072) {
    break label$3;
   }
   HEAP32[$2 + 140 >> 2] = jsvNewFromFloat(nan);
   break label$2;
  }
  $0 = $2 + 48 | 0;
  HEAP32[$2 + 44 >> 2] = $0;
  jsvGetString(HEAP32[$2 + 136 >> 2], $0, 70);
  HEAP8[$2 + 43 | 0] = 0;
  if (!(HEAP8[$2 + 48 | 0] != 48 | (HEAP32[$2 + 128 >> 2] != 16 ? HEAP32[$2 + 128 >> 2] : 0) | (HEAP8[$2 + 49 | 0] != 88 ? HEAP8[$2 + 49 | 0] != 120 : 0))) {
   HEAP32[$2 + 128 >> 2] = 16;
   HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 44 >> 2] + 2;
  }
  if (!HEAP32[$2 + 128 >> 2]) {
   HEAP32[$2 + 128 >> 2] = 10;
  }
  HEAP32[$2 + 24 >> 2] = stringToIntWithRadix(HEAP32[$2 + 44 >> 2], HEAP32[$2 + 128 >> 2], $2 + 43 | 0, $2 + 36 | 0);
  HEAP32[$2 + 28 >> 2] = i64toi32_i32$HIGH_BITS;
  if (HEAP8[$2 + 43 | 0] & 1) {
   HEAP32[$2 + 140 >> 2] = jsvNewFromFloat(nan);
   break label$2;
  }
  if (HEAP32[$2 + 36 >> 2] == ($2 + 117 | 0)) {
   jsExceptionHere(1, 121272, 0);
   HEAP32[$2 + 140 >> 2] = jsvNewFromFloat(nan);
   break label$2;
  }
  HEAP32[$2 + 140 >> 2] = jsvNewFromLongInteger(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 28 >> 2]);
 }
 global$0 = $2 + 144 | 0;
 return HEAP32[$2 + 140 >> 2];
}
function jswrap_array_fill($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 96 | 0;
 global$0 = $4;
 HEAP32[$4 + 88 >> 2] = $0;
 HEAP32[$4 + 84 >> 2] = $1;
 HEAP32[$4 + 80 >> 2] = $2;
 HEAP32[$4 + 76 >> 2] = $3;
 label$1 : {
  if (!(jsvIsIterable(HEAP32[$4 + 88 >> 2]) & 1)) {
   HEAP32[$4 + 92 >> 2] = 0;
   break label$1;
  }
  HEAP32[$4 + 72 >> 2] = jsvGetLength(HEAP32[$4 + 88 >> 2]);
  if (HEAP32[$4 + 80 >> 2] < 0) {
   HEAP32[$4 + 80 >> 2] = HEAP32[$4 + 80 >> 2] + HEAP32[$4 + 72 >> 2];
  }
  if (HEAP32[$4 + 80 >> 2] < 0) {
   HEAP32[$4 + 92 >> 2] = 0;
   break label$1;
  }
  $0 = $4;
  label$5 : {
   if (jsvIsNumeric(HEAP32[$4 + 76 >> 2]) & 1) {
    $1 = jsvGetInteger(HEAP32[$4 + 76 >> 2]);
    break label$5;
   }
   $1 = HEAP32[$4 + 72 >> 2];
  }
  HEAP32[$0 + 68 >> 2] = $1;
  if (HEAP32[$4 + 68 >> 2] < 0) {
   HEAP32[$4 + 68 >> 2] = HEAP32[$4 + 68 >> 2] + HEAP32[$4 + 72 >> 2];
  }
  if (HEAP32[$4 + 68 >> 2] < 0) {
   HEAP32[$4 + 92 >> 2] = 0;
   break label$1;
  }
  jsvIteratorNew($4 + 8 | 0, HEAP32[$4 + 88 >> 2], 1);
  while (1) {
   if (jsvIteratorHasElement($4 + 8 | 0) & 1) {
    $0 = jspIsInterrupted() ^ -1;
   } else {
    $0 = 0;
   }
   if ($0 & 1) {
    HEAP32[$4 + 4 >> 2] = jsvGetIntegerAndUnLock(jsvIteratorGetKey($4 + 8 | 0));
    if (!(HEAP32[$4 + 4 >> 2] < HEAP32[$4 + 80 >> 2] | HEAP32[$4 + 4 >> 2] >= HEAP32[$4 + 68 >> 2])) {
     jsvIteratorSetValue($4 + 8 | 0, HEAP32[$4 + 84 >> 2]);
    }
    jsvIteratorNext($4 + 8 | 0);
    continue;
   }
   break;
  }
  jsvIteratorFree($4 + 8 | 0);
  HEAP32[$4 + 92 >> 2] = jsvLockAgain(HEAP32[$4 + 88 >> 2]);
 }
 global$0 = $4 + 96 | 0;
 return HEAP32[$4 + 92 >> 2];
}
function void_20tflite__reference_ops__AffineQuantize_float_2c_20unsigned_20char__28tflite__QuantizationParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = Math_fround(0);
 $5 = global$0 + -64 | 0;
 global$0 = $5;
 HEAP32[$5 + 60 >> 2] = $0;
 HEAP32[$5 + 56 >> 2] = $1;
 HEAP32[$5 + 52 >> 2] = $2;
 HEAP32[$5 + 48 >> 2] = $3;
 HEAP32[$5 + 44 >> 2] = $4;
 HEAP32[$5 + 40 >> 2] = HEAP32[HEAP32[$5 + 60 >> 2] >> 2];
 HEAPF64[$5 + 32 >> 3] = HEAPF64[HEAP32[$5 + 60 >> 2] + 8 >> 3];
 HEAP32[$5 + 28 >> 2] = tflite__MatchingFlatSize_28tflite__RuntimeShape_20const__2c_20tflite__RuntimeShape_20const__29(HEAP32[$5 + 56 >> 2], HEAP32[$5 + 48 >> 2]);
 HEAP32[$5 + 24 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 24 >> 2] < HEAP32[$5 + 28 >> 2]) {
   $2 = $5 + 16 | 0;
   HEAPF32[$5 + 20 >> 2] = HEAPF32[HEAP32[$5 + 52 >> 2] + (HEAP32[$5 + 24 >> 2] << 2) >> 2];
   $0 = $5;
   $6 = float_20tflite__TfLiteRound_float__28float_29(Math_fround(HEAPF32[$5 + 20 >> 2] / Math_fround(HEAPF64[$5 + 32 >> 3])));
   label$3 : {
    if (Math_fround(Math_abs($6)) < Math_fround(2147483648)) {
     $1 = ~~$6;
     break label$3;
    }
    $1 = -2147483648;
   }
   HEAP32[$0 + 16 >> 2] = $1 + HEAP32[$5 + 40 >> 2];
   HEAP32[$5 + 12 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29(int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($2, 135664), 135668) >> 2];
   HEAP8[HEAP32[$5 + 44 >> 2] + HEAP32[$5 + 24 >> 2] | 0] = HEAP32[$5 + 12 >> 2];
   HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 24 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $5 - -64 | 0;
}
function log($0) {
 $0 = +$0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 label$1 : {
  label$2 : {
   label$3 : {
    label$4 : {
     wasm2js_scratch_store_f64(+$0);
     $1 = wasm2js_scratch_load_i32(1) | 0;
     $3 = wasm2js_scratch_load_i32(0) | 0;
     if (($1 | 0) > 0 ? 1 : ($1 | 0) >= 0 ? $3 >>> 0 < 0 ? 0 : 1 : 0) {
      $5 = $1;
      if ($1 >>> 0 > 1048575) {
       break label$4;
      }
     }
     if (!($1 & 2147483647 | $3)) {
      return +(-1 / ($0 * $0));
     }
     if (($1 | 0) > -1 ? 1 : ($1 | 0) >= -1 ? $3 >>> 0 <= 4294967295 ? 0 : 1 : 0) {
      break label$3;
     }
     return +(($0 - $0) / 0);
    }
    if ($5 >>> 0 > 2146435071) {
     break label$1;
    }
    $1 = 1072693248;
    $6 = -1023;
    if (($5 | 0) != 1072693248) {
     $1 = $5;
     break label$2;
    }
    if ($3) {
     break label$2;
    }
    return 0;
   }
   wasm2js_scratch_store_f64(+($0 * 0x40000000000000));
   $1 = wasm2js_scratch_load_i32(1) | 0;
   $3 = wasm2js_scratch_load_i32(0) | 0;
   $6 = -1077;
  }
  $1 = $1 + 614242 | 0;
  $4 = +(($1 >>> 20) + $6 | 0);
  $7 = $4 * .6931471803691238;
  $1 = ($1 & 1048575) + 1072079006 | 0;
  wasm2js_scratch_store_i32(0, $3 | 0);
  wasm2js_scratch_store_i32(1, $1 | 0);
  $0 = +wasm2js_scratch_load_f64() + -1;
  $2 = $0 / ($0 + 2);
  $8 = $0;
  $9 = $4 * 1.9082149292705877e-10;
  $10 = $2;
  $4 = $0 * ($0 * .5);
  $2 = $2 * $2;
  $0 = $2 * $2;
  $0 = $7 + ($8 + ($9 + $10 * ($4 + ($0 * ($0 * ($0 * .15313837699209373 + .22222198432149784) + .3999999999940942) + $2 * ($0 * ($0 * ($0 * .14798198605116586 + .1818357216161805) + .2857142874366239) + .6666666666666735))) - $4));
 }
 return +$0;
}
function void_20tflite__reference_ops__AffineQuantize_float_2c_20signed_20char__28tflite__QuantizationParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = Math_fround(0);
 $5 = global$0 + -64 | 0;
 global$0 = $5;
 HEAP32[$5 + 60 >> 2] = $0;
 HEAP32[$5 + 56 >> 2] = $1;
 HEAP32[$5 + 52 >> 2] = $2;
 HEAP32[$5 + 48 >> 2] = $3;
 HEAP32[$5 + 44 >> 2] = $4;
 HEAP32[$5 + 40 >> 2] = HEAP32[HEAP32[$5 + 60 >> 2] >> 2];
 HEAPF64[$5 + 32 >> 3] = HEAPF64[HEAP32[$5 + 60 >> 2] + 8 >> 3];
 HEAP32[$5 + 28 >> 2] = tflite__MatchingFlatSize_28tflite__RuntimeShape_20const__2c_20tflite__RuntimeShape_20const__29(HEAP32[$5 + 56 >> 2], HEAP32[$5 + 48 >> 2]);
 HEAP32[$5 + 24 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 24 >> 2] < HEAP32[$5 + 28 >> 2]) {
   $2 = $5 + 16 | 0;
   HEAPF32[$5 + 20 >> 2] = HEAPF32[HEAP32[$5 + 52 >> 2] + (HEAP32[$5 + 24 >> 2] << 2) >> 2];
   $0 = $5;
   $6 = float_20tflite__TfLiteRound_float__28float_29(Math_fround(HEAPF32[$5 + 20 >> 2] / Math_fround(HEAPF64[$5 + 32 >> 3])));
   label$3 : {
    if (Math_fround(Math_abs($6)) < Math_fround(2147483648)) {
     $1 = ~~$6;
     break label$3;
    }
    $1 = -2147483648;
   }
   HEAP32[$0 + 16 >> 2] = $1 + HEAP32[$5 + 40 >> 2];
   HEAP32[$5 + 12 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29(int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($2, 135656), 135660) >> 2];
   HEAP8[HEAP32[$5 + 44 >> 2] + HEAP32[$5 + 24 >> 2] | 0] = HEAP32[$5 + 12 >> 2];
   HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 24 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $5 - -64 | 0;
}
function jsvArrayJoin($0, $1) {
 var $2 = 0;
 $2 = global$0 - 144 | 0;
 global$0 = $2;
 HEAP32[$2 + 136 >> 2] = $0;
 HEAP32[$2 + 132 >> 2] = $1;
 HEAP32[$2 + 128 >> 2] = jsvNewWithFlags(27);
 label$1 : {
  if (!HEAP32[$2 + 128 >> 2]) {
   HEAP32[$2 + 140 >> 2] = 0;
   break label$1;
  }
  $0 = $2 + 24 | 0;
  jsvIteratorNew($2 - -64 | 0, HEAP32[$2 + 136 >> 2], 1);
  jsvStringIteratorNew($0, HEAP32[$2 + 128 >> 2], 0);
  HEAP8[$2 + 23 | 0] = 1;
  while (1) {
   if (jspIsInterrupted() & 1) {
    $0 = 0;
   } else {
    $0 = jsvIteratorHasElement($2 - -64 | 0);
   }
   if ($0 & 1) {
    HEAP32[$2 + 16 >> 2] = jsvIteratorGetKey($2 - -64 | 0);
    if (jsvIsInt(HEAP32[$2 + 16 >> 2]) & 1) {
     if (!(!HEAP32[$2 + 132 >> 2] | HEAP8[$2 + 23 | 0] & 1)) {
      jsvStringIteratorAppendString($2 + 24 | 0, HEAP32[$2 + 132 >> 2], 0, 2147483647);
     }
     HEAP8[$2 + 23 | 0] = 0;
     HEAP32[$2 + 12 >> 2] = jsvIteratorGetValue($2 - -64 | 0);
     label$9 : {
      if (!HEAP32[$2 + 12 >> 2]) {
       break label$9;
      }
      if (jsvIsNull(HEAP32[$2 + 12 >> 2]) & 1) {
       break label$9;
      }
      HEAP32[$2 + 8 >> 2] = jsvAsString(HEAP32[$2 + 12 >> 2]);
      if (HEAP32[$2 + 8 >> 2]) {
       jsvStringIteratorAppendString($2 + 24 | 0, HEAP32[$2 + 8 >> 2], 0, 2147483647);
       jsvUnLock(HEAP32[$2 + 8 >> 2]);
      }
     }
     jsvUnLock(HEAP32[$2 + 12 >> 2]);
    }
    $0 = $2 - -64 | 0;
    jsvUnLock(HEAP32[$2 + 16 >> 2]);
    jsvIteratorNext($0);
    continue;
   }
   break;
  }
  $0 = $2 + 24 | 0;
  jsvIteratorFree($2 - -64 | 0);
  jsvStringIteratorFree($0);
  HEAP32[$2 + 140 >> 2] = HEAP32[$2 + 128 >> 2];
 }
 global$0 = $2 + 144 | 0;
 return HEAP32[$2 + 140 >> 2];
}
function void_20tflite__reference_ops__AffineQuantize_float_2c_20short__28tflite__QuantizationParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20short__29($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = Math_fround(0);
 $5 = global$0 + -64 | 0;
 global$0 = $5;
 HEAP32[$5 + 60 >> 2] = $0;
 HEAP32[$5 + 56 >> 2] = $1;
 HEAP32[$5 + 52 >> 2] = $2;
 HEAP32[$5 + 48 >> 2] = $3;
 HEAP32[$5 + 44 >> 2] = $4;
 HEAP32[$5 + 40 >> 2] = HEAP32[HEAP32[$5 + 60 >> 2] >> 2];
 HEAPF64[$5 + 32 >> 3] = HEAPF64[HEAP32[$5 + 60 >> 2] + 8 >> 3];
 HEAP32[$5 + 28 >> 2] = tflite__MatchingFlatSize_28tflite__RuntimeShape_20const__2c_20tflite__RuntimeShape_20const__29(HEAP32[$5 + 56 >> 2], HEAP32[$5 + 48 >> 2]);
 HEAP32[$5 + 24 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 24 >> 2] < HEAP32[$5 + 28 >> 2]) {
   $2 = $5 + 16 | 0;
   HEAPF32[$5 + 20 >> 2] = HEAPF32[HEAP32[$5 + 52 >> 2] + (HEAP32[$5 + 24 >> 2] << 2) >> 2];
   $0 = $5;
   $6 = float_20tflite__TfLiteRound_float__28float_29(Math_fround(HEAPF32[$5 + 20 >> 2] / Math_fround(HEAPF64[$5 + 32 >> 3])));
   label$3 : {
    if (Math_fround(Math_abs($6)) < Math_fround(2147483648)) {
     $1 = ~~$6;
     break label$3;
    }
    $1 = -2147483648;
   }
   HEAP32[$0 + 16 >> 2] = $1 + HEAP32[$5 + 40 >> 2];
   HEAP32[$5 + 12 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29(int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($2, 135672), 135676) >> 2];
   HEAP16[HEAP32[$5 + 44 >> 2] + (HEAP32[$5 + 24 >> 2] << 1) >> 1] = HEAP32[$5 + 12 >> 2];
   HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 24 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $5 - -64 | 0;
}
function tflite__ComputePaddingHeightWidth_28int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20TfLitePadding_2c_20int__2c_20int__29($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) {
 var $12 = 0;
 $12 = global$0 - 48 | 0;
 global$0 = $12;
 HEAP32[$12 + 44 >> 2] = $1;
 HEAP32[$12 + 40 >> 2] = $2;
 HEAP32[$12 + 36 >> 2] = $3;
 HEAP32[$12 + 32 >> 2] = $4;
 HEAP32[$12 + 28 >> 2] = $5;
 HEAP32[$12 + 24 >> 2] = $6;
 HEAP32[$12 + 20 >> 2] = $7;
 HEAP32[$12 + 16 >> 2] = $8;
 HEAP32[$12 + 12 >> 2] = $9;
 HEAP32[$12 + 8 >> 2] = $10;
 HEAP32[$12 + 4 >> 2] = $11;
 $1 = tflite__ComputeOutSize_28TfLitePadding_2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$12 + 12 >> 2], HEAP32[$12 + 24 >> 2], HEAP32[$12 + 16 >> 2], HEAP32[$12 + 40 >> 2], HEAP32[$12 + 32 >> 2]);
 HEAP32[HEAP32[$12 + 4 >> 2] >> 2] = $1;
 $1 = tflite__ComputeOutSize_28TfLitePadding_2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$12 + 12 >> 2], HEAP32[$12 + 28 >> 2], HEAP32[$12 + 20 >> 2], HEAP32[$12 + 44 >> 2], HEAP32[$12 + 36 >> 2]);
 HEAP32[HEAP32[$12 + 8 >> 2] >> 2] = $1;
 HEAP32[$12 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = tflite__ComputePaddingWithOffset_28int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int__29(HEAP32[$12 + 44 >> 2], HEAP32[$12 + 36 >> 2], HEAP32[$12 + 28 >> 2], HEAP32[$12 + 20 >> 2], HEAP32[HEAP32[$12 + 8 >> 2] >> 2], $12);
 HEAP32[$0 + 12 >> 2] = HEAP32[$12 >> 2];
 HEAP32[$0 >> 2] = tflite__ComputePaddingWithOffset_28int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int__29(HEAP32[$12 + 40 >> 2], HEAP32[$12 + 32 >> 2], HEAP32[$12 + 24 >> 2], HEAP32[$12 + 16 >> 2], HEAP32[HEAP32[$12 + 4 >> 2] >> 2], $12);
 HEAP32[$0 + 8 >> 2] = HEAP32[$12 >> 2];
 global$0 = $12 + 48 | 0;
}
function jswrap_object_defineProperty($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 + -64 | 0;
 global$0 = $3;
 HEAP32[$3 + 56 >> 2] = $0;
 HEAP32[$3 + 52 >> 2] = $1;
 HEAP32[$3 + 48 >> 2] = $2;
 label$1 : {
  if (!(jsvIsObject(HEAP32[$3 + 56 >> 2]) & 1)) {
   HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 56 >> 2];
   jsExceptionHere(1, 123397, $3 + 16 | 0);
   HEAP32[$3 + 60 >> 2] = 0;
   break label$1;
  }
  if (!(jsvIsObject(HEAP32[$3 + 48 >> 2]) & 1)) {
   HEAP32[$3 >> 2] = HEAP32[$3 + 48 >> 2];
   jsExceptionHere(1, 123438, $3);
   HEAP32[$3 + 60 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 44 >> 2] = jsvAsArrayIndex(HEAP32[$3 + 52 >> 2]);
  HEAP32[$3 + 40 >> 2] = 0;
  HEAP32[$3 + 36 >> 2] = jsvObjectGetChild(HEAP32[$3 + 48 >> 2], 123383, 0);
  HEAP32[$3 + 32 >> 2] = jsvObjectGetChild(HEAP32[$3 + 48 >> 2], 123387, 0);
  if (!(HEAP32[$3 + 32 >> 2] ? 0 : !HEAP32[$3 + 36 >> 2])) {
   HEAP32[$3 + 40 >> 2] = jsvNewWithFlags(6);
   if (HEAP32[$3 + 40 >> 2]) {
    if (HEAP32[$3 + 36 >> 2]) {
     jsvObjectSetChild(HEAP32[$3 + 40 >> 2], 123383, HEAP32[$3 + 36 >> 2]);
    }
    if (HEAP32[$3 + 32 >> 2]) {
     jsvObjectSetChild(HEAP32[$3 + 40 >> 2], 123387, HEAP32[$3 + 32 >> 2]);
    }
   }
   jsvUnLock2(HEAP32[$3 + 36 >> 2], HEAP32[$3 + 32 >> 2]);
  }
  if (!HEAP32[$3 + 40 >> 2]) {
   HEAP32[$3 + 40 >> 2] = jsvObjectGetChild(HEAP32[$3 + 48 >> 2], 123391, 0);
  }
  jsvObjectSetChildVar(HEAP32[$3 + 56 >> 2], HEAP32[$3 + 44 >> 2], HEAP32[$3 + 40 >> 2]);
  jsvUnLock2(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 40 >> 2]);
  HEAP32[$3 + 60 >> 2] = jsvLockAgain(HEAP32[$3 + 56 >> 2]);
 }
 global$0 = $3 - -64 | 0;
 return HEAP32[$3 + 60 >> 2];
}
function jswrap_process_memory() {
 var $0 = 0, $1 = 0, $2 = 0;
 $0 = global$0 - 48 | 0;
 global$0 = $0;
 HEAP32[$0 + 40 >> 2] = jshGetSystemTime();
 HEAP32[$0 + 44 >> 2] = i64toi32_i32$HIGH_BITS;
 HEAP32[$0 + 36 >> 2] = jsvGarbageCollect();
 HEAP32[$0 + 24 >> 2] = jshGetSystemTime();
 HEAP32[$0 + 28 >> 2] = i64toi32_i32$HIGH_BITS;
 HEAP32[$0 + 20 >> 2] = jsvNewWithFlags(5);
 if (HEAP32[$0 + 20 >> 2]) {
  HEAP32[$0 + 16 >> 2] = 0;
  HEAP32[$0 + 12 >> 2] = jsvObjectGetChild(HEAP32[80546], 125054, 0);
  if (HEAP32[$0 + 12 >> 2]) {
   HEAP32[$0 + 16 >> 2] = jsvCountJsVarsUsed(HEAP32[$0 + 12 >> 2]);
   jsvUnLock(HEAP32[$0 + 12 >> 2]);
  }
  HEAP32[$0 + 8 >> 2] = jsvGetMemoryUsage() - HEAP32[$0 + 16 >> 2];
  HEAP32[$0 + 4 >> 2] = HEAP32[35415];
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 20 >> 2], 125062, jsvNewFromInteger(HEAP32[$0 + 4 >> 2] - HEAP32[$0 + 8 >> 2] | 0));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 20 >> 2], 125067, jsvNewFromInteger(HEAP32[$0 + 8 >> 2]));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 20 >> 2], 125073, jsvNewFromInteger(HEAP32[$0 + 4 >> 2]));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 20 >> 2], 125054, jsvNewFromInteger(HEAP32[$0 + 16 >> 2]));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 20 >> 2], 125079, jsvNewFromInteger(HEAP32[$0 + 36 >> 2]));
  $1 = HEAP32[$0 + 24 >> 2];
  $2 = HEAP32[$0 + 40 >> 2];
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 20 >> 2], 125082, jsvNewFromFloat(jshGetMillisecondsFromTime($1 - $2 | 0, HEAP32[$0 + 28 >> 2] - (HEAP32[$0 + 44 >> 2] + ($1 >>> 0 < $2 >>> 0) | 0) | 0)));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 20 >> 2], 125089, jsvNewFromInteger(15));
 }
 global$0 = $0 + 48 | 0;
 return HEAP32[$0 + 20 >> 2];
}
function jswrap_object_emit($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $3 = global$0 - 80 | 0;
 global$0 = $3;
 HEAP32[$3 + 76 >> 2] = $0;
 HEAP32[$3 + 72 >> 2] = $1;
 HEAP32[$3 + 68 >> 2] = $2;
 label$1 : {
  if (!(jsvHasChildren(HEAP32[$3 + 76 >> 2]) & 1)) {
   jsExceptionHere(3, 123613, 0);
   break label$1;
  }
  if (!(jsvIsString(HEAP32[$3 + 72 >> 2]) & 1)) {
   jsExceptionHere(3, 123835, 0);
   break label$1;
  }
  HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 72 >> 2];
  HEAP32[$3 + 64 >> 2] = jsvVarPrintf(123811, $3 + 16 | 0);
  if (!HEAP32[$3 + 64 >> 2]) {
   break label$1;
  }
  HEAP32[$3 + 60 >> 2] = 4;
  HEAP32[$3 + 28 >> 2] = 0;
  jsvObjectIteratorNew($3 + 24 | 0, HEAP32[$3 + 68 >> 2]);
  while (1) {
   label$5 : {
    if (!(jsvObjectIteratorHasValue($3 + 24 | 0) & 1)) {
     break label$5;
    }
    if (HEAPU32[$3 + 28 >> 2] >= 4) {
     HEAP32[$3 >> 2] = 4;
     jsExceptionHere(3, 123892, $3);
     break label$5;
    }
    $0 = $3 + 32 | 0;
    $1 = $3 + 24 | 0;
    $2 = jsvObjectIteratorGetValue($1);
    $4 = HEAP32[$3 + 28 >> 2];
    HEAP32[$3 + 28 >> 2] = $4 + 1;
    HEAP32[$0 + ($4 << 2) >> 2] = $2;
    jsvObjectIteratorNext($1);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree($3 + 24 | 0);
  HEAP32[$3 + 20 >> 2] = jsvSkipNameAndUnLock(jsvFindChildFromVar(HEAP32[$3 + 76 >> 2], HEAP32[$3 + 64 >> 2], 0));
  jsvUnLock(HEAP32[$3 + 64 >> 2]);
  if (HEAP32[$3 + 20 >> 2]) {
   jsiQueueEvents(HEAP32[$3 + 76 >> 2], HEAP32[$3 + 20 >> 2], $3 + 32 | 0, HEAP32[$3 + 28 >> 2]);
  }
  $0 = $3 + 32 | 0;
  jsvUnLock(HEAP32[$3 + 20 >> 2]);
  jsvUnLockMany(HEAP32[$3 + 28 >> 2], $0);
 }
 global$0 = $3 + 80 | 0;
}
function tflite__MicroAllocator__RequestScratchBufferInArena_28int_2c_20unsigned_20long_2c_20int__29($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 48 | 0;
 global$0 = $4;
 HEAP32[$4 + 40 >> 2] = $0;
 HEAP32[$4 + 36 >> 2] = $1;
 HEAP32[$4 + 32 >> 2] = $2;
 HEAP32[$4 + 28 >> 2] = $3;
 label$1 : {
  label$2 : {
   $0 = HEAP32[$4 + 40 >> 2];
   if (!HEAP32[$0 + 16 >> 2]) {
    break label$2;
   }
   if (HEAP32[$0 + 16 >> 2] == (tflite__SimpleMemoryAllocator__GetTail_28_29_20const(HEAP32[$0 + 4 >> 2]) | 0)) {
    break label$2;
   }
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$0 + 8 >> 2], 131923, 0);
   HEAP32[$4 + 44 >> 2] = 1;
   break label$1;
  }
  $1 = HEAP32[$0 + 4 >> 2];
  HEAP32[$4 + 24 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$1 >> 2] + 12 >> 2]]($1, 12, 4);
  if (!HEAP32[$4 + 24 >> 2]) {
   $0 = HEAP32[$0 + 8 >> 2];
   HEAP32[$4 >> 2] = HEAP32[$4 + 36 >> 2];
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 132021, $4);
   HEAP32[$4 + 44 >> 2] = 1;
   break label$1;
  }
  HEAP32[$4 + 8 >> 2] = 0;
  HEAP32[$4 + 12 >> 2] = 0;
  HEAP32[$4 + 16 >> 2] = 0;
  $2 = $4 + 8 | 0;
  $3 = HEAP32[$2 + 4 >> 2];
  $1 = HEAP32[$4 + 24 >> 2];
  HEAP32[$1 >> 2] = HEAP32[$2 >> 2];
  HEAP32[$1 + 4 >> 2] = $3;
  HEAP32[$1 + 8 >> 2] = HEAP32[$2 + 8 >> 2];
  HEAP32[HEAP32[$4 + 24 >> 2] + 4 >> 2] = HEAP32[$4 + 32 >> 2];
  HEAP32[HEAP32[$4 + 24 >> 2] + 8 >> 2] = HEAP32[$4 + 36 >> 2];
  HEAP32[HEAP32[$4 + 28 >> 2] >> 2] = HEAP32[$0 + 20 >> 2];
  HEAP32[$0 + 20 >> 2] = HEAP32[$0 + 20 >> 2] + 1;
  HEAP32[$0 + 16 >> 2] = HEAP32[$4 + 24 >> 2];
  HEAP32[$4 + 44 >> 2] = 0;
 }
 global$0 = $4 + 48 | 0;
 return HEAP32[$4 + 44 >> 2];
}
function jsfBankFindFileFromAddr($0, $1) {
 var $2 = 0;
 $2 = global$0 + -64 | 0;
 global$0 = $2;
 HEAP32[$2 + 56 >> 2] = 134217728;
 HEAP32[$2 + 52 >> 2] = 142606336;
 HEAP32[$2 + 48 >> 2] = $0;
 HEAP32[$2 + 44 >> 2] = $1;
 HEAP32[$2 + 40 >> 2] = HEAP32[$2 + 56 >> 2];
 $0 = $2 + 8 | 0;
 HEAP32[$0 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
 label$1 : {
  if (jsfGetFileHeader(HEAP32[$2 + 40 >> 2], $0, 0) & 1) {
   while (1) {
    HEAP32[$2 + 4 >> 2] = (HEAP32[$2 + 40 >> 2] + 32 | 0) + jsfGetFileSize($2 + 8 | 0);
    if (!(!HEAP32[$2 + 12 >> 2] | HEAPU32[$2 + 40 >> 2] > HEAPU32[$2 + 48 >> 2] | HEAPU32[$2 + 48 >> 2] > HEAPU32[$2 + 4 >> 2])) {
     jsfGetFileHeader(HEAP32[$2 + 40 >> 2], $2 + 8 | 0, 1);
     if (HEAP32[$2 + 44 >> 2]) {
      $1 = HEAP32[$2 + 12 >> 2];
      $0 = HEAP32[$2 + 44 >> 2];
      HEAP32[$0 >> 2] = HEAP32[$2 + 8 >> 2];
      HEAP32[$0 + 4 >> 2] = $1;
      $1 = HEAP32[$2 + 36 >> 2];
      HEAP32[$0 + 24 >> 2] = HEAP32[$2 + 32 >> 2];
      HEAP32[$0 + 28 >> 2] = $1;
      $1 = HEAP32[$2 + 28 >> 2];
      HEAP32[$0 + 16 >> 2] = HEAP32[$2 + 24 >> 2];
      HEAP32[$0 + 20 >> 2] = $1;
      $1 = HEAP32[$2 + 20 >> 2];
      HEAP32[$0 + 8 >> 2] = HEAP32[$2 + 16 >> 2];
      HEAP32[$0 + 12 >> 2] = $1;
     }
     HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 40 >> 2] + 32;
     break label$1;
    }
    if (jsfGetNextFileHeader($2 + 40 | 0, $2 + 8 | 0, 3) & 1) {
     continue;
    }
    break;
   }
  }
  HEAP32[$2 + 60 >> 2] = 0;
 }
 global$0 = $2 - -64 | 0;
 return HEAP32[$2 + 60 >> 2];
}
function _jswrap_promise_resolve_or_reject_chain($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP8[$3 + 39 | 0] = $2;
 HEAP32[$3 + 32 >> 2] = HEAP8[$3 + 39 | 0] & 1 ? 125099 : 125104;
 HEAP32[$3 + 28 >> 2] = jsvObjectGetChild(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 32 >> 2], 0);
 label$1 : {
  if (!HEAP32[$3 + 28 >> 2]) {
   HEAP32[$3 + 24 >> 2] = jsvObjectGetChild(HEAP32[$3 + 44 >> 2], 125109, 0);
   while (1) {
    if (HEAP32[$3 + 24 >> 2]) {
     HEAP32[$3 + 28 >> 2] = jsvObjectGetChild(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 32 >> 2], 0);
     if (HEAP32[$3 + 28 >> 2]) {
      _jswrap_promise_resolve_or_reject(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 40 >> 2], HEAP32[$3 + 28 >> 2]);
      jsvUnLock2(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2]);
      break label$1;
     }
     HEAP32[$3 + 20 >> 2] = jsvObjectGetChild(HEAP32[$3 + 24 >> 2], 125109, 0);
     jsvUnLock(HEAP32[$3 + 24 >> 2]);
     HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 20 >> 2];
     continue;
    }
    break;
   }
  }
  if (HEAP8[$3 + 39 | 0] & 1) {
   jsvObjectSetChild(HEAP32[$3 + 44 >> 2], 125120, HEAP32[$3 + 40 >> 2]);
  }
  if (HEAP32[$3 + 28 >> 2]) {
   _jswrap_promise_resolve_or_reject(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 40 >> 2], HEAP32[$3 + 28 >> 2]);
   jsvUnLock(HEAP32[$3 + 28 >> 2]);
   break label$1;
  }
  if (!(HEAP8[$3 + 39 | 0] & 1)) {
   HEAP32[$3 + 16 >> 2] = jsvFindChildFromString(HEAP32[$3 + 44 >> 2], 125120, 0);
   if (!HEAP32[$3 + 16 >> 2]) {
    HEAP32[$3 >> 2] = HEAP32[$3 + 40 >> 2];
    jsExceptionHere(1, 125129, $3);
   }
   jsvUnLock(HEAP32[$3 + 16 >> 2]);
  }
 }
 global$0 = $3 + 48 | 0;
}
function tflite__BytesRequiredForTensor_28tflite__Tensor_20const__2c_20unsigned_20long__2c_20unsigned_20long__2c_20tflite__ErrorReporter__29($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 48 | 0;
 global$0 = $4;
 HEAP32[$4 + 40 >> 2] = $0;
 HEAP32[$4 + 36 >> 2] = $1;
 HEAP32[$4 + 32 >> 2] = $2;
 HEAP32[$4 + 28 >> 2] = $3;
 HEAP32[$4 + 24 >> 2] = 1;
 if (tflite__Tensor__shape_28_29_20const(HEAP32[$4 + 40 >> 2])) {
  HEAP32[$4 + 20 >> 2] = 0;
  while (1) {
   if (HEAPU32[$4 + 20 >> 2] < flatbuffers__Vector_int___Length_28_29_20const(tflite__Tensor__shape_28_29_20const(HEAP32[$4 + 40 >> 2])) >>> 0) {
    HEAP32[$4 + 24 >> 2] = Math_imul(flatbuffers__Vector_int___Get_28unsigned_20int_29_20const(tflite__Tensor__shape_28_29_20const(HEAP32[$4 + 40 >> 2]), HEAP32[$4 + 20 >> 2]), HEAP32[$4 + 24 >> 2]);
    HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 20 >> 2] + 1;
    continue;
   }
   break;
  }
 }
 $0 = $4 + 16 | 0;
 HEAP32[$4 + 12 >> 2] = tflite__ConvertTensorType_28tflite__TensorType_2c_20TfLiteType__2c_20tflite__ErrorReporter__29(tflite__Tensor__type_28_29_20const(HEAP32[$4 + 40 >> 2]), $0, HEAP32[$4 + 28 >> 2]);
 label$4 : {
  if (HEAP32[$4 + 12 >> 2]) {
   HEAP32[$4 + 44 >> 2] = HEAP32[$4 + 12 >> 2];
   break label$4;
  }
  HEAP32[$4 + 8 >> 2] = tflite__TfLiteTypeSizeOf_28TfLiteType_2c_20unsigned_20long__29(HEAP32[$4 + 16 >> 2], HEAP32[$4 + 32 >> 2]);
  if (HEAP32[$4 + 8 >> 2]) {
   HEAP32[$4 + 44 >> 2] = HEAP32[$4 + 8 >> 2];
   break label$4;
  }
  HEAP32[HEAP32[$4 + 36 >> 2] >> 2] = Math_imul(HEAP32[$4 + 24 >> 2], HEAP32[HEAP32[$4 + 32 >> 2] >> 2]);
  HEAP32[$4 + 44 >> 2] = 0;
 }
 global$0 = $4 + 48 | 0;
 return HEAP32[$4 + 44 >> 2];
}
function atan($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 wasm2js_scratch_store_f64(+$0);
 $1 = wasm2js_scratch_load_i32(1) | 0;
 $5 = wasm2js_scratch_load_i32(0) | 0;
 $4 = $1;
 $1 = $1 & 2147483647;
 label$1 : {
  if ($1 >>> 0 >= 1141899264) {
   $1 = $4 & 2147483647;
   if (($1 | 0) == 2146435072 & $5 >>> 0 > 0 | $1 >>> 0 > 2146435072) {
    break label$1;
   }
   return (($4 | 0) < 0 ? 1 : ($4 | 0) <= 0 ? $5 >>> 0 >= 0 ? 0 : 1 : 0) ? -1.5707963267948966 : 1.5707963267948966;
  }
  label$3 : {
   if ($1 >>> 0 <= 1071382527) {
    $3 = -1;
    if ($1 >>> 0 >= 1044381696) {
     break label$3;
    }
    break label$1;
   }
   $0 = Math_abs($0);
   if ($1 >>> 0 <= 1072889855) {
    if ($1 >>> 0 <= 1072037887) {
     $0 = ($0 + $0 + -1) / ($0 + 2);
     $3 = 0;
     break label$3;
    }
    $0 = ($0 + -1) / ($0 + 1);
    $3 = 1;
    break label$3;
   }
   if ($1 >>> 0 <= 1073971199) {
    $0 = ($0 + -1.5) / ($0 * 1.5 + 1);
    $3 = 2;
    break label$3;
   }
   $0 = -1 / $0;
   $3 = 3;
  }
  $1 = $3;
  $6 = $0 * $0;
  $2 = $6 * $6;
  $7 = $2 * ($2 * ($2 * ($2 * ($2 * -.036531572744216916 + -.058335701337905735) + -.0769187620504483) + -.11111110405462356) + -.19999999999876483);
  $2 = $6 * ($2 * ($2 * ($2 * ($2 * ($2 * .016285820115365782 + .049768779946159324) + .06661073137387531) + .09090887133436507) + .14285714272503466) + .3333333333333293);
  if (($1 | 0) <= -1) {
   return $0 - $0 * ($7 + $2);
  }
  $1 = $1 << 3;
  $0 = HEAPF64[$1 + 141504 >> 3] - ($0 * ($7 + $2) - HEAPF64[$1 + 141536 >> 3] - $0);
  $0 = (($4 | 0) < 0 ? 1 : ($4 | 0) <= 0 ? $5 >>> 0 >= 0 ? 0 : 1 : 0) ? -$0 : $0;
 }
 return $0;
}
function lcdMemLCD_fillRect($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0;
 $6 = global$0 - 48 | 0;
 global$0 = $6;
 HEAP32[$6 + 44 >> 2] = $0;
 HEAP32[$6 + 40 >> 2] = $1;
 HEAP32[$6 + 36 >> 2] = $2;
 HEAP32[$6 + 32 >> 2] = $3;
 HEAP32[$6 + 28 >> 2] = $4;
 HEAP32[$6 + 24 >> 2] = $5;
 HEAP8[324605] = 1;
 HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 36 >> 2];
 while (1) {
  if (HEAP32[$6 + 20 >> 2] <= HEAP32[$6 + 28 >> 2]) {
   HEAP32[$6 + 16 >> 2] = (Math_imul(HEAP32[$6 + 40 >> 2], 3) + 16 | 0) + (Math_imul(HEAP32[$6 + 20 >> 2], 68) << 3);
   HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 40 >> 2];
   while (1) {
    if (HEAP32[$6 + 12 >> 2] <= HEAP32[$6 + 32 >> 2]) {
     HEAP32[$6 + 8 >> 2] = HEAP32[$6 + 16 >> 2] & 7;
     HEAP32[$6 + 4 >> 2] = lcdMemLCD_convert16to3(HEAP32[$6 + 24 >> 2], HEAP32[$6 + 12 >> 2], HEAP32[$6 + 20 >> 2]);
     $0 = HEAP32[$6 + 16 >> 2] >> 3;
     $0 = HEAPU8[$0 + 324608 | 0] | HEAPU8[$0 + 324609 | 0] << 8;
     HEAP16[$6 + 2 >> 1] = ($0 << 24 | $0 << 8 & 16711680) >>> 16;
     HEAP16[$6 + 2 >> 1] = HEAPU16[$6 + 2 >> 1] & 16719871 >> HEAP32[$6 + 8 >> 2] | HEAP32[$6 + 4 >> 2] << 13 - HEAP32[$6 + 8 >> 2];
     $0 = HEAP32[$6 + 16 >> 2] >> 3;
     $1 = HEAPU16[$6 + 2 >> 1];
     $1 = ($1 << 24 | $1 << 8 & 16711680) >>> 16;
     HEAP8[$0 + 324608 | 0] = $1;
     HEAP8[$0 + 324609 | 0] = $1 >>> 8;
     HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 16 >> 2] + 3;
     HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 12 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 20 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $6 + 48 | 0;
}
function void_20tflite__reference_ops__Requantize_signed_20char_2c_20signed_20char__28signed_20char_20const__2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20signed_20char__29($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0;
 $7 = global$0 + -64 | 0;
 global$0 = $7;
 HEAP32[$7 + 60 >> 2] = $0;
 HEAP32[$7 + 56 >> 2] = $1;
 HEAP32[$7 + 52 >> 2] = $2;
 HEAP32[$7 + 48 >> 2] = $3;
 HEAP32[$7 + 44 >> 2] = $4;
 HEAP32[$7 + 40 >> 2] = $5;
 HEAP32[$7 + 36 >> 2] = $6;
 ruy__profiler__ScopeLabel__ScopeLabel_char_20const___28char_20const__29($7 + 32 | 0, 135680);
 HEAP8[$7 + 31 | 0] = HEAP32[$7 + 52 >> 2] == 1073741824 ? HEAP32[$7 + 48 >> 2] == 1 : 0;
 if (HEAP8[$7 + 31 | 0] & 1) {
  HEAP8[$7 + 30 | 0] = 0;
  HEAP8[$7 + 29 | 0] = 0;
  HEAP32[$7 + 24 >> 2] = HEAP32[$7 + 44 >> 2] - HEAP32[$7 + 40 >> 2];
 }
 HEAP32[$7 + 20 >> 2] = 0;
 while (1) {
  if (HEAP32[$7 + 20 >> 2] < HEAP32[$7 + 56 >> 2]) {
   HEAP32[$7 + 16 >> 2] = HEAP8[HEAP32[$7 + 60 >> 2] + HEAP32[$7 + 20 >> 2] | 0] - HEAP32[$7 + 44 >> 2];
   HEAP32[$7 + 12 >> 2] = tflite__MultiplyByQuantizedMultiplier_28int_2c_20int_2c_20int_29(HEAP32[$7 + 16 >> 2], HEAP32[$7 + 52 >> 2], HEAP32[$7 + 48 >> 2]) + HEAP32[$7 + 40 >> 2];
   HEAP32[$7 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29(int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($7 + 12 | 0, 135712), 135708) >> 2];
   HEAP8[HEAP32[$7 + 36 >> 2] + HEAP32[$7 + 20 >> 2] | 0] = HEAP32[$7 >> 2];
   HEAP32[$7 + 20 >> 2] = HEAP32[$7 + 20 >> 2] + 1;
   continue;
  }
  break;
 }
 tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($7 + 32 | 0);
 global$0 = $7 - -64 | 0;
}
function _jswrap_promise_add($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP8[$3 + 39 | 0] = $2;
 label$1 : {
  if (!(jsvIsFunction(HEAP32[$3 + 40 >> 2]) & 1)) {
   HEAP32[$3 >> 2] = HEAP32[$3 + 40 >> 2];
   jsExceptionHere(3, 125222, $3);
   break label$1;
  }
  HEAP8[$3 + 38 | 0] = 0;
  HEAP32[$3 + 32 >> 2] = 0;
  if (HEAP8[$3 + 39 | 0] & 1) {
   HEAP32[$3 + 28 >> 2] = jsvFindChildFromString(HEAP32[$3 + 44 >> 2], 125120, 0);
   if (HEAP32[$3 + 28 >> 2]) {
    HEAP8[$3 + 38 | 0] = 1;
    HEAP32[$3 + 32 >> 2] = jsvSkipNameAndUnLock(HEAP32[$3 + 28 >> 2]);
   }
  }
  HEAP32[$3 + 24 >> 2] = HEAP8[$3 + 39 | 0] & 1 ? 125099 : 125104;
  HEAP32[$3 + 20 >> 2] = jsvObjectGetChild(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 24 >> 2], 0);
  label$5 : {
   if (!HEAP32[$3 + 20 >> 2]) {
    jsvObjectSetChild(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 40 >> 2]);
    break label$5;
   }
   label$7 : {
    if (jsvIsArray(HEAP32[$3 + 20 >> 2]) & 1) {
     jsvArrayPush(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 40 >> 2]);
     break label$7;
    }
    HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 20 >> 2];
    HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 40 >> 2];
    HEAP32[$3 + 8 >> 2] = jsvNewArray($3 + 12 | 0, 2);
    jsvObjectSetChild(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 8 >> 2]);
    jsvUnLock(HEAP32[$3 + 8 >> 2]);
   }
   jsvUnLock(HEAP32[$3 + 20 >> 2]);
  }
  if (!(HEAP8[$3 + 38 | 0] & 1)) {
   break label$1;
  }
  _jswrap_promise_queueresolve(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 32 >> 2]);
  jsvUnLock(HEAP32[$3 + 32 >> 2]);
 }
 global$0 = $3 + 48 | 0;
}
function jswrap_io_digitalRead($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 48 | 0;
 global$0 = $1;
 HEAP32[$1 + 40 >> 2] = $0;
 label$1 : {
  if (jsvIsArray(HEAP32[$1 + 40 >> 2]) & 1) {
   HEAP32[$1 + 36 >> 2] = 0;
   HEAP32[$1 + 32 >> 2] = 0;
   jsvObjectIteratorNew($1 + 24 | 0, HEAP32[$1 + 40 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue($1 + 24 | 0) & 1) {
     $0 = $1 + 24 | 0;
     HEAP32[$1 + 20 >> 2] = jsvObjectIteratorGetValue($0);
     HEAP32[$1 + 32 >> 2] = HEAP32[$1 + 32 >> 2] << 1 | jshPinInput(jshGetPinFromVar(HEAP32[$1 + 20 >> 2]) & 255) & 1;
     jsvUnLock(HEAP32[$1 + 20 >> 2]);
     jsvObjectIteratorNext($0);
     HEAP32[$1 + 36 >> 2] = HEAP32[$1 + 36 >> 2] + 1;
     continue;
    }
    break;
   }
   jsvObjectIteratorFree($1 + 24 | 0);
   if (!HEAP32[$1 + 36 >> 2]) {
    HEAP32[$1 + 44 >> 2] = 0;
    break label$1;
   }
   HEAP32[$1 + 44 >> 2] = HEAP32[$1 + 32 >> 2];
   break label$1;
  }
  if (jsvIsObject(HEAP32[$1 + 40 >> 2]) & 1) {
   HEAP32[$1 + 16 >> 2] = 0;
   HEAP32[$1 + 12 >> 2] = jspGetNamedField(HEAP32[$1 + 40 >> 2], 121939, 0);
   label$7 : {
    if (jsvIsFunction(HEAP32[$1 + 12 >> 2]) & 1) {
     HEAP32[$1 + 16 >> 2] = jsvGetIntegerAndUnLock(jspeFunctionCall(HEAP32[$1 + 12 >> 2], 0, HEAP32[$1 + 40 >> 2], 0, 0, 0));
     break label$7;
    }
    jsExceptionHere(1, 121926, 0);
   }
   jsvUnLock(HEAP32[$1 + 12 >> 2]);
   HEAP32[$1 + 44 >> 2] = HEAP32[$1 + 16 >> 2];
   break label$1;
  }
  HEAP8[$1 + 11 | 0] = jshGetPinFromVar(HEAP32[$1 + 40 >> 2]);
  HEAP32[$1 + 44 >> 2] = jshPinInput(HEAPU8[$1 + 11 | 0]) & 1;
 }
 global$0 = $1 + 48 | 0;
 return HEAP32[$1 + 44 >> 2];
}
function void_20tflite__reference_ops__Requantize_short_2c_20signed_20char__28short_20const__2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20signed_20char__29($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0;
 $7 = global$0 + -64 | 0;
 global$0 = $7;
 HEAP32[$7 + 60 >> 2] = $0;
 HEAP32[$7 + 56 >> 2] = $1;
 HEAP32[$7 + 52 >> 2] = $2;
 HEAP32[$7 + 48 >> 2] = $3;
 HEAP32[$7 + 44 >> 2] = $4;
 HEAP32[$7 + 40 >> 2] = $5;
 HEAP32[$7 + 36 >> 2] = $6;
 ruy__profiler__ScopeLabel__ScopeLabel_char_20const___28char_20const__29($7 + 32 | 0, 135680);
 HEAP8[$7 + 31 | 0] = HEAP32[$7 + 52 >> 2] == 1073741824 ? HEAP32[$7 + 48 >> 2] == 1 : 0;
 if (HEAP8[$7 + 31 | 0] & 1) {
  HEAP8[$7 + 30 | 0] = 0;
  HEAP8[$7 + 29 | 0] = 0;
  HEAP32[$7 + 24 >> 2] = HEAP32[$7 + 44 >> 2] - HEAP32[$7 + 40 >> 2];
 }
 HEAP32[$7 + 20 >> 2] = 0;
 while (1) {
  if (HEAP32[$7 + 20 >> 2] < HEAP32[$7 + 56 >> 2]) {
   HEAP32[$7 + 16 >> 2] = HEAP16[HEAP32[$7 + 60 >> 2] + (HEAP32[$7 + 20 >> 2] << 1) >> 1] - HEAP32[$7 + 44 >> 2];
   HEAP32[$7 + 12 >> 2] = tflite__MultiplyByQuantizedMultiplier_28int_2c_20int_2c_20int_29(HEAP32[$7 + 16 >> 2], HEAP32[$7 + 52 >> 2], HEAP32[$7 + 48 >> 2]) + HEAP32[$7 + 40 >> 2];
   HEAP32[$7 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29(int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($7 + 12 | 0, 135696), 135692) >> 2];
   HEAP8[HEAP32[$7 + 36 >> 2] + HEAP32[$7 + 20 >> 2] | 0] = HEAP32[$7 >> 2];
   HEAP32[$7 + 20 >> 2] = HEAP32[$7 + 20 >> 2] + 1;
   continue;
  }
  break;
 }
 tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($7 + 32 | 0);
 global$0 = $7 - -64 | 0;
}
function __jspeConditionalExpression($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 label$1 : {
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 63) {
   jslGetNextToken();
   label$3 : {
    if ((HEAP32[80549] & 63) != 1) {
     jsvUnLock(__jspeAssignmentExpression(jspeConditionalExpression()));
     if (!(jslMatch(58) & 1)) {
      HEAP32[$1 + 28 >> 2] = 0;
      break label$1;
     }
     jsvUnLock(__jspeAssignmentExpression(jspeConditionalExpression()));
     break label$3;
    }
    HEAP8[$1 + 23 | 0] = jsvGetBoolAndUnLock(jsvSkipName(HEAP32[$1 + 24 >> 2])) & 1;
    jsvUnLock(HEAP32[$1 + 24 >> 2]);
    label$6 : {
     if (HEAP8[$1 + 23 | 0] & 1) {
      HEAP32[$1 + 24 >> 2] = __jspeAssignmentExpression(jspeConditionalExpression());
      if (!(jslMatch(58) & 1)) {
       HEAP32[$1 + 28 >> 2] = 0;
       break label$1;
      }
      HEAP32[$1 + 16 >> 2] = HEAP32[80549];
      jspSetNoExecute();
      jsvUnLock(__jspeAssignmentExpression(jspeConditionalExpression()));
      HEAP32[80549] = HEAP32[80549] & -1664 | HEAP32[$1 + 16 >> 2] & 1663;
      break label$6;
     }
     HEAP32[$1 + 12 >> 2] = HEAP32[80549];
     jspSetNoExecute();
     jsvUnLock(__jspeAssignmentExpression(jspeConditionalExpression()));
     HEAP32[80549] = HEAP32[80549] & -1664 | HEAP32[$1 + 12 >> 2] & 1663;
     if (!(jslMatch(58) & 1)) {
      HEAP32[$1 + 28 >> 2] = 0;
      break label$1;
     }
     HEAP32[$1 + 24 >> 2] = __jspeAssignmentExpression(jspeConditionalExpression());
    }
   }
  }
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 24 >> 2];
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function void_20tflite__reference_ops__Requantize_signed_20char_2c_20int__28signed_20char_20const__2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int__29($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0;
 $7 = global$0 + -64 | 0;
 global$0 = $7;
 HEAP32[$7 + 60 >> 2] = $0;
 HEAP32[$7 + 56 >> 2] = $1;
 HEAP32[$7 + 52 >> 2] = $2;
 HEAP32[$7 + 48 >> 2] = $3;
 HEAP32[$7 + 44 >> 2] = $4;
 HEAP32[$7 + 40 >> 2] = $5;
 HEAP32[$7 + 36 >> 2] = $6;
 ruy__profiler__ScopeLabel__ScopeLabel_char_20const___28char_20const__29($7 + 32 | 0, 136075);
 HEAP8[$7 + 31 | 0] = HEAP32[$7 + 52 >> 2] == 1073741824 ? HEAP32[$7 + 48 >> 2] == 1 : 0;
 if (HEAP8[$7 + 31 | 0] & 1) {
  HEAP8[$7 + 30 | 0] = 0;
  HEAP8[$7 + 29 | 0] = 0;
  HEAP32[$7 + 24 >> 2] = HEAP32[$7 + 44 >> 2] - HEAP32[$7 + 40 >> 2];
 }
 HEAP32[$7 + 20 >> 2] = 0;
 while (1) {
  if (HEAP32[$7 + 20 >> 2] < HEAP32[$7 + 56 >> 2]) {
   HEAP32[$7 + 16 >> 2] = HEAP8[HEAP32[$7 + 60 >> 2] + HEAP32[$7 + 20 >> 2] | 0] - HEAP32[$7 + 44 >> 2];
   HEAP32[$7 + 12 >> 2] = tflite__MultiplyByQuantizedMultiplier_28int_2c_20int_2c_20int_29(HEAP32[$7 + 16 >> 2], HEAP32[$7 + 52 >> 2], HEAP32[$7 + 48 >> 2]) + HEAP32[$7 + 40 >> 2];
   HEAP32[$7 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29(int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($7 + 12 | 0, 136100), 136096) >> 2];
   HEAP32[HEAP32[$7 + 36 >> 2] + (HEAP32[$7 + 20 >> 2] << 2) >> 2] = HEAP32[$7 >> 2];
   HEAP32[$7 + 20 >> 2] = HEAP32[$7 + 20 >> 2] + 1;
   continue;
  }
  break;
 }
 tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($7 + 32 | 0);
 global$0 = $7 - -64 | 0;
}
function _jswrap_graphics_getCharWidth($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP8[$3 + 19 | 0] = $2;
 label$1 : {
  if (!HEAP32[HEAP32[$3 + 20 >> 2] >> 2]) {
   HEAP32[$3 + 28 >> 2] = graphicsVectorCharWidth(HEAP32[$3 + 24 >> 2], HEAPU16[HEAP32[$3 + 20 >> 2] + 6 >> 1], HEAP8[$3 + 19 | 0]);
   break label$1;
  }
  if (HEAP32[HEAP32[$3 + 20 >> 2] >> 2] == 8192) {
   HEAP32[$3 + 28 >> 2] = HEAPU16[HEAP32[$3 + 20 >> 2] + 6 >> 1] << 2;
   break label$1;
  }
  if (HEAP32[HEAP32[$3 + 20 >> 2] >> 2] == 16384) {
   HEAP32[$3 + 28 >> 2] = Math_imul(HEAPU16[HEAP32[$3 + 20 >> 2] + 6 >> 1], 6);
   break label$1;
  }
  if (HEAP32[HEAP32[$3 + 20 >> 2] >> 2] & 32768) {
   HEAP32[$3 + 12 >> 2] = 0;
   $0 = HEAP32[$3 + 24 >> 2];
   HEAP32[$3 + 8 >> 2] = jsvObjectGetChild(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 127552, 0);
   label$6 : {
    if (jsvIsString(HEAP32[$3 + 8 >> 2]) & 1) {
     if (HEAP8[$3 + 19 | 0] >= HEAPU8[HEAP32[$3 + 20 >> 2] + 10 | 0]) {
      HEAP32[$3 + 12 >> 2] = Math_imul(HEAPU16[HEAP32[$3 + 20 >> 2] + 6 >> 1], jsvGetCharInString(HEAP32[$3 + 8 >> 2], HEAP8[$3 + 19 | 0] - HEAPU8[HEAP32[$3 + 20 >> 2] + 10 | 0] | 0) & 255);
     }
     break label$6;
    }
    HEAP32[$3 + 12 >> 2] = Math_imul(HEAPU16[HEAP32[$3 + 20 >> 2] + 6 >> 1], jsvGetInteger(HEAP32[$3 + 8 >> 2]));
   }
   jsvUnLock(HEAP32[$3 + 8 >> 2]);
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2];
   break label$1;
  }
  HEAP32[$3 + 28 >> 2] = 0;
 }
 global$0 = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}
function void_20tflite__reference_ops__Requantize_short_2c_20short__28short_20const__2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20short__29($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0;
 $7 = global$0 + -64 | 0;
 global$0 = $7;
 HEAP32[$7 + 60 >> 2] = $0;
 HEAP32[$7 + 56 >> 2] = $1;
 HEAP32[$7 + 52 >> 2] = $2;
 HEAP32[$7 + 48 >> 2] = $3;
 HEAP32[$7 + 44 >> 2] = $4;
 HEAP32[$7 + 40 >> 2] = $5;
 HEAP32[$7 + 36 >> 2] = $6;
 ruy__profiler__ScopeLabel__ScopeLabel_char_20const___28char_20const__29($7 + 32 | 0, 135680);
 HEAP8[$7 + 31 | 0] = HEAP32[$7 + 52 >> 2] == 1073741824 ? HEAP32[$7 + 48 >> 2] == 1 : 0;
 if (HEAP8[$7 + 31 | 0] & 1) {
  HEAP8[$7 + 30 | 0] = 0;
  HEAP8[$7 + 29 | 0] = 0;
  HEAP32[$7 + 24 >> 2] = HEAP32[$7 + 44 >> 2] - HEAP32[$7 + 40 >> 2];
 }
 HEAP32[$7 + 20 >> 2] = 0;
 while (1) {
  if (HEAP32[$7 + 20 >> 2] < HEAP32[$7 + 56 >> 2]) {
   HEAP32[$7 + 16 >> 2] = HEAP16[HEAP32[$7 + 60 >> 2] + (HEAP32[$7 + 20 >> 2] << 1) >> 1] - HEAP32[$7 + 44 >> 2];
   HEAP32[$7 + 12 >> 2] = tflite__MultiplyByQuantizedMultiplier_28int_2c_20int_2c_20int_29(HEAP32[$7 + 16 >> 2], HEAP32[$7 + 52 >> 2], HEAP32[$7 + 48 >> 2]) + HEAP32[$7 + 40 >> 2];
   HEAP32[$7 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29(int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($7 + 12 | 0, 135704), 135700) >> 2];
   HEAP16[HEAP32[$7 + 36 >> 2] + (HEAP32[$7 + 20 >> 2] << 1) >> 1] = HEAP32[$7 >> 2];
   HEAP32[$7 + 20 >> 2] = HEAP32[$7 + 20 >> 2] + 1;
   continue;
  }
  break;
 }
 tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($7 + 32 | 0);
 global$0 = $7 - -64 | 0;
}
function void_20tflite__reference_ops__Requantize_short_2c_20int__28short_20const__2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int__29($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0;
 $7 = global$0 + -64 | 0;
 global$0 = $7;
 HEAP32[$7 + 60 >> 2] = $0;
 HEAP32[$7 + 56 >> 2] = $1;
 HEAP32[$7 + 52 >> 2] = $2;
 HEAP32[$7 + 48 >> 2] = $3;
 HEAP32[$7 + 44 >> 2] = $4;
 HEAP32[$7 + 40 >> 2] = $5;
 HEAP32[$7 + 36 >> 2] = $6;
 ruy__profiler__ScopeLabel__ScopeLabel_char_20const___28char_20const__29($7 + 32 | 0, 136075);
 HEAP8[$7 + 31 | 0] = HEAP32[$7 + 52 >> 2] == 1073741824 ? HEAP32[$7 + 48 >> 2] == 1 : 0;
 if (HEAP8[$7 + 31 | 0] & 1) {
  HEAP8[$7 + 30 | 0] = 0;
  HEAP8[$7 + 29 | 0] = 0;
  HEAP32[$7 + 24 >> 2] = HEAP32[$7 + 44 >> 2] - HEAP32[$7 + 40 >> 2];
 }
 HEAP32[$7 + 20 >> 2] = 0;
 while (1) {
  if (HEAP32[$7 + 20 >> 2] < HEAP32[$7 + 56 >> 2]) {
   HEAP32[$7 + 16 >> 2] = HEAP16[HEAP32[$7 + 60 >> 2] + (HEAP32[$7 + 20 >> 2] << 1) >> 1] - HEAP32[$7 + 44 >> 2];
   HEAP32[$7 + 12 >> 2] = tflite__MultiplyByQuantizedMultiplier_28int_2c_20int_2c_20int_29(HEAP32[$7 + 16 >> 2], HEAP32[$7 + 52 >> 2], HEAP32[$7 + 48 >> 2]) + HEAP32[$7 + 40 >> 2];
   HEAP32[$7 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29(int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($7 + 12 | 0, 136092), 136088) >> 2];
   HEAP32[HEAP32[$7 + 36 >> 2] + (HEAP32[$7 + 20 >> 2] << 2) >> 2] = HEAP32[$7 >> 2];
   HEAP32[$7 + 20 >> 2] = HEAP32[$7 + 20 >> 2] + 1;
   continue;
  }
  break;
 }
 tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($7 + 32 | 0);
 global$0 = $7 - -64 | 0;
}
function get_bits($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP8[$2 + 7 | 0] = $1;
 HEAP16[$2 + 4 >> 1] = 0;
 HEAP32[$2 >> 2] = 0;
 label$1 : {
  if (HEAPU8[$2 + 7 | 0] > 15) {
   HEAP16[$2 + 14 >> 1] = 65535;
   break label$1;
  }
  if (!HEAPU16[HEAP32[$2 + 8 >> 2] >> 1]) {
   if (HEAPU8[HEAP32[$2 + 8 >> 2] + 12 | 0] < 1 << HEAPU8[$2 + 7 | 0] - 1) {
    HEAP16[$2 + 14 >> 1] = 65535;
    break label$1;
   }
  }
  HEAP32[$2 >> 2] = 0;
  while (1) {
   if (HEAP32[$2 >> 2] < HEAPU8[$2 + 7 | 0]) {
    if (!HEAPU8[HEAP32[$2 + 8 >> 2] + 12 | 0]) {
     if (!HEAPU16[HEAP32[$2 + 8 >> 2] >> 1]) {
      HEAP16[$2 + 14 >> 1] = 65535;
      break label$1;
     }
     $0 = HEAP32[$2 + 8 >> 2];
     $1 = HEAPU16[$0 + 2 >> 1];
     HEAP16[$0 + 2 >> 1] = $1 + 1;
     HEAP8[HEAP32[$2 + 8 >> 2] + 11 | 0] = HEAPU8[$1 + ($0 + 13 | 0) | 0];
     if (HEAPU16[HEAP32[$2 + 8 >> 2] + 2 >> 1] == HEAPU16[HEAP32[$2 + 8 >> 2] >> 1]) {
      HEAP16[HEAP32[$2 + 8 >> 2] + 2 >> 1] = 0;
      HEAP16[HEAP32[$2 + 8 >> 2] >> 1] = 0;
     }
     HEAP8[HEAP32[$2 + 8 >> 2] + 12 | 0] = 128;
    }
    HEAP16[$2 + 4 >> 1] = HEAPU16[$2 + 4 >> 1] << 1;
    if (HEAPU8[HEAP32[$2 + 8 >> 2] + 11 | 0] & HEAPU8[HEAP32[$2 + 8 >> 2] + 12 | 0]) {
     HEAP16[$2 + 4 >> 1] = HEAPU16[$2 + 4 >> 1] | 1;
    }
    $0 = HEAP32[$2 + 8 >> 2];
    HEAP8[$0 + 12 | 0] = HEAPU8[$0 + 12 | 0] >> 1;
    HEAP32[$2 >> 2] = HEAP32[$2 >> 2] + 1;
    continue;
   }
   break;
  }
  label$11 : {
   if (HEAPU8[$2 + 7 | 0] <= 1) {
    break label$11;
   }
  }
  HEAP16[$2 + 14 >> 1] = HEAPU16[$2 + 4 >> 1];
 }
 return HEAPU16[$2 + 14 >> 1];
}
function jswrap_json_stringify($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP32[$3 + 36 >> 2] = $2;
 HEAP32[$3 + 32 >> 2] = 3280;
 HEAP32[$3 + 28 >> 2] = jsvNewWithFlags(27);
 if (HEAP32[$3 + 28 >> 2]) {
  HEAP8[$3 + 17 | 0] = 0;
  HEAP8[$3 + 18 | 0] = 0;
  HEAP8[$3 + 19 | 0] = 0;
  HEAP8[$3 + 20 | 0] = 0;
  HEAP8[$3 + 21 | 0] = 0;
  HEAP8[$3 + 22 | 0] = 0;
  HEAP8[$3 + 23 | 0] = 0;
  HEAP8[$3 + 24 | 0] = 0;
  HEAP8[$3 + 24 | 0] = 0;
  HEAP8[$3 + 25 | 0] = 0;
  HEAP8[$3 + 26 | 0] = 0;
  HEAP8[$3 + 27 | 0] = 0;
  label$2 : {
   if (jsvIsUndefined(HEAP32[$3 + 36 >> 2]) & 1) {
    break label$2;
   }
   if (jsvIsNull(HEAP32[$3 + 36 >> 2]) & 1) {
    break label$2;
   }
   label$3 : {
    if (jsvIsNumeric(HEAP32[$3 + 36 >> 2]) & 1) {
     HEAP32[$3 + 12 >> 2] = jsvGetInteger(HEAP32[$3 + 36 >> 2]);
     if (HEAPU32[$3 + 12 >> 2] > 10) {
      HEAP32[$3 + 12 >> 2] = 10;
     }
     HEAP8[HEAP32[$3 + 12 >> 2] + ($3 + 17 | 0) | 0] = 0;
     while (1) {
      if (HEAP32[$3 + 12 >> 2]) {
       $0 = HEAP32[$3 + 12 >> 2] + -1 | 0;
       HEAP32[$3 + 12 >> 2] = $0;
       HEAP8[$0 + ($3 + 17 | 0) | 0] = 32;
       continue;
      }
      break;
     }
     break label$3;
    }
    jsvGetString(HEAP32[$3 + 36 >> 2], $3 + 17 | 0, 11);
   }
  }
  if (strlen($3 + 17 | 0)) {
   HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 32 >> 2] | 6;
  }
  jsfGetJSONWhitespace(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 28 >> 2], HEAP32[$3 + 32 >> 2], $3 + 17 | 0);
 }
 global$0 = $3 + 48 | 0;
 return HEAP32[$3 + 28 >> 2];
}
function jswrap_decodeURIComponent($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 112 | 0;
 global$0 = $1;
 HEAP32[$1 + 104 >> 2] = $0;
 HEAP32[$1 + 100 >> 2] = jsvAsString(HEAP32[$1 + 104 >> 2]);
 label$1 : {
  if (!HEAP32[$1 + 100 >> 2]) {
   HEAP32[$1 + 108 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 96 >> 2] = jsvNewWithFlags(27);
  if (HEAP32[$1 + 96 >> 2]) {
   $0 = $1 + 16 | 0;
   jsvStringIteratorNew($1 + 56 | 0, HEAP32[$1 + 100 >> 2], 0);
   jsvStringIteratorNew($0, HEAP32[$1 + 96 >> 2], 0);
   while (1) {
    label$5 : {
     if (!(jsvStringIteratorHasChar($1 + 56 | 0) & 1)) {
      break label$5;
     }
     HEAP8[$1 + 15 | 0] = jsvStringIteratorGetCharAndNext($1 + 56 | 0);
     if (HEAP8[$1 + 15 | 0] >> 7) {
      jsExceptionHere(1, 121428, 0);
      break label$5;
     }
     if (HEAP8[$1 + 15 | 0] == 37) {
      $0 = $1 + 56 | 0;
      HEAP32[$1 + 8 >> 2] = jsvStringIteratorGetCharAndNext($0) << 24 >> 24;
      HEAP32[$1 + 4 >> 2] = jsvStringIteratorGetCharAndNext($0) << 24 >> 24;
      HEAP32[$1 >> 2] = hexToByte(HEAP32[$1 + 8 >> 2] << 24 >> 24, HEAP32[$1 + 4 >> 2] << 24 >> 24) << 24 >> 24;
      if (HEAP32[$1 >> 2] < 0) {
       jsExceptionHere(1, 121440, 0);
       break label$5;
      }
      HEAP8[$1 + 15 | 0] = HEAP32[$1 >> 2];
     }
     jsvStringIteratorAppend($1 + 16 | 0, HEAP8[$1 + 15 | 0]);
     continue;
    }
    break;
   }
   $0 = $1 + 56 | 0;
   jsvStringIteratorFree($1 + 16 | 0);
   jsvStringIteratorFree($0);
  }
  jsvUnLock(HEAP32[$1 + 100 >> 2]);
  HEAP32[$1 + 108 >> 2] = HEAP32[$1 + 96 >> 2];
 }
 global$0 = $1 + 112 | 0;
 return HEAP32[$1 + 108 >> 2];
}
function getCalendarDate($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $1;
 HEAP32[$2 >> 2] = 119600;
 HEAP32[$0 >> 2] = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 12 >> 2] / 1461;
 HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] - Math_imul(HEAP32[$2 + 8 >> 2], 1461);
 if (HEAP32[$2 + 12 >> 2] < 0) {
  HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1461;
  HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] + -1;
 }
 HEAP32[$2 + 8 >> 2] = (HEAP32[$2 + 8 >> 2] << 2) + 1970;
 if (HEAP32[$2 + 12 >> 2] >= 365) {
  HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] + 1;
  HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] - 365;
  if (HEAP32[$2 + 12 >> 2] >= 365) {
   HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] + 1;
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] - 365;
   label$4 : {
    if (HEAP32[$2 + 12 >> 2] >= 366) {
     HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] + 1;
     HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] - 366;
     break label$4;
    }
    HEAP32[$2 >> 2] = 119632;
   }
  }
 }
 HEAP32[$0 + 12 >> 2] = HEAP32[$2 + 8 >> 2];
 HEAP32[$2 + 4 >> 2] = 0;
 while (1) {
  if (HEAP16[HEAP32[$2 >> 2] + (HEAP32[$2 + 4 >> 2] << 1) >> 1] < (HEAP32[$2 + 12 >> 2] + 1 | 0) ? HEAP32[$2 + 4 >> 2] < 12 : 0) {
   HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[$0 + 8 >> 2] = HEAP32[$2 + 4 >> 2] - 1;
 HEAP32[$0 + 4 >> 2] = (HEAP32[$2 + 12 >> 2] - HEAP16[HEAP32[$2 >> 2] + (HEAP32[$0 + 8 >> 2] << 1) >> 1] | 0) + 1;
 HEAP32[$0 + 16 >> 2] = (HEAP32[$0 >> 2] + 4 | 0) % 7;
 if (HEAP32[$0 + 16 >> 2] < 0) {
  HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 16 >> 2] + 7;
 }
}
function jspeExpressionOrArrowFunction() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP8[$0 + 3 | 0] = 1;
 label$1 : {
  while (1) {
   if ((HEAP16[HEAP32[35539] + 2 >> 1] != 41 ? (HEAP32[80549] & 80) != 0 ^ -1 : 0) & 1) {
    if (!(!(HEAP8[$0 + 3 | 0] & 1) | !HEAP32[$0 + 8 >> 2])) {
     HEAP32[$0 + 4 >> 2] = jspeAddNamedFunctionParameter(HEAP32[$0 + 4 >> 2], HEAP32[$0 + 8 >> 2]);
    }
    jsvUnLock(HEAP32[$0 + 8 >> 2]);
    HEAP32[$0 + 8 >> 2] = __jspeAssignmentExpression(jspeConditionalExpression());
    label$7 : {
     if ((HEAP32[80549] & 63) != 1) {
      break label$7;
     }
     if (jsvIsName(HEAP32[$0 + 8 >> 2]) & 1) {
      if (jsvIsString(HEAP32[$0 + 8 >> 2]) & 1) {
       break label$7;
      }
     }
     HEAP8[$0 + 3 | 0] = 0;
    }
    if (HEAP16[HEAP32[35539] + 2 >> 1] != 41) {
     if (!(jslMatch(44) & 1)) {
      jsvUnLock2(HEAP32[$0 + 8 >> 2], HEAP32[$0 + 4 >> 2]);
      HEAP32[$0 + 12 >> 2] = 0;
      break label$1;
     }
    }
    continue;
   }
   break;
  }
  if (!(jslMatch(41) & 1)) {
   jsvUnLock2(HEAP32[$0 + 8 >> 2], HEAP32[$0 + 4 >> 2]);
   HEAP32[$0 + 12 >> 2] = 0;
   break label$1;
  }
  if (!(!(HEAP8[$0 + 3 | 0] & 1) | HEAP16[HEAP32[35539] + 2 >> 1] != 162)) {
   HEAP32[$0 + 4 >> 2] = jspeArrowFunction(HEAP32[$0 + 4 >> 2], HEAP32[$0 + 8 >> 2]);
   jsvUnLock(HEAP32[$0 + 8 >> 2]);
   HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 4 >> 2];
   break label$1;
  }
  jsvUnLock(HEAP32[$0 + 4 >> 2]);
  HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 8 >> 2];
 }
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}
function pop_arg($0, $1, $2) {
 label$1 : {
  label$2 : {
   if ($1 >>> 0 > 20) {
    break label$2;
   }
   $1 = $1 + -9 | 0;
   if ($1 >>> 0 > 9) {
    break label$2;
   }
   label$3 : {
    switch ($1 - 1 | 0) {
    default:
     $1 = HEAP32[$2 >> 2];
     HEAP32[$2 >> 2] = $1 + 4;
     HEAP32[$0 >> 2] = HEAP32[$1 >> 2];
     return;
    case 0:
     $1 = HEAP32[$2 >> 2];
     HEAP32[$2 >> 2] = $1 + 4;
     $1 = HEAP32[$1 >> 2];
     HEAP32[$0 >> 2] = $1;
     HEAP32[$0 + 4 >> 2] = $1 >> 31;
     return;
    case 1:
     $1 = HEAP32[$2 >> 2];
     HEAP32[$2 >> 2] = $1 + 4;
     HEAP32[$0 >> 2] = HEAP32[$1 >> 2];
     HEAP32[$0 + 4 >> 2] = 0;
     return;
    case 3:
     $1 = HEAP32[$2 >> 2];
     HEAP32[$2 >> 2] = $1 + 4;
     $1 = HEAP16[$1 >> 1];
     HEAP32[$0 >> 2] = $1;
     HEAP32[$0 + 4 >> 2] = $1 >> 31;
     return;
    case 4:
     $1 = HEAP32[$2 >> 2];
     HEAP32[$2 >> 2] = $1 + 4;
     HEAP32[$0 >> 2] = HEAPU16[$1 >> 1];
     HEAP32[$0 + 4 >> 2] = 0;
     return;
    case 5:
     $1 = HEAP32[$2 >> 2];
     HEAP32[$2 >> 2] = $1 + 4;
     $1 = HEAP8[$1 | 0];
     HEAP32[$0 >> 2] = $1;
     HEAP32[$0 + 4 >> 2] = $1 >> 31;
     return;
    case 6:
     $1 = HEAP32[$2 >> 2];
     HEAP32[$2 >> 2] = $1 + 4;
     HEAP32[$0 >> 2] = HEAPU8[$1 | 0];
     HEAP32[$0 + 4 >> 2] = 0;
     return;
    case 2:
    case 7:
     break label$1;
    case 8:
     break label$3;
    }
   }
   FUNCTION_TABLE[689]($0, $2);
  }
  return;
 }
 $1 = HEAP32[$2 >> 2] + 7 & -8;
 HEAP32[$2 >> 2] = $1 + 8;
 $2 = HEAP32[$1 + 4 >> 2];
 HEAP32[$0 >> 2] = HEAP32[$1 >> 2];
 HEAP32[$0 + 4 >> 2] = $2;
}
function lcdFillRect_ArrayBuffer_flat1($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0;
 $6 = global$0 - 48 | 0;
 HEAP32[$6 + 44 >> 2] = $0;
 HEAP32[$6 + 40 >> 2] = $1;
 HEAP32[$6 + 36 >> 2] = $2;
 HEAP32[$6 + 32 >> 2] = $3;
 HEAP32[$6 + 28 >> 2] = $4;
 HEAP32[$6 + 24 >> 2] = $5;
 HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 36 >> 2];
 while (1) {
  if (HEAP32[$6 + 20 >> 2] <= HEAP32[$6 + 28 >> 2]) {
   $0 = HEAP32[$6 + 44 >> 2];
   HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 40 >> 2] + Math_imul(HEAP32[$6 + 20 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
   HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 40 >> 2];
   while (1) {
    if (HEAP32[$6 + 12 >> 2] <= HEAP32[$6 + 32 >> 2]) {
     label$5 : {
      if (HEAP32[$6 + 24 >> 2]) {
       $0 = HEAP32[$6 + 44 >> 2];
       $0 = (HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24)) + (HEAP32[$6 + 16 >> 2] >> 3) | 0;
       HEAP8[$0 | 0] = HEAPU8[$0 | 0] | 128 >> (HEAP32[$6 + 16 >> 2] & 7) & 255;
       break label$5;
      }
      $0 = HEAP32[$6 + 44 >> 2];
      $0 = (HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24)) + (HEAP32[$6 + 16 >> 2] >> 3) | 0;
      HEAP8[$0 | 0] = HEAPU8[$0 | 0] & (65407 >> (HEAP32[$6 + 16 >> 2] & 7) & 255);
     }
     HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 16 >> 2] + 1;
     HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 12 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 20 >> 2] + 1;
   continue;
  }
  break;
 }
}
function tflite__MicroInterpreter__ResetVariableTensors_28_29($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 $0 = HEAP32[$1 + 24 >> 2];
 HEAP32[$1 + 20 >> 2] = 0;
 label$1 : {
  while (1) {
   if (HEAPU32[$1 + 20 >> 2] < flatbuffers__Vector_int___size_28_29_20const(tflite__Tensor__shape_28_29_20const(HEAP32[$0 + 116 >> 2])) >>> 0) {
    HEAP32[$1 + 16 >> 2] = flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph__20___Get_28unsigned_20int_29_20const(tflite__Tensor__shape_28_29_20const(HEAP32[$0 + 116 >> 2]), HEAP32[$1 + 20 >> 2]);
    if (tflite__Tensor__is_variable_28_29_20const(HEAP32[$1 + 16 >> 2]) & 1) {
     HEAP32[$1 + 8 >> 2] = tflite__TfLiteEvalTensorByteLength_28TfLiteEvalTensor_20const__2c_20unsigned_20long__29(HEAP32[$0 + 120 >> 2] + Math_imul(HEAP32[$1 + 20 >> 2], 12) | 0, $1 + 12 | 0);
     if (HEAP32[$1 + 8 >> 2]) {
      HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 8 >> 2];
      break label$1;
     }
     HEAP32[$1 + 4 >> 2] = 0;
     if ((tflite__Tensor__type_28_29_20const(HEAP32[$1 + 16 >> 2]) | 0) == 9) {
      HEAP32[$1 + 4 >> 2] = flatbuffers__Vector_long_20long___Get_28unsigned_20int_29_20const(tflite__SubGraph__operators_28_29_20const(tflite__Tensor__quantization_28_29_20const(HEAP32[$1 + 16 >> 2])), 0);
     }
     memset(HEAP32[HEAP32[$0 + 120 >> 2] + Math_imul(HEAP32[$1 + 20 >> 2], 12) >> 2], HEAP32[$1 + 4 >> 2], HEAP32[$1 + 12 >> 2]);
    }
    HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 20 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$1 + 28 >> 2] = 0;
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function mbedtls_sha256_update($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 label$1 : {
  if (!HEAP32[$3 + 20 >> 2]) {
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = HEAP32[HEAP32[$3 + 28 >> 2] >> 2] & 63;
  HEAP32[$3 + 16 >> 2] = 64 - HEAP32[$3 + 12 >> 2];
  $0 = HEAP32[$3 + 28 >> 2];
  HEAP32[$0 >> 2] = HEAP32[$3 + 20 >> 2] + HEAP32[$0 >> 2];
  $0 = HEAP32[$3 + 28 >> 2];
  HEAP32[$0 >> 2] = HEAP32[$0 >> 2];
  if (HEAPU32[HEAP32[$3 + 28 >> 2] >> 2] < HEAPU32[$3 + 20 >> 2]) {
   $0 = HEAP32[$3 + 28 >> 2];
   HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + 1;
  }
  if (!(!HEAP32[$3 + 12 >> 2] | HEAPU32[$3 + 20 >> 2] < HEAPU32[$3 + 16 >> 2])) {
   memcpy(HEAP32[$3 + 12 >> 2] + (HEAP32[$3 + 28 >> 2] + 40 | 0) | 0, HEAP32[$3 + 24 >> 2], HEAP32[$3 + 16 >> 2]);
   mbedtls_sha256_process(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 28 >> 2] + 40 | 0);
   HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 16 >> 2] + HEAP32[$3 + 24 >> 2];
   HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] - HEAP32[$3 + 16 >> 2];
   HEAP32[$3 + 12 >> 2] = 0;
  }
  while (1) {
   if (HEAPU32[$3 + 20 >> 2] >= 64) {
    mbedtls_sha256_process(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2]);
    HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 24 >> 2] - -64;
    HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] + -64;
    continue;
   }
   break;
  }
  if (HEAPU32[$3 + 20 >> 2] <= 0) {
   break label$1;
  }
  memcpy(HEAP32[$3 + 12 >> 2] + (HEAP32[$3 + 28 >> 2] + 40 | 0) | 0, HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
 }
 global$0 = $3 + 32 | 0;
}
function jshGetCharToTransmit($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP8[$1 + 11 | 0] = $0;
 label$1 : {
  if (!(HEAPU8[$1 + 11 | 0] < 21 | HEAPU8[$1 + 11 | 0] > 22)) {
   HEAP32[$1 + 4 >> 2] = HEAPU8[$1 + 11 | 0] + 322287;
   if (HEAP8[HEAP32[$1 + 4 >> 2]] & 1) {
    HEAP8[HEAP32[$1 + 4 >> 2]] = HEAPU8[HEAP32[$1 + 4 >> 2]] & -2 | 4;
    HEAP32[$1 + 12 >> 2] = 19;
    break label$1;
   }
   if (HEAPU8[HEAP32[$1 + 4 >> 2]] & 2) {
    HEAP8[HEAP32[$1 + 4 >> 2]] = HEAPU8[HEAP32[$1 + 4 >> 2]] & -7;
    HEAP32[$1 + 12 >> 2] = 17;
    break label$1;
   }
  }
  HEAP8[$1 + 3 | 0] = HEAPU8[322305];
  while (1) {
   if (HEAPU8[322304] != HEAPU8[$1 + 3 | 0]) {
    if (HEAPU8[$1 + 11 | 0] == (HEAPU8[(HEAPU8[$1 + 3 | 0] << 1) + 322384 | 0] & 31)) {
     HEAP8[$1 + 2 | 0] = HEAPU8[((HEAPU8[$1 + 3 | 0] << 1) + 322384 | 0) + 1 | 0];
     if (HEAPU8[$1 + 3 | 0] != HEAPU8[322305]) {
      HEAP8[$1 + 1 | 0] = HEAPU8[$1 + 3 | 0];
      HEAP8[$1 | 0] = HEAPU8[$1 + 1 | 0] + 255;
      while (1) {
       if (HEAPU8[$1 + 1 | 0] != HEAPU8[322305]) {
        HEAP16[(HEAPU8[$1 + 1 | 0] << 1) + 322384 >> 1] = HEAPU16[(HEAPU8[$1 | 0] << 1) + 322384 >> 1];
        HEAP8[$1 + 1 | 0] = HEAPU8[$1 | 0];
        HEAP8[$1 | 0] = HEAPU8[$1 + 1 | 0] + 255;
        continue;
       }
       break;
      }
     }
     HEAP8[322305] = HEAPU8[322305] + 1;
     HEAP32[$1 + 12 >> 2] = HEAPU8[$1 + 2 | 0];
     break label$1;
    } else {
     HEAP8[$1 + 3 | 0] = HEAPU8[$1 + 3 | 0] + 1;
     continue;
    }
   }
   break;
  }
  HEAP32[$1 + 12 >> 2] = -1;
 }
 return HEAP32[$1 + 12 >> 2];
}
function mbedtls_sha1_update($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 label$1 : {
  if (!HEAP32[$3 + 20 >> 2]) {
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = HEAP32[HEAP32[$3 + 28 >> 2] >> 2] & 63;
  HEAP32[$3 + 16 >> 2] = 64 - HEAP32[$3 + 12 >> 2];
  $0 = HEAP32[$3 + 28 >> 2];
  HEAP32[$0 >> 2] = HEAP32[$3 + 20 >> 2] + HEAP32[$0 >> 2];
  $0 = HEAP32[$3 + 28 >> 2];
  HEAP32[$0 >> 2] = HEAP32[$0 >> 2];
  if (HEAPU32[HEAP32[$3 + 28 >> 2] >> 2] < HEAPU32[$3 + 20 >> 2]) {
   $0 = HEAP32[$3 + 28 >> 2];
   HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + 1;
  }
  if (!(!HEAP32[$3 + 12 >> 2] | HEAPU32[$3 + 20 >> 2] < HEAPU32[$3 + 16 >> 2])) {
   memcpy(HEAP32[$3 + 12 >> 2] + (HEAP32[$3 + 28 >> 2] + 28 | 0) | 0, HEAP32[$3 + 24 >> 2], HEAP32[$3 + 16 >> 2]);
   mbedtls_sha1_process(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 28 >> 2] + 28 | 0);
   HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 16 >> 2] + HEAP32[$3 + 24 >> 2];
   HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] - HEAP32[$3 + 16 >> 2];
   HEAP32[$3 + 12 >> 2] = 0;
  }
  while (1) {
   if (HEAPU32[$3 + 20 >> 2] >= 64) {
    mbedtls_sha1_process(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2]);
    HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 24 >> 2] - -64;
    HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] + -64;
    continue;
   }
   break;
  }
  if (HEAPU32[$3 + 20 >> 2] <= 0) {
   break label$1;
  }
  memcpy(HEAP32[$3 + 12 >> 2] + (HEAP32[$3 + 28 >> 2] + 28 | 0) | 0, HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
 }
 global$0 = $3 + 32 | 0;
}
function jswrap_graphics_getFont($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = global$0 - 128 | 0;
 global$0 = $1;
 HEAP32[$1 + 120 >> 2] = $0;
 label$1 : {
  if (!(graphicsGetFromVar($1 + 48 | 0, HEAP32[$1 + 120 >> 2]) & 1)) {
   HEAP32[$1 + 124 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 44 >> 2] = (HEAPU8[$1 + 73 | 0] | HEAPU8[$1 + 74 | 0] << 8) & 57344;
  HEAP32[$1 + 40 >> 2] = 0;
  if (!HEAP32[$1 + 44 >> 2]) {
   HEAP32[$1 + 40 >> 2] = 127697;
  }
  if (HEAP32[$1 + 44 >> 2] == 8192) {
   HEAP32[$1 + 40 >> 2] = 127704;
  }
  if (HEAP32[$1 + 44 >> 2] == 16384) {
   HEAP32[$1 + 40 >> 2] = 127708;
  }
  if (HEAP32[$1 + 44 >> 2] & 32768) {
   HEAP32[$1 + 40 >> 2] = 127738;
  }
  if (HEAP32[$1 + 40 >> 2]) {
   HEAP32[$1 + 36 >> 2] = (HEAPU8[$1 + 73 | 0] | HEAPU8[$1 + 74 | 0] << 8) & 8191;
   if (HEAP32[$1 + 36 >> 2] & 4096) {
    $0 = HEAP32[$1 + 40 >> 2];
    $2 = HEAP32[$1 + 36 >> 2];
    HEAP32[$1 + 8 >> 2] = (HEAP32[$1 + 36 >> 2] & 4032) >> 6;
    HEAP32[$1 + 4 >> 2] = $2 & 63;
    HEAP32[$1 >> 2] = $0;
    HEAP32[$1 + 124 >> 2] = jsvVarPrintf(127745, $1);
    break label$1;
   }
   if (HEAP32[$1 + 36 >> 2] > 1) {
    $0 = HEAP32[$1 + 40 >> 2];
    HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 36 >> 2];
    HEAP32[$1 + 16 >> 2] = $0;
    HEAP32[$1 + 124 >> 2] = jsvVarPrintf(127754, $1 + 16 | 0);
    break label$1;
   }
   HEAP32[$1 + 124 >> 2] = jsvNewFromString(HEAP32[$1 + 40 >> 2]);
   break label$1;
  }
  HEAP32[$1 + 124 >> 2] = jsvNewFromInteger(HEAPU8[$1 + 73 | 0] | HEAPU8[$1 + 74 | 0] << 8);
 }
 global$0 = $1 + 128 | 0;
 return HEAP32[$1 + 124 >> 2];
}
function tflite__CalculateActivationRangeQuantized_28TfLiteContext__2c_20TfLiteFusedActivation_2c_20TfLiteTensor__2c_20int__2c_20int__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 48 | 0;
 global$0 = $5;
 HEAP32[$5 + 40 >> 2] = $0;
 HEAP32[$5 + 36 >> 2] = $1;
 HEAP32[$5 + 32 >> 2] = $2;
 HEAP32[$5 + 28 >> 2] = $3;
 HEAP32[$5 + 24 >> 2] = $4;
 HEAP32[$5 + 20 >> 2] = 0;
 HEAP32[$5 + 16 >> 2] = 0;
 label$1 : {
  label$2 : {
   if (HEAP32[HEAP32[$5 + 32 >> 2] + 28 >> 2] == 3) {
    HEAP32[$5 + 20 >> 2] = 0;
    HEAP32[$5 + 16 >> 2] = 255;
    break label$2;
   }
   label$4 : {
    if (HEAP32[HEAP32[$5 + 32 >> 2] + 28 >> 2] == 9) {
     HEAP32[$5 + 20 >> 2] = -128;
     HEAP32[$5 + 16 >> 2] = 127;
     break label$4;
    }
    label$6 : {
     if (HEAP32[HEAP32[$5 + 32 >> 2] + 28 >> 2] == 7) {
      HEAP32[$5 + 20 >> 2] = -32768;
      HEAP32[$5 + 16 >> 2] = 32767;
      break label$6;
     }
     $0 = HEAP32[HEAP32[$5 + 40 >> 2] + 20 >> 2];
     $1 = HEAP32[$5 + 40 >> 2];
     HEAP32[$5 + 8 >> 2] = 137612;
     HEAP32[$5 + 4 >> 2] = 261;
     HEAP32[$5 >> 2] = 137133;
     FUNCTION_TABLE[$0]($1, 137293, $5);
     HEAP32[$5 + 44 >> 2] = 1;
     break label$1;
    }
   }
  }
  tflite___28anonymous_20namespace_29__CalculateActivationRangeQuantizedImpl_28TfLiteFusedActivation_2c_20int_2c_20int_2c_20TfLiteTensor__2c_20int__2c_20int__29(HEAP32[$5 + 36 >> 2], HEAP32[$5 + 20 >> 2], HEAP32[$5 + 16 >> 2], HEAP32[$5 + 32 >> 2], HEAP32[$5 + 28 >> 2], HEAP32[$5 + 24 >> 2]);
  HEAP32[$5 + 44 >> 2] = 0;
 }
 global$0 = $5 + 48 | 0;
 return HEAP32[$5 + 44 >> 2];
}
function memset($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 label$1 : {
  if (!$2) {
   break label$1;
  }
  $4 = $0 + $2 | 0;
  HEAP8[$4 + -1 | 0] = $1;
  HEAP8[$0 | 0] = $1;
  if ($2 >>> 0 < 3) {
   break label$1;
  }
  HEAP8[$4 + -2 | 0] = $1;
  HEAP8[$0 + 1 | 0] = $1;
  HEAP8[$4 + -3 | 0] = $1;
  HEAP8[$0 + 2 | 0] = $1;
  if ($2 >>> 0 < 7) {
   break label$1;
  }
  HEAP8[$4 + -4 | 0] = $1;
  HEAP8[$0 + 3 | 0] = $1;
  if ($2 >>> 0 < 9) {
   break label$1;
  }
  $5 = $0;
  $0 = 0 - $0 & 3;
  $3 = $5 + $0 | 0;
  $1 = Math_imul($1 & 255, 16843009);
  HEAP32[$3 >> 2] = $1;
  $0 = $2 - $0 & -4;
  $2 = $0 + $3 | 0;
  HEAP32[$2 + -4 >> 2] = $1;
  if ($0 >>> 0 < 9) {
   break label$1;
  }
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$2 + -8 >> 2] = $1;
  HEAP32[$2 + -12 >> 2] = $1;
  if ($0 >>> 0 < 25) {
   break label$1;
  }
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP32[$3 + 16 >> 2] = $1;
  HEAP32[$3 + 12 >> 2] = $1;
  HEAP32[$2 + -16 >> 2] = $1;
  HEAP32[$2 + -20 >> 2] = $1;
  HEAP32[$2 + -24 >> 2] = $1;
  HEAP32[$2 + -28 >> 2] = $1;
  $4 = $3 & 4 | 24;
  $2 = $0 - $4 | 0;
  if ($2 >>> 0 < 32) {
   break label$1;
  }
  $0 = $1;
  $5 = $1;
  $1 = $3 + $4 | 0;
  while (1) {
   HEAP32[$1 + 24 >> 2] = $5;
   HEAP32[$1 + 28 >> 2] = $0;
   HEAP32[$1 + 16 >> 2] = $5;
   HEAP32[$1 + 20 >> 2] = $0;
   HEAP32[$1 + 8 >> 2] = $5;
   HEAP32[$1 + 12 >> 2] = $0;
   HEAP32[$1 >> 2] = $5;
   HEAP32[$1 + 4 >> 2] = $0;
   $1 = $1 + 32 | 0;
   $2 = $2 + -32 | 0;
   if ($2 >>> 0 > 31) {
    continue;
   }
   break;
  }
 }
}
function tflite__GetQuantizedConvolutionMultipler_28TfLiteContext__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor__2c_20double__29($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = global$0 - 80 | 0;
 global$0 = $6;
 HEAP32[$6 + 72 >> 2] = $0;
 HEAP32[$6 + 68 >> 2] = $1;
 HEAP32[$6 + 64 >> 2] = $2;
 HEAP32[$6 + 60 >> 2] = $3;
 HEAP32[$6 + 56 >> 2] = $4;
 HEAP32[$6 + 52 >> 2] = $5;
 HEAPF64[$6 + 40 >> 3] = +HEAPF32[HEAP32[$6 + 68 >> 2] + 8 >> 2] * +HEAPF32[HEAP32[$6 + 64 >> 2] + 8 >> 2];
 label$1 : {
  if (HEAP32[$6 + 60 >> 2]) {
   HEAPF64[$6 + 32 >> 3] = HEAPF32[HEAP32[$6 + 60 >> 2] + 8 >> 2];
   $0 = global$0 - 16 | 0;
   HEAPF64[$0 + 8 >> 3] = HEAPF64[$6 + 40 >> 3] - HEAPF64[$6 + 32 >> 3];
   HEAPF64[$6 + 24 >> 3] = Math_abs(HEAPF64[$0 + 8 >> 3]);
   HEAPF64[$6 + 16 >> 3] = HEAPF32[HEAP32[$6 + 56 >> 2] + 8 >> 2];
   if (!(HEAPF64[$6 + 24 >> 3] / HEAPF64[$6 + 16 >> 3] <= .02)) {
    $0 = HEAP32[HEAP32[$6 + 72 >> 2] + 20 >> 2];
    $1 = HEAP32[$6 + 72 >> 2];
    HEAP32[$6 + 8 >> 2] = 137553;
    HEAP32[$6 + 4 >> 2] = 197;
    HEAP32[$6 >> 2] = 137133;
    FUNCTION_TABLE[$0]($1, 137293, $6);
    HEAP32[$6 + 76 >> 2] = 1;
    break label$1;
   }
  }
  HEAP32[$6 + 76 >> 2] = tflite__GetQuantizedConvolutionMultipler_28TfLiteContext__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor__2c_20double__29(HEAP32[$6 + 72 >> 2], HEAP32[$6 + 68 >> 2], HEAP32[$6 + 64 >> 2], HEAP32[$6 + 56 >> 2], HEAP32[$6 + 52 >> 2]);
 }
 global$0 = $6 + 80 | 0;
 return HEAP32[$6 + 76 >> 2];
}
function jsvGetIndexOfFull($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 96 | 0;
 global$0 = $5;
 HEAP32[$5 + 88 >> 2] = $0;
 HEAP32[$5 + 84 >> 2] = $1;
 HEAP8[$5 + 83 | 0] = $2;
 HEAP8[$5 + 82 | 0] = $3;
 HEAP32[$5 + 76 >> 2] = $4;
 label$1 : {
  if (!(jsvIsIterable(HEAP32[$5 + 88 >> 2]) & 1)) {
   HEAP32[$5 + 92 >> 2] = 0;
   break label$1;
  }
  jsvIteratorNew($5 + 16 | 0, HEAP32[$5 + 88 >> 2], 0);
  while (1) {
   if (jsvIteratorHasElement($5 + 16 | 0) & 1) {
    HEAP32[$5 + 12 >> 2] = jsvIteratorGetKey($5 + 16 | 0);
    label$5 : {
     if (HEAP8[$5 + 82 | 0] & 1) {
      if (!(jsvIsInt(HEAP32[$5 + 12 >> 2]) & 1)) {
       break label$5;
      }
      if ((jsvGetInteger(HEAP32[$5 + 12 >> 2]) | 0) < HEAP32[$5 + 76 >> 2]) {
       break label$5;
      }
     }
     HEAP32[$5 + 8 >> 2] = jsvIteratorGetValue($5 + 16 | 0);
     label$7 : {
      if (HEAP32[$5 + 8 >> 2] != HEAP32[$5 + 84 >> 2]) {
       if (HEAP8[$5 + 83 | 0] & 1) {
        break label$7;
       }
       if (!(jsvMathsOpTypeEqual(HEAP32[$5 + 8 >> 2], HEAP32[$5 + 84 >> 2]) & 1)) {
        break label$7;
       }
      }
      $0 = $5 + 16 | 0;
      jsvUnLock(HEAP32[$5 + 8 >> 2]);
      jsvIteratorFree($0);
      HEAP32[$5 + 92 >> 2] = HEAP32[$5 + 12 >> 2];
      break label$1;
     }
     jsvUnLock(HEAP32[$5 + 8 >> 2]);
    }
    $0 = $5 + 16 | 0;
    jsvUnLock(HEAP32[$5 + 12 >> 2]);
    jsvIteratorNext($0);
    continue;
   }
   break;
  }
  jsvIteratorFree($5 + 16 | 0);
  HEAP32[$5 + 92 >> 2] = 0;
 }
 global$0 = $5 + 96 | 0;
 return HEAP32[$5 + 92 >> 2];
}
function st_yield_backref($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = HEAP32[HEAP32[$2 + 20 >> 2] + 4 >> 2] - HEAP32[HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2] >> 2];
 label$1 : {
  if (HEAPU32[$2 + 16 >> 2] > 0) {
   HEAP32[$2 + 12 >> 2] = 0;
   if (HEAPU16[HEAP32[$2 + 24 >> 2] + 4 >> 1] < HEAPU32[$2 + 16 >> 2]) {
    HEAP32[$2 + 16 >> 2] = HEAPU16[HEAP32[$2 + 24 >> 2] + 4 >> 1];
   }
   HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 24 >> 2] + 45;
   HEAP16[$2 + 6 >> 1] = 255;
   HEAP16[$2 + 4 >> 1] = HEAPU16[HEAP32[$2 + 24 >> 2] + 6 >> 1];
   HEAP32[$2 + 12 >> 2] = 0;
   while (1) {
    if (HEAPU32[$2 + 12 >> 2] < HEAPU32[$2 + 16 >> 2]) {
     HEAP8[$2 + 3 | 0] = HEAPU8[HEAP32[$2 + 8 >> 2] + (HEAPU16[$2 + 6 >> 1] & HEAPU16[HEAP32[$2 + 24 >> 2] + 8 >> 1] - HEAPU16[$2 + 4 >> 1]) | 0];
     push_byte(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], HEAPU8[$2 + 3 | 0]);
     HEAP8[HEAP32[$2 + 8 >> 2] + (HEAPU16[HEAP32[$2 + 24 >> 2] + 8 >> 1] & HEAPU16[$2 + 6 >> 1]) | 0] = HEAPU8[$2 + 3 | 0];
     $0 = HEAP32[$2 + 24 >> 2];
     HEAP16[$0 + 8 >> 1] = HEAPU16[$0 + 8 >> 1] + 1;
     HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
     continue;
    }
    break;
   }
   $0 = HEAP32[$2 + 24 >> 2];
   HEAP16[$0 + 4 >> 1] = HEAPU16[$0 + 4 >> 1] - HEAP32[$2 + 16 >> 2];
   if (!HEAPU16[HEAP32[$2 + 24 >> 2] + 4 >> 1]) {
    HEAP32[$2 + 28 >> 2] = 0;
    break label$1;
   }
  }
  HEAP32[$2 + 28 >> 2] = 6;
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function jswrap_io_digitalWrite($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 label$1 : {
  if (jsvIsArray(HEAP32[$2 + 28 >> 2]) & 1) {
   HEAP16[$2 + 22 >> 1] = jsvGetLastChild(HEAP32[$2 + 28 >> 2]);
   while (1) {
    if (HEAPU16[$2 + 22 >> 1]) {
     HEAP32[$2 + 16 >> 2] = jsvLock(HEAPU16[$2 + 22 >> 1]);
     HEAP32[$2 + 12 >> 2] = jsvSkipName(HEAP32[$2 + 16 >> 2]);
     jshPinOutput(jshGetPinFromVar(HEAP32[$2 + 12 >> 2]) & 255, (HEAP32[$2 + 24 >> 2] & 1) != 0);
     jsvUnLock(HEAP32[$2 + 12 >> 2]);
     HEAP16[$2 + 22 >> 1] = jsvGetPrevSibling(HEAP32[$2 + 16 >> 2]);
     jsvUnLock(HEAP32[$2 + 16 >> 2]);
     HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 24 >> 2] >> 1;
     continue;
    }
    break;
   }
   break label$1;
  }
  label$5 : {
   if (jsvIsObject(HEAP32[$2 + 28 >> 2]) & 1) {
    HEAP32[$2 + 8 >> 2] = jspGetNamedField(HEAP32[$2 + 28 >> 2], 121920, 0);
    label$7 : {
     if (jsvIsFunction(HEAP32[$2 + 8 >> 2]) & 1) {
      $0 = $2 + 4 | 0;
      HEAP32[$2 + 4 >> 2] = jsvNewFromInteger(HEAP32[$2 + 24 >> 2]);
      jsvUnLock(jspeFunctionCall(HEAP32[$2 + 8 >> 2], 0, HEAP32[$2 + 28 >> 2], 0, 1, $0));
      jsvUnLock(HEAP32[$2 + 4 >> 2]);
      break label$7;
     }
     jsExceptionHere(1, 121926, 0);
    }
    jsvUnLock(HEAP32[$2 + 8 >> 2]);
    break label$5;
   }
   HEAP8[$2 + 3 | 0] = jshGetPinFromVar(HEAP32[$2 + 28 >> 2]);
   jshPinOutput(HEAPU8[$2 + 3 | 0], HEAP32[$2 + 24 >> 2] != 0);
  }
 }
 global$0 = $2 + 32 | 0;
}
function jsvStringIteratorAppend($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 label$1 : {
  if (!HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2]) {
   break label$1;
  }
  if (HEAPU32[HEAP32[$2 + 12 >> 2] + 4 >> 2] > 0) {
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
  }
  if (HEAPU32[HEAP32[$2 + 12 >> 2] >> 2] >= jsvGetMaxCharactersInVar(HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2]) >>> 0) {
   HEAP32[$2 + 4 >> 2] = jsvNewWithFlags(41);
   if (!HEAP32[$2 + 4 >> 2]) {
    jsvUnLock(HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2]);
    HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2] = 0;
    HEAP32[HEAP32[$2 + 12 >> 2] + 16 >> 2] = 0;
    HEAP32[HEAP32[$2 + 12 >> 2] >> 2] = 0;
    break label$1;
   }
   jsvSetLastChild(HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2], jsvGetRef(HEAP32[$2 + 4 >> 2]) & 65535);
   jsvUnLock(HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2]);
   HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2] = HEAP32[$2 + 4 >> 2];
   HEAP32[HEAP32[$2 + 12 >> 2] + 16 >> 2] = HEAP32[$2 + 4 >> 2];
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 + 8 >> 2] = HEAP32[HEAP32[$2 + 12 >> 2] >> 2] + HEAP32[$0 + 8 >> 2];
   HEAP32[HEAP32[$2 + 12 >> 2] >> 2] = 0;
  }
  HEAP8[HEAP32[HEAP32[$2 + 12 >> 2] + 16 >> 2] + HEAP32[HEAP32[$2 + 12 >> 2] >> 2] | 0] = HEAPU8[$2 + 11 | 0];
  HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2] = HEAP32[HEAP32[$2 + 12 >> 2] >> 2] + 1;
  jsvSetCharactersInVar(HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2], HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2]);
 }
 global$0 = $2 + 16 | 0;
}
function jswrap_graphics_getModified($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 96 | 0;
 global$0 = $2;
 HEAP32[$2 + 88 >> 2] = $0;
 HEAP8[$2 + 87 | 0] = $1;
 label$1 : {
  if (!(graphicsGetFromVar($2 + 8 | 0, HEAP32[$2 + 88 >> 2]) & 1)) {
   HEAP32[$2 + 92 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 4 >> 2] = 0;
  if ((HEAPU8[$2 + 48 | 0] | HEAPU8[$2 + 49 | 0] << 8) << 16 >> 16 <= (HEAPU8[$2 + 52 | 0] | HEAPU8[$2 + 53 | 0] << 8) << 16 >> 16) {
   HEAP32[$2 + 4 >> 2] = jsvNewWithFlags(5);
   if (HEAP32[$2 + 4 >> 2]) {
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 4 >> 2], 127466, jsvNewFromInteger((HEAPU8[$2 + 48 | 0] | HEAPU8[$2 + 49 | 0] << 8) << 16 >> 16));
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 4 >> 2], 127469, jsvNewFromInteger((HEAPU8[$2 + 50 | 0] | HEAPU8[$2 + 51 | 0] << 8) << 16 >> 16));
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 4 >> 2], 127472, jsvNewFromInteger((HEAPU8[$2 + 52 | 0] | HEAPU8[$2 + 53 | 0] << 8) << 16 >> 16));
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 4 >> 2], 127475, jsvNewFromInteger((HEAPU8[$2 + 54 | 0] | HEAPU8[$2 + 55 | 0] << 8) << 16 >> 16));
   }
  }
  if (HEAP8[$2 + 87 | 0] & 1) {
   HEAP8[$2 + 52 | 0] = 32768;
   HEAP8[$2 + 53 | 0] = 128;
   HEAP8[$2 + 54 | 0] = 32768;
   HEAP8[$2 + 55 | 0] = 128;
   HEAP8[$2 + 48 | 0] = 32767;
   HEAP8[$2 + 49 | 0] = 127;
   HEAP8[$2 + 50 | 0] = 32767;
   HEAP8[$2 + 51 | 0] = 127;
   graphicsSetVar($2 + 8 | 0);
  }
  HEAP32[$2 + 92 >> 2] = HEAP32[$2 + 4 >> 2];
 }
 global$0 = $2 + 96 | 0;
 return HEAP32[$2 + 92 >> 2];
}
function graphicsDrawRect($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0;
 $5 = global$0 - 32 | 0;
 global$0 = $5;
 $6 = $5 + 16 | 0;
 $7 = $5 + 12 | 0;
 HEAP32[$5 + 28 >> 2] = $0;
 HEAP32[$5 + 24 >> 2] = $1;
 HEAP32[$5 + 20 >> 2] = $2;
 HEAP32[$5 + 16 >> 2] = $3;
 HEAP32[$5 + 12 >> 2] = $4;
 graphicsToDeviceCoordinates(HEAP32[$5 + 28 >> 2], $5 + 24 | 0, $5 + 20 | 0);
 graphicsToDeviceCoordinates(HEAP32[$5 + 28 >> 2], $6, $7);
 $0 = HEAP32[$5 + 28 >> 2];
 graphicsFillRectDevice(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 24 >> 2], HEAP32[$5 + 20 >> 2], HEAP32[$5 + 16 >> 2], HEAP32[$5 + 20 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
 $0 = HEAP32[$5 + 28 >> 2];
 graphicsFillRectDevice(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 16 >> 2], HEAP32[$5 + 20 >> 2], HEAP32[$5 + 16 >> 2], HEAP32[$5 + 12 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
 $0 = HEAP32[$5 + 28 >> 2];
 graphicsFillRectDevice(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 24 >> 2], HEAP32[$5 + 12 >> 2], HEAP32[$5 + 16 >> 2], HEAP32[$5 + 12 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
 $0 = HEAP32[$5 + 28 >> 2];
 graphicsFillRectDevice(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 24 >> 2], HEAP32[$5 + 12 >> 2], HEAP32[$5 + 24 >> 2], HEAP32[$5 + 20 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
 global$0 = $5 + 32 | 0;
}
function jsvAsNumber($0) {
 var $1 = 0;
 $1 = global$0 - 80 | 0;
 global$0 = $1;
 HEAP32[$1 + 72 >> 2] = $0;
 label$1 : {
  label$2 : {
   if (!(jsvIsInt(HEAP32[$1 + 72 >> 2]) & 1)) {
    if (!(jsvIsFloat(HEAP32[$1 + 72 >> 2]) & 1)) {
     break label$2;
    }
   }
   HEAP32[$1 + 76 >> 2] = jsvLockAgain(HEAP32[$1 + 72 >> 2]);
   break label$1;
  }
  label$4 : {
   label$5 : {
    if (jsvIsBoolean(HEAP32[$1 + 72 >> 2]) & 1) {
     break label$5;
    }
    if (jsvIsPin(HEAP32[$1 + 72 >> 2]) & 1) {
     break label$5;
    }
    if (jsvIsNull(HEAP32[$1 + 72 >> 2]) & 1) {
     break label$5;
    }
    if (jsvIsBoolean(HEAP32[$1 + 72 >> 2]) & 1) {
     break label$5;
    }
    if (!(jsvIsArrayBufferName(HEAP32[$1 + 72 >> 2]) & 1)) {
     break label$4;
    }
   }
   HEAP32[$1 + 76 >> 2] = jsvNewFromInteger(jsvGetInteger(HEAP32[$1 + 72 >> 2]));
   break label$1;
  }
  label$6 : {
   if (!(jsvIsString(HEAP32[$1 + 72 >> 2]) & 1)) {
    break label$6;
   }
   if (!(jsvIsEmptyString(HEAP32[$1 + 72 >> 2]) & 1)) {
    if (!(jsvIsStringNumericInt(HEAP32[$1 + 72 >> 2], 0) & 1)) {
     break label$6;
    }
   }
   if ((jsvGetString(HEAP32[$1 + 72 >> 2], $1, 64) | 0) == 64) {
    jsExceptionHere(1, 78511, 0);
    HEAP32[$1 + 76 >> 2] = jsvNewFromFloat(nan);
    break label$1;
   }
   HEAP32[$1 + 76 >> 2] = jsvNewFromLongInteger(stringToInt($1), i64toi32_i32$HIGH_BITS);
   break label$1;
  }
  HEAP32[$1 + 76 >> 2] = jsvNewFromFloat(jsvGetFloat(HEAP32[$1 + 72 >> 2]));
 }
 global$0 = $1 + 80 | 0;
 return HEAP32[$1 + 76 >> 2];
}
function jswrap_isNaN($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = global$0 + -64 | 0;
 global$0 = $1;
 HEAP32[$1 + 56 >> 2] = $0;
 label$1 : {
  label$2 : {
   label$3 : {
    if (jsvIsUndefined(HEAP32[$1 + 56 >> 2]) & 1) {
     break label$3;
    }
    if (jsvIsObject(HEAP32[$1 + 56 >> 2]) & 1) {
     break label$3;
    }
    if (!(jsvIsFloat(HEAP32[$1 + 56 >> 2]) & 1)) {
     if (!(jsvIsArray(HEAP32[$1 + 56 >> 2]) & 1)) {
      break label$2;
     }
    }
    $0 = __DOUBLE_BITS(jsvGetFloat(HEAP32[$1 + 56 >> 2]));
    $2 = i64toi32_i32$HIGH_BITS & 2147483647;
    if (($2 | 0) == 2146435072 & $0 >>> 0 > 0 | $2 >>> 0 > 2146435072) {
     break label$3;
    }
    break label$2;
   }
   HEAP8[$1 + 63 | 0] = 1;
   break label$1;
  }
  if (jsvIsString(HEAP32[$1 + 56 >> 2]) & 1) {
   HEAP8[$1 + 55 | 0] = 1;
   jsvStringIteratorNew($1 + 16 | 0, HEAP32[$1 + 56 >> 2], 0);
   while (1) {
    if (jsvStringIteratorHasChar($1 + 16 | 0) & 1) {
     if (isWhitespace(jsvStringIteratorGetCharAndNext($1 + 16 | 0) << 24 >> 24) & 1) {
      continue;
     }
     HEAP8[$1 + 55 | 0] = 0;
    }
    break;
   }
   jsvStringIteratorFree($1 + 16 | 0);
   if (HEAP8[$1 + 55 | 0] & 1) {
    HEAP8[$1 + 63 | 0] = 0;
    break label$1;
   }
   $0 = __DOUBLE_BITS(jsvGetFloat(HEAP32[$1 + 56 >> 2]));
   $2 = i64toi32_i32$HIGH_BITS & 2147483647;
   HEAP8[$1 + 63 | 0] = ($2 | 0) == 2146435072 & $0 >>> 0 > 0 | $2 >>> 0 > 2146435072;
   break label$1;
  }
  HEAP8[$1 + 63 | 0] = 0;
 }
 global$0 = $1 - -64 | 0;
 return HEAP8[$1 + 63 | 0] & 1;
}
function jspeStatementVar() {
 var $0 = 0, $1 = 0;
 $0 = global$0 - 32 | 0;
 global$0 = $0;
 HEAP32[$0 + 24 >> 2] = 0;
 jslGetNextToken();
 HEAP8[$0 + 23 | 0] = 1;
 while (1) {
  $1 = 0;
  label$2 : {
   if (!(HEAP8[$0 + 23 | 0] & 1)) {
    break label$2;
   }
   $1 = 0;
   if (HEAP16[HEAP32[35539] + 2 >> 1] != 128) {
    break label$2;
   }
   $1 = jspIsInterrupted() ^ -1;
  }
  if ($1 & 1) {
   label$4 : {
    HEAP32[$0 + 16 >> 2] = 0;
    if ((HEAP32[80549] & 63) == 1) {
     HEAP32[$0 + 16 >> 2] = jspeiFindOnTop(jslGetTokenValueAsString());
     if (!HEAP32[$0 + 16 >> 2]) {
      jspSetError();
      break label$4;
     }
    }
    if (!(jslMatch(128) & 1)) {
     jsvUnLock(HEAP32[$0 + 16 >> 2]);
     break label$4;
    }
    if (HEAP16[HEAP32[35539] + 2 >> 1] == 61) {
     if (!(jslMatch(61) & 1)) {
      jsvUnLock(HEAP32[$0 + 16 >> 2]);
      break label$4;
     }
     HEAP32[$0 + 12 >> 2] = jsvSkipNameAndUnLock(__jspeAssignmentExpression(jspeConditionalExpression()));
     if ((HEAP32[80549] & 63) == 1) {
      jsvReplaceWith(HEAP32[$0 + 16 >> 2], HEAP32[$0 + 12 >> 2]);
     }
     jsvUnLock(HEAP32[$0 + 12 >> 2]);
    }
    jsvUnLock(HEAP32[$0 + 24 >> 2]);
    HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 16 >> 2];
    HEAP8[$0 + 23 | 0] = HEAP16[HEAP32[35539] + 2 >> 1] == 44;
    if (HEAP8[$0 + 23 | 0] & 1) {
     if (!(jslMatch(44) & 1)) {
      break label$4;
     }
    }
    continue;
   }
  }
  break;
 }
 HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 24 >> 2];
 global$0 = $0 + 32 | 0;
 return HEAP32[$0 + 28 >> 2];
}
function jsiDumpSerialInitialisation($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 48 | 0;
 global$0 = $4;
 HEAP32[$4 + 44 >> 2] = $0;
 HEAP32[$4 + 40 >> 2] = $1;
 HEAP32[$4 + 36 >> 2] = $2;
 HEAP8[$4 + 35 | 0] = $3;
 HEAP32[$4 + 28 >> 2] = jsvFindChildFromString(HEAP32[80545], HEAP32[$4 + 36 >> 2], 0);
 HEAP32[$4 + 24 >> 2] = jsvSkipName(HEAP32[$4 + 28 >> 2]);
 if (HEAP32[$4 + 24 >> 2]) {
  if (HEAP8[$4 + 35 | 0] & 1) {
   jsiDumpObjectState(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 40 >> 2], HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2]);
  }
  HEAP32[$4 + 20 >> 2] = jsvObjectGetChild(HEAP32[$4 + 24 >> 2], 81182, 0);
  HEAP32[$4 + 16 >> 2] = jsvObjectGetChild(HEAP32[$4 + 24 >> 2], 81192, 0);
  if (!(HEAP32[$4 + 16 >> 2] ? 0 : !HEAP32[$4 + 20 >> 2])) {
   HEAP32[$4 + 12 >> 2] = jsvGetInteger(HEAP32[$4 + 20 >> 2]);
   if (HEAP32[$4 + 12 >> 2] <= 0) {
    HEAP32[$4 + 12 >> 2] = 9600;
   }
   $0 = HEAP32[$4 + 44 >> 2];
   $1 = HEAP32[$4 + 40 >> 2];
   $2 = HEAP32[$4 + 36 >> 2];
   HEAP32[$4 + 4 >> 2] = HEAP32[$4 + 12 >> 2];
   HEAP32[$4 >> 2] = $2;
   cbprintf($0, $1, 81201, $4);
   if (jsvIsObject(HEAP32[$4 + 16 >> 2]) & 1) {
    FUNCTION_TABLE[HEAP32[$4 + 44 >> 2]](81213, HEAP32[$4 + 40 >> 2]);
    jsfGetJSONWithCallback(HEAP32[$4 + 16 >> 2], 0, 32, 0, HEAP32[$4 + 44 >> 2], HEAP32[$4 + 40 >> 2]);
   }
   FUNCTION_TABLE[HEAP32[$4 + 44 >> 2]](81216, HEAP32[$4 + 40 >> 2]);
  }
  jsvUnLock3(HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2], HEAP32[$4 + 24 >> 2]);
 }
 jsvUnLock(HEAP32[$4 + 28 >> 2]);
 global$0 = $4 + 48 | 0;
}
function internal_memalign($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $2 = 16;
 $3 = $0 >>> 0 > 16 ? $0 : 16;
 label$1 : {
  if (!($3 + -1 & $3)) {
   $0 = $3;
   break label$1;
  }
  while (1) {
   $0 = $2;
   $2 = $0 << 1;
   if ($0 >>> 0 < $3 >>> 0) {
    continue;
   }
   break;
  }
 }
 if (-64 - $0 >>> 0 <= $1 >>> 0) {
  HEAP32[84242] = 48;
  return 0;
 }
 $3 = $1 >>> 0 < 11 ? 16 : $1 + 11 & -8;
 $2 = dlmalloc(($3 + $0 | 0) + 12 | 0);
 if (!$2) {
  return 0;
 }
 $1 = $2 + -8 | 0;
 label$6 : {
  if (!($2 & $0 + -1)) {
   $0 = $1;
   break label$6;
  }
  $5 = $2 + -4 | 0;
  $6 = HEAP32[$5 >> 2];
  $2 = (($0 + $2 | 0) + -1 & 0 - $0) + -8 | 0;
  $0 = $2 - $1 >>> 0 > 15 ? $2 : $0 + $2 | 0;
  $2 = $0 - $1 | 0;
  $4 = ($6 & -8) - $2 | 0;
  if (!($6 & 3)) {
   $1 = HEAP32[$1 >> 2];
   HEAP32[$0 + 4 >> 2] = $4;
   HEAP32[$0 >> 2] = $1 + $2;
   break label$6;
  }
  HEAP32[$0 + 4 >> 2] = $4 | HEAP32[$0 + 4 >> 2] & 1 | 2;
  $4 = $0 + $4 | 0;
  HEAP32[$4 + 4 >> 2] = HEAP32[$4 + 4 >> 2] | 1;
  HEAP32[$5 >> 2] = $2 | HEAP32[$5 >> 2] & 1 | 2;
  HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] | 1;
  dispose_chunk($1, $2);
 }
 $1 = HEAP32[$0 + 4 >> 2];
 label$9 : {
  if (!($1 & 3)) {
   break label$9;
  }
  $2 = $1 & -8;
  if ($2 >>> 0 <= $3 + 16 >>> 0) {
   break label$9;
  }
  HEAP32[$0 + 4 >> 2] = $3 | $1 & 1 | 2;
  $1 = $0 + $3 | 0;
  $3 = $2 - $3 | 0;
  HEAP32[$1 + 4 >> 2] = $3 | 3;
  $2 = $0 + $2 | 0;
  HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] | 1;
  dispose_chunk($1, $3);
 }
 return $0 + 8 | 0;
}
function jshSPISendMany($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 48 | 0;
 global$0 = $4;
 HEAP8[$4 + 47 | 0] = $0;
 HEAP32[$4 + 40 >> 2] = $1;
 HEAP32[$4 + 36 >> 2] = $2;
 HEAP32[$4 + 32 >> 2] = $3;
 HEAP32[$4 + 28 >> 2] = 0;
 HEAP32[$4 + 24 >> 2] = 0;
 HEAP32[$4 + 20 >> 2] = 0;
 while (1) {
  if (HEAPU32[$4 + 24 >> 2] < HEAPU32[$4 + 32 >> 2]) {
   $0 = jspIsInterrupted() ^ -1;
  } else {
   $0 = 0;
  }
  if ($0 & 1) {
   $0 = HEAPU8[$4 + 47 | 0];
   $1 = HEAP32[$4 + 40 >> 2];
   $2 = HEAP32[$4 + 24 >> 2];
   HEAP32[$4 + 24 >> 2] = $2 + 1;
   HEAP32[$4 + 16 >> 2] = jshSPISend($0, HEAPU8[$1 + $2 | 0]);
   if (HEAP32[$4 + 16 >> 2] >= 0) {
    if (HEAP32[$4 + 36 >> 2]) {
     $0 = HEAP32[$4 + 16 >> 2];
     $1 = HEAP32[$4 + 36 >> 2];
     $2 = HEAP32[$4 + 20 >> 2];
     HEAP32[$4 + 20 >> 2] = $2 + 1;
     HEAP8[$1 + $2 | 0] = $0;
    }
   }
   continue;
  }
  break;
 }
 label$7 : {
  if (HEAP32[$4 + 36 >> 2]) {
   while (1) {
    if (HEAPU32[$4 + 20 >> 2] < HEAPU32[$4 + 32 >> 2]) {
     $0 = jspIsInterrupted() ^ -1;
    } else {
     $0 = 0;
    }
    if ($0 & 1) {
     HEAP32[$4 + 12 >> 2] = jshSPISend(HEAPU8[$4 + 47 | 0], -1);
     $0 = HEAP32[$4 + 12 >> 2];
     $1 = HEAP32[$4 + 36 >> 2];
     $2 = HEAP32[$4 + 20 >> 2];
     HEAP32[$4 + 20 >> 2] = $2 + 1;
     HEAP8[$1 + $2 | 0] = $0;
     continue;
    }
    break;
   }
   break label$7;
  }
  jshUSARTUnSetup(HEAPU8[$4 + 47 | 0]);
 }
 if (HEAP32[$4 + 28 >> 2]) {
  FUNCTION_TABLE[HEAP32[$4 + 28 >> 2]]();
 }
 global$0 = $4 + 48 | 0;
}
function tflite__MicroAllocator__StartModelAllocation_28tflite__Model_20const__2c_20tflite__MicroOpResolver_20const__2c_20tflite__NodeAndRegistration___2c_20TfLiteEvalTensor___29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 48 | 0;
 global$0 = $5;
 HEAP32[$5 + 40 >> 2] = $0;
 HEAP32[$5 + 36 >> 2] = $1;
 HEAP32[$5 + 32 >> 2] = $2;
 HEAP32[$5 + 28 >> 2] = $3;
 HEAP32[$5 + 24 >> 2] = $4;
 $0 = HEAP32[$5 + 40 >> 2];
 label$1 : {
  if (!HEAP32[$5 + 36 >> 2]) {
   break label$1;
  }
 }
 label$2 : {
  if (HEAP8[$0 + 12 | 0] & 1) {
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$0 + 8 >> 2], 131763, 0);
   HEAP32[$5 + 44 >> 2] = 1;
   break label$2;
  }
  HEAP8[$0 + 12 | 0] = 1;
  HEAP32[$5 + 20 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 28 >> 2]]($0, HEAP32[$5 + 36 >> 2], HEAP32[$5 + 24 >> 2]);
  if (HEAP32[$5 + 20 >> 2]) {
   HEAP32[$5 + 44 >> 2] = HEAP32[$5 + 20 >> 2];
   break label$2;
  }
  HEAP32[$5 + 16 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 20 >> 2]]($0, HEAP32[$5 + 36 >> 2], HEAP32[$5 + 28 >> 2]);
  if (HEAP32[$5 + 16 >> 2]) {
   HEAP32[$5 + 44 >> 2] = HEAP32[$5 + 16 >> 2];
   break label$2;
  }
  HEAP32[$5 + 12 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 24 >> 2]]($0, HEAP32[$5 + 36 >> 2], HEAP32[$5 + 32 >> 2], HEAP32[HEAP32[$5 + 28 >> 2] >> 2]);
  if (HEAP32[$5 + 12 >> 2]) {
   HEAP32[$5 + 44 >> 2] = HEAP32[$5 + 12 >> 2];
   break label$2;
  }
  HEAP32[$5 + 44 >> 2] = 0;
 }
 global$0 = $5 + 48 | 0;
 return HEAP32[$5 + 44 >> 2];
}
function __stdio_write($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 $4 = HEAP32[$0 + 28 >> 2];
 HEAP32[$3 + 16 >> 2] = $4;
 $5 = HEAP32[$0 + 20 >> 2];
 HEAP32[$3 + 28 >> 2] = $2;
 HEAP32[$3 + 24 >> 2] = $1;
 $1 = $5 - $4 | 0;
 HEAP32[$3 + 20 >> 2] = $1;
 $5 = $1 + $2 | 0;
 $7 = 2;
 $1 = $3 + 16 | 0;
 while (1) {
  label$2 : {
   label$4 : {
    if (__wasi_syscall_ret(__wasi_fd_write(HEAP32[$0 + 60 >> 2], $1 | 0, $7 | 0, $3 + 12 | 0) | 0)) {
     HEAP32[$3 + 12 >> 2] = -1;
     $4 = -1;
     break label$4;
    }
    $4 = HEAP32[$3 + 12 >> 2];
   }
   label$3 : {
    if (($4 | 0) == ($5 | 0)) {
     $1 = HEAP32[$0 + 44 >> 2];
     HEAP32[$0 + 28 >> 2] = $1;
     HEAP32[$0 + 20 >> 2] = $1;
     HEAP32[$0 + 16 >> 2] = $1 + HEAP32[$0 + 48 >> 2];
     $0 = $2;
     break label$3;
    }
    if (($4 | 0) > -1) {
     break label$2;
    }
    HEAP32[$0 + 28 >> 2] = 0;
    HEAP32[$0 + 16 >> 2] = 0;
    HEAP32[$0 + 20 >> 2] = 0;
    HEAP32[$0 >> 2] = HEAP32[$0 >> 2] | 32;
    $0 = 0;
    if (($7 | 0) == 2) {
     break label$3;
    }
    $0 = $2 - HEAP32[$1 + 4 >> 2] | 0;
   }
   global$0 = $3 + 32 | 0;
   return $0 | 0;
  }
  $6 = HEAP32[$1 + 4 >> 2];
  $8 = $4 >>> 0 > $6 >>> 0;
  $1 = $8 ? $1 + 8 | 0 : $1;
  $6 = $4 - ($8 ? $6 : 0) | 0;
  HEAP32[$1 >> 2] = $6 + HEAP32[$1 >> 2];
  HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] - $6;
  $5 = $5 - $4 | 0;
  $7 = $7 - $8 | 0;
  continue;
 }
}
function jsvNewFromString($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP32[$1 + 20 >> 2] = jsvNewWithFlags(27);
 label$1 : {
  if (!HEAP32[$1 + 20 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 16 >> 2] = jsvLockAgain(HEAP32[$1 + 20 >> 2]);
  while (1) {
   if (HEAPU8[HEAP32[$1 + 24 >> 2]]) {
    HEAP32[$1 + 8 >> 2] = jsvGetMaxCharactersInVar(HEAP32[$1 + 16 >> 2]);
    HEAP32[$1 + 12 >> 2] = 0;
    while (1) {
     if (HEAPU32[$1 + 12 >> 2] < HEAPU32[$1 + 8 >> 2] ? HEAP8[HEAP32[$1 + 24 >> 2]] : 0) {
      $0 = HEAP32[$1 + 24 >> 2];
      HEAP32[$1 + 24 >> 2] = $0 + 1;
      HEAP8[HEAP32[$1 + 16 >> 2] + HEAP32[$1 + 12 >> 2] | 0] = HEAPU8[$0 | 0];
      HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 12 >> 2] + 1;
      continue;
     }
     break;
    }
    jsvSetCharactersInVar(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 12 >> 2]);
    if (HEAPU8[HEAP32[$1 + 24 >> 2]]) {
     HEAP32[$1 + 4 >> 2] = jsvNewWithFlags(41);
     if (!HEAP32[$1 + 4 >> 2]) {
      jsvUnLock(HEAP32[$1 + 16 >> 2]);
      HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
      break label$1;
     }
     jsvSetLastChild(HEAP32[$1 + 16 >> 2], jsvGetRef(HEAP32[$1 + 4 >> 2]) & 65535);
     jsvUnLock(HEAP32[$1 + 16 >> 2]);
     HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 4 >> 2];
    }
    continue;
   }
   break;
  }
  jsvUnLock(HEAP32[$1 + 16 >> 2]);
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function jswrap_graphics_fillPoly_X($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = global$0 - 432 | 0;
 global$0 = $2;
 HEAP32[$2 + 424 >> 2] = $0;
 HEAP32[$2 + 420 >> 2] = $1;
 HEAP8[$2 + 419 | 0] = 0;
 label$1 : {
  if (!(graphicsGetFromVar($2 + 344 | 0, HEAP32[$2 + 424 >> 2]) & 1)) {
   HEAP32[$2 + 428 >> 2] = 0;
   break label$1;
  }
  if (!(jsvIsIterable(HEAP32[$2 + 420 >> 2]) & 1)) {
   HEAP32[$2 + 428 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 340 >> 2] = 128;
  HEAP32[$2 + 76 >> 2] = 0;
  jsvIteratorNew($2 + 16 | 0, HEAP32[$2 + 420 >> 2], 1);
  while (1) {
   if (jsvIteratorHasElement($2 + 16 | 0) & 1) {
    $0 = HEAP32[$2 + 76 >> 2] < 128;
   } else {
    $0 = 0;
   }
   if ($0) {
    $1 = $2 + 16 | 0;
    $5 = $2 + 80 | 0;
    $3 = jsvIteratorGetFloatValue($2 + 16 | 0) * 16 + .5;
    label$8 : {
     if (Math_abs($3) < 2147483648) {
      $0 = ~~$3;
      break label$8;
     }
     $0 = -2147483648;
    }
    $4 = HEAP32[$2 + 76 >> 2];
    HEAP32[$2 + 76 >> 2] = $4 + 1;
    HEAP16[$5 + ($4 << 1) >> 1] = $0;
    jsvIteratorNext($1);
    continue;
   }
   break;
  }
  if (jsvIteratorHasElement($2 + 16 | 0) & 1) {
   HEAP32[$2 >> 2] = 64;
   jsExceptionHere(1, 127811, $2);
  }
  $0 = $2 + 344 | 0;
  $1 = $2 + 80 | 0;
  jsvIteratorFree($2 + 16 | 0);
  graphicsFillPoly($0, HEAP32[$2 + 76 >> 2] / 2 | 0, $1);
  graphicsSetVar($0);
  HEAP32[$2 + 428 >> 2] = jsvLockAgain(HEAP32[$2 + 424 >> 2]);
 }
 global$0 = $2 + 432 | 0;
 return HEAP32[$2 + 428 >> 2];
}
function jstPinOutputAtTime($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 + -64 | 0;
 global$0 = $4;
 HEAP32[$4 + 56 >> 2] = $0;
 HEAP32[$4 + 60 >> 2] = $1;
 HEAP32[$4 + 52 >> 2] = $2;
 HEAP32[$4 + 48 >> 2] = 1;
 HEAP8[$4 + 47 | 0] = $3;
 $0 = HEAP32[$4 + 56 >> 2];
 HEAP8[$4 + 16 | 0] = $0;
 HEAP8[$4 + 17 | 0] = $0 >>> 8;
 HEAP8[$4 + 18 | 0] = $0 >>> 16;
 HEAP8[$4 + 19 | 0] = $0 >>> 24;
 HEAP8[$4 + 20 | 0] = 0;
 HEAP8[$4 + 21 | 0] = 0;
 HEAP8[$4 + 22 | 0] = 0;
 HEAP8[$4 + 23 | 0] = 0;
 HEAP8[$4 + 40 | 0] = 1;
 HEAP32[$4 + 12 >> 2] = 0;
 while (1) {
  if (HEAP32[$4 + 12 >> 2] < 4) {
   $0 = HEAP32[$4 + 12 >> 2] + ($4 + 24 | 0) | 0;
   if (HEAP32[$4 + 12 >> 2] < HEAP32[$4 + 48 >> 2]) {
    $1 = HEAPU8[HEAP32[$4 + 52 >> 2] + HEAP32[$4 + 12 >> 2] | 0];
   } else {
    $1 = 255;
   }
   HEAP8[$0 | 0] = $1;
   HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP8[$4 + 28 | 0] = HEAPU8[$4 + 47 | 0];
 HEAP32[$4 + 8 >> 2] = 2e6;
 while (1) {
  $1 = !(utilTimerIsFull() & 1);
  $0 = 0;
  label$6 : {
   if ($1) {
    break label$6;
   }
   $1 = jspIsInterrupted() & 1;
   $0 = 0;
   if ($1) {
    break label$6;
   }
   $0 = HEAP32[$4 + 8 >> 2];
   HEAP32[$4 + 8 >> 2] = $0 + -1;
   $0 = ($0 | 0) > 0;
  }
  if ($0) {
   continue;
  }
  break;
 }
 label$7 : {
  if (HEAP32[$4 + 8 >> 2] > 0) {
   if (!(jspIsInterrupted() & 1)) {
    break label$7;
   }
  }
  jsExceptionHere(4, 83218, 0);
 }
 utilTimerInsertTask($4 + 16 | 0);
 global$0 = $4 - -64 | 0;
}
function jsvStringIteratorLoadInline($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 >> 2] = HEAP32[$0 >> 2] - HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 + 8 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] + HEAP32[$0 + 8 >> 2];
 label$1 : {
  if (jsvIsFlashString(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) & 1) {
   jsvStringIteratorLoadFlashString(HEAP32[$1 + 12 >> 2]);
   break label$1;
  }
  label$3 : {
   if (!HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) {
    break label$3;
   }
   if (!(jsvGetLastChild(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) & 65535)) {
    break label$3;
   }
   HEAP32[$1 + 8 >> 2] = jsvLock(jsvGetLastChild(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) & 65535);
   jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
   HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2] = HEAP32[$1 + 8 >> 2];
   HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = HEAP32[$1 + 8 >> 2];
   $0 = jsvGetCharactersInVar(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
   HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] = $0;
   break label$1;
  }
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
  HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2] = 0;
  HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = 0;
  HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] = 0;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP32[$0 + 8 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] >> 2] + HEAP32[$0 + 8 >> 2];
  HEAP32[HEAP32[$1 + 12 >> 2] >> 2] = 0;
 }
 global$0 = $1 + 16 | 0;
}
function jsvArrayBufferIteratorNew($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 HEAP32[HEAP32[$3 + 12 >> 2] + 48 >> 2] = HEAP32[$3 + 4 >> 2];
 $0 = HEAP32[$3 + 8 >> 2];
 HEAP16[HEAP32[$3 + 12 >> 2] + 36 >> 1] = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8;
 $0 = HEAP32[$3 + 8 >> 2];
 HEAP32[HEAP32[$3 + 12 >> 2] + 40 >> 2] = Math_imul(HEAPU16[HEAP32[$3 + 12 >> 2] + 36 >> 1] & 15, HEAPU8[$0 + 2 | 0] | HEAPU8[$0 + 3 | 0] << 8);
 $0 = HEAP32[$3 + 8 >> 2];
 HEAP32[HEAP32[$3 + 12 >> 2] + 44 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8;
 HEAP32[$3 >> 2] = jsvGetArrayBufferBackingString(HEAP32[$3 + 8 >> 2], 0);
 $0 = HEAP32[$3 + 12 >> 2];
 HEAP32[$0 + 40 >> 2] = HEAP32[HEAP32[$3 + 12 >> 2] + 44 >> 2] + HEAP32[$0 + 40 >> 2];
 HEAP32[HEAP32[$3 + 12 >> 2] + 44 >> 2] = HEAP32[HEAP32[$3 + 12 >> 2] + 44 >> 2] + Math_imul(HEAP32[$3 + 4 >> 2], HEAPU16[HEAP32[$3 + 12 >> 2] + 36 >> 1] & 15);
 label$1 : {
  if (HEAPU32[HEAP32[$3 + 12 >> 2] + 44 >> 2] >= (HEAP32[HEAP32[$3 + 12 >> 2] + 40 >> 2] + 1 | 0) - (HEAPU16[HEAP32[$3 + 12 >> 2] + 36 >> 1] & 15) >>> 0) {
   jsvUnLock(HEAP32[$3 >> 2]);
   HEAP16[HEAP32[$3 + 12 >> 2] + 36 >> 1] = 0;
   break label$1;
  }
  jsvStringIteratorNew(HEAP32[$3 + 12 >> 2], HEAP32[$3 >> 2], HEAP32[HEAP32[$3 + 12 >> 2] + 44 >> 2]);
  jsvUnLock(HEAP32[$3 >> 2]);
  HEAP8[HEAP32[$3 + 12 >> 2] + 52 | 0] = 0;
 }
 global$0 = $3 + 16 | 0;
}
function tflite__SimpleMemoryAllocator__EnsureHeadSize_28unsigned_20long_2c_20unsigned_20long_29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP32[$3 + 40 >> 2] = $0;
 HEAP32[$3 + 36 >> 2] = $1;
 HEAP32[$3 + 32 >> 2] = $2;
 $0 = HEAP32[$3 + 40 >> 2];
 label$1 : {
  if (HEAP32[$0 + 16 >> 2] != HEAP32[$0 + 24 >> 2]) {
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$0 + 4 >> 2], 128816, 0);
   HEAP32[$3 + 44 >> 2] = 1;
   break label$1;
  }
  HEAP32[$3 + 28 >> 2] = tflite__AlignPointerUp_28unsigned_20char__2c_20unsigned_20long_29(HEAP32[$0 + 8 >> 2], HEAP32[$3 + 32 >> 2]);
  if (HEAP32[$3 + 28 >> 2] + HEAP32[$3 + 36 >> 2] >>> 0 < HEAPU32[$0 + 16 >> 2]) {
   HEAP32[$3 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 24 >> 2] = HEAP32[$0 + 20 >> 2] - HEAP32[$3 + 28 >> 2];
  if (HEAPU32[$3 + 24 >> 2] < HEAPU32[$3 + 36 >> 2]) {
   $0 = HEAP32[$0 + 4 >> 2];
   $1 = HEAP32[$3 + 36 >> 2];
   $2 = HEAP32[$3 + 24 >> 2];
   HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 36 >> 2] - HEAP32[$3 + 24 >> 2];
   HEAP32[$3 + 4 >> 2] = $2;
   HEAP32[$3 >> 2] = $1;
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 128897, $3);
   HEAP32[$3 + 44 >> 2] = 1;
   break label$1;
  }
  HEAP32[$0 + 16 >> 2] = HEAP32[$3 + 28 >> 2] + HEAP32[$3 + 36 >> 2];
  HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 16 >> 2];
  HEAP32[$3 + 44 >> 2] = 0;
 }
 global$0 = $3 + 48 | 0;
 return HEAP32[$3 + 44 >> 2];
}
function graphicsFallbackScroll($0, $1, $2, $3, $4, $5, $6) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 var $7 = 0;
 $7 = global$0 - 48 | 0;
 global$0 = $7;
 HEAP32[$7 + 44 >> 2] = $0;
 HEAP32[$7 + 40 >> 2] = $1;
 HEAP32[$7 + 36 >> 2] = $2;
 HEAP32[$7 + 32 >> 2] = $3;
 HEAP32[$7 + 28 >> 2] = $4;
 HEAP32[$7 + 24 >> 2] = $5;
 HEAP32[$7 + 20 >> 2] = $6;
 label$1 : {
  if (!(HEAP32[$7 + 40 >> 2] | HEAP32[$7 + 36 >> 2])) {
   break label$1;
  }
  if (HEAP32[$7 + 36 >> 2] <= 0) {
   HEAP32[$7 + 12 >> 2] = HEAP32[$7 + 20 >> 2] + HEAP32[$7 + 36 >> 2];
   HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 28 >> 2];
   while (1) {
    if (HEAP32[$7 + 16 >> 2] <= HEAP32[$7 + 12 >> 2]) {
     graphicsFallbackScrollX(HEAP32[$7 + 44 >> 2], HEAP32[$7 + 40 >> 2], HEAP32[$7 + 16 >> 2] - HEAP32[$7 + 36 >> 2] | 0, HEAP32[$7 + 16 >> 2], HEAP32[$7 + 32 >> 2], HEAP32[$7 + 24 >> 2]);
     HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 16 >> 2] + 1;
     continue;
    }
    break;
   }
   break label$1;
  }
  HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 20 >> 2] - HEAP32[$7 + 36 >> 2];
  while (1) {
   if (HEAP32[$7 + 16 >> 2] >= HEAP32[$7 + 28 >> 2]) {
    graphicsFallbackScrollX(HEAP32[$7 + 44 >> 2], HEAP32[$7 + 40 >> 2], HEAP32[$7 + 16 >> 2], HEAP32[$7 + 16 >> 2] + HEAP32[$7 + 36 >> 2] | 0, HEAP32[$7 + 32 >> 2], HEAP32[$7 + 24 >> 2]);
    HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 16 >> 2] + -1;
    continue;
   }
   break;
  }
 }
 global$0 = $7 + 48 | 0;
}
function tflite___28anonymous_20namespace_29__FlatBufferIntVectorToArray_28int_2c_20flatbuffers__Vector_int__20const__2c_20int__2c_20tflite__ErrorReporter__2c_20char_20const__29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 + -64 | 0;
 global$0 = $3;
 HEAP32[$3 + 56 >> 2] = 32;
 HEAP32[$3 + 52 >> 2] = $0;
 HEAP32[$3 + 48 >> 2] = $1;
 HEAP32[$3 + 44 >> 2] = $2;
 HEAP32[$3 + 40 >> 2] = 136796;
 label$1 : {
  if (!HEAP32[$3 + 52 >> 2]) {
   $0 = HEAP32[$3 + 44 >> 2];
   HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 40 >> 2];
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 136804, $3 + 16 | 0);
   HEAP32[$3 + 60 >> 2] = 1;
   break label$1;
  }
  HEAP32[$3 + 36 >> 2] = flatbuffers__Vector_int___size_28_29_20const(HEAP32[$3 + 52 >> 2]);
  if (HEAPU32[$3 + 36 >> 2] > HEAP32[$3 + 56 >> 2] >>> 2 >>> 0) {
   $0 = HEAP32[$3 + 44 >> 2];
   HEAP32[$3 >> 2] = HEAP32[$3 + 40 >> 2];
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 136850, $3);
   HEAP32[$3 + 60 >> 2] = 1;
   break label$1;
  }
  HEAP32[$3 + 32 >> 2] = 0;
  while (1) {
   if (HEAPU32[$3 + 32 >> 2] < HEAPU32[$3 + 36 >> 2]) {
    $0 = flatbuffers__Vector_int___Get_28unsigned_20int_29_20const(HEAP32[$3 + 52 >> 2], HEAP32[$3 + 32 >> 2]);
    HEAP32[HEAP32[$3 + 48 >> 2] + (HEAP32[$3 + 32 >> 2] << 2) >> 2] = $0;
    HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 32 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$3 + 60 >> 2] = 0;
 }
 global$0 = $3 - -64 | 0;
 return HEAP32[$3 + 60 >> 2];
}
function jswrap_math_round($0) {
 $0 = +$0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $1 = global$0 - 48 | 0;
 global$0 = $1;
 HEAPF64[$1 + 32 >> 3] = $0;
 label$1 : {
  label$2 : {
   $3 = __DOUBLE_BITS(HEAPF64[$1 + 32 >> 3]);
   $2 = i64toi32_i32$HIGH_BITS & 2147483647;
   if (($2 | 0) == 2146435072 & $3 >>> 0 < 0 | $2 >>> 0 < 2146435072) {
    $2 = global$0 - 16 | 0;
    HEAPF64[$2 + 8 >> 3] = HEAPF64[$1 + 32 >> 3];
    HEAPF64[$2 >> 3] = -0;
    if (HEAP32[$2 + 8 >> 2] != HEAP32[$2 >> 2] | HEAP32[$2 + 12 >> 2] != HEAP32[$2 + 4 >> 2]) {
     break label$2;
    }
   }
   HEAP32[$1 + 44 >> 2] = jsvNewFromFloat(HEAPF64[$1 + 32 >> 3]);
   break label$1;
  }
  HEAPF64[$1 + 32 >> 3] = HEAPF64[$1 + 32 >> 3] + (HEAPF64[$1 + 32 >> 3] < 0 ? -.4999999999 : .4999999999);
  $2 = $1;
  $0 = HEAPF64[$1 + 32 >> 3];
  label$4 : {
   if (Math_abs($0) < 0x8000000000000000) {
    $4 = ~~$0 >>> 0;
    $3 = Math_abs($0) >= 1 ? $0 > 0 ? ~~Math_min(Math_floor($0 / 4294967296), 4294967295) >>> 0 : ~~Math_ceil(($0 - +(~~$0 >>> 0 >>> 0)) / 4294967296) >>> 0 : 0;
    break label$4;
   }
   $3 = -2147483648;
  }
  HEAP32[$2 + 24 >> 2] = $4;
  HEAP32[$2 + 28 >> 2] = $3;
  if (!(!!(HEAP32[$1 + 24 >> 2] | HEAP32[$1 + 28 >> 2]) | !(HEAPF64[$1 + 32 >> 3] < 0))) {
   HEAP32[$1 + 44 >> 2] = jsvNewFromFloat(-0);
   break label$1;
  }
  HEAP32[$1 + 44 >> 2] = jsvNewFromLongInteger(HEAP32[$1 + 24 >> 2], HEAP32[$1 + 28 >> 2]);
 }
 global$0 = $1 + 48 | 0;
 return HEAP32[$1 + 44 >> 2];
}
function jswrap_object_removeAllListeners($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 label$1 : {
  if (!(jsvHasChildren(HEAP32[$2 + 28 >> 2]) & 1)) {
   jsExceptionHere(3, 123613, 0);
   break label$1;
  }
  if (jsvIsString(HEAP32[$2 + 24 >> 2]) & 1) {
   HEAP32[$2 >> 2] = HEAP32[$2 + 24 >> 2];
   HEAP32[$2 + 20 >> 2] = jsvVarPrintf(123811, $2);
   if (!HEAP32[$2 + 20 >> 2]) {
    break label$1;
   }
   HEAP32[$2 + 16 >> 2] = jsvFindChildFromVar(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 20 >> 2], 1);
   jsvUnLock(HEAP32[$2 + 20 >> 2]);
   if (HEAP32[$2 + 16 >> 2]) {
    jsvRemoveChild(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 16 >> 2]);
    jsvUnLock(HEAP32[$2 + 16 >> 2]);
   }
   break label$1;
  }
  label$5 : {
   if (jsvIsUndefined(HEAP32[$2 + 24 >> 2]) & 1) {
    jsvObjectIteratorNew($2 + 8 | 0, HEAP32[$2 + 28 >> 2]);
    while (1) {
     if (jsvObjectIteratorHasValue($2 + 8 | 0) & 1) {
      $0 = $2 + 8 | 0;
      HEAP32[$2 + 4 >> 2] = jsvObjectIteratorGetKey($0);
      jsvObjectIteratorNext($0);
      if (jsvIsStringEqualOrStartsWith(HEAP32[$2 + 4 >> 2], 123984, 1) & 1) {
       jsvRemoveChild(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 4 >> 2]);
      }
      jsvUnLock(HEAP32[$2 + 4 >> 2]);
      continue;
     }
     break;
    }
    jsvObjectIteratorFree($2 + 8 | 0);
    break label$5;
   }
   jsExceptionHere(3, 123988, 0);
  }
 }
 global$0 = $2 + 32 | 0;
}
function jspeStatementFunctionDecl($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP8[$1 + 27 | 0] = $0;
 HEAP32[$1 + 20 >> 2] = 0;
 jslGetNextToken();
 HEAP8[$1 + 15 | 0] = (HEAP32[80549] & 63) == 1;
 label$1 : {
  if (HEAP8[$1 + 15 | 0] & 1) {
   HEAP32[$1 + 20 >> 2] = jsvMakeIntoVariableName(jslGetTokenValueAsVar(), 0);
   if (!HEAP32[$1 + 20 >> 2]) {
    HEAP32[$1 + 28 >> 2] = 0;
    break label$1;
   }
  }
  if (!(jslMatch(128) & 1)) {
   jsvUnLock(HEAP32[$1 + 20 >> 2]);
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  $0 = $1;
  label$5 : {
   if (HEAP8[$1 + 27 | 0] & 1) {
    $2 = jspeClassDefinition(0);
    break label$5;
   }
   $2 = jspeFunctionDefinition(0);
  }
  HEAP32[$0 + 16 >> 2] = $2;
  if (HEAP8[$1 + 15 | 0] & 1) {
   HEAP32[$1 + 8 >> 2] = jspeiFindNameOnTop(HEAP32[$1 + 20 >> 2]);
   HEAP32[$1 + 4 >> 2] = jsvSkipName(HEAP32[$1 + 8 >> 2]);
   label$8 : {
    if (jsvIsFunction(HEAP32[$1 + 4 >> 2]) & 1) {
     HEAP32[$1 + 16 >> 2] = jsvSkipNameAndUnLock(HEAP32[$1 + 16 >> 2]);
     jswrap_function_replaceWith(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 16 >> 2]);
     break label$8;
    }
    jsvReplaceWith(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 16 >> 2]);
   }
   jsvUnLock(HEAP32[$1 + 20 >> 2]);
   HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 8 >> 2];
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
  }
  jsvUnLock(HEAP32[$1 + 16 >> 2]);
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function jswrap_storagefile_erase($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 80 | 0;
 global$0 = $1;
 HEAP32[$1 + 76 >> 2] = $0;
 jsfNameFromVarAndUnLock($1 + 48 | 0, jsvObjectGetChild(HEAP32[$1 + 76 >> 2], 125552, 0));
 HEAP32[$1 + 44 >> 2] = 27;
 while (1) {
  if (HEAP32[$1 + 44 >> 2] ? !HEAP8[(HEAP32[$1 + 44 >> 2] + $1 | 0) + 47 | 0] : 0) {
   HEAP32[$1 + 44 >> 2] = HEAP32[$1 + 44 >> 2] + -1;
   continue;
  }
  break;
 }
 HEAP32[$1 + 40 >> 2] = 1;
 HEAP8[$1 + 39 | 0] = 1;
 while (1) {
  if (HEAP8[$1 + 39 | 0] & 1) {
   HEAP8[HEAP32[$1 + 44 >> 2] + ($1 + 48 | 0) | 0] = HEAP32[$1 + 40 >> 2];
   HEAP32[$1 + 32 >> 2] = HEAP32[$1 + 72 >> 2];
   $0 = HEAP32[$1 + 68 >> 2];
   HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 64 >> 2];
   HEAP32[$1 + 28 >> 2] = $0;
   $0 = HEAP32[$1 + 60 >> 2];
   HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 56 >> 2];
   HEAP32[$1 + 20 >> 2] = $0;
   $0 = HEAP32[$1 + 52 >> 2];
   HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 48 >> 2];
   HEAP32[$1 + 12 >> 2] = $0;
   HEAP8[$1 + 39 | 0] = jsfEraseFile($1 + 8 | 0) & 1;
   HEAP32[$1 + 40 >> 2] = HEAP32[$1 + 40 >> 2] + 1;
   continue;
  }
  break;
 }
 jsvObjectSetChildAndUnLock(HEAP32[$1 + 76 >> 2], 125557, jsvNewFromInteger(1));
 jsvObjectSetChildAndUnLock(HEAP32[$1 + 76 >> 2], 125563, jsvNewFromInteger(0));
 jsvObjectSetChildAndUnLock(HEAP32[$1 + 76 >> 2], 125570, jsvNewFromInteger(0));
 jsvObjectSetChildAndUnLock(HEAP32[$1 + 76 >> 2], 125579, jsvNewFromInteger(0));
 global$0 = $1 + 80 | 0;
}
function jsvIteratorNew($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 label$1 : {
  label$2 : {
   label$3 : {
    if (jsvIsArray(HEAP32[$3 + 8 >> 2]) & 1) {
     break label$3;
    }
    if (jsvIsObject(HEAP32[$3 + 8 >> 2]) & 1) {
     break label$3;
    }
    if (jsvIsFunction(HEAP32[$3 + 8 >> 2]) & 1) {
     break label$3;
    }
    if (!(jsvIsGetterOrSetter(HEAP32[$3 + 8 >> 2]) & 1)) {
     break label$2;
    }
   }
   HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = 2;
   if (!(!(jsvIsArray(HEAP32[$3 + 8 >> 2]) & 1) | !(HEAP32[$3 + 4 >> 2] & 1))) {
    HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = 4;
    HEAP32[HEAP32[$3 + 12 >> 2] + 12 >> 2] = 0;
    $0 = jsvLockAgain(HEAP32[$3 + 8 >> 2]);
    HEAP32[HEAP32[$3 + 12 >> 2] + 8 >> 2] = $0;
   }
   jsvObjectIteratorNew(HEAP32[$3 + 12 >> 2] + 4 | 0, HEAP32[$3 + 8 >> 2]);
   break label$1;
  }
  label$5 : {
   if (jsvIsArrayBuffer(HEAP32[$3 + 8 >> 2]) & 1) {
    HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = 3;
    jsvArrayBufferIteratorNew(HEAP32[$3 + 12 >> 2] + 4 | 0, HEAP32[$3 + 8 >> 2], 0);
    break label$5;
   }
   label$7 : {
    if (jsvHasCharacterData(HEAP32[$3 + 8 >> 2]) & 1) {
     HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = 1;
     jsvStringIteratorNew(HEAP32[$3 + 12 >> 2] + 4 | 0, HEAP32[$3 + 8 >> 2], 0);
     break label$7;
    }
    HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = 0;
   }
  }
 }
 global$0 = $3 + 16 | 0;
}
function heatshrink_encoder_sink($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 global$0 = $4;
 HEAP32[$4 + 24 >> 2] = $0;
 HEAP32[$4 + 20 >> 2] = $1;
 HEAP32[$4 + 16 >> 2] = $2;
 HEAP32[$4 + 12 >> 2] = $3;
 label$1 : {
  if (!(HEAP32[$4 + 12 >> 2] ? !(!HEAP32[$4 + 24 >> 2] | !HEAP32[$4 + 20 >> 2]) : 0)) {
   HEAP32[$4 + 28 >> 2] = -1;
   break label$1;
  }
  if (is_finishing(HEAP32[$4 + 24 >> 2])) {
   HEAP32[$4 + 28 >> 2] = -2;
   break label$1;
  }
  if (HEAPU8[HEAP32[$4 + 24 >> 2] + 12 | 0]) {
   HEAP32[$4 + 28 >> 2] = -2;
   break label$1;
  }
  HEAP16[$4 + 10 >> 1] = (get_input_offset(HEAP32[$4 + 24 >> 2]) & 65535) + HEAPU16[HEAP32[$4 + 24 >> 2] >> 1];
  HEAP16[$4 + 8 >> 1] = get_input_buffer_size(HEAP32[$4 + 24 >> 2]);
  HEAP16[$4 + 6 >> 1] = HEAPU16[$4 + 8 >> 1] - HEAPU16[HEAP32[$4 + 24 >> 2] >> 1];
  $0 = $4;
  if (HEAPU16[$4 + 6 >> 1] < HEAPU32[$4 + 16 >> 2]) {
   $1 = HEAPU16[$4 + 6 >> 1];
  } else {
   $1 = HEAP32[$4 + 16 >> 2];
  }
  HEAP16[$0 + 4 >> 1] = $1;
  memcpy(HEAPU16[$4 + 10 >> 1] + (HEAP32[$4 + 24 >> 2] + 15 | 0) | 0, HEAP32[$4 + 20 >> 2], HEAPU16[$4 + 4 >> 1]);
  HEAP32[HEAP32[$4 + 12 >> 2] >> 2] = HEAPU16[$4 + 4 >> 1];
  $0 = HEAP32[$4 + 24 >> 2];
  HEAP16[$0 >> 1] = HEAPU16[$4 + 4 >> 1] + HEAPU16[$0 >> 1];
  if (HEAPU16[$4 + 4 >> 1] == HEAPU16[$4 + 6 >> 1]) {
   HEAP8[HEAP32[$4 + 24 >> 2] + 12 | 0] = 1;
  }
  HEAP32[$4 + 28 >> 2] = 0;
 }
 global$0 = $4 + 32 | 0;
 return HEAP32[$4 + 28 >> 2];
}
function std____2____compressed_pair_TfLiteConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_____compressed_pair_TfLiteConvParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28TfLiteConvParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 std____2____compressed_pair_elem_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_2c_201_2c_20false_____compressed_pair_elem_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_2c_20void__28tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___29($0, tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(HEAP32[$3 + 8 >> 2]));
 std____2____compressed_pair_elem_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_2c_201_2c_20false_____compressed_pair_elem_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_2c_20void__28tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___29($0 + 4 | 0, tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(HEAP32[$3 + 4 >> 2]));
 global$0 = $3 + 16 | 0;
}
function jswrap_interface_changeInterval($0, $1) {
 $0 = $0 | 0;
 $1 = +$1;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP32[$2 + 44 >> 2] = $0;
 HEAPF64[$2 + 32 >> 3] = $1;
 HEAP32[$2 + 28 >> 2] = jsvLock(HEAPU16[161110]);
 if (HEAPF64[$2 + 32 >> 3] < .1) {
  HEAPF64[$2 + 32 >> 3] = .1;
 }
 $0 = $2;
 label$2 : {
  if (jsvIsBasic(HEAP32[$2 + 44 >> 2]) & 1) {
   $3 = jsvFindChildFromVar(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 44 >> 2], 0);
   break label$2;
  }
  $3 = 0;
 }
 HEAP32[$0 + 24 >> 2] = $3;
 label$4 : {
  if (HEAP32[$2 + 24 >> 2]) {
   HEAP32[$2 + 20 >> 2] = jsvSkipNameAndUnLock(HEAP32[$2 + 24 >> 2]);
   HEAP32[$2 + 8 >> 2] = jshGetTimeFromMilliseconds(HEAPF64[$2 + 32 >> 3]);
   HEAP32[$2 + 12 >> 2] = i64toi32_i32$HIGH_BITS;
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 20 >> 2], 121680, jsvNewFromLongInteger(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 12 >> 2]));
   $6 = HEAP32[$2 + 20 >> 2];
   $0 = jshGetSystemTime();
   $4 = HEAP32[80572];
   $5 = HEAP32[$2 + 8 >> 2];
   $3 = ($0 - $4 | 0) + $5 | 0;
   $0 = HEAP32[$2 + 12 >> 2] + (i64toi32_i32$HIGH_BITS - (HEAP32[80573] + ($0 >>> 0 < $4 >>> 0) | 0) | 0) | 0;
   jsvObjectSetChildAndUnLock($6, 121675, jsvNewFromLongInteger($3, $3 >>> 0 < $5 >>> 0 ? $0 + 1 | 0 : $0));
   jsvUnLock(HEAP32[$2 + 20 >> 2]);
   jsiTimersChanged();
   break label$4;
  }
  jsExceptionHere(1, 121781, 0);
 }
 jsvUnLock(HEAP32[$2 + 28 >> 2]);
 global$0 = $2 + 48 | 0;
}
function tflite__ops__micro__pooling___28anonymous_20namespace_29__CalculateOpData_28TfLiteContext_20const__2c_20TfLitePoolParams_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20tflite__ops__micro__pooling___28anonymous_20namespace_29__OpData__29($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $5 = global$0 + -64 | 0;
 global$0 = $5;
 $6 = $5 + 8 | 0;
 $7 = $5 + 32 | 0;
 $8 = $5 + 28 | 0;
 HEAP32[$5 + 60 >> 2] = $0;
 HEAP32[$5 + 56 >> 2] = $1;
 HEAP32[$5 + 52 >> 2] = $2;
 HEAP32[$5 + 48 >> 2] = $3;
 HEAP32[$5 + 44 >> 2] = $4;
 HEAP32[$5 + 40 >> 2] = tflite__SizeOfDimension_28TfLiteTensor_20const__2c_20int_29(HEAP32[$5 + 52 >> 2], 1);
 HEAP32[$5 + 36 >> 2] = tflite__SizeOfDimension_28TfLiteTensor_20const__2c_20int_29(HEAP32[$5 + 52 >> 2], 2);
 tflite__ComputePaddingHeightWidth_28int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20TfLitePadding_2c_20int__2c_20int__29($6, HEAP32[HEAP32[$5 + 56 >> 2] + 8 >> 2], HEAP32[HEAP32[$5 + 56 >> 2] + 4 >> 2], 1, 1, HEAP32[$5 + 40 >> 2], HEAP32[$5 + 36 >> 2], HEAP32[HEAP32[$5 + 56 >> 2] + 16 >> 2], HEAP32[HEAP32[$5 + 56 >> 2] + 12 >> 2], HEAP32[HEAP32[$5 + 56 >> 2] >> 2], $7, $8);
 $0 = HEAP32[$6 + 4 >> 2];
 $2 = HEAP32[$5 + 44 >> 2];
 HEAP32[$2 >> 2] = HEAP32[$6 >> 2];
 HEAP32[$2 + 4 >> 2] = $0;
 $0 = HEAP32[$6 + 12 >> 2];
 HEAP32[$2 + 8 >> 2] = HEAP32[$6 + 8 >> 2];
 HEAP32[$2 + 12 >> 2] = $0;
 global$0 = $5 - -64 | 0;
 return 0;
}
function jsiDebuggerPrintScope($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 jsvObjectIteratorNew($1 + 24 | 0, HEAP32[$1 + 28 >> 2]);
 HEAP8[$1 + 23 | 0] = 0;
 while (1) {
  if (jsvObjectIteratorHasValue($1 + 24 | 0) & 1) {
   $0 = $1 + 24 | 0;
   HEAP32[$1 + 16 >> 2] = jsvObjectIteratorGetKey($0);
   HEAP32[$1 + 12 >> 2] = jsvAsString(HEAP32[$1 + 16 >> 2]);
   HEAP32[$1 + 8 >> 2] = jsvObjectIteratorGetValue($0);
   HEAP32[$1 + 4 >> 2] = jsvGetStringLength(HEAP32[$1 + 12 >> 2]);
   if (!(jsvIsStringEqual(HEAP32[$1 + 12 >> 2], 82273) & 1)) {
    HEAP8[$1 + 23 | 0] = 1;
    jsiConsolePrintChar(32);
    if (jsvIsFunctionParameter(HEAP32[$1 + 16 >> 2]) & 1) {
     jsiConsolePrintString(82280);
     HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + 6;
    }
    jsiConsolePrintStringVar(HEAP32[$1 + 12 >> 2]);
    while (1) {
     if (HEAPU32[$1 + 4 >> 2] < 20) {
      jsiConsolePrintChar(32);
      HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + 1;
      continue;
     }
     break;
    }
    jsiConsolePrintString(82287);
    jsfPrintJSON(HEAP32[$1 + 8 >> 2], 301);
    jsiConsolePrintString(81553);
   }
   $0 = $1 + 24 | 0;
   jsvUnLock3(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 12 >> 2], HEAP32[$1 + 8 >> 2]);
   jsvObjectIteratorNext($0);
   continue;
  }
  break;
 }
 jsvObjectIteratorFree($1 + 24 | 0);
 if (!(HEAP8[$1 + 23 | 0] & 1)) {
  jsiConsolePrintString(82291);
 }
 global$0 = $1 + 32 | 0;
}
function jswrap_stream_pushData($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP8[$2 + 23 | 0] = 1;
 HEAP8[$2 + 22 | 0] = 1;
 HEAP32[$2 + 16 >> 2] = jsvFindChildFromString(HEAP32[$2 + 28 >> 2], 125940, 0);
 label$1 : {
  if (HEAP32[$2 + 16 >> 2]) {
   if (!(jsiExecuteEventCallback(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 16 >> 2], 1, $2 + 24 | 0) & 1)) {
    jsError(125948, 0);
    HEAP8[322179] = HEAPU8[322179] | 4;
    jsvObjectRemoveChild(HEAP32[$2 + 28 >> 2], 125940);
   }
   jsvUnLock(HEAP32[$2 + 16 >> 2]);
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jsvObjectGetChild(HEAP32[$2 + 28 >> 2], 125935, 0);
  label$4 : {
   if (!(jsvIsString(HEAP32[$2 + 12 >> 2]) & 1)) {
    jsvObjectSetChild(HEAP32[$2 + 28 >> 2], 125935, HEAP32[$2 + 24 >> 2]);
    break label$4;
   }
   HEAP32[$2 + 8 >> 2] = jsvGetStringLength(HEAP32[$2 + 12 >> 2]);
   HEAP32[$2 + 4 >> 2] = jsvGetStringLength(HEAP32[$2 + 24 >> 2]);
   if (HEAP32[$2 + 8 >> 2] + HEAP32[$2 + 4 >> 2] >>> 0 > 512) {
    if (HEAP8[$2 + 23 | 0] & 1) {
     HEAP8[322179] = HEAPU8[322179] | 2;
    }
    HEAP8[$2 + 22 | 0] = 0;
   }
   if (!(HEAPU32[$2 + 8 >> 2] >= 512 | (HEAP8[$2 + 23 | 0] & 1 ? 0 : !(HEAP8[$2 + 22 | 0] & 1)))) {
    jsvAppendStringVar(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 24 >> 2], 0, 512 - HEAP32[$2 + 8 >> 2] | 0);
   }
   jsvUnLock(HEAP32[$2 + 12 >> 2]);
  }
 }
 global$0 = $2 + 32 | 0;
}
function jspeUnaryExpression() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 label$1 : {
  label$2 : {
   if (!(HEAP16[HEAP32[35539] + 2 >> 1] == 33 | HEAP16[HEAP32[35539] + 2 >> 1] == 126 | HEAP16[HEAP32[35539] + 2 >> 1] == 45)) {
    if (HEAP16[HEAP32[35539] + 2 >> 1] != 43) {
     break label$2;
    }
   }
   HEAP16[$0 + 10 >> 1] = HEAPU16[HEAP32[35539] + 2 >> 1];
   jslGetNextToken();
   if ((HEAP32[80549] & 63) != 1) {
    HEAP32[$0 + 12 >> 2] = jspeUnaryExpression();
    break label$1;
   }
   if (HEAP16[$0 + 10 >> 1] == 33) {
    HEAP32[$0 + 12 >> 2] = jsvNewFromBool((jsvGetBoolAndUnLock(jsvSkipNameAndUnLock(jspeUnaryExpression())) ^ -1) & 1);
    break label$1;
   }
   if (HEAP16[$0 + 10 >> 1] == 126) {
    HEAP32[$0 + 12 >> 2] = jsvNewFromInteger(jsvGetIntegerAndUnLock(jsvSkipNameAndUnLock(jspeUnaryExpression())) ^ -1);
    break label$1;
   }
   if (HEAP16[$0 + 10 >> 1] == 45) {
    HEAP32[$0 + 12 >> 2] = jsvNegateAndUnLock(jspeUnaryExpression());
    break label$1;
   }
   if (HEAP16[$0 + 10 >> 1] == 43) {
    HEAP32[$0 + 4 >> 2] = jsvSkipNameAndUnLock(jspeUnaryExpression());
    HEAP32[$0 >> 2] = jsvAsNumber(HEAP32[$0 + 4 >> 2]);
    jsvUnLock(HEAP32[$0 + 4 >> 2]);
    HEAP32[$0 + 12 >> 2] = HEAP32[$0 >> 2];
    break label$1;
   }
   HEAP32[$0 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$0 + 12 >> 2] = jspePostfixExpression();
 }
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}
function jsfReadFile($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 96 | 0;
 global$0 = $3;
 HEAP32[$3 + 88 >> 2] = $1;
 HEAP32[$3 + 84 >> 2] = $2;
 HEAP32[$3 + 32 >> 2] = HEAP32[$0 + 24 >> 2];
 $1 = HEAP32[$0 + 20 >> 2];
 HEAP32[$3 + 24 >> 2] = HEAP32[$0 + 16 >> 2];
 HEAP32[$3 + 28 >> 2] = $1;
 $1 = HEAP32[$0 + 12 >> 2];
 HEAP32[$3 + 16 >> 2] = HEAP32[$0 + 8 >> 2];
 HEAP32[$3 + 20 >> 2] = $1;
 $1 = HEAP32[$0 + 4 >> 2];
 HEAP32[$3 + 8 >> 2] = HEAP32[$0 >> 2];
 HEAP32[$3 + 12 >> 2] = $1;
 HEAP32[$3 + 44 >> 2] = jsfFindFile($3 + 8 | 0, $3 + 48 | 0);
 label$1 : {
  if (!HEAP32[$3 + 44 >> 2]) {
   HEAP32[$3 + 92 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$3 + 88 >> 2] < 0) {
   HEAP32[$3 + 88 >> 2] = 0;
  }
  HEAP32[$3 + 40 >> 2] = jsfGetFileSize($3 + 48 | 0);
  if (HEAP32[$3 + 84 >> 2] <= 0) {
   HEAP32[$3 + 84 >> 2] = HEAP32[$3 + 40 >> 2];
  }
  if (HEAP32[$3 + 88 >> 2] > HEAP32[$3 + 40 >> 2]) {
   HEAP32[$3 + 88 >> 2] = HEAP32[$3 + 40 >> 2];
  }
  if ((HEAP32[$3 + 88 >> 2] + HEAP32[$3 + 84 >> 2] | 0) > HEAP32[$3 + 40 >> 2]) {
   HEAP32[$3 + 84 >> 2] = HEAP32[$3 + 40 >> 2] - HEAP32[$3 + 88 >> 2];
  }
  if (HEAP32[$3 + 84 >> 2] <= 0) {
   HEAP32[$3 + 92 >> 2] = jsvNewWithFlags(27);
   break label$1;
  }
  HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 88 >> 2] + HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 92 >> 2] = jsvAddressToVar(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 84 >> 2]);
 }
 global$0 = $3 + 96 | 0;
 return HEAP32[$3 + 92 >> 2];
}
function jsfBankCompact() {
 var $0 = 0, $1 = 0;
 $1 = global$0 - 48 | 0;
 $0 = $1;
 global$0 = $0;
 HEAP32[$0 + 40 >> 2] = 134217728;
 label$1 : {
  if (!(jshFlashGetPage(HEAP32[$0 + 40 >> 2], $0 + 36 | 0, $0 + 32 | 0) & 1)) {
   HEAP8[$0 + 47 | 0] = 0;
   break label$1;
  }
  HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 32 >> 2] + 32;
  HEAP32[$0 + 24 >> 2] = 0;
  HEAP32[$0 + 20 >> 2] = jsfGetAllocatedSpace(HEAP32[$0 + 40 >> 2], $0 + 24 | 0);
  if (!HEAP32[$0 + 24 >> 2]) {
   HEAP8[$0 + 47 | 0] = 1;
   break label$1;
  }
  HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 20 >> 2];
  if (HEAPU32[$0 + 16 >> 2] > HEAPU32[$0 + 28 >> 2]) {
   HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 28 >> 2];
  }
  if (HEAP32[$0 + 16 >> 2] + 256 >>> 0 < 1e6) {
   $1 = $1 - (HEAP32[$0 + 16 >> 2] + 15 & -16) | 0;
   global$0 = $1;
   HEAP32[$0 + 12 >> 2] = $1;
   HEAP8[$0 + 47 | 0] = jsfCompactInternal(HEAP32[$0 + 40 >> 2], HEAP32[$0 + 12 >> 2], HEAP32[$0 + 16 >> 2]) & 1;
   break label$1;
  }
  HEAP32[$0 + 8 >> 2] = jsvNewFlatStringOfLength(HEAP32[$0 + 16 >> 2]);
  if (HEAP32[$0 + 8 >> 2]) {
   HEAP32[$0 + 4 >> 2] = jsvGetFlatStringPointer(HEAP32[$0 + 8 >> 2]);
   HEAP8[$0 + 3 | 0] = jsfCompactInternal(HEAP32[$0 + 40 >> 2], HEAP32[$0 + 4 >> 2], HEAP32[$0 + 16 >> 2]) & 1;
   jsvUnLock(HEAP32[$0 + 8 >> 2]);
   HEAP8[$0 + 47 | 0] = HEAP8[$0 + 3 | 0] & 1;
   break label$1;
  }
  HEAP8[$0 + 47 | 0] = 0;
 }
 global$0 = $0 + 48 | 0;
 return HEAP8[$0 + 47 | 0] & 1;
}
function jslGetNextCh() {
 var $0 = 0;
 $0 = jslNextCh();
 HEAP8[HEAP32[35539]] = $0;
 $0 = HEAP32[35539];
 HEAP32[$0 + 88 >> 2] = HEAP32[$0 + 88 >> 2] + 1;
 label$1 : {
  if (HEAPU32[HEAP32[35539] + 88 >> 2] < HEAPU32[HEAP32[35539] + 92 >> 2]) {
   break label$1;
  }
  $0 = HEAP32[35539];
  HEAP32[$0 + 88 >> 2] = HEAP32[$0 + 88 >> 2] - HEAP32[HEAP32[35539] + 92 >> 2];
  $0 = HEAP32[35539];
  HEAP32[$0 + 96 >> 2] = HEAP32[HEAP32[35539] + 92 >> 2] + HEAP32[$0 + 96 >> 2];
  if (jsvIsFlashString(HEAP32[HEAP32[35539] + 100 >> 2]) & 1) {
   jsvStringIteratorLoadFlashString(HEAP32[35539] + 88 | 0);
   break label$1;
  }
  label$3 : {
   label$4 : {
    if (!HEAP32[HEAP32[35539] + 100 >> 2]) {
     break label$4;
    }
    if (!(jsvGetLastChild(HEAP32[HEAP32[35539] + 100 >> 2]) & 65535)) {
     break label$4;
    }
    $0 = _jsvGetAddressOf(jsvGetLastChild(HEAP32[HEAP32[35539] + 100 >> 2]) & 65535);
    HEAP32[HEAP32[35539] + 100 >> 2] = $0;
    HEAP32[HEAP32[35539] + 104 >> 2] = HEAP32[HEAP32[35539] + 100 >> 2];
    $0 = jsvGetCharactersInVar(HEAP32[HEAP32[35539] + 100 >> 2]);
    HEAP32[HEAP32[35539] + 92 >> 2] = $0;
    break label$3;
   }
   HEAP32[HEAP32[35539] + 100 >> 2] = 0;
   HEAP32[HEAP32[35539] + 104 >> 2] = 0;
   HEAP32[HEAP32[35539] + 92 >> 2] = 0;
   $0 = HEAP32[35539];
   HEAP32[$0 + 96 >> 2] = HEAP32[HEAP32[35539] + 88 >> 2] + HEAP32[$0 + 96 >> 2];
   HEAP32[HEAP32[35539] + 88 >> 2] = 0;
  }
 }
}
function match($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = global$0 - 368 | 0;
 global$0 = $4;
 $5 = $4 + 184 | 0;
 HEAP32[$4 + 364 >> 2] = $0;
 HEAP32[$4 + 360 >> 2] = $1;
 HEAP32[$4 + 356 >> 2] = $2;
 HEAP8[$4 + 355 | 0] = $3;
 HEAP32[$4 + 264 >> 2] = HEAP32[$4 + 360 >> 2];
 HEAP32[$4 + 268 >> 2] = HEAP32[$4 + 356 >> 2];
 HEAP8[$4 + 272 | 0] = HEAP8[$4 + 355 | 0] & 1;
 HEAP8[$4 + 273 | 0] = 0;
 HEAP16[$4 + 274 >> 1] = 256;
 HEAP32[$4 + 276 >> 2] = 0;
 $0 = $4 + 224 | 0;
 jsvStringIteratorNew($0, HEAP32[$4 + 360 >> 2], HEAP32[$4 + 356 >> 2]);
 jsvStringIteratorClone($5, $0);
 $0 = HEAP32[$4 + 364 >> 2];
 memcpy($4 + 96 | 0, $4 + 264 | 0, 88);
 $0 = matchhere($0, $4 + 184 | 0, $4 + 96 | 0);
 $1 = $4 + 224 | 0;
 HEAP32[$4 + 260 >> 2] = $0;
 jsvStringIteratorFree($4 + 184 | 0);
 jsvStringIteratorNext($1);
 while (1) {
  if (HEAP32[$4 + 260 >> 2]) {
   $0 = 0;
  } else {
   $0 = jsvStringIteratorHasChar($4 + 224 | 0);
  }
  if ($0 & 1) {
   HEAP32[$4 + 268 >> 2] = HEAP32[$4 + 268 >> 2] + 1;
   jsvStringIteratorClone($4 + 184 | 0, $4 + 224 | 0);
   $0 = HEAP32[$4 + 364 >> 2];
   memcpy($4 + 8 | 0, $4 + 264 | 0, 88);
   $0 = matchhere($0, $4 + 184 | 0, $4 + 8 | 0);
   $1 = $4 + 224 | 0;
   HEAP32[$4 + 260 >> 2] = $0;
   jsvStringIteratorFree($4 + 184 | 0);
   jsvStringIteratorNext($1);
   continue;
  }
  break;
 }
 jsvStringIteratorFree($4 + 224 | 0);
 global$0 = $4 + 368 | 0;
 return HEAP32[$4 + 260 >> 2];
}
function jspEvaluateModule($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 label$1 : {
  label$2 : {
   if (jsvIsFunction(HEAP32[$1 + 24 >> 2]) & 1) {
    HEAP32[$1 + 24 >> 2] = jsvObjectGetChild(HEAP32[$1 + 24 >> 2], 79689, 0);
    if (!(jsvIsString(HEAP32[$1 + 24 >> 2]) & 1)) {
     jsvUnLock(HEAP32[$1 + 24 >> 2]);
     HEAP32[$1 + 28 >> 2] = 0;
     break label$1;
    }
    break label$2;
   }
   jsvLockAgain(HEAP32[$1 + 24 >> 2]);
  }
  HEAP32[$1 + 20 >> 2] = jsvNewWithFlags(5);
  HEAP32[$1 + 16 >> 2] = jsvNewWithFlags(5);
  if (!(HEAP32[$1 + 16 >> 2] ? HEAP32[$1 + 20 >> 2] : 0)) {
   jsvUnLock3(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 16 >> 2], HEAP32[$1 + 24 >> 2]);
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvAddNamedChild(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 16 >> 2], 80882);
  jsvUnLock2(HEAP32[$1 + 16 >> 2], jsvAddNamedChild(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 20 >> 2], 80890));
  HEAP32[$1 + 8 >> 2] = HEAP32[80549];
  HEAP32[$1 + 4 >> 2] = HEAP32[80548];
  HEAP32[80548] = HEAP32[$1 + 16 >> 2];
  jsvUnLock(jspEvaluateVar(HEAP32[$1 + 24 >> 2], HEAP32[$1 + 20 >> 2], 0));
  HEAP32[80548] = HEAP32[$1 + 4 >> 2];
  HEAP32[80549] = HEAP32[$1 + 8 >> 2];
  jsvUnLock2(HEAP32[$1 + 24 >> 2], HEAP32[$1 + 20 >> 2]);
  HEAP32[$1 + 28 >> 2] = jsvSkipNameAndUnLock(HEAP32[$1 + 12 >> 2]);
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function tflite__ops__micro__reshape__Eval_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], 0);
 HEAP32[$2 + 12 >> 2] = tflite__micro__GetEvalOutput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2]);
 HEAP32[$2 + 4 >> 2] = tflite__TfLiteTypeSizeOf_28TfLiteType_2c_20unsigned_20long__29(HEAP32[HEAP32[$2 + 16 >> 2] + 8 >> 2], $2 + 8 | 0);
 label$1 : {
  if (HEAP32[$2 + 4 >> 2]) {
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 4 >> 2];
   break label$1;
  }
  HEAP32[$2 + 8 >> 2] = Math_imul(tflite__ElementCount_28TfLiteIntArray_20const__29(HEAP32[HEAP32[$2 + 16 >> 2] + 4 >> 2]), HEAP32[$2 + 8 >> 2]);
  if (HEAP32[HEAP32[$2 + 16 >> 2] >> 2] != HEAP32[HEAP32[$2 + 12 >> 2] >> 2]) {
   HEAP32[$2 >> 2] = 0;
   while (1) {
    if (HEAPU32[$2 >> 2] < HEAPU32[$2 + 8 >> 2]) {
     HEAP8[HEAP32[HEAP32[$2 + 12 >> 2] >> 2] + HEAP32[$2 >> 2] | 0] = HEAPU8[HEAP32[HEAP32[$2 + 16 >> 2] >> 2] + HEAP32[$2 >> 2] | 0];
     HEAP32[$2 >> 2] = HEAP32[$2 >> 2] + 1;
     continue;
    }
    break;
   }
  }
  HEAP32[$2 + 28 >> 2] = 0;
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function jstExecuteFn($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 + -64 | 0;
 global$0 = $3;
 HEAP32[$3 + 60 >> 2] = $0;
 HEAP32[$3 + 56 >> 2] = 0;
 HEAP32[$3 + 48 >> 2] = $1;
 HEAP32[$3 + 52 >> 2] = $2;
 HEAP32[$3 + 44 >> 2] = 0;
 $0 = HEAP32[$3 + 48 >> 2];
 HEAP8[$3 + 16 | 0] = $0;
 HEAP8[$3 + 17 | 0] = $0 >>> 8;
 HEAP8[$3 + 18 | 0] = $0 >>> 16;
 HEAP8[$3 + 19 | 0] = $0 >>> 24;
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP8[$3 + 20 | 0] = $0;
 HEAP8[$3 + 21 | 0] = $0 >>> 8;
 HEAP8[$3 + 22 | 0] = $0 >>> 16;
 HEAP8[$3 + 23 | 0] = $0 >>> 24;
 HEAP8[$3 + 40 | 0] = 2;
 $0 = HEAP32[$3 + 60 >> 2];
 HEAP8[$3 + 24 | 0] = $0;
 HEAP8[$3 + 25 | 0] = $0 >>> 8;
 HEAP8[$3 + 26 | 0] = $0 >>> 16;
 HEAP8[$3 + 27 | 0] = $0 >>> 24;
 $0 = HEAP32[$3 + 56 >> 2];
 HEAP8[$3 + 28 | 0] = $0;
 HEAP8[$3 + 29 | 0] = $0 >>> 8;
 HEAP8[$3 + 30 | 0] = $0 >>> 16;
 HEAP8[$3 + 31 | 0] = $0 >>> 24;
 HEAP32[$3 + 12 >> 2] = 2e6;
 while (1) {
  $1 = !(utilTimerIsFull() & 1);
  $0 = 0;
  label$2 : {
   if ($1) {
    break label$2;
   }
   $1 = jspIsInterrupted() & 1;
   $0 = 0;
   if ($1) {
    break label$2;
   }
   $0 = HEAP32[$3 + 12 >> 2];
   HEAP32[$3 + 12 >> 2] = $0 + -1;
   $0 = ($0 | 0) > 0;
  }
  if ($0) {
   continue;
  }
  break;
 }
 label$3 : {
  if (HEAP32[$3 + 12 >> 2] > 0) {
   if (!(jspIsInterrupted() & 1)) {
    break label$3;
   }
  }
  jsExceptionHere(4, 83218, 0);
 }
 utilTimerInsertTask($3 + 16 | 0);
 global$0 = $3 - -64 | 0;
}
function jspNewObject($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = jspNewPrototype(HEAP32[$2 + 20 >> 2]);
 HEAP32[$2 + 12 >> 2] = jsvNewWithFlags(5);
 label$1 : {
  if (!HEAP32[$2 + 12 >> 2]) {
   jsvUnLock(HEAP32[$2 + 16 >> 2]);
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$2 + 24 >> 2]) {
   HEAP8[$2 + 11 | 0] = jshFromDeviceString(HEAP32[$2 + 24 >> 2]);
   if (HEAPU8[$2 + 11 | 0]) {
    HEAP8[HEAP32[$2 + 12 >> 2]] = 68;
    HEAP8[HEAP32[$2 + 12 >> 2] + 1 | 0] = 69;
    HEAP8[HEAP32[$2 + 12 >> 2] + 2 | 0] = 86;
    HEAP8[HEAP32[$2 + 12 >> 2] + 3 | 0] = HEAPU8[$2 + 11 | 0];
   }
  }
  HEAP32[$2 + 4 >> 2] = jsvSkipName(HEAP32[$2 + 16 >> 2]);
  jsvUnLock3(jsvAddNamedChild(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2], 79526), HEAP32[$2 + 4 >> 2], HEAP32[$2 + 16 >> 2]);
  HEAP32[$2 + 16 >> 2] = 0;
  if (HEAP32[$2 + 24 >> 2]) {
   HEAP32[$2 >> 2] = jsvFindChildFromString(HEAP32[80545], HEAP32[$2 + 24 >> 2], 1);
   if (HEAP32[$2 >> 2]) {
    jsvSetValueOfName(HEAP32[$2 >> 2], HEAP32[$2 + 12 >> 2]);
   }
   jsvUnLock(HEAP32[$2 + 12 >> 2]);
   if (!HEAP32[$2 >> 2]) {
    HEAP32[$2 + 28 >> 2] = 0;
    break label$1;
   }
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 >> 2];
   break label$1;
  }
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function jswrap_graphics_imageMetrics($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 192 | 0;
 global$0 = $2;
 HEAP32[$2 + 184 >> 2] = $0;
 HEAP32[$2 + 180 >> 2] = $1;
 label$1 : {
  if (!(graphicsGetFromVar($2 + 104 | 0, HEAP32[$2 + 184 >> 2]) & 1)) {
   HEAP32[$2 + 188 >> 2] = 0;
   break label$1;
  }
  if (!(_jswrap_graphics_parseImage($2 + 104 | 0, HEAP32[$2 + 180 >> 2], 0, $2 + 16 | 0) & 1)) {
   HEAP32[$2 + 188 >> 2] = 0;
   break label$1;
  }
  $0 = $2 + 16 | 0;
  HEAP32[$2 + 12 >> 2] = jsvGetLength(HEAP32[$2 + 36 >> 2]) - HEAP32[$2 + 40 >> 2];
  _jswrap_graphics_freeImageInfo($0);
  HEAP32[$2 + 8 >> 2] = jsvNewWithFlags(5);
  if (HEAP32[$2 + 8 >> 2]) {
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 8 >> 2], 127442, jsvNewFromInteger(HEAP32[$2 + 16 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 8 >> 2], 127448, jsvNewFromInteger(HEAP32[$2 + 20 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 8 >> 2], 127863, jsvNewFromInteger(HEAP32[$2 + 24 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 8 >> 2], 127867, jsvNewFromBool(HEAP8[$2 + 28 | 0] & 1));
   HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 12 >> 2] / HEAPU16[$2 + 66 >> 1];
   if (HEAP32[$2 + 4 >> 2] > 1) {
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 8 >> 2], 127879, jsvNewFromInteger(HEAP32[$2 + 4 >> 2]));
   }
  }
  HEAP32[$2 + 188 >> 2] = HEAP32[$2 + 8 >> 2];
 }
 global$0 = $2 + 192 | 0;
 return HEAP32[$2 + 188 >> 2];
}
function jsvGetBool($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 label$1 : {
  if (jsvIsString(HEAP32[$1 + 24 >> 2]) & 1) {
   HEAP8[$1 + 31 | 0] = (jsvGetStringLength(HEAP32[$1 + 24 >> 2]) | 0) != 0;
   break label$1;
  }
  if (jsvIsPin(HEAP32[$1 + 24 >> 2]) & 1) {
   HEAP8[$1 + 31 | 0] = jshIsPinValid(jshGetPinFromVar(HEAP32[$1 + 24 >> 2]) & 255) & 1;
   break label$1;
  }
  label$4 : {
   label$5 : {
    if (jsvIsFunction(HEAP32[$1 + 24 >> 2]) & 1) {
     break label$5;
    }
    if (jsvIsArray(HEAP32[$1 + 24 >> 2]) & 1) {
     break label$5;
    }
    if (jsvIsObject(HEAP32[$1 + 24 >> 2]) & 1) {
     break label$5;
    }
    if (!(jsvIsArrayBuffer(HEAP32[$1 + 24 >> 2]) & 1)) {
     break label$4;
    }
   }
   HEAP8[$1 + 31 | 0] = 1;
   break label$1;
  }
  if (jsvIsFloat(HEAP32[$1 + 24 >> 2]) & 1) {
   HEAPF64[$1 + 16 >> 3] = jsvGetFloat(HEAP32[$1 + 24 >> 2]);
   $3 = $1;
   $0 = __DOUBLE_BITS(HEAPF64[$1 + 16 >> 3]);
   $2 = i64toi32_i32$HIGH_BITS & 2147483647;
   $2 = ($2 | 0) == 2146435072 & $0 >>> 0 > 0 | $2 >>> 0 > 2146435072;
   $0 = 0;
   label$7 : {
    if ($2) {
     break label$7;
    }
    $0 = HEAPF64[$1 + 16 >> 3] != 0;
   }
   HEAP8[$3 + 31 | 0] = $0;
   break label$1;
  }
  HEAP8[$1 + 31 | 0] = (jsvGetInteger(HEAP32[$1 + 24 >> 2]) | 0) != 0;
 }
 global$0 = $1 + 32 | 0;
 return HEAP8[$1 + 31 | 0] & 1;
}
function jsiGetHistoryLine($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP8[$1 + 27 | 0] = $0;
 HEAP32[$1 + 20 >> 2] = jsiGetHistory();
 label$1 : {
  if (!HEAP32[$1 + 20 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 16 >> 2] = 0;
  HEAP32[$1 + 12 >> 2] = jsvGetIndexOf(HEAP32[$1 + 20 >> 2], HEAP32[80557], 1);
  label$3 : {
   if (HEAP32[$1 + 12 >> 2]) {
    label$5 : {
     label$6 : {
      if (!(HEAP8[$1 + 27 | 0] & 1)) {
       break label$6;
      }
      if (!(jsvGetPrevSibling(HEAP32[$1 + 12 >> 2]) & 65535)) {
       break label$6;
      }
      HEAP32[$1 + 16 >> 2] = jsvSkipNameAndUnLock(jsvLock(jsvGetPrevSibling(HEAP32[$1 + 12 >> 2]) & 65535));
      break label$5;
     }
     label$7 : {
      if (HEAP8[$1 + 27 | 0] & 1) {
       break label$7;
      }
      if (!(jsvGetNextSibling(HEAP32[$1 + 12 >> 2]) & 65535)) {
       break label$7;
      }
      HEAP32[$1 + 16 >> 2] = jsvSkipNameAndUnLock(jsvLock(jsvGetNextSibling(HEAP32[$1 + 12 >> 2]) & 65535));
     }
    }
    jsvUnLock(HEAP32[$1 + 12 >> 2]);
    break label$3;
   }
   if (HEAP8[$1 + 27 | 0] & 1) {
    HEAP32[$1 + 16 >> 2] = jsvSkipNameAndUnLock(jsvGetArrayItem(HEAP32[$1 + 20 >> 2], jsvGetArrayLength(HEAP32[$1 + 20 >> 2]) - 1 | 0));
   }
  }
  jsvUnLock(HEAP32[$1 + 20 >> 2]);
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 16 >> 2];
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function jsvIteratorSetValue($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[HEAP32[$2 + 12 >> 2] >> 2] + -1 | 0;
 label$1 : {
  if ($0 >>> 0 > 3) {
   break label$1;
  }
  label$2 : {
   switch ($0 - 1 | 0) {
   case 2:
    label$6 : {
     if (!(jsvIsIntegerish(HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2]) & 1)) {
      break label$6;
     }
     if ((jsvGetInteger(HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2]) | 0) != HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2]) {
      break label$6;
     }
     jsvObjectIteratorSetValue(HEAP32[$2 + 12 >> 2] + 4 | 0, HEAP32[$2 + 8 >> 2]);
    }
    jsvSetArrayItem(HEAP32[HEAP32[$2 + 12 >> 2] + 8 >> 2], HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2], HEAP32[$2 + 8 >> 2]);
    break label$1;
   case 0:
    jsvObjectIteratorSetValue(HEAP32[$2 + 12 >> 2] + 4 | 0, HEAP32[$2 + 8 >> 2]);
    break label$1;
   default:
    $0 = HEAP32[$2 + 12 >> 2] + 4 | 0;
    label$7 : {
     if (jsvIsString(HEAP32[$2 + 8 >> 2]) & 1) {
      $1 = HEAP8[HEAP32[$2 + 8 >> 2]];
      break label$7;
     }
     $1 = jsvGetInteger(HEAP32[$2 + 8 >> 2]) << 24 >> 24;
    }
    jsvStringIteratorSetChar($0, $1 << 24 >> 24);
    break label$1;
   case 1:
    break label$2;
   }
  }
  jsvArrayBufferIteratorSetValueAndRewind(HEAP32[$2 + 12 >> 2] + 4 | 0, HEAP32[$2 + 8 >> 2]);
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 8 >> 2];
}
function jsfGetNextFileHeader($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 HEAP32[$3 + 12 >> 2] = HEAP32[HEAP32[$3 + 24 >> 2] >> 2];
 HEAP32[HEAP32[$3 + 24 >> 2] >> 2] = 0;
 HEAP32[$3 + 8 >> 2] = (HEAP32[$3 + 12 >> 2] + jsfGetFileSize(HEAP32[$3 + 20 >> 2]) | 0) + 32;
 HEAP32[$3 + 8 >> 2] = jsfAlignAddress(HEAP32[$3 + 8 >> 2]);
 label$1 : {
  if (HEAPU32[$3 + 8 >> 2] < HEAPU32[$3 + 12 >> 2]) {
   HEAP8[$3 + 31 | 0] = 0;
   break label$1;
  }
  if (HEAP32[$3 + 8 >> 2] + 32 >>> 0 > jsfGetBankEndAddress(HEAP32[$3 + 12 >> 2]) >>> 0) {
   HEAP8[$3 + 31 | 0] = 0;
   break label$1;
  }
  HEAP32[HEAP32[$3 + 24 >> 2] >> 2] = HEAP32[$3 + 8 >> 2];
  HEAP8[$3 + 7 | 0] = jsfGetFileHeader(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 20 >> 2], ((HEAP32[$3 + 16 >> 2] & 2) != 0 ^ -1) & 1) & 1;
  if (!(!(HEAP32[$3 + 16 >> 2] & 1) | HEAP8[$3 + 7 | 0] & 1)) {
   HEAP32[$3 + 8 >> 2] = jsfGetAddressOfNextPage(HEAP32[$3 + 8 >> 2]);
   HEAP32[HEAP32[$3 + 24 >> 2] >> 2] = HEAP32[$3 + 8 >> 2];
   if (!HEAP32[$3 + 8 >> 2]) {
    HEAP8[$3 + 31 | 0] = 0;
    break label$1;
   }
   HEAP8[$3 + 7 | 0] = jsfGetFileHeader(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 20 >> 2], ((HEAP32[$3 + 16 >> 2] & 2) != 0 ^ -1) & 1) & 1;
  }
  HEAP8[$3 + 31 | 0] = HEAP8[$3 + 7 | 0] & 1;
 }
 global$0 = $3 + 32 | 0;
 return HEAP8[$3 + 31 | 0] & 1;
}
function tflite__GreedyMemoryPlanner__NextSimultaneouslyActiveBuffer_28tflite__GreedyMemoryPlanner__ListEntry_20const__2c_20int_2c_20int_29($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 global$0 = $4;
 HEAP32[$4 + 24 >> 2] = $0;
 HEAP32[$4 + 20 >> 2] = $1;
 HEAP32[$4 + 16 >> 2] = $2;
 HEAP32[$4 + 12 >> 2] = $3;
 $0 = HEAP32[$4 + 24 >> 2];
 HEAP32[$4 + 8 >> 2] = 0;
 label$1 : {
  label$2 : {
   if (!HEAP32[$4 + 20 >> 2]) {
    HEAP32[$4 + 4 >> 2] = HEAP32[$0 + 24 >> 2] + Math_imul(HEAP32[$0 + 32 >> 2], 12);
    break label$2;
   }
   if (HEAP32[HEAP32[$4 + 20 >> 2] + 8 >> 2] == -1) {
    HEAP32[$4 + 28 >> 2] = 0;
    break label$1;
   }
   HEAP32[$4 + 4 >> 2] = HEAP32[$0 + 24 >> 2] + Math_imul(HEAP32[HEAP32[$4 + 20 >> 2] + 8 >> 2], 12);
  }
  while (1) {
   label$6 : {
    if (tflite__GreedyMemoryPlanner__DoesEntryOverlapInTime_28tflite__GreedyMemoryPlanner__ListEntry_20const__2c_20int_2c_20int_29_20const($0, HEAP32[$4 + 4 >> 2], HEAP32[$4 + 16 >> 2], HEAP32[$4 + 12 >> 2]) & 1) {
     HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 4 >> 2];
     break label$6;
    }
    if (HEAP32[HEAP32[$4 + 4 >> 2] + 8 >> 2] == -1) {
     break label$6;
    }
    HEAP32[$4 + 4 >> 2] = HEAP32[$0 + 24 >> 2] + Math_imul(HEAP32[HEAP32[$4 + 4 >> 2] + 8 >> 2], 12);
    continue;
   }
   break;
  }
  HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 8 >> 2];
 }
 global$0 = $4 + 32 | 0;
 return HEAP32[$4 + 28 >> 2];
}
function push_bits($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP8[$4 + 27 | 0] = $1;
 HEAP8[$4 + 26 | 0] = $2;
 HEAP32[$4 + 20 >> 2] = $3;
 label$1 : {
  if (!(HEAPU8[$4 + 27 | 0] != 8 | HEAPU8[HEAP32[$4 + 28 >> 2] + 14 | 0] != 128)) {
   $1 = HEAPU8[$4 + 26 | 0];
   $2 = HEAP32[HEAP32[$4 + 20 >> 2] >> 2];
   $3 = HEAP32[HEAP32[$4 + 20 >> 2] + 8 >> 2];
   $0 = HEAP32[$3 >> 2];
   HEAP32[$3 >> 2] = $0 + 1;
   HEAP8[$0 + $2 | 0] = $1;
   break label$1;
  }
  HEAP32[$4 + 16 >> 2] = HEAPU8[$4 + 27 | 0] - 1;
  while (1) {
   if (HEAP32[$4 + 16 >> 2] >= 0) {
    HEAP8[$4 + 15 | 0] = (HEAPU8[$4 + 26 | 0] & 1 << HEAP32[$4 + 16 >> 2]) != 0;
    if (HEAP8[$4 + 15 | 0] & 1) {
     $0 = HEAP32[$4 + 28 >> 2];
     HEAP8[$0 + 13 | 0] = HEAPU8[HEAP32[$4 + 28 >> 2] + 14 | 0] | HEAPU8[$0 + 13 | 0];
    }
    $0 = HEAP32[$4 + 28 >> 2];
    HEAP8[$0 + 14 | 0] = HEAPU8[$0 + 14 | 0] >> 1;
    if (!HEAPU8[HEAP32[$4 + 28 >> 2] + 14 | 0]) {
     HEAP8[HEAP32[$4 + 28 >> 2] + 14 | 0] = 128;
     $1 = HEAPU8[HEAP32[$4 + 28 >> 2] + 13 | 0];
     $2 = HEAP32[HEAP32[$4 + 20 >> 2] >> 2];
     $3 = HEAP32[HEAP32[$4 + 20 >> 2] + 8 >> 2];
     $0 = HEAP32[$3 >> 2];
     HEAP32[$3 >> 2] = $0 + 1;
     HEAP8[$0 + $2 | 0] = $1;
     HEAP8[HEAP32[$4 + 28 >> 2] + 13 | 0] = 0;
    }
    HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 16 >> 2] + -1;
    continue;
   }
   break;
  }
 }
}
function tflite__MicroAllocator__AllocateNodeAndRegistrations_28tflite__Model_20const__2c_20tflite__NodeAndRegistration___29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0, wasm2js_i32$3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 $0 = HEAP32[$3 + 24 >> 2];
 label$1 : {
  if (!HEAP32[$3 + 16 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$3 + 12 >> 2] = tflite__MicroAllocator__GetSubGraphFromModel_28tflite__Model_20const__29($0, HEAP32[$3 + 20 >> 2]);
 label$2 : {
  if (!HEAP32[$3 + 12 >> 2]) {
   break label$2;
  }
 }
 $1 = HEAP32[$0 + 4 >> 2];
 HEAP32[$3 + 8 >> 2] = (wasm2js_i32$1 = $1, wasm2js_i32$2 = Math_imul(flatbuffers__Vector_int___size_28_29_20const(tflite__SubGraph__operators_28_29_20const(HEAP32[$3 + 12 >> 2])), 28), wasm2js_i32$3 = 4, wasm2js_i32$0 = HEAP32[HEAP32[$1 >> 2] + 12 >> 2], FUNCTION_TABLE[wasm2js_i32$0](wasm2js_i32$1 | 0, wasm2js_i32$2 | 0, wasm2js_i32$3 | 0) | 0);
 label$3 : {
  if (!HEAP32[$3 + 8 >> 2]) {
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$0 + 8 >> 2], 132117, 0);
   HEAP32[$3 + 28 >> 2] = 1;
   break label$3;
  }
  HEAP32[HEAP32[$3 + 16 >> 2] >> 2] = HEAP32[$3 + 8 >> 2];
  HEAP32[$3 + 28 >> 2] = 0;
 }
 global$0 = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}
function jswrap_object_removeListener($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 label$1 : {
  if (!(jsvHasChildren(HEAP32[$3 + 28 >> 2]) & 1)) {
   jsExceptionHere(3, 123613, 0);
   break label$1;
  }
  if (jsvIsString(HEAP32[$3 + 24 >> 2]) & 1) {
   HEAP32[$3 >> 2] = HEAP32[$3 + 24 >> 2];
   HEAP32[$3 + 16 >> 2] = jsvVarPrintf(123811, $3);
   if (!HEAP32[$3 + 16 >> 2]) {
    break label$1;
   }
   HEAP32[$3 + 12 >> 2] = jsvFindChildFromVar(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 16 >> 2], 1);
   jsvUnLock(HEAP32[$3 + 16 >> 2]);
   HEAP32[$3 + 8 >> 2] = jsvSkipName(HEAP32[$3 + 12 >> 2]);
   if (HEAP32[$3 + 8 >> 2]) {
    label$5 : {
     if (HEAP32[$3 + 8 >> 2] == HEAP32[$3 + 20 >> 2]) {
      jsvRemoveChild(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 12 >> 2]);
      break label$5;
     }
     if (jsvIsArray(HEAP32[$3 + 8 >> 2]) & 1) {
      HEAP32[$3 + 4 >> 2] = jsvGetIndexOf(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 20 >> 2], 1);
      if (HEAP32[$3 + 4 >> 2]) {
       jsvRemoveChild(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
       jsvUnLock(HEAP32[$3 + 4 >> 2]);
      }
     }
    }
    jsvUnLock(HEAP32[$3 + 8 >> 2]);
   }
   jsvUnLock(HEAP32[$3 + 12 >> 2]);
   break label$1;
  }
  jsExceptionHere(3, 123917, 0);
 }
 global$0 = $3 + 32 | 0;
}
function jsvAsArrayIndex($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 label$1 : {
  label$2 : {
   if (!(jsvIsSimpleInt(HEAP32[$1 + 24 >> 2]) & 1)) {
    break label$2;
   }
   if ((jsvGetInteger(HEAP32[$1 + 24 >> 2]) | 0) < 0) {
    break label$2;
   }
   HEAP32[$1 + 28 >> 2] = jsvLockAgain(HEAP32[$1 + 24 >> 2]);
   break label$1;
  }
  label$3 : {
   if (jsvIsString(HEAP32[$1 + 24 >> 2]) & 1) {
    if (jsvIsStringNumericStrict(HEAP32[$1 + 24 >> 2]) & 1) {
     HEAP32[$1 + 20 >> 2] = jsvNewFromInteger(jsvGetInteger(HEAP32[$1 + 24 >> 2]));
     HEAP32[$1 + 16 >> 2] = jsvAsString(HEAP32[$1 + 20 >> 2]);
     if (!jsvCompareString(HEAP32[$1 + 24 >> 2], HEAP32[$1 + 16 >> 2], 0, 0)) {
      jsvUnLock(HEAP32[$1 + 16 >> 2]);
      HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
      break label$1;
     }
     jsvUnLock2(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 16 >> 2]);
    }
    break label$3;
   }
   if (jsvIsFloat(HEAP32[$1 + 24 >> 2]) & 1) {
    HEAPF64[$1 + 8 >> 3] = jsvGetFloat(HEAP32[$1 + 24 >> 2]);
    HEAP32[$1 + 4 >> 2] = jsvGetInteger(HEAP32[$1 + 24 >> 2]);
    if (HEAPF64[$1 + 8 >> 3] == +HEAP32[$1 + 4 >> 2]) {
     HEAP32[$1 + 28 >> 2] = jsvNewFromInteger(HEAP32[$1 + 4 >> 2]);
     break label$1;
    }
   }
  }
  HEAP32[$1 + 28 >> 2] = jsvAsString(HEAP32[$1 + 24 >> 2]);
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function jsvUpdateMemoryAddress($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 HEAP32[$3 + 16 >> 2] = 1;
 while (1) {
  if (HEAPU32[$3 + 16 >> 2] <= HEAPU32[35415]) {
   HEAP32[$3 + 12 >> 2] = jsvGetAddressOf(HEAP32[$3 + 16 >> 2] & 65535);
   label$3 : {
    label$4 : {
     if (!(jsvIsNativeString(HEAP32[$3 + 12 >> 2]) & 1)) {
      if (!(jsvIsFlashString(HEAP32[$3 + 12 >> 2]) & 1)) {
       break label$4;
      }
     }
     $0 = HEAP32[$3 + 12 >> 2];
     HEAP32[$3 + 8 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
     if (!(HEAPU32[$3 + 8 >> 2] < HEAPU32[$3 + 28 >> 2] | HEAPU32[$3 + 8 >> 2] >= HEAP32[$3 + 28 >> 2] + HEAP32[$3 + 24 >> 2] >>> 0)) {
      $0 = HEAP32[$3 + 12 >> 2];
      $1 = (HEAP32[$3 + 8 >> 2] + HEAP32[$3 + 20 >> 2] | 0) - HEAP32[$3 + 28 >> 2] | 0;
      HEAP8[$0 | 0] = $1;
      HEAP8[$0 + 1 | 0] = $1 >>> 8;
      HEAP8[$0 + 2 | 0] = $1 >>> 16;
      HEAP8[$0 + 3 | 0] = $1 >>> 24;
     }
     break label$3;
    }
    if (jsvIsFlatString(HEAP32[$3 + 12 >> 2]) & 1) {
     HEAP32[$3 + 16 >> 2] = jsvGetFlatStringBlocks(HEAP32[$3 + 12 >> 2]) + HEAP32[$3 + 16 >> 2];
    }
   }
   HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 16 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $3 + 32 | 0;
}
function lcdFillRect_JS($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0;
 $6 = global$0 - 48 | 0;
 global$0 = $6;
 HEAP32[$6 + 44 >> 2] = $0;
 HEAP32[$6 + 40 >> 2] = $1;
 HEAP32[$6 + 36 >> 2] = $2;
 HEAP32[$6 + 32 >> 2] = $3;
 HEAP32[$6 + 28 >> 2] = $4;
 HEAP32[$6 + 24 >> 2] = $5;
 $0 = HEAP32[$6 + 44 >> 2];
 HEAP32[$6 + 20 >> 2] = jsvObjectGetChild(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 108460, 0);
 label$1 : {
  if (HEAP32[$6 + 20 >> 2]) {
   HEAP32[$6 >> 2] = jsvNewFromInteger(HEAP32[$6 + 40 >> 2]);
   HEAP32[$6 + 4 >> 2] = jsvNewFromInteger(HEAP32[$6 + 36 >> 2]);
   HEAP32[$6 + 8 >> 2] = jsvNewFromInteger(HEAP32[$6 + 32 >> 2]);
   HEAP32[$6 + 12 >> 2] = jsvNewFromInteger(HEAP32[$6 + 28 >> 2]);
   HEAP32[$6 + 16 >> 2] = jsvNewFromInteger(HEAP32[$6 + 24 >> 2]);
   $0 = HEAP32[$6 + 44 >> 2];
   jsvUnLock(jspExecuteFunction(HEAP32[$6 + 20 >> 2], HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 5, $6));
   jsvUnLockMany(5, $6);
   jsvUnLock(HEAP32[$6 + 20 >> 2]);
   break label$1;
  }
  graphicsFallbackFillRect(HEAP32[$6 + 44 >> 2], HEAP32[$6 + 40 >> 2], HEAP32[$6 + 36 >> 2], HEAP32[$6 + 32 >> 2], HEAP32[$6 + 28 >> 2], HEAP32[$6 + 24 >> 2]);
 }
 global$0 = $6 + 48 | 0;
}
function jsvGetCommonCharacters($0, $1) {
 var $2 = 0;
 $2 = global$0 - 112 | 0;
 global$0 = $2;
 HEAP32[$2 + 104 >> 2] = $0;
 HEAP32[$2 + 100 >> 2] = $1;
 HEAP32[$2 + 96 >> 2] = jsvNewWithFlags(27);
 label$1 : {
  if (!HEAP32[$2 + 96 >> 2]) {
   HEAP32[$2 + 108 >> 2] = 0;
   break label$1;
  }
  $0 = $2 + 16 | 0;
  $1 = $2 + 56 | 0;
  jsvStringIteratorNew($1, HEAP32[$2 + 104 >> 2], 0);
  jsvStringIteratorNew($0, HEAP32[$2 + 100 >> 2], 0);
  HEAP32[$2 + 12 >> 2] = jsvStringIteratorGetCharOrMinusOne($1);
  HEAP32[$2 + 8 >> 2] = jsvStringIteratorGetCharOrMinusOne($0);
  while (1) {
   $0 = 0;
   label$4 : {
    if (HEAP32[$2 + 12 >> 2] <= 0) {
     break label$4;
    }
    $0 = 0;
    if (HEAP32[$2 + 8 >> 2] <= 0) {
     break label$4;
    }
    $0 = HEAP32[$2 + 12 >> 2] == HEAP32[$2 + 8 >> 2];
   }
   if ($0) {
    $0 = $2 + 16 | 0;
    $1 = $2 + 56 | 0;
    jsvAppendCharacter(HEAP32[$2 + 96 >> 2], HEAP32[$2 + 12 >> 2] << 24 >> 24);
    jsvStringIteratorNext($1);
    jsvStringIteratorNext($0);
    HEAP32[$2 + 12 >> 2] = jsvStringIteratorGetCharOrMinusOne($1);
    HEAP32[$2 + 8 >> 2] = jsvStringIteratorGetCharOrMinusOne($0);
    continue;
   }
   break;
  }
  $0 = $2 + 16 | 0;
  jsvStringIteratorFree($2 + 56 | 0);
  jsvStringIteratorFree($0);
  HEAP32[$2 + 108 >> 2] = HEAP32[$2 + 96 >> 2];
 }
 global$0 = $2 + 112 | 0;
 return HEAP32[$2 + 108 >> 2];
}
function graphicsFallbackBlit($0, $1, $2, $3, $4, $5, $6) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 var $7 = 0;
 $7 = global$0 - 48 | 0;
 global$0 = $7;
 HEAP32[$7 + 44 >> 2] = $0;
 HEAP32[$7 + 40 >> 2] = $1;
 HEAP32[$7 + 36 >> 2] = $2;
 HEAP32[$7 + 32 >> 2] = $3;
 HEAP32[$7 + 28 >> 2] = $4;
 HEAP32[$7 + 24 >> 2] = $5;
 HEAP32[$7 + 20 >> 2] = $6;
 HEAP32[$7 + 16 >> 2] = 0;
 while (1) {
  if (HEAP32[$7 + 16 >> 2] < HEAP32[$7 + 28 >> 2]) {
   HEAP32[$7 + 12 >> 2] = 0;
   while (1) {
    if (HEAP32[$7 + 12 >> 2] < HEAP32[$7 + 32 >> 2]) {
     $0 = HEAP32[$7 + 44 >> 2];
     $1 = HEAPU8[$0 + 52 | 0] | HEAPU8[$0 + 53 | 0] << 8 | (HEAPU8[$0 + 54 | 0] << 16 | HEAPU8[$0 + 55 | 0] << 24);
     $0 = HEAP32[$7 + 44 >> 2];
     FUNCTION_TABLE[$1](HEAP32[$7 + 44 >> 2], HEAP32[$7 + 12 >> 2] + HEAP32[$7 + 24 >> 2] | 0, HEAP32[$7 + 16 >> 2] + HEAP32[$7 + 20 >> 2] | 0, FUNCTION_TABLE[HEAPU8[$0 + 60 | 0] | HEAPU8[$0 + 61 | 0] << 8 | (HEAPU8[$0 + 62 | 0] << 16 | HEAPU8[$0 + 63 | 0] << 24)](HEAP32[$7 + 44 >> 2], HEAP32[$7 + 12 >> 2] + HEAP32[$7 + 40 >> 2] | 0, HEAP32[$7 + 16 >> 2] + HEAP32[$7 + 36 >> 2] | 0) | 0);
     HEAP32[$7 + 12 >> 2] = HEAP32[$7 + 12 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 16 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $7 + 48 | 0;
}
function jswrap_io_peek($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 96 | 0;
 global$0 = $3;
 HEAP32[$3 + 88 >> 2] = $0;
 HEAP32[$3 + 84 >> 2] = $1;
 HEAP32[$3 + 80 >> 2] = $2;
 HEAP32[$3 + 76 >> 2] = jshFlashGetMemMapAddress(HEAP32[$3 + 88 >> 2]);
 label$1 : {
  if (HEAP32[$3 + 84 >> 2] <= 1) {
   HEAP32[$3 + 92 >> 2] = jsvNewFromLongInteger(_jswrap_io_peek(HEAP32[$3 + 76 >> 2], HEAP32[$3 + 80 >> 2]), 0);
   break label$1;
  }
  if (HEAP32[$3 + 80 >> 2] == 1) {
   HEAP16[$3 + 74 >> 1] = 1;
  }
  if (HEAP32[$3 + 80 >> 2] == 2) {
   HEAP16[$3 + 74 >> 1] = 2;
  }
  if (HEAP32[$3 + 80 >> 2] == 4) {
   HEAP16[$3 + 74 >> 1] = 4;
  }
  HEAP32[$3 + 68 >> 2] = jsvNewTypedArray(HEAPU16[$3 + 74 >> 1], HEAP32[$3 + 84 >> 2]);
  if (!HEAP32[$3 + 68 >> 2]) {
   HEAP32[$3 + 92 >> 2] = 0;
   break label$1;
  }
  jsvArrayBufferIteratorNew($3 + 8 | 0, HEAP32[$3 + 68 >> 2], 0);
  while (1) {
   if (jsvArrayBufferIteratorHasElement($3 + 8 | 0) & 1) {
    $0 = $3 + 8 | 0;
    jsvArrayBufferIteratorSetIntegerValue($0, _jswrap_io_peek(HEAP32[$3 + 76 >> 2], HEAP32[$3 + 80 >> 2]));
    HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 80 >> 2] + HEAP32[$3 + 76 >> 2];
    jsvArrayBufferIteratorNext($0);
    continue;
   }
   break;
  }
  jsvArrayBufferIteratorFree($3 + 8 | 0);
  HEAP32[$3 + 92 >> 2] = HEAP32[$3 + 68 >> 2];
 }
 global$0 = $3 + 96 | 0;
 return HEAP32[$3 + 92 >> 2];
}
function tflite___28anonymous_20namespace_29__CommitPlan_28tflite__ErrorReporter__2c_20tflite__MemoryPlanner__2c_20unsigned_20char__2c_20tflite___28anonymous_20namespace_29__AllocationInfo_20const__2c_20unsigned_20long_29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 48 | 0;
 global$0 = $5;
 HEAP32[$5 + 40 >> 2] = $0;
 HEAP32[$5 + 36 >> 2] = $1;
 HEAP32[$5 + 32 >> 2] = $2;
 HEAP32[$5 + 28 >> 2] = $3;
 HEAP32[$5 + 24 >> 2] = $4;
 HEAP32[$5 + 20 >> 2] = 0;
 HEAP32[$5 + 16 >> 2] = 0;
 label$1 : {
  while (1) {
   if (HEAPU32[$5 + 16 >> 2] < HEAPU32[$5 + 24 >> 2]) {
    HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 28 >> 2] + Math_imul(HEAP32[$5 + 16 >> 2], 24);
    if (HEAP8[HEAP32[$5 + 12 >> 2] + 20 | 0] & 1) {
     HEAP32[$5 + 8 >> 2] = -1;
     $0 = HEAP32[$5 + 36 >> 2];
     HEAP32[$5 + 4 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 20 >> 2]]($0, HEAP32[$5 + 40 >> 2], HEAP32[$5 + 20 >> 2], $5 + 8 | 0);
     if (HEAP32[$5 + 4 >> 2]) {
      HEAP32[$5 + 44 >> 2] = HEAP32[$5 + 4 >> 2];
      break label$1;
     }
     HEAP32[HEAP32[HEAP32[$5 + 12 >> 2] + 4 >> 2] >> 2] = HEAP32[$5 + 32 >> 2] + HEAP32[$5 + 8 >> 2];
     HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 20 >> 2] + 1;
    }
    HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 16 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$5 + 44 >> 2] = 0;
 }
 global$0 = $5 + 48 | 0;
 return HEAP32[$5 + 44 >> 2];
}
function jsvArrayBufferIteratorGetValueData($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 label$1 : {
  if (!HEAPU16[HEAP32[$2 + 12 >> 2] + 36 >> 1]) {
   break label$1;
  }
  HEAP32[$2 >> 2] = HEAPU16[HEAP32[$2 + 12 >> 2] + 36 >> 1] & 15;
  label$2 : {
   if (HEAPU16[HEAP32[$2 + 12 >> 2] + 36 >> 1] & 256) {
    HEAP32[$2 + 4 >> 2] = HEAP32[$2 >> 2] - 1;
    while (1) {
     if (HEAP32[$2 + 4 >> 2] >= 0) {
      $0 = jsvStringIteratorGetChar(HEAP32[$2 + 12 >> 2]);
      HEAP8[HEAP32[$2 + 8 >> 2] + HEAP32[$2 + 4 >> 2] | 0] = $0;
      if (HEAP32[$2 >> 2] != 1) {
       jsvStringIteratorNext(HEAP32[$2 + 12 >> 2]);
      }
      HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + -1;
      continue;
     }
     break;
    }
    break label$2;
   }
   HEAP32[$2 + 4 >> 2] = 0;
   while (1) {
    if (HEAP32[$2 + 4 >> 2] < HEAP32[$2 >> 2]) {
     $0 = jsvStringIteratorGetChar(HEAP32[$2 + 12 >> 2]);
     HEAP8[HEAP32[$2 + 8 >> 2] + HEAP32[$2 + 4 >> 2] | 0] = $0;
     if (HEAP32[$2 >> 2] != 1) {
      jsvStringIteratorNext(HEAP32[$2 + 12 >> 2]);
     }
     HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + 1;
     continue;
    }
    break;
   }
  }
  if (HEAP32[$2 >> 2] == 1) {
   break label$1;
  }
  HEAP8[HEAP32[$2 + 12 >> 2] + 52 | 0] = 1;
 }
 global$0 = $2 + 16 | 0;
}
function jsvCompareString($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = global$0 - 112 | 0;
 global$0 = $4;
 $5 = $4 + 8 | 0;
 HEAP32[$4 + 104 >> 2] = $0;
 HEAP32[$4 + 100 >> 2] = $1;
 HEAP32[$4 + 96 >> 2] = $2;
 HEAP32[$4 + 92 >> 2] = 0;
 HEAP8[$4 + 91 | 0] = $3;
 jsvStringIteratorNew($4 + 48 | 0, HEAP32[$4 + 104 >> 2], HEAP32[$4 + 96 >> 2]);
 jsvStringIteratorNew($5, HEAP32[$4 + 100 >> 2], HEAP32[$4 + 92 >> 2]);
 while (1) {
  label$2 : {
   $0 = $4 + 8 | 0;
   HEAP32[$4 + 4 >> 2] = jsvStringIteratorGetCharOrMinusOne($4 + 48 | 0);
   HEAP32[$4 >> 2] = jsvStringIteratorGetCharOrMinusOne($0);
   if (HEAP32[$4 + 4 >> 2] != HEAP32[$4 >> 2]) {
    $0 = $4 + 8 | 0;
    jsvStringIteratorFree($4 + 48 | 0);
    jsvStringIteratorFree($0);
    if (!(!(HEAP8[$4 + 91 | 0] & 1) | (HEAP32[$4 >> 2] >= 0 ? HEAP32[$4 + 4 >> 2] >= 0 : 0))) {
     HEAP32[$4 + 108 >> 2] = 0;
     break label$2;
    }
    HEAP32[$4 + 108 >> 2] = HEAP32[$4 + 4 >> 2] - HEAP32[$4 >> 2];
    break label$2;
   }
   if (HEAP32[$4 + 4 >> 2] < 0) {
    $0 = $4 + 8 | 0;
    jsvStringIteratorFree($4 + 48 | 0);
    jsvStringIteratorFree($0);
    HEAP32[$4 + 108 >> 2] = 0;
    break label$2;
   }
   $0 = $4 + 8 | 0;
   jsvStringIteratorNext($4 + 48 | 0);
   jsvStringIteratorNext($0);
   continue;
  }
  break;
 }
 global$0 = $4 + 112 | 0;
 return HEAP32[$4 + 108 >> 2];
}
function jsvStringIteratorNew($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jsvLockAgain(HEAP32[$3 + 8 >> 2]);
 HEAP32[HEAP32[$3 + 12 >> 2] + 12 >> 2] = $0;
 HEAP32[HEAP32[$3 + 12 >> 2] + 8 >> 2] = 0;
 $0 = jsvGetCharactersInVar(HEAP32[$3 + 8 >> 2]);
 HEAP32[HEAP32[$3 + 12 >> 2] + 4 >> 2] = $0;
 HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = HEAP32[$3 + 4 >> 2];
 label$1 : {
  label$2 : {
   if (jsvIsFlatString(HEAP32[$3 + 8 >> 2]) & 1) {
    $0 = jsvGetFlatStringPointer(HEAP32[HEAP32[$3 + 12 >> 2] + 12 >> 2]);
    HEAP32[HEAP32[$3 + 12 >> 2] + 16 >> 2] = $0;
    break label$2;
   }
   label$4 : {
    if (jsvIsNativeString(HEAP32[$3 + 8 >> 2]) & 1) {
     $0 = HEAP32[HEAP32[$3 + 12 >> 2] + 12 >> 2];
     HEAP32[HEAP32[$3 + 12 >> 2] + 16 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
     break label$4;
    }
    if (jsvIsFlashString(HEAP32[$3 + 8 >> 2]) & 1) {
     HEAP32[HEAP32[$3 + 12 >> 2] + 4 >> 2] = 0;
     jsvStringIteratorLoadFlashString(HEAP32[$3 + 12 >> 2]);
     break label$1;
    }
    HEAP32[HEAP32[$3 + 12 >> 2] + 16 >> 2] = HEAP32[HEAP32[$3 + 12 >> 2] + 12 >> 2];
   }
  }
  jsvStringIteratorCatchUp(HEAP32[$3 + 12 >> 2]);
 }
 global$0 = $3 + 16 | 0;
}
function jsvArrayPop($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = 0;
 HEAP32[$1 + 4 >> 2] = jsvGetArrayLength(HEAP32[$1 + 12 >> 2]);
 if (HEAP32[$1 + 4 >> 2] > 0) {
  HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + -1;
  if (jsvGetLastChild(HEAP32[$1 + 12 >> 2]) & 65535) {
   HEAP16[$1 + 2 >> 1] = jsvGetLastChild(HEAP32[$1 + 12 >> 2]);
   HEAP32[$1 + 8 >> 2] = jsvLock(HEAPU16[$1 + 2 >> 1]);
   while (1) {
    if (HEAP32[$1 + 8 >> 2]) {
     $0 = jsvIsInt(HEAP32[$1 + 8 >> 2]) ^ -1;
    } else {
     $0 = 0;
    }
    if ($0 & 1) {
     HEAP16[$1 + 2 >> 1] = jsvGetPrevSibling(HEAP32[$1 + 8 >> 2]);
     jsvUnLock(HEAP32[$1 + 8 >> 2]);
     label$7 : {
      if (HEAPU16[$1 + 2 >> 1]) {
       HEAP32[$1 + 8 >> 2] = jsvLock(HEAPU16[$1 + 2 >> 1]);
       break label$7;
      }
      HEAP32[$1 + 8 >> 2] = 0;
     }
     continue;
    }
    break;
   }
   if (HEAP32[$1 + 8 >> 2]) {
    label$10 : {
     if ((jsvGetInteger(HEAP32[$1 + 8 >> 2]) | 0) == HEAP32[$1 + 4 >> 2]) {
      jsvRemoveChild(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 8 >> 2]);
      break label$10;
     }
     jsvUnLock(HEAP32[$1 + 8 >> 2]);
     HEAP32[$1 + 8 >> 2] = 0;
    }
   }
  }
  jsvSetArrayLength(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 4 >> 2]);
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function jsvArrayInsertBefore($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 label$1 : {
  if (HEAP32[$3 + 24 >> 2]) {
   HEAP32[$3 + 16 >> 2] = jsvMakeIntoVariableName(jsvNewFromInteger(0), HEAP32[$3 + 20 >> 2]);
   if (!HEAP32[$3 + 16 >> 2]) {
    break label$1;
   }
   HEAP16[$3 + 14 >> 1] = jsvGetRef(jsvRef(HEAP32[$3 + 16 >> 2]));
   HEAP16[$3 + 12 >> 1] = jsvGetPrevSibling(HEAP32[$3 + 24 >> 2]);
   label$3 : {
    if (HEAPU16[$3 + 12 >> 1]) {
     HEAP32[$3 + 8 >> 2] = jsvRef(jsvLock(HEAPU16[$3 + 12 >> 1]));
     jsvSetInteger(HEAP32[$3 + 16 >> 2], jsvGetInteger(HEAP32[$3 + 8 >> 2]) + 1 | 0);
     jsvSetNextSibling(HEAP32[$3 + 8 >> 2], HEAPU16[$3 + 14 >> 1]);
     jsvUnLock(HEAP32[$3 + 8 >> 2]);
     jsvSetPrevSibling(HEAP32[$3 + 16 >> 2], HEAPU16[$3 + 12 >> 1]);
     break label$3;
    }
    jsvSetPrevSibling(HEAP32[$3 + 16 >> 2], 0);
    jsvSetFirstChild(HEAP32[$3 + 28 >> 2], HEAPU16[$3 + 14 >> 1]);
   }
   jsvSetPrevSibling(HEAP32[$3 + 24 >> 2], HEAPU16[$3 + 14 >> 1]);
   jsvSetNextSibling(HEAP32[$3 + 16 >> 2], jsvGetRef(jsvRef(HEAP32[$3 + 24 >> 2])) & 65535);
   jsvUnLock(HEAP32[$3 + 16 >> 2]);
   break label$1;
  }
  jsvArrayPush(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 20 >> 2]);
 }
 global$0 = $3 + 32 | 0;
}
function jswrap_string_trim($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 80 | 0;
 global$0 = $1;
 HEAP32[$1 + 72 >> 2] = $0;
 HEAP32[$1 + 68 >> 2] = jsvAsString(HEAP32[$1 + 72 >> 2]);
 label$1 : {
  if (!HEAP32[$1 + 68 >> 2]) {
   HEAP32[$1 + 76 >> 2] = HEAP32[$1 + 68 >> 2];
   break label$1;
  }
  HEAP32[$1 + 64 >> 2] = 0;
  HEAP32[$1 + 60 >> 2] = -1;
  jsvStringIteratorNew($1 + 24 | 0, HEAP32[$1 + 68 >> 2], 0);
  while (1) {
   if (jsvStringIteratorHasChar($1 + 24 | 0) & 1) {
    $0 = $1 + 24 | 0;
    HEAP32[$1 + 20 >> 2] = jsvStringIteratorGetIndex($0);
    HEAP8[$1 + 19 | 0] = isWhitespace(jsvStringIteratorGetCharAndNext($0) << 24 >> 24) & 1;
    if (!(HEAP8[$1 + 19 | 0] & 1)) {
     if (HEAP32[$1 + 60 >> 2] < 0) {
      HEAP32[$1 + 64 >> 2] = HEAP32[$1 + 20 >> 2];
     }
     HEAP32[$1 + 60 >> 2] = HEAP32[$1 + 20 >> 2];
    }
    continue;
   }
   break;
  }
  jsvStringIteratorFree($1 + 24 | 0);
  HEAP32[$1 + 12 >> 2] = 0;
  if (HEAP32[$1 + 60 >> 2] >= HEAP32[$1 + 64 >> 2]) {
   HEAP32[$1 + 12 >> 2] = (HEAP32[$1 + 60 >> 2] + 1 | 0) - HEAP32[$1 + 64 >> 2];
  }
  HEAP32[$1 + 8 >> 2] = jsvNewFromStringVar(HEAP32[$1 + 68 >> 2], HEAP32[$1 + 64 >> 2], HEAP32[$1 + 12 >> 2]);
  jsvUnLock(HEAP32[$1 + 68 >> 2]);
  HEAP32[$1 + 76 >> 2] = HEAP32[$1 + 8 >> 2];
 }
 global$0 = $1 + 80 | 0;
 return HEAP32[$1 + 76 >> 2];
}
function jswrap_flash_read($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 80 | 0;
 global$0 = $2;
 HEAP32[$2 + 72 >> 2] = $0;
 HEAP32[$2 + 68 >> 2] = $1;
 label$1 : {
  if (HEAP32[$2 + 72 >> 2] <= 0) {
   HEAP32[$2 + 76 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 64 >> 2] = jsvNewTypedArray(1, HEAP32[$2 + 72 >> 2]);
  if (!HEAP32[$2 + 64 >> 2]) {
   HEAP32[$2 + 76 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 56 >> 2] = jsvGetArrayBufferBackingString(HEAP32[$2 + 64 >> 2], $2 + 60 | 0);
  if (HEAP32[$2 + 56 >> 2]) {
   jsvStringIteratorNew($2 + 16 | 0, HEAP32[$2 + 56 >> 2], HEAP32[$2 + 60 >> 2]);
   while (1) {
    if (HEAP32[$2 + 72 >> 2] > 0) {
     $0 = jsvStringIteratorHasChar($2 + 16 | 0);
    } else {
     $0 = 0;
    }
    if ($0 & 1) {
     HEAP32[$2 + 8 >> 2] = 0;
     jsvStringIteratorGetPtrAndNext($2 + 16 | 0, $2 + 12 | 0, $2 + 8 | 0);
     jshFlashRead(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 68 >> 2], HEAP32[$2 + 8 >> 2]);
     HEAP32[$2 + 68 >> 2] = HEAP32[$2 + 8 >> 2] + HEAP32[$2 + 68 >> 2];
     HEAP32[$2 + 72 >> 2] = HEAP32[$2 + 72 >> 2] - HEAP32[$2 + 8 >> 2];
     continue;
    }
    break;
   }
   jsvStringIteratorFree($2 + 16 | 0);
   jsvUnLock(HEAP32[$2 + 56 >> 2]);
  }
  HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 64 >> 2];
 }
 global$0 = $2 + 80 | 0;
 return HEAP32[$2 + 76 >> 2];
}
function jswrap_io_getPinMode($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 11 | 0] = $0;
 label$1 : {
  if (!(jshIsPinValid(HEAPU8[$1 + 11 | 0]) & 1)) {
   jsExceptionHere(1, 121944, 0);
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP8[$1 + 10 | 0] = jshPinGetState(HEAPU8[$1 + 11 | 0]) & 15;
  HEAP32[$1 + 4 >> 2] = 0;
  $0 = HEAPU8[$1 + 10 | 0] + -1 | 0;
  label$3 : {
   if ($0 >>> 0 > 8) {
    break label$3;
   }
   label$4 : {
    switch ($0 - 1 | 0) {
    case 5:
     HEAP32[$1 + 4 >> 2] = 121956;
     break label$3;
    case 2:
     HEAP32[$1 + 4 >> 2] = 121963;
     break label$3;
    case 3:
     HEAP32[$1 + 4 >> 2] = 121969;
     break label$3;
    case 4:
     HEAP32[$1 + 4 >> 2] = 121982;
     break label$3;
    default:
     HEAP32[$1 + 4 >> 2] = 121997;
     break label$3;
    case 0:
     HEAP32[$1 + 4 >> 2] = 122004;
     break label$3;
    case 1:
     HEAP32[$1 + 4 >> 2] = 122014;
     break label$3;
    case 6:
     HEAP32[$1 + 4 >> 2] = 122031;
     break label$3;
    case 7:
     break label$4;
    }
   }
   HEAP32[$1 + 4 >> 2] = 122041;
  }
  if (HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 + 12 >> 2] = jsvNewFromString(HEAP32[$1 + 4 >> 2]);
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jspeFactorDelete() {
 var $0 = 0, $1 = 0;
 $0 = global$0 - 32 | 0;
 global$0 = $0;
 $1 = $0 + 28 | 0;
 jslGetNextToken();
 HEAP32[$0 + 28 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = jspeFactorMember(jspeFactor(), $1);
 HEAP32[$0 + 20 >> 2] = 0;
 if ((HEAP32[80549] & 63) == 1) {
  HEAP8[$0 + 19 | 0] = 0;
  label$2 : {
   if (!(jsvIsName(HEAP32[$0 + 24 >> 2]) & 1)) {
    break label$2;
   }
   if (jsvIsNewChild(HEAP32[$0 + 24 >> 2]) & 1) {
    break label$2;
   }
   label$3 : {
    if (HEAP32[$0 + 28 >> 2]) {
     break label$3;
    }
    if (!(jsvIsChild(HEAP32[80545], HEAP32[$0 + 24 >> 2]) & 1)) {
     break label$3;
    }
    HEAP32[$0 + 28 >> 2] = jsvLockAgain(HEAP32[80545]);
   }
   if (jsvHasChildren(HEAP32[$0 + 28 >> 2]) & 1) {
    label$5 : {
     if (jsvIsArray(HEAP32[$0 + 28 >> 2]) & 1) {
      HEAP32[$0 + 12 >> 2] = jsvGetArrayLength(HEAP32[$0 + 28 >> 2]);
      jsvRemoveChild(HEAP32[$0 + 28 >> 2], HEAP32[$0 + 24 >> 2]);
      jsvSetArrayLength(HEAP32[$0 + 28 >> 2], HEAP32[$0 + 12 >> 2]);
      break label$5;
     }
     jsvRemoveChild(HEAP32[$0 + 28 >> 2], HEAP32[$0 + 24 >> 2]);
    }
    HEAP8[$0 + 19 | 0] = 1;
   }
  }
  HEAP32[$0 + 20 >> 2] = jsvNewFromBool(HEAP8[$0 + 19 | 0] & 1);
 }
 jsvUnLock2(HEAP32[$0 + 24 >> 2], HEAP32[$0 + 28 >> 2]);
 global$0 = $0 + 32 | 0;
 return HEAP32[$0 + 20 >> 2];
}
function jswrap_array_sort($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 80 | 0;
 global$0 = $2;
 HEAP32[$2 + 72 >> 2] = $0;
 HEAP32[$2 + 68 >> 2] = $1;
 label$1 : {
  label$2 : {
   if (jsvIsUndefined(HEAP32[$2 + 68 >> 2]) & 1) {
    break label$2;
   }
   if (jsvIsFunction(HEAP32[$2 + 68 >> 2]) & 1) {
    break label$2;
   }
   HEAP32[$2 >> 2] = HEAP32[$2 + 68 >> 2];
   jsExceptionHere(1, 119028, $2);
   HEAP32[$2 + 76 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 4 >> 2] = 0;
  label$3 : {
   label$4 : {
    if (!(jsvIsArray(HEAP32[$2 + 72 >> 2]) & 1)) {
     if (!(jsvIsObject(HEAP32[$2 + 72 >> 2]) & 1)) {
      break label$4;
     }
    }
    jsvIteratorNew($2 + 8 | 0, HEAP32[$2 + 72 >> 2], 1);
    while (1) {
     if (jsvIteratorHasElement($2 + 8 | 0) & 1) {
      HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + 1;
      jsvIteratorNext($2 + 8 | 0);
      continue;
     }
     break;
    }
    jsvIteratorFree($2 + 8 | 0);
    break label$3;
   }
   HEAP32[$2 + 4 >> 2] = jsvGetLength(HEAP32[$2 + 72 >> 2]);
  }
  $0 = $2 + 8 | 0;
  jsvIteratorNew($0, HEAP32[$2 + 72 >> 2], 1);
  _jswrap_array_sort($0, HEAP32[$2 + 4 >> 2], HEAP32[$2 + 68 >> 2]);
  jsvIteratorFree($0);
  HEAP32[$2 + 76 >> 2] = jsvLockAgain(HEAP32[$2 + 72 >> 2]);
 }
 global$0 = $2 + 80 | 0;
 return HEAP32[$2 + 76 >> 2];
}
function jsvMathsOpTypeEqual($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP8[$2 + 7 | 0] = (!HEAP32[$2 + 12 >> 2] | 0) == (!HEAP32[$2 + 8 >> 2] | 0);
 if (!(!HEAP32[$2 + 12 >> 2] | !HEAP32[$2 + 8 >> 2])) {
  $3 = $2;
  label$2 : {
   label$3 : {
    if (!(jsvIsInt(HEAP32[$2 + 12 >> 2]) & 1)) {
     if (!(jsvIsFloat(HEAP32[$2 + 12 >> 2]) & 1)) {
      break label$3;
     }
    }
    $0 = jsvIsInt(HEAP32[$2 + 8 >> 2]) & 1;
    $1 = 1;
    if ($0) {
     break label$2;
    }
    $0 = jsvIsFloat(HEAP32[$2 + 8 >> 2]) & 1;
    $1 = 1;
    if ($0) {
     break label$2;
    }
   }
   if (jsvIsString(HEAP32[$2 + 12 >> 2]) & 1) {
    $0 = jsvIsString(HEAP32[$2 + 8 >> 2]) & 1;
    $1 = 1;
    if ($0) {
     break label$2;
    }
   }
   $1 = HEAP32[$2 + 12 >> 2];
   $0 = (HEAPU8[$1 + 13 | 0] | HEAPU8[$1 + 14 | 0] << 8) & 63;
   $1 = HEAP32[$2 + 8 >> 2];
   $1 = ($0 | 0) == ((HEAPU8[$1 + 13 | 0] | HEAPU8[$1 + 14 | 0] << 8) & 63);
  }
  HEAP8[$3 + 7 | 0] = $1;
 }
 if (HEAP8[$2 + 7 | 0] & 1) {
  HEAP32[$2 >> 2] = jsvMathsOp(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 138);
  if (!(jsvGetBool(HEAP32[$2 >> 2]) & 1)) {
   HEAP8[$2 + 7 | 0] = 0;
  }
  jsvUnLock(HEAP32[$2 >> 2]);
 }
 global$0 = $2 + 16 | 0;
 return HEAP8[$2 + 7 | 0] & 1;
}
function jsvGetIndexFromLineAndCol($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 80 | 0;
 global$0 = $3;
 HEAP32[$3 + 72 >> 2] = $0;
 HEAP32[$3 + 68 >> 2] = $1;
 HEAP32[$3 + 64 >> 2] = $2;
 HEAP32[$3 + 60 >> 2] = 1;
 HEAP32[$3 + 56 >> 2] = 1;
 HEAP32[$3 + 52 >> 2] = 0;
 jsvStringIteratorNew($3 + 16 | 0, HEAP32[$3 + 72 >> 2], 0);
 label$1 : {
  while (1) {
   if (jsvStringIteratorHasChar($3 + 16 | 0) & 1) {
    HEAP8[$3 + 15 | 0] = jsvStringIteratorGetCharAndNext($3 + 16 | 0);
    if (!(HEAPU32[$3 + 56 >> 2] <= HEAPU32[$3 + 68 >> 2] ? !(HEAPU32[$3 + 60 >> 2] >= HEAPU32[$3 + 64 >> 2] ? HEAP32[$3 + 56 >> 2] == HEAP32[$3 + 68 >> 2] : 0) : 0)) {
     jsvStringIteratorFree($3 + 16 | 0);
     $0 = $3;
     if (HEAPU32[$3 + 56 >> 2] > HEAPU32[$3 + 68 >> 2]) {
      $1 = HEAP32[$3 + 52 >> 2] - 1 | 0;
     } else {
      $1 = HEAP32[$3 + 52 >> 2];
     }
     HEAP32[$0 + 76 >> 2] = $1;
     break label$1;
    }
    HEAP32[$3 + 60 >> 2] = HEAP32[$3 + 60 >> 2] + 1;
    if (HEAP8[$3 + 15 | 0] == 10) {
     HEAP32[$3 + 60 >> 2] = 1;
     HEAP32[$3 + 56 >> 2] = HEAP32[$3 + 56 >> 2] + 1;
    }
    HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 52 >> 2] + 1;
    continue;
   }
   break;
  }
  jsvStringIteratorFree($3 + 16 | 0);
  HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 52 >> 2];
 }
 global$0 = $3 + 80 | 0;
 return HEAP32[$3 + 76 >> 2];
}
function graphicsVectorCharWidth($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 + -64 | 0;
 global$0 = $3;
 HEAP32[$3 + 56 >> 2] = $0;
 HEAP32[$3 + 52 >> 2] = $1;
 HEAP8[$3 + 51 | 0] = $2;
 HEAP32[$3 + 40 >> 2] = vfGetCharPtr(HEAP8[$3 + 51 | 0], $3 + 44 | 0);
 label$1 : {
  if (!HEAP32[$3 + 40 >> 2]) {
   HEAP32[$3 + 60 >> 2] = HEAP32[$3 + 52 >> 2] >>> 1;
   break label$1;
  }
  HEAP32[$3 + 36 >> 2] = 0;
  HEAP32[$3 + 32 >> 2] = 0;
  while (1) {
   if (HEAP32[$3 + 32 >> 2] < HEAP32[$3 + 44 >> 2]) {
    HEAP32[$3 + 24 >> 2] = vfGetPolyPtr(HEAPU8[HEAP32[$3 + 40 >> 2] + HEAP32[$3 + 32 >> 2] | 0], $3 + 28 | 0);
    HEAP32[$3 + 20 >> 2] = 0;
    while (1) {
     if (HEAP32[$3 + 20 >> 2] < HEAP32[$3 + 28 >> 2]) {
      HEAP8[$3 + 19 | 0] = HEAPU8[HEAP32[$3 + 24 >> 2] + HEAP32[$3 + 20 >> 2] | 0];
      HEAP32[$3 + 12 >> 2] = HEAPU8[$3 + 19 | 0] % 13;
      if (HEAP32[$3 + 12 >> 2] > HEAP32[$3 + 36 >> 2]) {
       HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 12 >> 2];
      }
      HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] + 1;
      continue;
     }
     break;
    }
    HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 32 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$3 + 60 >> 2] = (Math_imul(HEAP32[$3 + 52 >> 2], HEAP32[$3 + 36 >> 2] + 2 | 0) << 4 >>> 4) + 7 >>> 4;
 }
 global$0 = $3 - -64 | 0;
 return HEAP32[$3 + 60 >> 2];
}
function tflite__ReverseSortInPlace_28int__2c_20int__2c_20int_29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 while (1) {
  HEAP8[$3 + 19 | 0] = 0;
  HEAP32[$3 + 12 >> 2] = 1;
  while (1) {
   if (HEAP32[$3 + 12 >> 2] < HEAP32[$3 + 20 >> 2]) {
    if (HEAP32[HEAP32[$3 + 28 >> 2] + (HEAP32[$3 + 12 >> 2] - 1 << 2) >> 2] < HEAP32[HEAP32[$3 + 28 >> 2] + (HEAP32[$3 + 12 >> 2] << 2) >> 2]) {
     HEAP32[$3 + 8 >> 2] = HEAP32[HEAP32[$3 + 28 >> 2] + (HEAP32[$3 + 12 >> 2] - 1 << 2) >> 2];
     HEAP32[HEAP32[$3 + 28 >> 2] + (HEAP32[$3 + 12 >> 2] - 1 << 2) >> 2] = HEAP32[HEAP32[$3 + 28 >> 2] + (HEAP32[$3 + 12 >> 2] << 2) >> 2];
     HEAP32[HEAP32[$3 + 28 >> 2] + (HEAP32[$3 + 12 >> 2] << 2) >> 2] = HEAP32[$3 + 8 >> 2];
     HEAP32[$3 + 4 >> 2] = HEAP32[HEAP32[$3 + 24 >> 2] + (HEAP32[$3 + 12 >> 2] - 1 << 2) >> 2];
     HEAP32[HEAP32[$3 + 24 >> 2] + (HEAP32[$3 + 12 >> 2] - 1 << 2) >> 2] = HEAP32[HEAP32[$3 + 24 >> 2] + (HEAP32[$3 + 12 >> 2] << 2) >> 2];
     HEAP32[HEAP32[$3 + 24 >> 2] + (HEAP32[$3 + 12 >> 2] << 2) >> 2] = HEAP32[$3 + 4 >> 2];
     HEAP8[$3 + 19 | 0] = 1;
    }
    HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + 1;
    continue;
   }
   break;
  }
  if (HEAP8[$3 + 19 | 0] & 1) {
   continue;
  }
  break;
 }
}
function int_20gemmlowp__RoundingDivideByPOT_int__28int_2c_20int_29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 $0 = HEAP32[$2 + 24 >> 2];
 HEAP32[$2 + 20 >> 2] = tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29((32 <= ($0 & 63) >>> 0 ? 0 : 1 << ($0 & 31)) - 1 | 0);
 HEAP32[$2 + 16 >> 2] = tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(0);
 HEAP32[$2 + 12 >> 2] = tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(1);
 HEAP32[$2 + 8 >> 2] = int_20gemmlowp__BitAnd_int__28int_2c_20int_29(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 20 >> 2]);
 HEAP32[$2 + 4 >> 2] = int_20gemmlowp__Add_int__28int_2c_20int_29(int_20gemmlowp__ShiftRight_int__28int_2c_20int_29(HEAP32[$2 + 20 >> 2], 1), int_20gemmlowp__BitAnd_int__28int_2c_20int_29(int_20gemmlowp__MaskIfLessThan_int__28int_2c_20int_29(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 16 >> 2]), HEAP32[$2 + 12 >> 2]));
 $0 = int_20gemmlowp__Add_int__28int_2c_20int_29(int_20gemmlowp__ShiftRight_int__28int_2c_20int_29(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2]), int_20gemmlowp__BitAnd_int__28int_2c_20int_29(int_20gemmlowp__MaskIfGreaterThan_int__28int_2c_20int_29(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]), HEAP32[$2 + 12 >> 2]));
 global$0 = $2 + 32 | 0;
 return $0;
}
function jswrap_stream_read($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1 : {
  if (!(jsvIsObject(HEAP32[$2 + 24 >> 2]) & 1)) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 16 >> 2] = jsvObjectGetChild(HEAP32[$2 + 24 >> 2], 125935, 0);
  HEAP32[$2 + 12 >> 2] = 0;
  label$3 : {
   if (jsvIsString(HEAP32[$2 + 16 >> 2]) & 1) {
    HEAP32[$2 + 8 >> 2] = jsvGetStringLength(HEAP32[$2 + 16 >> 2]);
    label$5 : {
     if (!(HEAPU32[$2 + 20 >> 2] < HEAPU32[$2 + 8 >> 2] ? HEAP32[$2 + 20 >> 2] > 0 : 0)) {
      HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 16 >> 2];
      HEAP32[$2 + 16 >> 2] = 0;
      jsvObjectRemoveChild(HEAP32[$2 + 24 >> 2], 125935);
      break label$5;
     }
     HEAP32[$2 + 12 >> 2] = jsvNewFromStringVar(HEAP32[$2 + 16 >> 2], 0, HEAP32[$2 + 20 >> 2]);
     HEAP32[$2 + 4 >> 2] = jsvNewFromStringVar(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 20 >> 2], 2147483647);
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 125935, HEAP32[$2 + 4 >> 2]);
    }
    break label$3;
   }
   HEAP32[$2 + 12 >> 2] = jsvNewWithFlags(27);
  }
  jsvUnLock(HEAP32[$2 + 16 >> 2]);
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function jstUtilTimerSetupBuffer($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 $0 = _jsvGetAddressOf(HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
 $2 = HEAP32[$1 + 12 >> 2];
 HEAP8[$2 + 8 | 0] = $0;
 HEAP8[$2 + 9 | 0] = $0 >>> 8;
 HEAP8[$2 + 10 | 0] = $0 >>> 16;
 HEAP8[$2 + 11 | 0] = $0 >>> 24;
 $0 = HEAP32[$1 + 12 >> 2];
 label$1 : {
  if (jsvIsFlatString(HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 1) {
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP8[$0 + 18 | 0] = 15;
   HEAP8[$0 + 19 | 0] = 0;
   $0 = HEAP32[$1 + 12 >> 2];
   $0 = jsvGetCharactersInVar(HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24));
   $2 = HEAP32[$1 + 12 >> 2];
   $0 = $0 + 15 | 0;
   HEAP8[$2 + 20 | 0] = $0;
   HEAP8[$2 + 21 | 0] = $0 >>> 8;
   break label$1;
  }
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP8[$0 + 18 | 0] = 0;
  HEAP8[$0 + 19 | 0] = 0;
  $0 = HEAP32[$1 + 12 >> 2];
  $0 = jsvGetCharactersInVar(HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24));
  $2 = HEAP32[$1 + 12 >> 2];
  HEAP8[$2 + 20 | 0] = $0;
  HEAP8[$2 + 21 | 0] = $0 >>> 8;
 }
 global$0 = $1 + 16 | 0;
}
function jsspiSend8bit($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 global$0 = $4;
 HEAP8[$4 + 15 | 0] = $0;
 HEAP8[$4 + 14 | 0] = $1;
 HEAP32[$4 + 8 >> 2] = $2;
 HEAP32[$4 + 4 >> 2] = $3;
 $1 = HEAPU8[$4 + 15 | 0];
 if (HEAPU8[$4 + 14 | 0] >> 6 & 1) {
  $0 = HEAP32[$4 + 4 >> 2];
 } else {
  $0 = HEAP32[$4 + 8 >> 2];
 }
 if (HEAPU8[$4 + 14 | 0] >> 7) {
  $2 = HEAP32[$4 + 4 >> 2];
 } else {
  $2 = HEAP32[$4 + 8 >> 2];
 }
 jshSPISend($1, $0 | $2 << 8);
 $1 = HEAPU8[$4 + 15 | 0];
 if (HEAPU8[$4 + 14 | 0] >> 4 & 1) {
  $0 = HEAP32[$4 + 4 >> 2];
 } else {
  $0 = HEAP32[$4 + 8 >> 2];
 }
 if (HEAPU8[$4 + 14 | 0] >> 5 & 1) {
  $2 = HEAP32[$4 + 4 >> 2];
 } else {
  $2 = HEAP32[$4 + 8 >> 2];
 }
 jshSPISend($1, $0 | $2 << 8);
 $1 = HEAPU8[$4 + 15 | 0];
 if (HEAPU8[$4 + 14 | 0] >> 2 & 1) {
  $0 = HEAP32[$4 + 4 >> 2];
 } else {
  $0 = HEAP32[$4 + 8 >> 2];
 }
 if (HEAPU8[$4 + 14 | 0] >> 3 & 1) {
  $2 = HEAP32[$4 + 4 >> 2];
 } else {
  $2 = HEAP32[$4 + 8 >> 2];
 }
 jshSPISend($1, $0 | $2 << 8);
 $1 = HEAPU8[$4 + 15 | 0];
 if (HEAP8[$4 + 14 | 0] & 1) {
  $0 = HEAP32[$4 + 4 >> 2];
 } else {
  $0 = HEAP32[$4 + 8 >> 2];
 }
 if (HEAPU8[$4 + 14 | 0] >> 1 & 1) {
  $2 = HEAP32[$4 + 4 >> 2];
 } else {
  $2 = HEAP32[$4 + 8 >> 2];
 }
 jshSPISend($1, $0 | $2 << 8);
 global$0 = $4 + 16 | 0;
}
function tflite__MicroAllocator__AllocatePersistentTfLiteTensor_28tflite__Model_20const__2c_20TfLiteEvalTensor__2c_20int_29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 global$0 = $4;
 HEAP32[$4 + 24 >> 2] = $0;
 HEAP32[$4 + 20 >> 2] = $1;
 HEAP32[$4 + 16 >> 2] = $2;
 HEAP32[$4 + 12 >> 2] = $3;
 $0 = HEAP32[$4 + 24 >> 2];
 HEAP32[$4 + 8 >> 2] = tflite__MicroAllocator__GetSubGraphFromModel_28tflite__Model_20const__29($0, HEAP32[$4 + 20 >> 2]);
 label$1 : {
  if (!HEAP32[$4 + 8 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$4 + 4 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 36 >> 2]]($0, HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2], HEAP32[$4 + 12 >> 2]);
 label$2 : {
  if (FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 40 >> 2]]($0, HEAP32[$4 + 20 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 + 12 >> 2], 0)) {
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$0 + 8 >> 2], 132390, 0);
   HEAP32[$4 + 28 >> 2] = 0;
   break label$2;
  }
  if (HEAP32[$4 + 16 >> 2]) {
   HEAP32[HEAP32[$4 + 4 >> 2] + 16 >> 2] = HEAP32[HEAP32[$4 + 16 >> 2] + Math_imul(HEAP32[$4 + 12 >> 2], 12) >> 2];
  }
  HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 4 >> 2];
 }
 global$0 = $4 + 32 | 0;
 return HEAP32[$4 + 28 >> 2];
}
function jswrap_function_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP32[$1 + 20 >> 2] = jsvNewWithFlags(7);
 label$1 : {
  if (!HEAP32[$1 + 20 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  $0 = $1 + 16 | 0;
  jsvObjectIteratorNew($0, HEAP32[$1 + 24 >> 2]);
  HEAP32[$1 + 12 >> 2] = jsvObjectIteratorGetValue($0);
  jsvObjectIteratorNext($0);
  while (1) {
   if (jsvObjectIteratorHasValue($1 + 16 | 0) & 1) {
    HEAP32[$1 + 8 >> 2] = jsvAsString(HEAP32[$1 + 12 >> 2]);
    if (HEAP32[$1 + 8 >> 2]) {
     HEAP32[$1 + 4 >> 2] = jsvNewFromString(121265);
     if (HEAP32[$1 + 4 >> 2]) {
      jsvAppendStringVarComplete(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 8 >> 2]);
      jsvAddFunctionParameter(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 4 >> 2], 0);
     }
     jsvUnLock(HEAP32[$1 + 8 >> 2]);
    }
    $0 = $1 + 16 | 0;
    jsvUnLock(HEAP32[$1 + 12 >> 2]);
    HEAP32[$1 + 12 >> 2] = jsvObjectIteratorGetValue($0);
    jsvObjectIteratorNext($0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree($1 + 16 | 0);
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 20 >> 2], 121267, HEAP32[$1 + 12 >> 2]);
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function jswrap_dataview_get($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 96 | 0;
 global$0 = $4;
 HEAP32[$4 + 88 >> 2] = $0;
 HEAP16[$4 + 86 >> 1] = $1;
 HEAP32[$4 + 80 >> 2] = $2;
 HEAP8[$4 + 79 | 0] = $3;
 HEAP32[$4 + 72 >> 2] = jsvObjectGetChild(HEAP32[$4 + 88 >> 2], 119561, 0);
 label$1 : {
  if (!(jsvIsArrayBuffer(HEAP32[$4 + 72 >> 2]) & 1)) {
   jsvUnLock(HEAP32[$4 + 72 >> 2]);
   HEAP32[$4 + 92 >> 2] = 0;
   break label$1;
  }
  HEAP32[$4 + 80 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$4 + 88 >> 2], 119568, 0)) + HEAP32[$4 + 80 >> 2];
  HEAP32[$4 + 68 >> 2] = HEAPU16[$4 + 86 >> 1] & 15;
  if (!(HEAP8[$4 + 79 | 0] & 1)) {
   HEAP16[$4 + 86 >> 1] = HEAPU16[$4 + 86 >> 1] | 256;
  }
  HEAP32[$4 + 64 >> 2] = jswrap_typedarray_constructor(HEAPU16[$4 + 86 >> 1], HEAP32[$4 + 72 >> 2], HEAP32[$4 + 80 >> 2], HEAP32[$4 + 68 >> 2]);
  jsvUnLock(HEAP32[$4 + 72 >> 2]);
  if (!HEAP32[$4 + 64 >> 2]) {
   HEAP32[$4 + 92 >> 2] = 0;
   break label$1;
  }
  $0 = $4 + 8 | 0;
  jsvArrayBufferIteratorNew($0, HEAP32[$4 + 64 >> 2], 0);
  HEAP32[$4 + 4 >> 2] = jsvArrayBufferIteratorGetValue($0);
  jsvArrayBufferIteratorFree($0);
  jsvUnLock(HEAP32[$4 + 64 >> 2]);
  HEAP32[$4 + 92 >> 2] = HEAP32[$4 + 4 >> 2];
 }
 global$0 = $4 + 96 | 0;
 return HEAP32[$4 + 92 >> 2];
}
function tflite__reference_ops__DepthwiseConv_28tflite__DepthwiseParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0;
 $9 = global$0 - 48 | 0;
 global$0 = $9;
 HEAP32[$9 + 44 >> 2] = $0;
 HEAP32[$9 + 40 >> 2] = $1;
 HEAP32[$9 + 36 >> 2] = $2;
 HEAP32[$9 + 32 >> 2] = $3;
 HEAP32[$9 + 28 >> 2] = $4;
 HEAP32[$9 + 24 >> 2] = $5;
 HEAP32[$9 + 20 >> 2] = $6;
 HEAP32[$9 + 16 >> 2] = $7;
 HEAP32[$9 + 12 >> 2] = $8;
 tflite__reference_ops__depthwise_conv__DepthwiseConvBasicKernel__28tflite__DepthwiseConvOutputRounding_291___Run_28tflite__DepthwiseParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29(HEAP32[$9 + 44 >> 2], HEAP32[$9 + 40 >> 2], HEAP32[$9 + 36 >> 2], HEAP32[$9 + 32 >> 2], HEAP32[$9 + 28 >> 2], HEAP32[$9 + 24 >> 2], HEAP32[$9 + 20 >> 2], HEAP32[$9 + 16 >> 2], HEAP32[$9 + 12 >> 2]);
 global$0 = $9 + 48 | 0;
}
function jshGetPinFromString($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!(!HEAP8[HEAP32[$1 + 8 >> 2] + 1 | 0] | (HEAP8[HEAP32[$1 + 8 >> 2]] != 86 ? !(HEAP8[HEAP32[$1 + 8 >> 2]] <= 73 ? HEAP8[HEAP32[$1 + 8 >> 2]] >= 65 : 0) : 0))) {
   $0 = $1;
   if (HEAP8[HEAP32[$1 + 8 >> 2]] == 86) {
    $2 = 10;
   } else {
    $2 = HEAP8[HEAP32[$1 + 8 >> 2]] + -64 | 0;
   }
   HEAP32[$0 + 4 >> 2] = $2;
   HEAP32[$1 >> 2] = -1;
   if (!(HEAP8[HEAP32[$1 + 8 >> 2] + 1 | 0] < 48 | HEAP8[HEAP32[$1 + 8 >> 2] + 1 | 0] > 57)) {
    label$7 : {
     if (!HEAPU8[HEAP32[$1 + 8 >> 2] + 2 | 0]) {
      HEAP32[$1 >> 2] = HEAP8[HEAP32[$1 + 8 >> 2] + 1 | 0] - 48;
      break label$7;
     }
     if (!(HEAP8[HEAP32[$1 + 8 >> 2] + 2 | 0] < 48 | HEAP8[HEAP32[$1 + 8 >> 2] + 2 | 0] > 57)) {
      if (!HEAPU8[HEAP32[$1 + 8 >> 2] + 3 | 0]) {
       HEAP32[$1 >> 2] = (HEAP8[HEAP32[$1 + 8 >> 2] + 2 | 0] + Math_imul(HEAP8[HEAP32[$1 + 8 >> 2] + 1 | 0], 10) | 0) + -528;
      }
     }
    }
   }
   if (HEAP32[$1 >> 2] >= 0) {
    if (HEAP32[$1 + 4 >> 2] == 4) {
     if (HEAP32[$1 >> 2] < 48) {
      HEAP8[$1 + 15 | 0] = HEAP32[$1 >> 2];
      break label$1;
     }
    }
   }
  }
  HEAP8[$1 + 15 | 0] = 255;
 }
 return HEAPU8[$1 + 15 | 0];
}
function jsfGetFreeSpace() {
 var $0 = 0, $1 = 0;
 $0 = global$0 + -64 | 0;
 global$0 = $0;
 HEAP32[$0 + 56 >> 2] = 0;
 HEAP8[$0 + 55 | 0] = 1;
 if (!HEAP32[$0 + 56 >> 2]) {
  HEAP32[$0 + 56 >> 2] = 134217728;
 }
 HEAP32[$0 + 48 >> 2] = jsfGetBankEndAddress(HEAP32[$0 + 56 >> 2]);
 label$2 : {
  if (!(HEAP8[$0 + 55 | 0] & 1)) {
   if (!(jshFlashGetPage(HEAP32[$0 + 56 >> 2], $0 + 44 | 0, $0 + 40 | 0) & 1)) {
    HEAP32[$0 + 60 >> 2] = 0;
    break label$2;
   }
   HEAP32[$0 + 48 >> 2] = HEAP32[$0 + 44 >> 2] + HEAP32[$0 + 40 >> 2];
  }
  $1 = $0 + 8 | 0;
  HEAP32[$1 >> 2] = 0;
  HEAP32[$1 + 4 >> 2] = 0;
  HEAP32[$1 + 24 >> 2] = 0;
  HEAP32[$1 + 28 >> 2] = 0;
  HEAP32[$1 + 16 >> 2] = 0;
  HEAP32[$1 + 20 >> 2] = 0;
  HEAP32[$1 + 8 >> 2] = 0;
  HEAP32[$1 + 12 >> 2] = 0;
  HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 56 >> 2];
  if (jsfGetFileHeader(HEAP32[$0 + 56 >> 2], $1, 0) & 1) {
   while (1) {
    HEAP32[$0 + 4 >> 2] = jsfAlignAddress((HEAP32[$0 + 56 >> 2] + 32 | 0) + jsfGetFileSize($0 + 8 | 0) | 0);
    if (jsfGetNextFileHeader($0 + 56 | 0, $0 + 8 | 0, (HEAP8[$0 + 55 | 0] & 1 ? 1 : 0) | 2) & 1) {
     continue;
    }
    break;
   }
  }
  HEAP32[$0 + 60 >> 2] = HEAP32[$0 + 48 >> 2] - HEAP32[$0 + 4 >> 2];
 }
 global$0 = $0 - -64 | 0;
 return HEAP32[$0 + 60 >> 2];
}
function jswGetBasicObjectPrototypeName($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!strcmp(HEAP32[$1 + 8 >> 2], 93731)) {
   HEAP32[$1 + 12 >> 2] = 93715;
   break label$1;
  }
  if (!strcmp(HEAP32[$1 + 8 >> 2], 93742)) {
   HEAP32[$1 + 12 >> 2] = 93715;
   break label$1;
  }
  if (!strcmp(HEAP32[$1 + 8 >> 2], 93760)) {
   HEAP32[$1 + 12 >> 2] = 93715;
   break label$1;
  }
  if (!strcmp(HEAP32[$1 + 8 >> 2], 93770)) {
   HEAP32[$1 + 12 >> 2] = 93715;
   break label$1;
  }
  if (!strcmp(HEAP32[$1 + 8 >> 2], 93782)) {
   HEAP32[$1 + 12 >> 2] = 93715;
   break label$1;
  }
  if (!strcmp(HEAP32[$1 + 8 >> 2], 93793)) {
   HEAP32[$1 + 12 >> 2] = 93715;
   break label$1;
  }
  if (!strcmp(HEAP32[$1 + 8 >> 2], 93805)) {
   HEAP32[$1 + 12 >> 2] = 93715;
   break label$1;
  }
  if (!strcmp(HEAP32[$1 + 8 >> 2], 93817)) {
   HEAP32[$1 + 12 >> 2] = 93715;
   break label$1;
  }
  if (!strcmp(HEAP32[$1 + 8 >> 2], 93828)) {
   HEAP32[$1 + 12 >> 2] = 93715;
   break label$1;
  }
  if (!strcmp(HEAP32[$1 + 8 >> 2], 93841)) {
   HEAP32[$1 + 12 >> 2] = 93715;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = strcmp(HEAP32[$1 + 8 >> 2], 93966) ? 93966 : 0;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jsiSetConsoleDevice($0, $1) {
 var $2 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP8[$2 + 47 | 0] = $0;
 HEAP8[$2 + 46 | 0] = $1;
 label$1 : {
  if (HEAP8[$2 + 46 | 0] & 1) {
   HEAP16[161112] = HEAPU16[161112] | 256;
   break label$1;
  }
  HEAP16[161112] = HEAPU16[161112] & -257;
 }
 label$3 : {
  if (HEAPU8[$2 + 47 | 0] == HEAPU8[141672]) {
   break label$3;
  }
  label$4 : {
   if (HEAPU8[$2 + 47 | 0] < 22 | HEAPU8[$2 + 47 | 0] > 22) {
    break label$4;
   }
   if (jshIsDeviceInitialised(HEAPU8[$2 + 47 | 0]) & 1) {
    break label$4;
   }
   $0 = $2 + 32 | 0;
   jshUSARTInitInfo($0);
   jshUSARTSetup(HEAPU8[$2 + 47 | 0], $0);
  }
  HEAP8[$2 + 31 | 0] = jsiEcho() & 1;
  if (HEAPU8[141672] == 19) {
   HEAP8[$2 + 31 | 0] = 0;
   jshTransmitMove(HEAPU8[$2 + 47 | 0]);
   jshUSARTUnSetup(HEAPU8[$2 + 47 | 0]);
  }
  if (HEAP8[$2 + 31 | 0] & 1) {
   jsiConsoleRemoveInputLine();
   HEAP32[$2 + 16 >> 2] = jshGetDeviceString(HEAPU8[$2 + 47 | 0]);
   jsiConsolePrintf(81025, $2 + 16 | 0);
  }
  HEAP8[$2 + 30 | 0] = HEAPU8[141672];
  HEAP8[141672] = HEAPU8[$2 + 47 | 0];
  if (!(HEAP8[$2 + 31 | 0] & 1)) {
   break label$3;
  }
  HEAP32[$2 >> 2] = jshGetDeviceString(HEAPU8[$2 + 30 | 0]);
  jsiConsolePrintf(81032, $2);
 }
 global$0 = $2 + 48 | 0;
}
function jsiCountBracketsInInput() {
 var $0 = 0, $1 = 0;
 $0 = global$0 - 144 | 0;
 global$0 = $0;
 HEAP32[$0 + 140 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = jslSetLex($0 + 16 | 0);
 jslInit(HEAP32[80557]);
 while (1) {
  label$2 : {
   $1 = 0;
   label$3 : {
    if (!HEAP16[$0 + 18 >> 1]) {
     break label$3;
    }
    $1 = 0;
    if (HEAP16[$0 + 18 >> 1] == 137) {
     break label$3;
    }
    $1 = 0;
    if (HEAP16[$0 + 18 >> 1] == 132) {
     break label$3;
    }
    $1 = HEAP16[$0 + 18 >> 1] != 134;
   }
   if (!$1) {
    break label$2;
   }
   if (!(HEAP16[$0 + 18 >> 1] != 40 ? !(HEAP16[$0 + 18 >> 1] == 123 | HEAP16[$0 + 18 >> 1] == 91) : 0)) {
    HEAP32[$0 + 140 >> 2] = HEAP32[$0 + 140 >> 2] + 1;
   }
   if (!(HEAP16[$0 + 18 >> 1] != 41 ? !(HEAP16[$0 + 18 >> 1] == 125 | HEAP16[$0 + 18 >> 1] == 93) : 0)) {
    HEAP32[$0 + 140 >> 2] = HEAP32[$0 + 140 >> 2] + -1;
   }
   if (HEAP32[$0 + 140 >> 2] < 0) {
    break label$2;
   }
   jslGetNextToken();
   continue;
  }
  break;
 }
 if (HEAP16[$0 + 18 >> 1] == 132) {
  HEAP32[$0 + 140 >> 2] = 0;
 }
 if (!(HEAP16[$0 + 18 >> 1] != 134 ? HEAP16[$0 + 18 >> 1] != 137 : 0)) {
  HEAP32[$0 + 140 >> 2] = 1e3;
 }
 jslKill();
 jslSetLex(HEAP32[$0 + 12 >> 2]);
 global$0 = $0 + 144 | 0;
 return HEAP32[$0 + 140 >> 2];
}
function jspeConstruct($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP32[$3 + 40 >> 2] = $0;
 HEAP32[$3 + 36 >> 2] = $1;
 HEAP8[$3 + 35 | 0] = $2;
 label$1 : {
  if (!(jsvIsFunction(HEAP32[$3 + 40 >> 2]) & 1)) {
   HEAP32[$3 >> 2] = HEAP32[$3 + 40 >> 2];
   jsExceptionHere(1, 80070, $3);
   HEAP32[$3 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 28 >> 2] = jsvNewWithFlags(5);
  if (!HEAP32[$3 + 28 >> 2]) {
   HEAP32[$3 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 24 >> 2] = jsvFindChildFromString(HEAP32[$3 + 40 >> 2], 79516, 1);
  jspEnsureIsPrototype(HEAP32[$3 + 40 >> 2], HEAP32[$3 + 24 >> 2]);
  HEAP32[$3 + 20 >> 2] = jsvSkipName(HEAP32[$3 + 24 >> 2]);
  jsvUnLock3(jsvAddNamedChild(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 20 >> 2], 79526), HEAP32[$3 + 20 >> 2], HEAP32[$3 + 24 >> 2]);
  HEAP32[$3 + 16 >> 2] = jspeFunctionCall(HEAP32[$3 + 40 >> 2], HEAP32[$3 + 36 >> 2], HEAP32[$3 + 28 >> 2], HEAP8[$3 + 35 | 0] & 1, 0, 0);
  label$4 : {
   if (HEAP32[$3 + 16 >> 2]) {
    jsvUnLock(HEAP32[$3 + 28 >> 2]);
    HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 16 >> 2];
    break label$4;
   }
   jsvUnLock(HEAP32[$3 + 16 >> 2]);
  }
  HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 28 >> 2];
 }
 global$0 = $3 + 48 | 0;
 return HEAP32[$3 + 44 >> 2];
}
function jswrap_espruino_setConsole($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 112 | 0;
 global$0 = $2;
 HEAP32[$2 + 108 >> 2] = $0;
 HEAP32[$2 + 104 >> 2] = $1;
 HEAP8[$2 + 103 | 0] = 0;
 HEAP32[$2 + 88 >> 2] = 120428;
 HEAP16[$2 + 92 >> 1] = 11;
 HEAP32[$2 + 96 >> 2] = $2 + 103;
 label$1 : {
  if (!(jsvReadConfigObject(HEAP32[$2 + 104 >> 2], $2 + 88 | 0, 1) & 1)) {
   break label$1;
  }
  HEAP8[$2 + 87 | 0] = 0;
  label$2 : {
   if (jsvIsObject(HEAP32[$2 + 108 >> 2]) & 1) {
    HEAP8[$2 + 87 | 0] = jsiGetDeviceFromClass(HEAP32[$2 + 108 >> 2]);
    break label$2;
   }
   if (jsvIsString(HEAP32[$2 + 108 >> 2]) & 1) {
    $0 = $2 + 16 | 0;
    jsvGetString(HEAP32[$2 + 108 >> 2], $0, 64);
    HEAP8[$2 + 87 | 0] = jshFromDeviceString($0);
   }
  }
  label$5 : {
   if (HEAPU8[$2 + 87 | 0]) {
    break label$5;
   }
   if (jsvIsNull(HEAP32[$2 + 108 >> 2]) & 1) {
    break label$5;
   }
   HEAP32[$2 >> 2] = HEAPU8[$2 + 87 | 0];
   jsExceptionHere(1, 120434, $2);
   break label$1;
  }
  if (!(!HEAPU8[$2 + 87 | 0] | (HEAPU8[$2 + 87 | 0] <= 22 ? HEAPU8[$2 + 87 | 0] >= 17 : 0))) {
   jsExceptionHere(1, 120457, 0);
   break label$1;
  }
  jsiSetConsoleDevice(HEAPU8[$2 + 87 | 0], HEAP8[$2 + 103 | 0] & 1);
 }
 global$0 = $2 + 112 | 0;
}
function tflite__TfLiteTypeSizeOf_28TfLiteType_2c_20unsigned_20long__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1 : {
  label$2 : {
   label$3 : {
    $0 = HEAP32[$2 + 8 >> 2] + -1 | 0;
    if ($0 >>> 0 > 11) {
     break label$3;
    }
    label$4 : {
     switch ($0 - 1 | 0) {
     default:
      HEAP32[HEAP32[$2 + 4 >> 2] >> 2] = 4;
      break label$2;
     case 5:
      HEAP32[HEAP32[$2 + 4 >> 2] >> 2] = 2;
      break label$2;
     case 0:
      HEAP32[HEAP32[$2 + 4 >> 2] >> 2] = 4;
      break label$2;
     case 1:
      HEAP32[HEAP32[$2 + 4 >> 2] >> 2] = 1;
      break label$2;
     case 7:
      HEAP32[HEAP32[$2 + 4 >> 2] >> 2] = 1;
      break label$2;
     case 2:
      HEAP32[HEAP32[$2 + 4 >> 2] >> 2] = 8;
      break label$2;
     case 4:
      HEAP32[HEAP32[$2 + 4 >> 2] >> 2] = 1;
      break label$2;
     case 6:
      HEAP32[HEAP32[$2 + 4 >> 2] >> 2] = 8;
      break label$2;
     case 3:
     case 8:
     case 9:
      break label$3;
     case 10:
      break label$4;
     }
    }
    HEAP32[HEAP32[$2 + 4 >> 2] >> 2] = 16;
    break label$2;
   }
   HEAP32[$2 + 12 >> 2] = 1;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = 0;
 }
 return HEAP32[$2 + 12 >> 2];
}
function jswrap_serial_unsetup($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 HEAP8[$1 + 27 | 0] = jsiGetDeviceFromClass(HEAP32[$1 + 28 >> 2]);
 HEAP32[$1 + 20 >> 2] = jsvObjectGetChild(HEAP32[$1 + 28 >> 2], 125456, 0);
 HEAP32[$1 + 16 >> 2] = jsvObjectGetChild(HEAP32[$1 + 28 >> 2], 125465, 0);
 if (HEAP32[$1 + 20 >> 2]) {
  jsserialPopulateUSARTInfo($1, HEAP32[$1 + 16 >> 2], HEAP32[$1 + 20 >> 2]);
  if (HEAPU8[$1 + 6 | 0] != 255) {
   jshPinSetState(HEAPU8[$1 + 6 | 0], 0);
  }
  if (HEAPU8[$1 + 7 | 0] != 255) {
   jshPinSetState(HEAPU8[$1 + 7 | 0], 0);
  }
  if (HEAPU8[$1 + 4 | 0] != 255) {
   jshPinSetState(HEAPU8[$1 + 4 | 0], 0);
  }
  if (HEAPU8[$1 + 5 | 0] != 255) {
   jshPinSetState(HEAPU8[$1 + 5 | 0], 0);
  }
  if (!(HEAPU8[$1 + 27 | 0] <= 22 ? HEAPU8[$1 + 27 | 0] >= 17 : 0)) {
   jsserialEventCallbackKill(HEAP32[$1 + 28 >> 2], $1);
  }
 }
 jsvUnLock2(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 16 >> 2]);
 jsvObjectRemoveChild(HEAP32[$1 + 28 >> 2], 125465);
 jsvObjectRemoveChild(HEAP32[$1 + 28 >> 2], 125456);
 if (!(HEAPU8[$1 + 27 | 0] < 17 | HEAPU8[$1 + 27 | 0] > 22)) {
  jshUSARTUnSetup(HEAPU8[$1 + 27 | 0]);
  jshSetFlowControlEnabled(HEAPU8[$1 + 27 | 0]);
 }
 global$0 = $1 + 32 | 0;
}
function jsvIteratorGetValue($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 $0 = HEAP32[HEAP32[$1 + 8 >> 2] >> 2] + -1 | 0;
 label$1 : {
  if ($0 >>> 0 <= 3) {
   label$3 : {
    switch ($0 - 1 | 0) {
    case 2:
     label$7 : {
      if (!(jsvIsIntegerish(HEAP32[HEAP32[$1 + 8 >> 2] + 4 >> 2]) & 1)) {
       break label$7;
      }
      if ((jsvGetInteger(HEAP32[HEAP32[$1 + 8 >> 2] + 4 >> 2]) | 0) != HEAP32[HEAP32[$1 + 8 >> 2] + 12 >> 2]) {
       break label$7;
      }
      HEAP32[$1 + 12 >> 2] = jsvObjectIteratorGetValue(HEAP32[$1 + 8 >> 2] + 4 | 0);
      break label$1;
     }
     HEAP32[$1 + 12 >> 2] = 0;
     break label$1;
    case 0:
     HEAP32[$1 + 12 >> 2] = jsvObjectIteratorGetValue(HEAP32[$1 + 8 >> 2] + 4 | 0);
     break label$1;
    default:
     $0 = $1 + 6 | 0;
     HEAP8[$1 + 6 | 0] = jsvStringIteratorGetChar(HEAP32[$1 + 8 >> 2] + 4 | 0);
     HEAP8[$1 + 7 | 0] = 0;
     HEAP32[$1 + 12 >> 2] = jsvNewFromString($0);
     break label$1;
    case 1:
     break label$3;
    }
   }
   HEAP32[$1 + 12 >> 2] = jsvArrayBufferIteratorGetValueAndRewind(HEAP32[$1 + 8 >> 2] + 4 | 0);
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jswrap_object_assign($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 HEAP32[$1 + 24 >> 2] = 0;
 jsvObjectIteratorNew($1 + 16 | 0, HEAP32[$1 + 28 >> 2]);
 HEAP8[$1 + 15 | 0] = 0;
 while (1) {
  if (HEAP8[$1 + 15 | 0] & 1) {
   $0 = 0;
  } else {
   $0 = jsvObjectIteratorHasValue($1 + 16 | 0);
  }
  if ($0 & 1) {
   HEAP32[$1 + 8 >> 2] = jsvObjectIteratorGetValue($1 + 16 | 0);
   label$5 : {
    if (jsvIsUndefined(HEAP32[$1 + 8 >> 2]) & 1) {
     break label$5;
    }
    if (jsvIsNull(HEAP32[$1 + 8 >> 2]) & 1) {
     break label$5;
    }
    label$7 : {
     if (!(jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1)) {
      HEAP32[$1 >> 2] = HEAP32[$1 + 8 >> 2];
      jsExceptionHere(3, 123587, $1);
      HEAP8[$1 + 15 | 0] = 1;
      break label$7;
     }
     label$9 : {
      if (!HEAP32[$1 + 24 >> 2]) {
       HEAP32[$1 + 24 >> 2] = jsvLockAgain(HEAP32[$1 + 8 >> 2]);
       break label$9;
      }
      jsvObjectAppendAll(HEAP32[$1 + 24 >> 2], HEAP32[$1 + 8 >> 2]);
     }
    }
   }
   $0 = $1 + 16 | 0;
   jsvUnLock(HEAP32[$1 + 8 >> 2]);
   jsvObjectIteratorNext($0);
   continue;
  }
  break;
 }
 jsvObjectIteratorFree($1 + 16 | 0);
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 24 >> 2];
}
function tflite__MicroAllocator__FinishModelAllocation_28tflite__Model_20const__2c_20TfLiteEvalTensor__29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 $0 = HEAP32[$3 + 24 >> 2];
 label$1 : {
  if (!(HEAP8[$0 + 12 | 0] & 1)) {
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$0 + 8 >> 2], 131848, 0);
   HEAP32[$3 + 28 >> 2] = 1;
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = tflite__MicroAllocator__GetSubGraphFromModel_28tflite__Model_20const__29($0, HEAP32[$3 + 20 >> 2]);
  label$3 : {
   if (!HEAP32[$3 + 12 >> 2]) {
    break label$3;
   }
  }
  HEAP32[$3 + 8 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 44 >> 2]]($0, HEAP32[$3 + 20 >> 2], HEAP32[$3 + 12 >> 2], HEAP32[$3 + 16 >> 2]);
  if (HEAP32[$3 + 8 >> 2]) {
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 8 >> 2];
   break label$1;
  }
  HEAP32[$3 + 4 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 32 >> 2]]($0, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 16 >> 2]);
  if (HEAP32[$3 + 4 >> 2]) {
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 4 >> 2];
   break label$1;
  }
  HEAP8[$0 + 12 | 0] = 0;
  HEAP32[$3 + 28 >> 2] = 0;
 }
 global$0 = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}
function tflite__MicroAllocator__AllocateTempTfLiteTensor_28tflite__Model_20const__2c_20TfLiteEvalTensor__2c_20int_29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 global$0 = $4;
 HEAP32[$4 + 24 >> 2] = $0;
 HEAP32[$4 + 20 >> 2] = $1;
 HEAP32[$4 + 16 >> 2] = $2;
 HEAP32[$4 + 12 >> 2] = $3;
 $0 = HEAP32[$4 + 24 >> 2];
 HEAP32[$4 + 8 >> 2] = tflite__MicroAllocator__GetSubGraphFromModel_28tflite__Model_20const__29($0, HEAP32[$4 + 20 >> 2]);
 label$1 : {
  if (!HEAP32[$4 + 8 >> 2]) {
   break label$1;
  }
 }
 $1 = HEAP32[$0 + 4 >> 2];
 HEAP32[$4 + 4 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$1 >> 2] + 16 >> 2]]($1, 40, 4);
 label$2 : {
  if (FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 40 >> 2]]($0, HEAP32[$4 + 20 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 + 12 >> 2], 1)) {
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$0 + 8 >> 2], 132464, 0);
   HEAP32[$4 + 28 >> 2] = 0;
   break label$2;
  }
  if (HEAP32[$4 + 16 >> 2]) {
   HEAP32[HEAP32[$4 + 4 >> 2] + 16 >> 2] = HEAP32[HEAP32[$4 + 16 >> 2] + Math_imul(HEAP32[$4 + 12 >> 2], 12) >> 2];
  }
  HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 4 >> 2];
 }
 global$0 = $4 + 32 | 0;
 return HEAP32[$4 + 28 >> 2];
}
function jshTransmit($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
 label$1 : {
  if (!(HEAPU8[$2 + 15 | 0] != 18 ? HEAPU8[$2 + 15 | 0] != 17 : 0)) {
   jshPushIOCharEvent((HEAPU8[$2 + 15 | 0] == 18 ? 17 : 18) & 255, HEAP8[$2 + 14 | 0]);
   break label$1;
  }
  if (HEAPU8[$2 + 15 | 0] == 20) {
   terminalSendChar(HEAP8[$2 + 14 | 0]);
   break label$1;
  }
  label$5 : {
   if (HEAPU8[$2 + 15 | 0] != 21) {
    break label$5;
   }
  }
  if (!HEAPU8[$2 + 15 | 0]) {
   break label$1;
  }
  HEAP8[$2 + 13 | 0] = HEAPU8[322304] + 1;
  if (HEAPU8[$2 + 13 | 0] == HEAPU8[322305]) {
   jsiSetBusy(2, 1);
   HEAP8[$2 + 12 | 0] = HEAPU8[$2 + 15 | 0] == 19 ? HEAPU8[141672] == 19 : 0;
   while (1) {
    if (HEAPU8[$2 + 13 | 0] == HEAPU8[322305]) {
     jshBusyIdle();
     continue;
    }
    break;
   }
   if (!(!(HEAP8[$2 + 12 | 0] & 1) | HEAPU8[141672] == 19)) {
    HEAP8[$2 + 15 | 0] = HEAPU8[141672];
   }
   jsiSetBusy(2, 0);
  }
  HEAP8[(HEAPU8[322304] << 1) + 322384 | 0] = HEAPU8[$2 + 15 | 0];
  HEAP8[((HEAPU8[322304] << 1) + 322384 | 0) + 1 | 0] = HEAPU8[$2 + 14 | 0];
  HEAP8[322304] = HEAPU8[$2 + 13 | 0];
  jshUSARTUnSetup(HEAPU8[$2 + 15 | 0]);
 }
 global$0 = $2 + 16 | 0;
}
function jsfGetBootCodeFromFlash($0) {
 var $1 = 0;
 $1 = global$0 - 144 | 0;
 global$0 = $1;
 HEAP8[$1 + 139 | 0] = $0;
 jsfNameFromString($1 + 104 | 0, 78221);
 HEAP32[$1 + 64 >> 2] = HEAP32[$1 + 128 >> 2];
 $0 = HEAP32[$1 + 124 >> 2];
 HEAP32[$1 + 56 >> 2] = HEAP32[$1 + 120 >> 2];
 HEAP32[$1 + 60 >> 2] = $0;
 $0 = HEAP32[$1 + 116 >> 2];
 HEAP32[$1 + 48 >> 2] = HEAP32[$1 + 112 >> 2];
 HEAP32[$1 + 52 >> 2] = $0;
 $0 = HEAP32[$1 + 108 >> 2];
 HEAP32[$1 + 40 >> 2] = HEAP32[$1 + 104 >> 2];
 HEAP32[$1 + 44 >> 2] = $0;
 HEAP32[$1 + 132 >> 2] = jsfReadFile($1 + 40 | 0, 0, 0);
 label$1 : {
  if (!(HEAP32[$1 + 132 >> 2] ? 0 : !(HEAP8[$1 + 139 | 0] & 1))) {
   HEAP32[$1 + 140 >> 2] = HEAP32[$1 + 132 >> 2];
   break label$1;
  }
  jsfNameFromString($1 + 72 | 0, 78212);
  HEAP32[$1 + 32 >> 2] = HEAP32[$1 + 96 >> 2];
  $0 = HEAP32[$1 + 92 >> 2];
  HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 88 >> 2];
  HEAP32[$1 + 28 >> 2] = $0;
  $0 = HEAP32[$1 + 84 >> 2];
  HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 80 >> 2];
  HEAP32[$1 + 20 >> 2] = $0;
  $0 = HEAP32[$1 + 76 >> 2];
  HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 72 >> 2];
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 140 >> 2] = jsfReadFile($1 + 8 | 0, 0, 0);
 }
 global$0 = $1 + 144 | 0;
 return HEAP32[$1 + 140 >> 2];
}
function jsiTabComplete_printCommon($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 28 >> 2];
 label$1 : {
  if (jsvGetStringLength(HEAP32[$2 + 24 >> 2]) >>> 0 <= HEAPU32[HEAP32[$2 + 20 >> 2] >> 2]) {
   break label$1;
  }
  if (jsvCompareString(HEAP32[HEAP32[$2 + 20 >> 2] + 4 >> 2], HEAP32[$2 + 24 >> 2], 0, 1)) {
   break label$1;
  }
  label$2 : {
   if (!HEAP32[HEAP32[$2 + 20 >> 2] + 16 >> 2]) {
    HEAP32[$2 >> 2] = HEAP32[$2 + 24 >> 2];
    jsiConsolePrintf(81142, $2);
    $0 = jsvGetStringLength(HEAP32[$2 + 24 >> 2]);
    HEAP32[HEAP32[$2 + 20 >> 2] + 16 >> 2] = $0;
    break label$2;
   }
   if (HEAPU32[HEAP32[$2 + 20 >> 2] + 16 >> 2] >= 20) {
    HEAP32[HEAP32[$2 + 20 >> 2] + 16 >> 2] = 19;
   }
   while (1) {
    if (HEAPU32[HEAP32[$2 + 20 >> 2] + 16 >> 2] < 20) {
     jsiConsolePrintChar(32);
     $0 = HEAP32[$2 + 20 >> 2];
     HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 16 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 24 >> 2];
   jsiConsolePrintf(81733, $2 + 16 | 0);
   HEAP32[HEAP32[$2 + 20 >> 2] + 16 >> 2] = 0;
  }
 }
 global$0 = $2 + 32 | 0;
}
function mbedtls_sha256_starts($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[HEAP32[$2 + 12 >> 2] >> 2] = 0;
 HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2] = 0;
 label$1 : {
  if (!HEAP32[$2 + 8 >> 2]) {
   HEAP32[HEAP32[$2 + 12 >> 2] + 8 >> 2] = 1779033703;
   HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2] = -1150833019;
   HEAP32[HEAP32[$2 + 12 >> 2] + 16 >> 2] = 1013904242;
   HEAP32[HEAP32[$2 + 12 >> 2] + 20 >> 2] = -1521486534;
   HEAP32[HEAP32[$2 + 12 >> 2] + 24 >> 2] = 1359893119;
   HEAP32[HEAP32[$2 + 12 >> 2] + 28 >> 2] = -1694144372;
   HEAP32[HEAP32[$2 + 12 >> 2] + 32 >> 2] = 528734635;
   HEAP32[HEAP32[$2 + 12 >> 2] + 36 >> 2] = 1541459225;
   break label$1;
  }
  HEAP32[HEAP32[$2 + 12 >> 2] + 8 >> 2] = -1056596264;
  HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2] = 914150663;
  HEAP32[HEAP32[$2 + 12 >> 2] + 16 >> 2] = 812702999;
  HEAP32[HEAP32[$2 + 12 >> 2] + 20 >> 2] = -150054599;
  HEAP32[HEAP32[$2 + 12 >> 2] + 24 >> 2] = -4191439;
  HEAP32[HEAP32[$2 + 12 >> 2] + 28 >> 2] = 1750603025;
  HEAP32[HEAP32[$2 + 12 >> 2] + 32 >> 2] = 1694076839;
  HEAP32[HEAP32[$2 + 12 >> 2] + 36 >> 2] = -1090891868;
 }
 HEAP32[HEAP32[$2 + 12 >> 2] + 104 >> 2] = HEAP32[$2 + 8 >> 2];
}
function jswrap_string_slice($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 $0 = $3;
 $2 = jsvIsUndefined(HEAP32[$3 + 16 >> 2]) & 1;
 $1 = 2147483647;
 label$1 : {
  if ($2) {
   break label$1;
  }
  $1 = jsvGetInteger(HEAP32[$3 + 16 >> 2]);
 }
 HEAP32[$0 + 8 >> 2] = $1;
 if (HEAP32[$3 + 20 >> 2] < 0) {
  HEAP32[$3 + 20 >> 2] = jsvGetStringLength(HEAP32[$3 + 24 >> 2]) + HEAP32[$3 + 20 >> 2];
 }
 if (HEAP32[$3 + 8 >> 2] < 0) {
  HEAP32[$3 + 8 >> 2] = jsvGetStringLength(HEAP32[$3 + 24 >> 2]) + HEAP32[$3 + 8 >> 2];
 }
 if (HEAP32[$3 + 20 >> 2] < 0) {
  HEAP32[$3 + 20 >> 2] = 0;
 }
 if (HEAP32[$3 + 8 >> 2] < 0) {
  HEAP32[$3 + 8 >> 2] = 0;
 }
 HEAP32[$3 + 12 >> 2] = jsvNewWithFlags(27);
 label$6 : {
  if (!HEAP32[$3 + 12 >> 2]) {
   HEAP32[$3 + 28 >> 2] = 0;
   break label$6;
  }
  if (HEAP32[$3 + 8 >> 2] > HEAP32[$3 + 20 >> 2]) {
   jsvAppendStringVar(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 8 >> 2] - HEAP32[$3 + 20 >> 2] | 0);
  }
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2];
 }
 global$0 = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}
function jswrap_onewire_read($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 80 | 0;
 global$0 = $2;
 HEAP32[$2 + 72 >> 2] = $0;
 HEAP32[$2 + 68 >> 2] = $1;
 HEAP8[$2 + 67 | 0] = onewire_getpin(HEAP32[$2 + 72 >> 2]);
 label$1 : {
  if (!(jshIsPinValid(HEAPU8[$2 + 67 | 0]) & 1)) {
   HEAP32[$2 + 76 >> 2] = 0;
   break label$1;
  }
  if (jsvIsNumeric(HEAP32[$2 + 68 >> 2]) & 1) {
   HEAP32[$2 + 60 >> 2] = jsvGetInteger(HEAP32[$2 + 68 >> 2]);
   HEAP32[$2 + 56 >> 2] = jsvNewTypedArray(1, HEAP32[$2 + 60 >> 2]);
   if (!HEAP32[$2 + 56 >> 2]) {
    HEAP32[$2 + 76 >> 2] = 0;
    break label$1;
   }
   jsvArrayBufferIteratorNew($2, HEAP32[$2 + 56 >> 2], 0);
   while (1) {
    label$6 : {
     $0 = HEAP32[$2 + 60 >> 2];
     HEAP32[$2 + 60 >> 2] = $0 + -1;
     if (!$0) {
      break label$6;
     }
     jsvArrayBufferIteratorSetByteValue($2, OneWireRead(HEAPU8[$2 + 67 | 0], 8) << 24 >> 24);
     jsvArrayBufferIteratorNext($2);
     continue;
    }
    break;
   }
   jsvArrayBufferIteratorFree($2);
   HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 56 >> 2];
   break label$1;
  }
  HEAP32[$2 + 76 >> 2] = jsvNewFromInteger(OneWireRead(HEAPU8[$2 + 67 | 0], 8));
 }
 global$0 = $2 + 80 | 0;
 return HEAP32[$2 + 76 >> 2];
}
function jsvStringIteratorLoadFlashString($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 + 8 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] >> 2] + HEAP32[$0 + 8 >> 2];
 HEAP32[HEAP32[$1 + 12 >> 2] >> 2] = 0;
 $0 = HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
 label$1 : {
  if (HEAPU32[HEAP32[$1 + 12 >> 2] + 8 >> 2] >= HEAPU32[$1 + 8 >> 2]) {
   HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = 0;
   HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] = 0;
   break label$1;
  }
  HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] = HEAP32[$1 + 8 >> 2] - HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2];
  if (HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2] > 16) {
   HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] = 16;
  }
  $0 = HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2];
  jshFlashRead(HEAP32[$1 + 12 >> 2] + 20 | 0, HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] + (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) | 0, HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2]);
  HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = HEAP32[$1 + 12 >> 2] + 20;
 }
 global$0 = $1 + 16 | 0;
}
function jswrap_string_endsWith($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 label$1 : {
  if (!(jsvIsString(HEAP32[$3 + 24 >> 2]) & 1)) {
   HEAP8[$3 + 31 | 0] = 0;
   break label$1;
  }
  $0 = $3;
  label$3 : {
   if (jsvIsNumeric(HEAP32[$3 + 16 >> 2]) & 1) {
    $1 = jsvGetInteger(HEAP32[$3 + 16 >> 2]);
    break label$3;
   }
   $1 = jsvGetStringLength(HEAP32[$3 + 24 >> 2]);
  }
  HEAP32[$0 + 12 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = jsvAsString(HEAP32[$3 + 20 >> 2]);
  $0 = jsvGetStringLength(HEAP32[$3 + 8 >> 2]);
  HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] - $0;
  HEAP8[$3 + 7 | 0] = 0;
  label$5 : {
   if (HEAP32[$3 + 12 >> 2] < 0) {
    break label$5;
   }
   if ((jsvGetStringLength(HEAP32[$3 + 8 >> 2]) + HEAP32[$3 + 12 >> 2] | 0) > (jsvGetStringLength(HEAP32[$3 + 24 >> 2]) | 0)) {
    break label$5;
   }
   HEAP8[$3 + 7 | 0] = !jsvCompareString(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 12 >> 2], 1);
  }
  jsvUnLock(HEAP32[$3 + 8 >> 2]);
  HEAP8[$3 + 31 | 0] = HEAP8[$3 + 7 | 0] & 1;
 }
 global$0 = $3 + 32 | 0;
 return HEAP8[$3 + 31 | 0] & 1;
}
function matchfound($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = jsvNewWithFlags(3);
 HEAP32[$2 + 20 >> 2] = jsvStringIteratorGetIndex(HEAP32[$2 + 28 >> 2]);
 HEAP32[$2 + 16 >> 2] = jsvNewFromStringVar(HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2], HEAP32[$2 + 20 >> 2] - HEAP32[$1 + 4 >> 2] | 0);
 jsvSetArrayItem(HEAP32[$2 + 24 >> 2], 0, HEAP32[$2 + 16 >> 2]);
 jsvUnLock(HEAP32[$2 + 16 >> 2]);
 HEAP32[$2 + 12 >> 2] = 0;
 while (1) {
  if (HEAP32[$2 + 12 >> 2] < HEAP32[$1 + 12 >> 2]) {
   HEAP32[$2 + 16 >> 2] = jsvNewFromStringVar(HEAP32[$1 >> 2], HEAP32[($1 + 16 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2], HEAP32[($1 + 52 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2] - HEAP32[($1 + 16 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2] | 0);
   jsvSetArrayItem(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 12 >> 2] + 1 | 0, HEAP32[$2 + 16 >> 2]);
   jsvUnLock(HEAP32[$2 + 16 >> 2]);
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 125394, jsvNewFromInteger(HEAP32[$1 + 4 >> 2]));
 jsvObjectSetChild(HEAP32[$2 + 24 >> 2], 125400, HEAP32[$1 >> 2]);
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 24 >> 2];
}
function itostr_extra($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 global$0 = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP8[$4 + 23 | 0] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 label$1 : {
  if (!(!(HEAP8[$4 + 23 | 0] & 1) | HEAP32[$4 + 28 >> 2] >= 0)) {
   $0 = HEAP32[$4 + 24 >> 2];
   HEAP32[$4 + 24 >> 2] = $0 + 1;
   HEAP8[$0 | 0] = 45;
   HEAP32[$4 + 12 >> 2] = 0 - HEAP32[$4 + 28 >> 2];
   break label$1;
  }
  HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 28 >> 2];
 }
 HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 12 >> 2];
 HEAP32[$4 + 4 >> 2] = 1;
 while (1) {
  if (HEAPU32[$4 + 8 >> 2] >= HEAPU32[$4 + 16 >> 2]) {
   HEAP32[$4 + 4 >> 2] = HEAP32[$4 + 4 >> 2] + 1;
   HEAP32[$4 + 8 >> 2] = HEAPU32[$4 + 8 >> 2] / HEAPU32[$4 + 16 >> 2];
   continue;
  }
  break;
 }
 HEAP32[$4 >> 2] = HEAP32[$4 + 4 >> 2] - 1;
 while (1) {
  if (HEAP32[$4 >> 2] >= 0) {
   $0 = itoch(HEAPU32[$4 + 12 >> 2] % HEAPU32[$4 + 16 >> 2] | 0);
   HEAP8[HEAP32[$4 + 24 >> 2] + HEAP32[$4 >> 2] | 0] = $0;
   HEAP32[$4 + 12 >> 2] = HEAPU32[$4 + 12 >> 2] / HEAPU32[$4 + 16 >> 2];
   HEAP32[$4 >> 2] = HEAP32[$4 >> 2] + -1;
   continue;
  }
  break;
 }
 HEAP8[HEAP32[$4 + 24 >> 2] + HEAP32[$4 + 4 >> 2] | 0] = 0;
 global$0 = $4 + 32 | 0;
}
function jsiExtractIOEventData($0, $1) {
 var $2 = 0;
 $2 = global$0 + -64 | 0;
 global$0 = $2;
 HEAP32[$2 + 60 >> 2] = $0;
 HEAP32[$2 + 56 >> 2] = $1;
 HEAP32[HEAP32[$2 + 56 >> 2] >> 2] = 0;
 HEAP32[$2 + 52 >> 2] = jsvNewWithFlags(27);
 if (HEAP32[$2 + 52 >> 2]) {
  jsvStringIteratorNew($2 + 16 | 0, HEAP32[$2 + 52 >> 2], 0);
  HEAP32[$2 + 8 >> 2] = ((HEAPU8[HEAP32[$2 + 60 >> 2]] & 96) >> 5) + 1;
  while (1) {
   if (HEAP32[$2 + 8 >> 2]) {
    HEAP32[$2 + 12 >> 2] = 0;
    while (1) {
     if (HEAP32[$2 + 12 >> 2] < HEAP32[$2 + 8 >> 2]) {
      jsvStringIteratorAppend($2 + 16 | 0, HEAP8[HEAP32[$2 + 12 >> 2] + (HEAP32[$2 + 60 >> 2] + 1 | 0) | 0]);
      HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
      continue;
     }
     break;
    }
    label$6 : {
     if (jshIsTopEvent(HEAPU8[HEAP32[$2 + 60 >> 2]] & 31) & 1) {
      jshPopIOEvent(HEAP32[$2 + 60 >> 2]);
      $0 = HEAP32[$2 + 56 >> 2];
      HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
      HEAP32[$2 + 8 >> 2] = ((HEAPU8[HEAP32[$2 + 60 >> 2]] & 96) >> 5) + 1;
      break label$6;
     }
     HEAP32[$2 + 8 >> 2] = 0;
    }
    continue;
   }
   break;
  }
  jsvStringIteratorFree($2 + 16 | 0);
 }
 global$0 = $2 - -64 | 0;
 return HEAP32[$2 + 52 >> 2];
}
function getTimeFromMilliSeconds($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAPF64[$3 + 24 >> 3] = $1;
 HEAP8[$3 + 23 | 0] = $2;
 $2 = $0;
 if (HEAP8[$3 + 23 | 0] & 1) {
  $4 = 0;
 } else {
  $4 = jsdGetTimeZone();
 }
 HEAP32[$2 + 20 >> 2] = $4;
 HEAPF64[$3 + 24 >> 3] = HEAPF64[$3 + 24 >> 3] + +(Math_imul(HEAP32[$0 + 20 >> 2], 6e4) | 0);
 $2 = $0;
 $1 = HEAPF64[$3 + 24 >> 3] / 864e5;
 label$2 : {
  if (Math_abs($1) < 2147483648) {
   $4 = ~~$1;
   break label$2;
  }
  $4 = -2147483648;
 }
 HEAP32[$2 >> 2] = $4;
 $2 = $3;
 $1 = HEAPF64[$3 + 24 >> 3] - +HEAP32[$0 >> 2] * 864e5;
 label$4 : {
  if (Math_abs($1) < 2147483648) {
   $4 = ~~$1;
   break label$4;
  }
  $4 = -2147483648;
 }
 HEAP32[$2 + 16 >> 2] = $4;
 if (HEAP32[$3 + 16 >> 2] < 0) {
  HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 16 >> 2] + 864e5;
  HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + -1;
 }
 HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 16 >> 2] / 1e3;
 HEAP32[$0 + 4 >> 2] = HEAP32[$3 + 16 >> 2] % 1e3;
 HEAP32[$0 + 16 >> 2] = HEAP32[$3 + 12 >> 2] / 3600;
 HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] % 3600;
 HEAP32[$0 + 12 >> 2] = HEAP32[$3 + 12 >> 2] / 60;
 HEAP32[$0 + 8 >> 2] = HEAP32[$3 + 12 >> 2] % 60;
 global$0 = $3 + 32 | 0;
}
function jswrap_string_toUpperLowerCase($0, $1) {
 var $2 = 0;
 $2 = global$0 - 112 | 0;
 global$0 = $2;
 HEAP32[$2 + 104 >> 2] = $0;
 HEAP8[$2 + 103 | 0] = $1;
 HEAP32[$2 + 96 >> 2] = jsvNewWithFlags(27);
 label$1 : {
  if (!HEAP32[$2 + 96 >> 2]) {
   HEAP32[$2 + 108 >> 2] = 0;
   break label$1;
  }
  $0 = $2 + 16 | 0;
  $1 = $2 + 56 | 0;
  HEAP32[$2 + 92 >> 2] = jsvAsString(HEAP32[$2 + 104 >> 2]);
  jsvStringIteratorNew($1, HEAP32[$2 + 92 >> 2], 0);
  jsvStringIteratorNew($0, HEAP32[$2 + 96 >> 2], 0);
  while (1) {
   if (jsvStringIteratorHasChar($2 + 56 | 0) & 1) {
    HEAP8[$2 + 15 | 0] = jsvStringIteratorGetCharAndNext($2 + 56 | 0);
    $0 = $2;
    label$5 : {
     if (HEAP8[$2 + 103 | 0] & 1) {
      $1 = charToUpperCase(HEAP8[$2 + 15 | 0]) << 24 >> 24;
      break label$5;
     }
     $1 = charToLowerCase(HEAP8[$2 + 15 | 0]) << 24 >> 24;
    }
    HEAP8[$0 + 15 | 0] = $1;
    jsvStringIteratorAppend($2 + 16 | 0, HEAP8[$2 + 15 | 0]);
    continue;
   }
   break;
  }
  $0 = $2 + 16 | 0;
  jsvStringIteratorFree($2 + 56 | 0);
  jsvStringIteratorFree($0);
  jsvUnLock(HEAP32[$2 + 92 >> 2]);
  HEAP32[$2 + 108 >> 2] = HEAP32[$2 + 96 >> 2];
 }
 global$0 = $2 + 112 | 0;
 return HEAP32[$2 + 108 >> 2];
}
function gemmlowp__ImplSaturatingRoundingMultiplyByPOT_1_2c_20int_2c_201___eval_28int_29($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 HEAP32[$1 + 24 >> 2] = tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(-2147483648);
 HEAP32[$1 + 20 >> 2] = tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(2147483647);
 HEAP32[$1 + 16 >> 2] = 32;
 HEAP32[$1 + 12 >> 2] = 1073741823;
 HEAP32[$1 + 8 >> 2] = int_20gemmlowp__MaskIfGreaterThan_int__28int_2c_20int_29(HEAP32[$1 + 28 >> 2], tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(1073741823));
 HEAP32[$1 + 4 >> 2] = int_20gemmlowp__MaskIfLessThan_int__28int_2c_20int_29(HEAP32[$1 + 28 >> 2], tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(-1073741823));
 HEAP32[$1 >> 2] = int_20gemmlowp__ShiftLeft_int__28int_2c_20int_29(HEAP32[$1 + 28 >> 2], 1);
 HEAP32[$1 >> 2] = int_20gemmlowp__SelectUsingMask_int__28int_2c_20int_2c_20int_29(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 20 >> 2], HEAP32[$1 >> 2]);
 HEAP32[$1 >> 2] = int_20gemmlowp__SelectUsingMask_int__28int_2c_20int_2c_20int_29(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 24 >> 2], HEAP32[$1 >> 2]);
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 >> 2];
}
function gemmlowp__ImplSaturatingRoundingMultiplyByPOT_2_2c_20int_2c_201___eval_28int_29($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 HEAP32[$1 + 24 >> 2] = tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(-2147483648);
 HEAP32[$1 + 20 >> 2] = tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(2147483647);
 HEAP32[$1 + 16 >> 2] = 32;
 HEAP32[$1 + 12 >> 2] = 536870911;
 HEAP32[$1 + 8 >> 2] = int_20gemmlowp__MaskIfGreaterThan_int__28int_2c_20int_29(HEAP32[$1 + 28 >> 2], tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(536870911));
 HEAP32[$1 + 4 >> 2] = int_20gemmlowp__MaskIfLessThan_int__28int_2c_20int_29(HEAP32[$1 + 28 >> 2], tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(-536870911));
 HEAP32[$1 >> 2] = int_20gemmlowp__ShiftLeft_int__28int_2c_20int_29(HEAP32[$1 + 28 >> 2], 2);
 HEAP32[$1 >> 2] = int_20gemmlowp__SelectUsingMask_int__28int_2c_20int_2c_20int_29(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 20 >> 2], HEAP32[$1 >> 2]);
 HEAP32[$1 >> 2] = int_20gemmlowp__SelectUsingMask_int__28int_2c_20int_2c_20int_29(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 24 >> 2], HEAP32[$1 >> 2]);
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 >> 2];
}
function jswrap_date_toString($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $1 = global$0 - 112 | 0;
 global$0 = $1;
 $2 = $1 + 56 | 0;
 HEAP32[$1 + 108 >> 2] = $0;
 getTimeFromDateVar($1 + 80 | 0, HEAP32[$1 + 108 >> 2], 0);
 getCalendarDate($2, HEAP32[$1 + 80 >> 2]);
 label$1 : {
  if (HEAP32[$1 + 100 >> 2] < 0) {
   HEAP32[$1 + 48 >> 2] = 0 - HEAP32[$1 + 100 >> 2];
   HEAP8[$1 + 55 | 0] = 45;
   break label$1;
  }
  HEAP32[$1 + 48 >> 2] = HEAP32[$1 + 100 >> 2];
  HEAP8[$1 + 55 | 0] = 43;
 }
 $0 = HEAP32[35429] + (HEAP32[$1 + 72 >> 2] << 2) | 0;
 $2 = HEAP32[35428] + (HEAP32[$1 + 64 >> 2] << 2) | 0;
 $3 = HEAP32[$1 + 60 >> 2];
 $4 = HEAP32[$1 + 68 >> 2];
 $5 = HEAP32[$1 + 96 >> 2];
 $6 = HEAP32[$1 + 92 >> 2];
 $7 = HEAP32[$1 + 88 >> 2];
 $8 = HEAP8[$1 + 55 | 0];
 HEAP32[$1 + 32 >> 2] = Math_imul(HEAP32[$1 + 48 >> 2] / 60 | 0, 100) + (HEAP32[$1 + 48 >> 2] % 60 | 0);
 HEAP32[$1 + 28 >> 2] = $8;
 HEAP32[$1 + 24 >> 2] = $7;
 HEAP32[$1 + 20 >> 2] = $6;
 HEAP32[$1 + 16 >> 2] = $5;
 HEAP32[$1 + 12 >> 2] = $4;
 HEAP32[$1 + 8 >> 2] = $3;
 HEAP32[$1 + 4 >> 2] = $2;
 HEAP32[$1 >> 2] = $0;
 $0 = jsvVarPrintf(119812, $1);
 global$0 = $1 + 112 | 0;
 return $0 | 0;
}
function jsvIteratorGetFloatValue($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 4 >> 2] = $0;
 $0 = HEAP32[HEAP32[$1 + 4 >> 2] >> 2] + -1 | 0;
 label$1 : {
  if ($0 >>> 0 <= 3) {
   label$3 : {
    switch ($0 - 1 | 0) {
    case 2:
     label$7 : {
      if (!(jsvIsIntegerish(HEAP32[HEAP32[$1 + 4 >> 2] + 4 >> 2]) & 1)) {
       break label$7;
      }
      if ((jsvGetInteger(HEAP32[HEAP32[$1 + 4 >> 2] + 4 >> 2]) | 0) != HEAP32[HEAP32[$1 + 4 >> 2] + 12 >> 2]) {
       break label$7;
      }
      HEAPF64[$1 + 8 >> 3] = jsvGetFloatAndUnLock(jsvObjectIteratorGetValue(HEAP32[$1 + 4 >> 2] + 4 | 0));
      break label$1;
     }
     HEAPF64[$1 + 8 >> 3] = nan;
     break label$1;
    case 0:
     HEAPF64[$1 + 8 >> 3] = jsvGetFloatAndUnLock(jsvObjectIteratorGetValue(HEAP32[$1 + 4 >> 2] + 4 | 0));
     break label$1;
    default:
     HEAPF64[$1 + 8 >> 3] = jsvStringIteratorGetChar(HEAP32[$1 + 4 >> 2] + 4 | 0) | 0;
     break label$1;
    case 1:
     break label$3;
    }
   }
   HEAPF64[$1 + 8 >> 3] = jsvArrayBufferIteratorGetFloatValue(HEAP32[$1 + 4 >> 2] + 4 | 0);
   break label$1;
  }
  HEAPF64[$1 + 8 >> 3] = nan;
 }
 global$0 = $1 + 16 | 0;
 return HEAPF64[$1 + 8 >> 3];
}
function jswrap_object_defineProperties($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 label$1 : {
  if (!(jsvIsObject(HEAP32[$2 + 40 >> 2]) & 1)) {
   HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 40 >> 2];
   jsExceptionHere(1, 123485, $2 + 16 | 0);
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  if (!(jsvIsObject(HEAP32[$2 + 36 >> 2]) & 1)) {
   HEAP32[$2 >> 2] = HEAP32[$2 + 36 >> 2];
   jsExceptionHere(1, 123527, $2);
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  jsvObjectIteratorNew($2 + 32 | 0, HEAP32[$2 + 36 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue($2 + 32 | 0) & 1) {
    $0 = $2 + 32 | 0;
    HEAP32[$2 + 28 >> 2] = jsvObjectIteratorGetKey($0);
    HEAP32[$2 + 24 >> 2] = jsvObjectIteratorGetValue($0);
    jsvUnLock3(jswrap_object_defineProperty(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2]), HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2]);
    jsvObjectIteratorNext($0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree($2 + 32 | 0);
  HEAP32[$2 + 44 >> 2] = jsvLockAgain(HEAP32[$2 + 40 >> 2]);
 }
 global$0 = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}
function gemmlowp__ImplSaturatingRoundingMultiplyByPOT_5_2c_20int_2c_201___eval_28int_29($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 HEAP32[$1 + 24 >> 2] = tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(-2147483648);
 HEAP32[$1 + 20 >> 2] = tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(2147483647);
 HEAP32[$1 + 16 >> 2] = 32;
 HEAP32[$1 + 12 >> 2] = 67108863;
 HEAP32[$1 + 8 >> 2] = int_20gemmlowp__MaskIfGreaterThan_int__28int_2c_20int_29(HEAP32[$1 + 28 >> 2], tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(67108863));
 HEAP32[$1 + 4 >> 2] = int_20gemmlowp__MaskIfLessThan_int__28int_2c_20int_29(HEAP32[$1 + 28 >> 2], tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(-67108863));
 HEAP32[$1 >> 2] = int_20gemmlowp__ShiftLeft_int__28int_2c_20int_29(HEAP32[$1 + 28 >> 2], 5);
 HEAP32[$1 >> 2] = int_20gemmlowp__SelectUsingMask_int__28int_2c_20int_2c_20int_29(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 20 >> 2], HEAP32[$1 >> 2]);
 HEAP32[$1 >> 2] = int_20gemmlowp__SelectUsingMask_int__28int_2c_20int_2c_20int_29(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 24 >> 2], HEAP32[$1 >> 2]);
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 >> 2];
}
function memchr($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = ($1 | 0) != 0;
 label$1 : {
  label$2 : {
   label$3 : {
    label$4 : {
     if (!$1 | !($0 & 3)) {
      break label$4;
     }
     while (1) {
      if (!HEAPU8[$0 | 0]) {
       break label$3;
      }
      $0 = $0 + 1 | 0;
      $1 = $1 + -1 | 0;
      $2 = ($1 | 0) != 0;
      if (!$1) {
       break label$4;
      }
      if ($0 & 3) {
       continue;
      }
      break;
     }
    }
    if (!$2) {
     break label$2;
    }
   }
   if (!HEAPU8[$0 | 0]) {
    break label$1;
   }
   label$6 : {
    if ($1 >>> 0 >= 4) {
     $2 = $1 + -4 | 0;
     $3 = $2 & -4;
     $2 = $2 - $3 | 0;
     $3 = ($0 + $3 | 0) + 4 | 0;
     while (1) {
      $4 = HEAP32[$0 >> 2];
      if (($4 ^ -1) & $4 + -16843009 & -2139062144) {
       break label$6;
      }
      $0 = $0 + 4 | 0;
      $1 = $1 + -4 | 0;
      if ($1 >>> 0 > 3) {
       continue;
      }
      break;
     }
     $1 = $2;
     $0 = $3;
    }
    if (!$1) {
     break label$2;
    }
   }
   while (1) {
    if (!HEAPU8[$0 | 0]) {
     break label$1;
    }
    $0 = $0 + 1 | 0;
    $1 = $1 + -1 | 0;
    if ($1) {
     continue;
    }
    break;
   }
  }
  return 0;
 }
 return $0;
}
function jswrap_process_env() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 12 >> 2] = jsvNewWithFlags(5);
 jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 124936, jsvNewFromString(124944));
 jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 124949, jsvNewFromString(124960));
 jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 124970, jsvNewFromString(124976));
 jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 124988, jsvNewFromInteger(8388608));
 jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 124994, jsvNewFromInteger(8388608));
 jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 125003, jsvNewFromInteger(2));
 jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 125013, jsvNewFromInteger(8388608));
 jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 125021, jsvNewFromInteger(0));
 jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 125025, jswrap_interface_getSerial());
 jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 125032, jswrap_espruino_getConsole());
 jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 125040, jsvNewFromString(95142));
 jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 125048, jsvNewFromInteger(124864));
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}
function __vfprintf_internal($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $1 = global$0 - 208 | 0;
 global$0 = $1;
 HEAP32[$1 + 204 >> 2] = 0;
 memset($1 + 160 | 0, 0, 40);
 HEAP32[$1 + 200 >> 2] = HEAP32[$1 + 204 >> 2];
 label$1 : {
  if ((printf_core(0, $1 + 200 | 0, $1 + 80 | 0, $1 + 160 | 0) | 0) < 0) {
   break label$1;
  }
  $3 = HEAP32[$0 + 76 >> 2] >= 0 ? 1 : $3;
  $2 = HEAP32[$0 >> 2];
  if (HEAP8[$0 + 74 | 0] <= 0) {
   HEAP32[$0 >> 2] = $2 & -33;
  }
  $4 = $2 & 32;
  label$4 : {
   if (HEAP32[$0 + 48 >> 2]) {
    printf_core($0, $1 + 200 | 0, $1 + 80 | 0, $1 + 160 | 0);
    break label$4;
   }
   HEAP32[$0 + 48 >> 2] = 80;
   HEAP32[$0 + 16 >> 2] = $1 + 80;
   HEAP32[$0 + 28 >> 2] = $1;
   HEAP32[$0 + 20 >> 2] = $1;
   $2 = HEAP32[$0 + 44 >> 2];
   HEAP32[$0 + 44 >> 2] = $1;
   printf_core($0, $1 + 200 | 0, $1 + 80 | 0, $1 + 160 | 0);
   if (!$2) {
    break label$4;
   }
   FUNCTION_TABLE[HEAP32[$0 + 36 >> 2]]($0, 0, 0) | 0;
   HEAP32[$0 + 48 >> 2] = 0;
   HEAP32[$0 + 44 >> 2] = $2;
   HEAP32[$0 + 28 >> 2] = 0;
   HEAP32[$0 + 16 >> 2] = 0;
   HEAP32[$0 + 20 >> 2] = 0;
  }
  HEAP32[$0 >> 2] = HEAP32[$0 >> 2] | $4;
  if (!$3) {
   break label$1;
  }
 }
 global$0 = $1 + 208 | 0;
}
function jsiExecuteEvents() {
 var $0 = 0, $1 = 0, $2 = 0;
 $0 = global$0 - 32 | 0;
 global$0 = $0;
 HEAP8[$0 + 31 | 0] = (jsvArrayIsEmpty(HEAP32[80554]) ^ -1) & 1;
 if (HEAP8[$0 + 31 | 0] & 1) {
  jsiSetBusy(1, 1);
 }
 while (1) {
  if ((jsvArrayIsEmpty(HEAP32[80554]) ^ -1) & 1) {
   HEAP32[$0 + 24 >> 2] = jsvSkipNameAndUnLock(jsvArrayPopFirst(HEAP32[80554]));
   HEAP32[$0 + 20 >> 2] = jsvObjectGetChild(HEAP32[$0 + 24 >> 2], 81793, 0);
   HEAP32[$0 + 16 >> 2] = jsvObjectGetChild(HEAP32[$0 + 24 >> 2], 81803, 0);
   HEAP32[$0 + 12 >> 2] = jsvObjectGetChild(HEAP32[$0 + 24 >> 2], 81798, 0);
   jsvUnLock(HEAP32[$0 + 24 >> 2]);
   jsiExecuteEventCallbackArgsArray(HEAP32[$0 + 16 >> 2], HEAP32[$0 + 20 >> 2], HEAP32[$0 + 12 >> 2]);
   jsvUnLock(HEAP32[$0 + 12 >> 2]);
   jsvUnLock2(HEAP32[$0 + 20 >> 2], HEAP32[$0 + 16 >> 2]);
   continue;
  }
  break;
 }
 if (HEAP8[$0 + 31 | 0] & 1) {
  jsiSetBusy(1, 0);
  label$5 : {
   if (!(jspIsInterrupted() & 1)) {
    $2 = HEAPU32[80574] < jshGetTimeFromMilliseconds(100) >>> 0 ? 0 : 1;
    $1 = i64toi32_i32$HIGH_BITS;
    if (0 > ($1 | 0) ? 1 : 0 >= ($1 | 0) ? $2 : 0) {
     break label$5;
    }
   }
   HEAP8[322300] = 1;
  }
 }
 global$0 = $0 + 32 | 0;
}
function jsiAppendStringToInputLine($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsiIsAboutToEditInputLine();
 HEAP32[$1 + 8 >> 2] = 1;
 while (1) {
  if (HEAPU8[HEAP32[$1 + 12 >> 2] + HEAP32[$1 + 8 >> 2] | 0]) {
   HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
   continue;
  }
  break;
 }
 if (HEAP32[35419] < 0) {
  HEAP32[35419] = jsvGetStringLength(HEAP32[80557]);
 }
 label$4 : {
  if (HEAP32[80559] >= HEAP32[35419]) {
   jsiAppendToInputLine(HEAP32[$1 + 12 >> 2]);
   break label$4;
  }
  HEAP32[$1 + 4 >> 2] = jsvNewWithFlags(27);
  if (HEAPU32[80559] > 0) {
   jsvAppendStringVar(HEAP32[$1 + 4 >> 2], HEAP32[80557], 0, HEAP32[80559]);
  }
  jsvAppendString(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 12 >> 2]);
  jsvAppendStringVar(HEAP32[$1 + 4 >> 2], HEAP32[80557], HEAP32[80559], 2147483647);
  jsiInputLineCursorMoved();
  jsvUnLock(HEAP32[80557]);
  HEAP32[80557] = HEAP32[$1 + 4 >> 2];
  if (jsiShowInputLine() & 1) {
   jsiConsolePrintStringVarUntilEOL(HEAP32[80557], HEAP32[80559]);
  }
 }
 HEAP32[80559] = HEAP32[$1 + 8 >> 2] + HEAP32[80559];
 if (jsiShowInputLine() & 1) {
  jsiConsolePrintString(HEAP32[$1 + 12 >> 2]);
 }
 global$0 = $1 + 16 | 0;
}
function jswrap_storage_write($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 96 | 0;
 global$0 = $4;
 HEAP32[$4 + 92 >> 2] = $0;
 HEAP32[$4 + 88 >> 2] = $1;
 HEAP32[$4 + 84 >> 2] = $2;
 HEAP32[$4 + 80 >> 2] = $3;
 label$1 : {
  if (jsvIsObject(HEAP32[$4 + 88 >> 2]) & 1) {
   HEAP32[$4 + 76 >> 2] = jswrap_json_stringify(HEAP32[$4 + 88 >> 2], 0, 0);
   HEAP32[$4 + 84 >> 2] = 0;
   HEAP32[$4 + 80 >> 2] = 0;
   break label$1;
  }
  HEAP32[$4 + 76 >> 2] = jsvLockAgainSafe(HEAP32[$4 + 88 >> 2]);
 }
 jsfNameFromVar($4 + 40 | 0, HEAP32[$4 + 92 >> 2]);
 $0 = HEAP32[$4 + 76 >> 2];
 $1 = HEAP32[$4 + 84 >> 2];
 $2 = HEAP32[$4 + 80 >> 2];
 HEAP32[$4 + 32 >> 2] = HEAP32[$4 + 64 >> 2];
 $3 = HEAP32[$4 + 60 >> 2];
 HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 56 >> 2];
 HEAP32[$4 + 28 >> 2] = $3;
 $3 = HEAP32[$4 + 52 >> 2];
 HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 48 >> 2];
 HEAP32[$4 + 20 >> 2] = $3;
 $3 = HEAP32[$4 + 44 >> 2];
 HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 40 >> 2];
 HEAP32[$4 + 12 >> 2] = $3;
 HEAP8[$4 + 75 | 0] = jsfWriteFile($4 + 8 | 0, $0, 0, $1, $2) & 1;
 jsvUnLock(HEAP32[$4 + 76 >> 2]);
 global$0 = $4 + 96 | 0;
 return HEAP8[$4 + 75 | 0] & 1;
}
function lcdFillRect_ArrayBuffer_flat8($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0;
 $6 = global$0 - 48 | 0;
 HEAP32[$6 + 44 >> 2] = $0;
 HEAP32[$6 + 40 >> 2] = $1;
 HEAP32[$6 + 36 >> 2] = $2;
 HEAP32[$6 + 32 >> 2] = $3;
 HEAP32[$6 + 28 >> 2] = $4;
 HEAP32[$6 + 24 >> 2] = $5;
 HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 36 >> 2];
 while (1) {
  if (HEAP32[$6 + 20 >> 2] <= HEAP32[$6 + 28 >> 2]) {
   $0 = HEAP32[$6 + 44 >> 2];
   $1 = HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24);
   $0 = HEAP32[$6 + 44 >> 2];
   HEAP32[$6 + 16 >> 2] = $1 + (HEAP32[$6 + 40 >> 2] + Math_imul(HEAP32[$6 + 20 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) | 0);
   HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 40 >> 2];
   while (1) {
    if (HEAP32[$6 + 12 >> 2] <= HEAP32[$6 + 32 >> 2]) {
     $0 = HEAP32[$6 + 24 >> 2];
     $1 = HEAP32[$6 + 16 >> 2];
     HEAP32[$6 + 16 >> 2] = $1 + 1;
     HEAP8[$1 | 0] = $0;
     HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 12 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 20 >> 2] + 1;
   continue;
  }
  break;
 }
}
function jswrap_io_shiftOutCallback($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 24 >> 2];
 HEAP32[$2 + 12 >> 2] = 0;
 while (1) {
  if (HEAP32[$2 + 12 >> 2] < HEAP32[HEAP32[$2 + 20 >> 2] + 16 >> 2]) {
   HEAP32[$2 + 16 >> 2] = HEAP32[HEAP32[$2 + 20 >> 2] + 12 >> 2] - 1;
   while (1) {
    if (HEAP32[$2 + 16 >> 2] >= 0) {
     if (jshIsPinValid(HEAPU8[HEAP32[$2 + 20 >> 2] + HEAP32[$2 + 16 >> 2] | 0]) & 1) {
      jshPinSetValue(HEAPU8[HEAP32[$2 + 20 >> 2] + HEAP32[$2 + 16 >> 2] | 0], (HEAP32[$2 + 28 >> 2] & 1) != 0);
     }
     HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 28 >> 2] >> 1;
     HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 16 >> 2] + -1;
     continue;
    }
    break;
   }
   if (jshIsPinValid(HEAPU8[HEAP32[$2 + 20 >> 2] + 8 | 0]) & 1) {
    jshPinSetValue(HEAPU8[HEAP32[$2 + 20 >> 2] + 8 | 0], HEAP8[HEAP32[$2 + 20 >> 2] + 9 | 0] & 1);
    jshPinSetValue(HEAPU8[HEAP32[$2 + 20 >> 2] + 8 | 0], (HEAPU8[HEAP32[$2 + 20 >> 2] + 9 | 0] ^ -1) & 1);
   }
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $2 + 32 | 0;
}
function void_20tflite__reference_ops__Dequantize_unsigned_20char_2c_20float__28tflite__DequantizationParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 48 | 0;
 global$0 = $5;
 HEAP32[$5 + 44 >> 2] = $0;
 HEAP32[$5 + 40 >> 2] = $1;
 HEAP32[$5 + 36 >> 2] = $2;
 HEAP32[$5 + 32 >> 2] = $3;
 HEAP32[$5 + 28 >> 2] = $4;
 HEAP32[$5 + 24 >> 2] = HEAP32[HEAP32[$5 + 44 >> 2] + 8 >> 2];
 HEAPF64[$5 + 16 >> 3] = HEAPF64[HEAP32[$5 + 44 >> 2] >> 3];
 HEAP32[$5 + 12 >> 2] = tflite__MatchingFlatSize_28tflite__RuntimeShape_20const__2c_20tflite__RuntimeShape_20const__29(HEAP32[$5 + 40 >> 2], HEAP32[$5 + 32 >> 2]);
 HEAP32[$5 + 8 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 8 >> 2] < HEAP32[$5 + 12 >> 2]) {
   HEAP32[$5 + 4 >> 2] = HEAPU8[HEAP32[$5 + 36 >> 2] + HEAP32[$5 + 8 >> 2] | 0];
   HEAPF32[$5 >> 2] = HEAPF64[$5 + 16 >> 3] * +(HEAP32[$5 + 4 >> 2] - HEAP32[$5 + 24 >> 2] | 0);
   HEAPF32[HEAP32[$5 + 28 >> 2] + (HEAP32[$5 + 8 >> 2] << 2) >> 2] = HEAPF32[$5 >> 2];
   HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 8 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $5 + 48 | 0;
}
function jsvClearEmptyVarList() {
 var $0 = 0, $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[35541] = 1;
 HEAP16[71084] = 0;
 HEAP16[$1 + 14 >> 1] = 1;
 while (1) {
  if (HEAPU16[$1 + 14 >> 1] <= HEAPU32[35415]) {
   HEAP32[$1 + 8 >> 2] = jsvGetAddressOf(HEAPU16[$1 + 14 >> 1]);
   $0 = HEAP32[$1 + 8 >> 2];
   label$3 : {
    if (!((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63)) {
     $0 = HEAP32[$1 + 8 >> 2];
     HEAP8[$0 | 0] = 0;
     HEAP8[$0 + 1 | 0] = 0;
     HEAP8[$0 + 2 | 0] = 0;
     HEAP8[$0 + 3 | 0] = 0;
     HEAP8[$0 + 4 | 0] = 0;
     HEAP8[$0 + 5 | 0] = 0;
     HEAP8[$0 + 6 | 0] = 0;
     HEAP8[$0 + 7 | 0] = 0;
     HEAP8[$0 + 7 | 0] = 0;
     HEAP8[$0 + 8 | 0] = 0;
     HEAP8[$0 + 9 | 0] = 0;
     HEAP8[$0 + 10 | 0] = 0;
     HEAP8[$0 + 11 | 0] = 0;
     HEAP8[$0 + 12 | 0] = 0;
     HEAP8[$0 + 13 | 0] = 0;
     HEAP8[$0 + 14 | 0] = 0;
     break label$3;
    }
    if (jsvIsFlatString(HEAP32[$1 + 8 >> 2]) & 1) {
     HEAP16[$1 + 14 >> 1] = HEAPU16[$1 + 14 >> 1] + jsvGetFlatStringBlocks(HEAP32[$1 + 8 >> 2]);
    }
   }
   HEAP16[$1 + 14 >> 1] = HEAPU16[$1 + 14 >> 1] + 1;
   continue;
  }
  break;
 }
 HEAP32[35541] = 0;
 global$0 = $1 + 16 | 0;
}
function jsvArrayBufferIteratorSetIntegerValue($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 label$1 : {
  if (!HEAPU16[HEAP32[$2 + 28 >> 2] + 36 >> 1]) {
   break label$1;
  }
  HEAP32[$2 + 8 >> 2] = HEAPU16[HEAP32[$2 + 28 >> 2] + 36 >> 1] & 15;
  label$2 : {
   if (HEAPU16[HEAP32[$2 + 28 >> 2] + 36 >> 1] & 32) {
    jsvArrayBufferIteratorFloatToData($2 + 16 | 0, HEAP32[$2 + 8 >> 2], HEAPU16[HEAP32[$2 + 28 >> 2] + 36 >> 1], +HEAP32[$2 + 24 >> 2]);
    break label$2;
   }
   jsvArrayBufferIteratorIntToData($2 + 16 | 0, HEAP32[$2 + 8 >> 2], HEAPU16[HEAP32[$2 + 28 >> 2] + 36 >> 1], HEAP32[$2 + 24 >> 2]);
  }
  HEAP32[$2 + 12 >> 2] = 0;
  while (1) {
   if (HEAPU32[$2 + 12 >> 2] < HEAPU32[$2 + 8 >> 2]) {
    jsvStringIteratorSetChar(HEAP32[$2 + 28 >> 2], HEAP8[HEAP32[$2 + 12 >> 2] + ($2 + 16 | 0) | 0]);
    if (HEAP32[$2 + 8 >> 2] != 1) {
     jsvStringIteratorNext(HEAP32[$2 + 28 >> 2]);
    }
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
    continue;
   }
   break;
  }
  if (HEAP32[$2 + 8 >> 2] == 1) {
   break label$1;
  }
  HEAP8[HEAP32[$2 + 28 >> 2] + 52 | 0] = 1;
 }
 global$0 = $2 + 32 | 0;
}
function graphicsSetModified($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 32 | 0;
 HEAP32[$5 + 28 >> 2] = $0;
 HEAP32[$5 + 24 >> 2] = $1;
 HEAP32[$5 + 20 >> 2] = $2;
 HEAP32[$5 + 16 >> 2] = $3;
 HEAP32[$5 + 12 >> 2] = $4;
 $0 = HEAP32[$5 + 28 >> 2];
 if (HEAP32[$5 + 24 >> 2] < (HEAPU8[$0 + 40 | 0] | HEAPU8[$0 + 41 | 0] << 8) << 16 >> 16) {
  $0 = HEAP32[$5 + 28 >> 2];
  $1 = HEAP32[$5 + 24 >> 2];
  HEAP8[$0 + 40 | 0] = $1;
  HEAP8[$0 + 41 | 0] = $1 >>> 8;
 }
 $0 = HEAP32[$5 + 28 >> 2];
 if (HEAP32[$5 + 16 >> 2] > (HEAPU8[$0 + 44 | 0] | HEAPU8[$0 + 45 | 0] << 8) << 16 >> 16) {
  $0 = HEAP32[$5 + 28 >> 2];
  $1 = HEAP32[$5 + 16 >> 2];
  HEAP8[$0 + 44 | 0] = $1;
  HEAP8[$0 + 45 | 0] = $1 >>> 8;
 }
 $0 = HEAP32[$5 + 28 >> 2];
 if (HEAP32[$5 + 20 >> 2] < (HEAPU8[$0 + 42 | 0] | HEAPU8[$0 + 43 | 0] << 8) << 16 >> 16) {
  $0 = HEAP32[$5 + 28 >> 2];
  $1 = HEAP32[$5 + 20 >> 2];
  HEAP8[$0 + 42 | 0] = $1;
  HEAP8[$0 + 43 | 0] = $1 >>> 8;
 }
 $0 = HEAP32[$5 + 28 >> 2];
 if (HEAP32[$5 + 12 >> 2] > (HEAPU8[$0 + 46 | 0] | HEAPU8[$0 + 47 | 0] << 8) << 16 >> 16) {
  $0 = HEAP32[$5 + 28 >> 2];
  $1 = HEAP32[$5 + 12 >> 2];
  HEAP8[$0 + 46 | 0] = $1;
  HEAP8[$0 + 47 | 0] = $1 >>> 8;
 }
}
function void_20tflite__reference_ops__Dequantize_signed_20char_2c_20float__28tflite__DequantizationParams_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 48 | 0;
 global$0 = $5;
 HEAP32[$5 + 44 >> 2] = $0;
 HEAP32[$5 + 40 >> 2] = $1;
 HEAP32[$5 + 36 >> 2] = $2;
 HEAP32[$5 + 32 >> 2] = $3;
 HEAP32[$5 + 28 >> 2] = $4;
 HEAP32[$5 + 24 >> 2] = HEAP32[HEAP32[$5 + 44 >> 2] + 8 >> 2];
 HEAPF64[$5 + 16 >> 3] = HEAPF64[HEAP32[$5 + 44 >> 2] >> 3];
 HEAP32[$5 + 12 >> 2] = tflite__MatchingFlatSize_28tflite__RuntimeShape_20const__2c_20tflite__RuntimeShape_20const__29(HEAP32[$5 + 40 >> 2], HEAP32[$5 + 32 >> 2]);
 HEAP32[$5 + 8 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 8 >> 2] < HEAP32[$5 + 12 >> 2]) {
   HEAP32[$5 + 4 >> 2] = HEAP8[HEAP32[$5 + 36 >> 2] + HEAP32[$5 + 8 >> 2] | 0];
   HEAPF32[$5 >> 2] = HEAPF64[$5 + 16 >> 3] * +(HEAP32[$5 + 4 >> 2] - HEAP32[$5 + 24 >> 2] | 0);
   HEAPF32[HEAP32[$5 + 28 >> 2] + (HEAP32[$5 + 8 >> 2] << 2) >> 2] = HEAPF32[$5 >> 2];
   HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 8 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $5 + 48 | 0;
}
function jswrap_graphics_setFontAlign($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 96 | 0;
 global$0 = $4;
 HEAP32[$4 + 88 >> 2] = $0;
 HEAP32[$4 + 84 >> 2] = $1;
 HEAP32[$4 + 80 >> 2] = $2;
 HEAP32[$4 + 76 >> 2] = $3;
 label$1 : {
  if (!(graphicsGetFromVar($4, HEAP32[$4 + 88 >> 2]) & 1)) {
   HEAP32[$4 + 92 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$4 + 84 >> 2] < -1) {
   HEAP32[$4 + 84 >> 2] = -1;
  }
  if (HEAP32[$4 + 84 >> 2] > 1) {
   HEAP32[$4 + 84 >> 2] = 1;
  }
  if (HEAP32[$4 + 80 >> 2] < -1) {
   HEAP32[$4 + 80 >> 2] = -1;
  }
  if (HEAP32[$4 + 80 >> 2] > 1) {
   HEAP32[$4 + 80 >> 2] = 1;
  }
  if (HEAP32[$4 + 76 >> 2] < 0) {
   HEAP32[$4 + 76 >> 2] = 0;
  }
  if (HEAP32[$4 + 76 >> 2] > 3) {
   HEAP32[$4 + 76 >> 2] = 3;
  }
  HEAP8[$4 + 31 | 0] = HEAPU8[$4 + 84 | 0] & 3 | HEAPU8[$4 + 31 | 0] & 252;
  HEAP8[$4 + 31 | 0] = HEAPU8[$4 + 31 | 0] & 243 | (HEAPU8[$4 + 80 | 0] & 3) << 2;
  HEAP8[$4 + 31 | 0] = HEAPU8[$4 + 31 | 0] & -49 | (HEAPU8[$4 + 76 | 0] & 3) << 4;
  graphicsSetVar($4);
  HEAP32[$4 + 92 >> 2] = jsvLockAgain(HEAP32[$4 + 88 >> 2]);
 }
 global$0 = $4 + 96 | 0;
 return HEAP32[$4 + 92 >> 2];
}
function jswrap_object_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 label$1 : {
  label$2 : {
   label$3 : {
    if (jsvIsObject(HEAP32[$1 + 24 >> 2]) & 1) {
     break label$3;
    }
    if (jsvIsArray(HEAP32[$1 + 24 >> 2]) & 1) {
     break label$3;
    }
    if (!(jsvIsFunction(HEAP32[$1 + 24 >> 2]) & 1)) {
     break label$2;
    }
   }
   HEAP32[$1 + 28 >> 2] = jsvLockAgain(HEAP32[$1 + 24 >> 2]);
   break label$1;
  }
  HEAP32[$1 + 20 >> 2] = jswGetBasicObjectName(HEAP32[$1 + 24 >> 2]);
  $0 = $1;
  label$4 : {
   if (HEAP32[$1 + 20 >> 2]) {
    $2 = jspGetNamedVariable(HEAP32[$1 + 20 >> 2]);
    break label$4;
   }
   $2 = 0;
  }
  HEAP32[$0 + 16 >> 2] = $2;
  if (!HEAP32[$1 + 16 >> 2]) {
   HEAP32[$1 + 28 >> 2] = jsvNewWithFlags(5);
   break label$1;
  }
  $0 = $1 + 24 | 0;
  HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[$1 + 16 >> 2]);
  HEAP32[$1 + 8 >> 2] = jspeFunctionCall(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 16 >> 2], 0, 0, 1, $0);
  jsvUnLock2(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 12 >> 2]);
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 8 >> 2];
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function _jswrap_drawImageLayerNextY($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 + 172 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 168 >> 2] + HEAP32[$0 + 172 >> 2];
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 + 176 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 164 >> 2] + HEAP32[$0 + 176 >> 2];
 if (HEAP8[HEAP32[$1 + 12 >> 2] + 33 | 0] & 1) {
  if (HEAP32[HEAP32[$1 + 12 >> 2] + 172 >> 2] < 0) {
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$0 + 172 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 156 >> 2] + HEAP32[$0 + 172 >> 2];
  }
  if (HEAP32[HEAP32[$1 + 12 >> 2] + 172 >> 2] >= HEAP32[HEAP32[$1 + 12 >> 2] + 156 >> 2]) {
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$0 + 172 >> 2] = HEAP32[$0 + 172 >> 2] - HEAP32[HEAP32[$1 + 12 >> 2] + 156 >> 2];
  }
  if (HEAP32[HEAP32[$1 + 12 >> 2] + 176 >> 2] < 0) {
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$0 + 176 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 160 >> 2] + HEAP32[$0 + 176 >> 2];
  }
  if (HEAP32[HEAP32[$1 + 12 >> 2] + 176 >> 2] >= HEAP32[HEAP32[$1 + 12 >> 2] + 160 >> 2]) {
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$0 + 176 >> 2] = HEAP32[$0 + 176 >> 2] - HEAP32[HEAP32[$1 + 12 >> 2] + 160 >> 2];
  }
 }
}
function _jswrap_espruino_FFT_setData($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 96 | 0;
 global$0 = $4;
 HEAP32[$4 + 92 >> 2] = $0;
 HEAP32[$4 + 88 >> 2] = $1;
 HEAP32[$4 + 84 >> 2] = $2;
 HEAP32[$4 + 80 >> 2] = $3;
 jsvIteratorNew($4 + 16 | 0, HEAP32[$4 + 92 >> 2], 1);
 HEAP32[$4 + 12 >> 2] = 0;
 while (1) {
  if (HEAPU32[$4 + 12 >> 2] < HEAPU32[$4 + 80 >> 2]) {
   $0 = jsvIteratorHasElement($4 + 16 | 0);
  } else {
   $0 = 0;
  }
  if ($0 & 1) {
   label$5 : {
    if (HEAP32[$4 + 84 >> 2]) {
     HEAPF64[$4 >> 3] = jswrap_math_sqrt(HEAPF64[HEAP32[$4 + 88 >> 2] + (HEAP32[$4 + 12 >> 2] << 3) >> 3] * HEAPF64[HEAP32[$4 + 88 >> 2] + (HEAP32[$4 + 12 >> 2] << 3) >> 3] + HEAPF64[HEAP32[$4 + 84 >> 2] + (HEAP32[$4 + 12 >> 2] << 3) >> 3] * HEAPF64[HEAP32[$4 + 84 >> 2] + (HEAP32[$4 + 12 >> 2] << 3) >> 3]);
     break label$5;
    }
    HEAPF64[$4 >> 3] = HEAPF64[HEAP32[$4 + 88 >> 2] + (HEAP32[$4 + 12 >> 2] << 3) >> 3];
   }
   $0 = $4 + 16 | 0;
   jsvUnLock(jsvIteratorSetValue($0, jsvNewFromFloat(HEAPF64[$4 >> 3])));
   HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 12 >> 2] + 1;
   jsvIteratorNext($0);
   continue;
  }
  break;
 }
 jsvIteratorFree($4 + 16 | 0);
 global$0 = $4 + 96 | 0;
}
function _jswrap_graphics_getFontInfo($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[HEAP32[$2 + 8 >> 2] >> 2] = (HEAPU8[$0 + 25 | 0] | HEAPU8[$0 + 26 | 0] << 8) & 57344;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP16[HEAP32[$2 + 8 >> 2] + 4 >> 1] = (HEAPU8[$0 + 25 | 0] | HEAPU8[$0 + 26 | 0] << 8) & 8191;
 HEAP16[HEAP32[$2 + 8 >> 2] + 6 >> 1] = HEAPU16[HEAP32[$2 + 8 >> 2] + 4 >> 1];
 HEAP16[HEAP32[$2 + 8 >> 2] + 8 >> 1] = HEAPU16[HEAP32[$2 + 8 >> 2] + 4 >> 1];
 if (HEAPU16[HEAP32[$2 + 8 >> 2] + 4 >> 1] & 4096) {
  HEAP16[HEAP32[$2 + 8 >> 2] + 6 >> 1] = HEAPU16[HEAP32[$2 + 8 >> 2] + 4 >> 1] & 63;
  HEAP16[HEAP32[$2 + 8 >> 2] + 8 >> 1] = (HEAPU16[HEAP32[$2 + 8 >> 2] + 4 >> 1] & 4032) >> 6;
 }
 label$2 : {
  if (HEAP32[HEAP32[$2 + 8 >> 2] >> 2] & 32768) {
   $0 = HEAP32[$2 + 12 >> 2];
   $0 = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 127562, 0));
   HEAP8[HEAP32[$2 + 8 >> 2] + 10 | 0] = $0;
   break label$2;
  }
  HEAP8[HEAP32[$2 + 8 >> 2] + 10 | 0] = 0;
 }
 global$0 = $2 + 16 | 0;
}
function TfLiteTypeGetName($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 $0 = HEAP32[$1 + 8 >> 2];
 label$1 : {
  if ($0 >>> 0 <= 12) {
   label$3 : {
    switch ($0 - 1 | 0) {
    default:
     HEAP32[$1 + 12 >> 2] = 109568;
     break label$1;
    case 0:
     HEAP32[$1 + 12 >> 2] = 109575;
     break label$1;
    case 6:
     HEAP32[$1 + 12 >> 2] = 109583;
     break label$1;
    case 1:
     HEAP32[$1 + 12 >> 2] = 109589;
     break label$1;
    case 2:
     HEAP32[$1 + 12 >> 2] = 109595;
     break label$1;
    case 8:
     HEAP32[$1 + 12 >> 2] = 109601;
     break label$1;
    case 3:
     HEAP32[$1 + 12 >> 2] = 109606;
     break label$1;
    case 5:
     HEAP32[$1 + 12 >> 2] = 109612;
     break label$1;
    case 7:
     HEAP32[$1 + 12 >> 2] = 109617;
     break label$1;
    case 11:
     HEAP32[$1 + 12 >> 2] = 109627;
     break label$1;
    case 4:
     HEAP32[$1 + 12 >> 2] = 109638;
     break label$1;
    case 9:
     HEAP32[$1 + 12 >> 2] = 109645;
     break label$1;
    case 10:
     break label$3;
    }
   }
   HEAP32[$1 + 12 >> 2] = 109653;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 109661;
 }
 return HEAP32[$1 + 12 >> 2];
}
function void_20tflite__reference_ops__Dequantize_short_2c_20float__28tflite__DequantizationParams_20const__2c_20tflite__RuntimeShape_20const__2c_20short_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 48 | 0;
 global$0 = $5;
 HEAP32[$5 + 44 >> 2] = $0;
 HEAP32[$5 + 40 >> 2] = $1;
 HEAP32[$5 + 36 >> 2] = $2;
 HEAP32[$5 + 32 >> 2] = $3;
 HEAP32[$5 + 28 >> 2] = $4;
 HEAP32[$5 + 24 >> 2] = HEAP32[HEAP32[$5 + 44 >> 2] + 8 >> 2];
 HEAPF64[$5 + 16 >> 3] = HEAPF64[HEAP32[$5 + 44 >> 2] >> 3];
 HEAP32[$5 + 12 >> 2] = tflite__MatchingFlatSize_28tflite__RuntimeShape_20const__2c_20tflite__RuntimeShape_20const__29(HEAP32[$5 + 40 >> 2], HEAP32[$5 + 32 >> 2]);
 HEAP32[$5 + 8 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 8 >> 2] < HEAP32[$5 + 12 >> 2]) {
   HEAP32[$5 + 4 >> 2] = HEAP16[HEAP32[$5 + 36 >> 2] + (HEAP32[$5 + 8 >> 2] << 1) >> 1];
   HEAPF32[$5 >> 2] = HEAPF64[$5 + 16 >> 3] * +(HEAP32[$5 + 4 >> 2] - HEAP32[$5 + 24 >> 2] | 0);
   HEAPF32[HEAP32[$5 + 28 >> 2] + (HEAP32[$5 + 8 >> 2] << 2) >> 2] = HEAPF32[$5 >> 2];
   HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 8 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $5 + 48 | 0;
}
function tflite__GreedyMemoryPlanner__GetMaximumMemorySize_28_29($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 $0 = HEAP32[$1 + 24 >> 2];
 tflite__GreedyMemoryPlanner__CalculateOffsetsIfNeeded_28_29($0);
 label$1 : {
  if (!HEAP32[$0 + 8 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 20 >> 2] = HEAP32[$0 + 24 >> 2] + Math_imul(HEAP32[$0 + 32 >> 2], 12);
  HEAP32[$1 + 16 >> 2] = 0;
  while (1) {
   label$4 : {
    if (!HEAP32[$1 + 20 >> 2]) {
     break label$4;
    }
    HEAP32[$1 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + (HEAP32[HEAP32[$1 + 20 >> 2] + 4 >> 2] << 4);
    HEAP32[$1 + 8 >> 2] = HEAP32[HEAP32[$1 + 20 >> 2] >> 2] + HEAP32[HEAP32[$1 + 12 >> 2] >> 2];
    if (HEAPU32[$1 + 8 >> 2] > HEAPU32[$1 + 16 >> 2]) {
     HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 8 >> 2];
    }
    if (HEAP32[HEAP32[$1 + 20 >> 2] + 8 >> 2] == -1) {
     break label$4;
    }
    HEAP32[$1 + 20 >> 2] = HEAP32[$0 + 24 >> 2] + Math_imul(HEAP32[HEAP32[$1 + 20 >> 2] + 8 >> 2], 12);
    continue;
   }
   break;
  }
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 16 >> 2];
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function jswrap_dataview_set($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 96 | 0;
 global$0 = $5;
 HEAP32[$5 + 92 >> 2] = $0;
 HEAP16[$5 + 90 >> 1] = $1;
 HEAP32[$5 + 84 >> 2] = $2;
 HEAP32[$5 + 80 >> 2] = $3;
 HEAP8[$5 + 79 | 0] = $4;
 HEAP32[$5 + 72 >> 2] = jsvObjectGetChild(HEAP32[$5 + 92 >> 2], 119561, 0);
 label$1 : {
  if (!(jsvIsArrayBuffer(HEAP32[$5 + 72 >> 2]) & 1)) {
   jsvUnLock(HEAP32[$5 + 72 >> 2]);
   break label$1;
  }
  HEAP32[$5 + 84 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$5 + 92 >> 2], 119568, 0)) + HEAP32[$5 + 84 >> 2];
  HEAP32[$5 + 68 >> 2] = HEAPU16[$5 + 90 >> 1] & 15;
  if (!(HEAP8[$5 + 79 | 0] & 1)) {
   HEAP16[$5 + 90 >> 1] = HEAPU16[$5 + 90 >> 1] | 256;
  }
  HEAP32[$5 + 64 >> 2] = jswrap_typedarray_constructor(HEAPU16[$5 + 90 >> 1], HEAP32[$5 + 72 >> 2], HEAP32[$5 + 84 >> 2], HEAP32[$5 + 68 >> 2]);
  jsvUnLock(HEAP32[$5 + 72 >> 2]);
  if (!HEAP32[$5 + 64 >> 2]) {
   break label$1;
  }
  $0 = $5 + 8 | 0;
  jsvArrayBufferIteratorNew($0, HEAP32[$5 + 64 >> 2], 0);
  jsvArrayBufferIteratorSetValue($0, HEAP32[$5 + 80 >> 2]);
  jsvArrayBufferIteratorFree($0);
  jsvUnLock(HEAP32[$5 + 64 >> 2]);
 }
 global$0 = $5 + 96 | 0;
}
function jspGetNamedField($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP8[$3 + 19 | 0] = $2;
 HEAP32[$3 + 12 >> 2] = 0;
 if (jsvHasChildren(HEAP32[$3 + 24 >> 2]) & 1) {
  HEAP32[$3 + 12 >> 2] = jsvFindChildFromString(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], 0);
 }
 if (!HEAP32[$3 + 12 >> 2]) {
  HEAP32[$3 + 12 >> 2] = jspGetNamedFieldInParents(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP8[$3 + 19 | 0] & 1);
  label$3 : {
   if (HEAP32[$3 + 12 >> 2]) {
    break label$3;
   }
   if (!(jsvIsFunction(HEAP32[$3 + 24 >> 2]) & 1)) {
    break label$3;
   }
   if (strcmp(HEAP32[$3 + 20 >> 2], 79516)) {
    break label$3;
   }
   HEAP32[$3 + 8 >> 2] = jsvNewWithFlags(5);
   HEAP32[$3 + 12 >> 2] = jsvAddNamedChild(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 8 >> 2], 79516);
   jsvUnLock(HEAP32[$3 + 8 >> 2]);
  }
 }
 label$4 : {
  if (HEAP8[$3 + 19 | 0] & 1) {
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2];
   break label$4;
  }
  HEAP32[$3 + 28 >> 2] = jsvSkipNameAndUnLock(HEAP32[$3 + 12 >> 2]);
 }
 global$0 = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}
function jshGetDeviceString($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP8[$1 + 11 | 0] = $0;
 label$1 : {
  label$2 : {
   $0 = HEAPU8[$1 + 11 | 0];
   if ($0 >>> 0 > 25) {
    break label$2;
   }
   label$3 : {
    switch ($0 - 1 | 0) {
    default:
     HEAP32[$1 + 12 >> 2] = 83129;
     break label$1;
    case 16:
     HEAP32[$1 + 12 >> 2] = 83134;
     break label$1;
    case 17:
     HEAP32[$1 + 12 >> 2] = 83144;
     break label$1;
    case 18:
     HEAP32[$1 + 12 >> 2] = 83154;
     break label$1;
    case 20:
     HEAP32[$1 + 12 >> 2] = 83160;
     break label$1;
    case 19:
     HEAP32[$1 + 12 >> 2] = 83164;
     break label$1;
    case 21:
     HEAP32[$1 + 12 >> 2] = 83173;
     break label$1;
    case 23:
     HEAP32[$1 + 12 >> 2] = 83181;
     break label$1;
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 22:
     break label$2;
    case 24:
     break label$3;
    }
   }
   HEAP32[$1 + 12 >> 2] = 83186;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 83191;
 }
 return HEAP32[$1 + 12 >> 2];
}
function __lshrti3($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 label$1 : {
  label$2 : {
   if ($5 & 64) {
    $2 = $5 + -64 | 0;
    $1 = $2 & 31;
    if (32 <= ($2 & 63) >>> 0) {
     $2 = 0;
     $1 = $4 >>> $1;
    } else {
     $2 = $4 >>> $1;
     $1 = ((1 << $1) - 1 & $4) << 32 - $1 | $3 >>> $1;
    }
    $3 = 0;
    $4 = 0;
    break label$2;
   }
   if (!$5) {
    break label$1;
   }
   $7 = $4;
   $8 = $3;
   $9 = 64 - $5 | 0;
   $6 = $9 & 31;
   if (32 <= ($9 & 63) >>> 0) {
    $7 = $8 << $6;
    $9 = 0;
   } else {
    $7 = (1 << $6) - 1 & $8 >>> 32 - $6 | $7 << $6;
    $9 = $8 << $6;
   }
   $8 = $1;
   $6 = $5;
   $1 = $6 & 31;
   if (32 <= ($6 & 63) >>> 0) {
    $6 = 0;
    $1 = $2 >>> $1;
   } else {
    $6 = $2 >>> $1;
    $1 = ((1 << $1) - 1 & $2) << 32 - $1 | $8 >>> $1;
   }
   $1 = $9 | $1;
   $2 = $6 | $7;
   $6 = $3;
   $3 = $5 & 31;
   if (32 <= ($5 & 63) >>> 0) {
    $7 = 0;
    $3 = $4 >>> $3;
   } else {
    $7 = $4 >>> $3;
    $3 = ((1 << $3) - 1 & $4) << 32 - $3 | $6 >>> $3;
   }
   $4 = $7;
  }
 }
 HEAP32[$0 >> 2] = $1;
 HEAP32[$0 + 4 >> 2] = $2;
 HEAP32[$0 + 8 >> 2] = $3;
 HEAP32[$0 + 12 >> 2] = $4;
}
function lcdMemLCD_flip($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 $2 = (HEAPU8[$0 + 42 | 0] | HEAPU8[$0 + 43 | 0] << 8) << 16 >> 16;
 $0 = HEAP32[$1 + 12 >> 2];
 if (($2 | 0) <= (HEAPU8[$0 + 46 | 0] | HEAPU8[$0 + 47 | 0] << 8) << 16 >> 16) {
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP32[$1 + 8 >> 2] = (HEAPU8[$0 + 42 | 0] | HEAPU8[$0 + 43 | 0] << 8) << 16 >> 16;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP32[$1 + 4 >> 2] = (HEAPU8[$0 + 46 | 0] | HEAPU8[$0 + 47 | 0] << 8) << 16 >> 16;
  HEAP32[$1 >> 2] = (HEAP32[$1 + 4 >> 2] + 1 | 0) - HEAP32[$1 + 8 >> 2];
  jshPinSetValue(5, 1);
  jshSPISendMany(24, Math_imul(HEAP32[$1 + 8 >> 2], 68) + 324608 | 0, 0, Math_imul(HEAP32[$1 >> 2], 68) + 2 | 0);
  jshPinSetValue(5, 0);
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP8[$0 + 44 | 0] = 32768;
  HEAP8[$0 + 45 | 0] = 128;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP8[$0 + 46 | 0] = 32768;
  HEAP8[$0 + 47 | 0] = 128;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP8[$0 + 40 | 0] = 32767;
  HEAP8[$0 + 41 | 0] = 127;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP8[$0 + 42 | 0] = 32767;
  HEAP8[$0 + 43 | 0] = 127;
 }
 global$0 = $1 + 16 | 0;
}
function jsvSetCharactersInVar($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 + 4 >> 2] = (HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP16[$2 + 2 >> 1] = (HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & -64;
 label$1 : {
  if (HEAPU32[$2 + 4 >> 2] <= 26) {
   if (HEAPU32[$2 + 4 >> 2] <= 21) {
    $0 = HEAP32[$2 + 12 >> 2];
    $1 = HEAPU16[$2 + 2 >> 1] | HEAP32[$2 + 8 >> 2] + 17;
    HEAP8[$0 + 13 | 0] = $1;
    HEAP8[$0 + 14 | 0] = $1 >>> 8;
    break label$1;
   }
   $0 = HEAP32[$2 + 12 >> 2];
   $1 = HEAPU16[$2 + 2 >> 1] | HEAP32[$2 + 8 >> 2] + 22;
   HEAP8[$0 + 13 | 0] = $1;
   HEAP8[$0 + 14 | 0] = $1 >>> 8;
   break label$1;
  }
  label$4 : {
   if (HEAPU32[$2 + 4 >> 2] <= 37) {
    $0 = HEAP32[$2 + 12 >> 2];
    $1 = HEAPU16[$2 + 2 >> 1] | HEAP32[$2 + 8 >> 2] + 27;
    HEAP8[$0 + 13 | 0] = $1;
    HEAP8[$0 + 14 | 0] = $1 >>> 8;
    break label$4;
   }
   $0 = HEAP32[$2 + 12 >> 2];
   $1 = HEAPU16[$2 + 2 >> 1] | HEAP32[$2 + 8 >> 2] + 41;
   HEAP8[$0 + 13 | 0] = $1;
   HEAP8[$0 + 14 | 0] = $1 >>> 8;
  }
 }
}
function jswrap_dataview_constructor($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 label$1 : {
  label$2 : {
   if (jsvIsArrayBuffer(HEAP32[$3 + 24 >> 2]) & 1) {
    $0 = HEAP32[$3 + 24 >> 2];
    if ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8) == 129) {
     break label$2;
    }
   }
   HEAP32[$3 >> 2] = HEAP32[$3 + 24 >> 2];
   jsExceptionHere(3, 119522, $3);
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = jspNewObject(0, 119552);
  if (HEAP32[$3 + 12 >> 2]) {
   jsvObjectSetChild(HEAP32[$3 + 12 >> 2], 119561, HEAP32[$3 + 24 >> 2]);
   jsvObjectSetChildAndUnLock(HEAP32[$3 + 12 >> 2], 119568, jsvNewFromInteger(HEAP32[$3 + 20 >> 2]));
   $0 = HEAP32[$3 + 12 >> 2];
   if (HEAP32[$3 + 16 >> 2]) {
    $1 = HEAP32[$3 + 16 >> 2];
   } else {
    $1 = jsvGetArrayBufferLength(HEAP32[$3 + 24 >> 2]);
   }
   jsvObjectSetChildAndUnLock($0, 119579, jsvNewFromInteger($1));
  }
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2];
 }
 global$0 = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}
function int_20gemmlowp__SaturatingRoundingDoublingHighMul_int__28int_2c_20int_29($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP32[$2 + 44 >> 2] = $0;
 HEAP32[$2 + 40 >> 2] = $1;
 HEAP8[$2 + 39 | 0] = HEAP32[$2 + 44 >> 2] == HEAP32[$2 + 40 >> 2] ? HEAP32[$2 + 44 >> 2] == -2147483648 : 0;
 $0 = HEAP32[$2 + 44 >> 2];
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 28 >> 2] = $0 >> 31;
 $0 = HEAP32[$2 + 40 >> 2];
 HEAP32[$2 + 16 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $0 >> 31;
 HEAP32[$2 + 8 >> 2] = __wasm_i64_mul(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 20 >> 2]);
 HEAP32[$2 + 12 >> 2] = i64toi32_i32$HIGH_BITS;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 + 4 >> 2] = (($0 | 0) > 0 ? 1 : ($0 | 0) >= 0 ? HEAPU32[$2 + 8 >> 2] < 0 ? 0 : 1 : 0) ? 1073741824 : -1073741823;
 $0 = HEAP32[$2 + 4 >> 2];
 $3 = $0;
 $1 = $0 + HEAP32[$2 + 8 >> 2] | 0;
 $0 = HEAP32[$2 + 12 >> 2] + ($0 >> 31) | 0;
 HEAP32[$2 >> 2] = __wasm_i64_sdiv($1, $1 >>> 0 < $3 >>> 0 ? $0 + 1 | 0 : $0, -2147483648);
 global$0 = $2 + 48 | 0;
 if (HEAP8[$2 + 39 | 0] & 1) {
  $0 = 2147483647;
 } else {
  $0 = HEAP32[$2 >> 2];
 }
 return $0;
}
function jsvStringTrimRight($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = global$0 - 96 | 0;
 global$0 = $1;
 $2 = $1 + 16 | 0;
 $3 = $1 + 56 | 0;
 HEAP32[$1 + 92 >> 2] = $0;
 HEAP32[$1 + 12 >> 2] = jsvNewWithFlags(27);
 jsvStringIteratorNew($3, HEAP32[$1 + 92 >> 2], 0);
 jsvStringIteratorNew($2, HEAP32[$1 + 12 >> 2], 0);
 HEAP32[$1 + 8 >> 2] = 0;
 while (1) {
  if (jsvStringIteratorHasChar($1 + 56 | 0) & 1) {
   HEAP8[$1 + 7 | 0] = jsvStringIteratorGetCharAndNext($1 + 56 | 0);
   label$3 : {
    if (HEAP8[$1 + 7 | 0] == 32) {
     HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
     break label$3;
    }
    label$5 : {
     if (HEAP8[$1 + 7 | 0] == 10) {
      HEAP32[$1 + 8 >> 2] = 0;
      break label$5;
     }
     while (1) {
      if (HEAP32[$1 + 8 >> 2] > 0) {
       jsvStringIteratorAppend($1 + 16 | 0, 32);
       HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + -1;
       continue;
      }
      break;
     }
    }
    jsvStringIteratorAppend($1 + 16 | 0, HEAP8[$1 + 7 | 0]);
   }
   continue;
  }
  break;
 }
 $0 = $1 + 16 | 0;
 jsvStringIteratorFree($1 + 56 | 0);
 jsvStringIteratorFree($0);
 global$0 = $1 + 96 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function tflite__TfLiteEvalTensorByteLength_28TfLiteEvalTensor_20const__2c_20unsigned_20long__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1 : {
  if (!HEAP32[$2 + 20 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$2 + 16 >> 2] = 1;
 if (HEAP32[HEAP32[$2 + 24 >> 2] + 4 >> 2]) {
  HEAP32[$2 + 12 >> 2] = 0;
  while (1) {
   if (HEAP32[$2 + 12 >> 2] < HEAP32[HEAP32[HEAP32[$2 + 24 >> 2] + 4 >> 2] >> 2]) {
    HEAP32[$2 + 16 >> 2] = Math_imul(HEAP32[(HEAP32[HEAP32[$2 + 24 >> 2] + 4 >> 2] + 4 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2], HEAP32[$2 + 16 >> 2]);
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
    continue;
   }
   break;
  }
 }
 HEAP32[$2 + 4 >> 2] = tflite__TfLiteTypeSizeOf_28TfLiteType_2c_20unsigned_20long__29(HEAP32[HEAP32[$2 + 24 >> 2] + 8 >> 2], $2 + 8 | 0);
 label$5 : {
  if (HEAP32[$2 + 4 >> 2]) {
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 4 >> 2];
   break label$5;
  }
  HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = Math_imul(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 8 >> 2]);
  HEAP32[$2 + 28 >> 2] = 0;
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function tflite__MicroAllocator__PopulateTfLiteTensorFromFlatbuffer_28tflite__Model_20const__2c_20tflite__SubGraph_20const__2c_20TfLiteTensor__2c_20int_2c_20bool_29($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0;
 $6 = global$0 - 32 | 0;
 global$0 = $6;
 HEAP32[$6 + 28 >> 2] = $0;
 HEAP32[$6 + 24 >> 2] = $1;
 HEAP32[$6 + 20 >> 2] = $2;
 HEAP32[$6 + 16 >> 2] = $3;
 HEAP32[$6 + 12 >> 2] = $4;
 HEAP8[$6 + 11 | 0] = $5;
 $0 = HEAP32[$6 + 28 >> 2];
 $0 = tflite__internal__InitializeTfLiteTensorFromFlatbuffer_28tflite__SimpleMemoryAllocator__2c_20bool_2c_20tflite__Tensor_20const__2c_20flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer__20__20const__2c_20tflite__ErrorReporter__2c_20TfLiteTensor__29(HEAP32[$0 + 4 >> 2], HEAP8[$6 + 11 | 0] & 1, flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph__20___Get_28unsigned_20int_29_20const(tflite__Tensor__shape_28_29_20const(HEAP32[$6 + 20 >> 2]), HEAP32[$6 + 12 >> 2]), tflite__Tensor__quantization_28_29_20const(HEAP32[$6 + 24 >> 2]), HEAP32[$0 + 8 >> 2], HEAP32[$6 + 16 >> 2]);
 global$0 = $6 + 32 | 0;
 return $0 | 0;
}
function tflite__GreedyMemoryPlanner__GreedyMemoryPlanner_28unsigned_20char__2c_20int_29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 $1 = global$0 - 16 | 0;
 $0 = HEAP32[$3 + 28 >> 2];
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[HEAP32[$1 + 12 >> 2] >> 2] = 136456;
 HEAP32[$0 >> 2] = 136488;
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP8[$0 + 40 | 0] = 1;
 $1 = HEAP32[$3 + 20 >> 2];
 HEAP32[(global$0 - 16 | 0) + 12 >> 2] = 40;
 HEAP32[$0 + 4 >> 2] = ($1 >>> 0) / 40;
 HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 24 >> 2];
 HEAP32[$0 + 12 >> 2] = HEAP32[$3 + 8 >> 2];
 HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 8 >> 2] + (HEAP32[$0 + 4 >> 2] << 4);
 HEAP32[$0 + 16 >> 2] = HEAP32[$3 + 8 >> 2];
 HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 8 >> 2] + (HEAP32[$0 + 4 >> 2] << 2);
 HEAP32[$0 + 20 >> 2] = HEAP32[$3 + 8 >> 2];
 HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 8 >> 2] + (HEAP32[$0 + 4 >> 2] << 2);
 HEAP32[$0 + 24 >> 2] = HEAP32[$3 + 8 >> 2];
 HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 8 >> 2] + Math_imul(HEAP32[$0 + 4 >> 2], 12);
 HEAP32[$0 + 36 >> 2] = HEAP32[$3 + 8 >> 2];
 global$0 = $3 + 32 | 0;
}
function tflite__GreedyMemoryPlanner__AddBuffer_28tflite__ErrorReporter__2c_20int_2c_20int_2c_20int_29($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0;
 $5 = global$0 - 32 | 0;
 global$0 = $5;
 HEAP32[$5 + 24 >> 2] = $0;
 HEAP32[$5 + 20 >> 2] = $1;
 HEAP32[$5 + 16 >> 2] = $2;
 HEAP32[$5 + 12 >> 2] = $3;
 HEAP32[$5 + 8 >> 2] = $4;
 $0 = HEAP32[$5 + 24 >> 2];
 label$1 : {
  if (HEAP32[$0 + 8 >> 2] >= HEAP32[$0 + 4 >> 2]) {
   $1 = HEAP32[$5 + 20 >> 2];
   HEAP32[$5 >> 2] = HEAP32[$0 + 4 >> 2];
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($1, 136512, $5);
   HEAP32[$5 + 28 >> 2] = 1;
   break label$1;
  }
  HEAP32[$5 + 4 >> 2] = HEAP32[$0 + 12 >> 2] + (HEAP32[$0 + 8 >> 2] << 4);
  HEAP32[HEAP32[$5 + 4 >> 2] >> 2] = HEAP32[$5 + 16 >> 2];
  HEAP32[HEAP32[$5 + 4 >> 2] + 8 >> 2] = HEAP32[$5 + 12 >> 2];
  HEAP32[HEAP32[$5 + 4 >> 2] + 12 >> 2] = HEAP32[$5 + 8 >> 2];
  HEAP32[HEAP32[$5 + 4 >> 2] + 4 >> 2] = -1;
  HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 8 >> 2] + 1;
  HEAP8[$0 + 40 | 0] = 1;
  HEAP32[$5 + 28 >> 2] = 0;
 }
 global$0 = $5 + 32 | 0;
 return HEAP32[$5 + 28 >> 2];
}
function jsiConsolePrintStringVarUntilEOL($0, $1) {
 var $2 = 0;
 $2 = global$0 + -64 | 0;
 global$0 = $2;
 HEAP32[$2 + 60 >> 2] = $0;
 HEAP32[$2 + 56 >> 2] = $1;
 HEAP32[$2 + 52 >> 2] = -1;
 HEAP8[$2 + 51 | 0] = 1;
 HEAP32[$2 + 44 >> 2] = 0;
 jsvStringIteratorNew($2 + 8 | 0, HEAP32[$2 + 60 >> 2], HEAP32[$2 + 56 >> 2]);
 while (1) {
  label$2 : {
   if (jsvStringIteratorHasChar($2 + 8 | 0) & 1) {
    $0 = HEAPU32[$2 + 44 >> 2] < HEAPU32[$2 + 52 >> 2];
   } else {
    $0 = 0;
   }
   if (!$0) {
    break label$2;
   }
   HEAP8[$2 + 7 | 0] = jsvStringIteratorGetCharAndNext($2 + 8 | 0);
   if (HEAP8[$2 + 7 | 0] == 10) {
    break label$2;
   }
   jsiConsolePrintChar(HEAP8[$2 + 7 | 0]);
   HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 44 >> 2] + 1;
   continue;
  }
  break;
 }
 jsvStringIteratorFree($2 + 8 | 0);
 if (HEAP8[$2 + 51 | 0] & 1) {
  jsiConsolePrintChar(32);
  HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 44 >> 2] + 1;
  while (1) {
   label$7 : {
    $0 = HEAP32[$2 + 44 >> 2];
    HEAP32[$2 + 44 >> 2] = $0 + -1;
    if (!$0) {
     break label$7;
    }
    jsiConsolePrintChar(8);
    continue;
   }
   break;
  }
 }
 global$0 = $2 - -64 | 0;
}
function jswrap_espruino_getErrorFlagArray($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 11 | 0] = $0;
 HEAP32[$1 + 4 >> 2] = jsvNewWithFlags(3);
 label$1 : {
  if (!HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  if (HEAP8[$1 + 11 | 0] & 1) {
   jsvArrayPushAndUnLock(HEAP32[$1 + 4 >> 2], jsvNewFromString(120353));
  }
  if (HEAPU8[$1 + 11 | 0] & 2) {
   jsvArrayPushAndUnLock(HEAP32[$1 + 4 >> 2], jsvNewFromString(120363));
  }
  if (HEAPU8[$1 + 11 | 0] & 4) {
   jsvArrayPushAndUnLock(HEAP32[$1 + 4 >> 2], jsvNewFromString(120375));
  }
  if (HEAPU8[$1 + 11 | 0] & 8) {
   jsvArrayPushAndUnLock(HEAP32[$1 + 4 >> 2], jsvNewFromString(120384));
  }
  if (HEAPU8[$1 + 11 | 0] & 16) {
   jsvArrayPushAndUnLock(HEAP32[$1 + 4 >> 2], jsvNewFromString(120395));
  }
  if (HEAPU8[$1 + 11 | 0] & 32) {
   jsvArrayPushAndUnLock(HEAP32[$1 + 4 >> 2], jsvNewFromString(120402));
  }
  if (HEAPU8[$1 + 11 | 0] & 64) {
   jsvArrayPushAndUnLock(HEAP32[$1 + 4 >> 2], jsvNewFromString(120414));
  }
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jswrap_graphics_setPixel($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 112 | 0;
 global$0 = $4;
 HEAP32[$4 + 104 >> 2] = $0;
 HEAP32[$4 + 100 >> 2] = $1;
 HEAP32[$4 + 96 >> 2] = $2;
 HEAP32[$4 + 92 >> 2] = $3;
 label$1 : {
  if (!(graphicsGetFromVar($4 + 16 | 0, HEAP32[$4 + 104 >> 2]) & 1)) {
   HEAP32[$4 + 108 >> 2] = 0;
   break label$1;
  }
  HEAP32[$4 + 12 >> 2] = HEAPU8[$4 + 33 | 0] | HEAPU8[$4 + 34 | 0] << 8 | (HEAPU8[$4 + 35 | 0] << 16 | HEAPU8[$4 + 36 | 0] << 24);
  if (!(jsvIsUndefined(HEAP32[$4 + 92 >> 2]) & 1)) {
   HEAP32[$4 + 12 >> 2] = jswrap_graphics_toColor(HEAP32[$4 + 104 >> 2], HEAP32[$4 + 92 >> 2], 0, 0);
  }
  $0 = $4 + 16 | 0;
  graphicsSetPixel($0, HEAP32[$4 + 100 >> 2], HEAP32[$4 + 96 >> 2], HEAP32[$4 + 12 >> 2]);
  $1 = HEAP32[$4 + 100 >> 2];
  HEAP8[$4 + 43 | 0] = $1;
  HEAP8[$4 + 44 | 0] = $1 >>> 8;
  $1 = HEAP32[$4 + 96 >> 2];
  HEAP8[$4 + 45 | 0] = $1;
  HEAP8[$4 + 46 | 0] = $1 >>> 8;
  graphicsSetVar($0);
  HEAP32[$4 + 108 >> 2] = jsvLockAgain(HEAP32[$4 + 104 >> 2]);
 }
 global$0 = $4 + 112 | 0;
 return HEAP32[$4 + 108 >> 2];
}
function jsfGetAllocatedSpace($0, $1) {
 var $2 = 0;
 $2 = global$0 + -64 | 0;
 global$0 = $2;
 HEAP32[$2 + 60 >> 2] = $0;
 HEAP8[$2 + 59 | 0] = 1;
 HEAP32[$2 + 52 >> 2] = $1;
 HEAP32[$2 + 48 >> 2] = 0;
 if (HEAP32[$2 + 52 >> 2]) {
  HEAP32[HEAP32[$2 + 52 >> 2] >> 2] = 0;
 }
 $0 = $2 + 16 | 0;
 HEAP32[$0 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
 if (jsfGetFileHeader(HEAP32[$2 + 60 >> 2], $0, 0) & 1) {
  while (1) {
   HEAP32[$2 + 12 >> 2] = jsfAlignAddress(jsfGetFileSize($2 + 16 | 0)) + 32;
   label$4 : {
    if (HEAP32[$2 + 20 >> 2]) {
     HEAP32[$2 + 48 >> 2] = HEAP32[$2 + 12 >> 2] + HEAP32[$2 + 48 >> 2];
     break label$4;
    }
    if (HEAP32[$2 + 52 >> 2]) {
     $0 = HEAP32[$2 + 52 >> 2];
     HEAP32[$0 >> 2] = HEAP32[$2 + 12 >> 2] + HEAP32[$0 >> 2];
    }
   }
   if (jsfGetNextFileHeader($2 + 60 | 0, $2 + 16 | 0, (HEAP8[$2 + 59 | 0] & 1 ? 1 : 0) | 2) & 1) {
    continue;
   }
   break;
  }
 }
 global$0 = $2 - -64 | 0;
 return HEAP32[$2 + 48 >> 2];
}
function jswrap_math_minmax($0, $1) {
 var $2 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP32[$2 + 44 >> 2] = $0;
 HEAP8[$2 + 43 | 0] = $1 & 1;
 HEAPF64[$2 + 32 >> 3] = HEAPU8[$2 + 43 | 0] ? Math_fround(-infinity) : Math_fround(infinity);
 jsvObjectIteratorNew($2 + 24 | 0, HEAP32[$2 + 44 >> 2]);
 while (1) {
  if (jsvObjectIteratorHasValue($2 + 24 | 0) & 1) {
   HEAPF64[$2 + 16 >> 3] = jsvGetFloatAndUnLock(jsvObjectIteratorGetValue($2 + 24 | 0));
   label$3 : {
    label$4 : {
     if ((HEAPF64[$2 + 16 >> 3] > HEAPF64[$2 + 32 >> 3] ? HEAP8[$2 + 43 | 0] & 1 : 0) | (HEAPF64[$2 + 16 >> 3] < HEAPF64[$2 + 32 >> 3] ? !(HEAP8[$2 + 43 | 0] & 1) : 0)) {
      break label$4;
     }
     $0 = __DOUBLE_BITS(HEAPF64[$2 + 16 >> 3]);
     $1 = i64toi32_i32$HIGH_BITS & 2147483647;
     if (($1 | 0) == 2146435072 & $0 >>> 0 > 0 | $1 >>> 0 > 2146435072) {
      break label$4;
     }
     break label$3;
    }
    HEAPF64[$2 + 32 >> 3] = HEAPF64[$2 + 16 >> 3];
   }
   jsvObjectIteratorNext($2 + 24 | 0);
   continue;
  }
  break;
 }
 jsvObjectIteratorFree($2 + 24 | 0);
 global$0 = $2 + 48 | 0;
 return HEAPF64[$2 + 32 >> 3];
}
function graphicsToDeviceCoordinates16x($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 16) {
  HEAP32[$3 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] >> 2];
  HEAP32[HEAP32[$3 + 8 >> 2] >> 2] = HEAP32[HEAP32[$3 + 4 >> 2] >> 2];
  HEAP32[HEAP32[$3 + 4 >> 2] >> 2] = HEAP32[$3 >> 2];
 }
 $0 = HEAP32[$3 + 12 >> 2];
 if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 32) {
  $0 = HEAP32[$3 + 12 >> 2];
  HEAP32[HEAP32[$3 + 8 >> 2] >> 2] = ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) - 1 << 4) - HEAP32[HEAP32[$3 + 8 >> 2] >> 2];
 }
 $0 = HEAP32[$3 + 12 >> 2];
 if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 64) {
  $0 = HEAP32[$3 + 12 >> 2];
  HEAP32[HEAP32[$3 + 4 >> 2] >> 2] = ((HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8) - 1 << 4) - HEAP32[HEAP32[$3 + 4 >> 2] >> 2];
 }
}
function jspeFunctionArguments($0) {
 var $1 = 0;
 $1 = global$0 - 96 | 0;
 global$0 = $1;
 HEAP32[$1 + 88 >> 2] = $0;
 label$1 : {
  if (!(jslMatch(40) & 1)) {
   HEAP8[$1 + 95 | 0] = 0;
   break label$1;
  }
  while (1) {
   if (HEAP16[HEAP32[35539] + 2 >> 1] != 41) {
    if (HEAP32[$1 + 88 >> 2]) {
     HEAP8[$1 + 16 | 0] = 255;
     $0 = $1 + 16 | 0;
     strcpy($0 + 1 | 0, jslGetTokenValueAsString());
     HEAP32[$1 + 12 >> 2] = jsvAddNamedChild(HEAP32[$1 + 88 >> 2], 0, $0);
     if (!HEAP32[$1 + 12 >> 2]) {
      jspSetError();
      HEAP8[$1 + 95 | 0] = 0;
      break label$1;
     }
     jsvMakeFunctionParameter(HEAP32[$1 + 12 >> 2]);
     jsvUnLock(HEAP32[$1 + 12 >> 2]);
    }
    if (!(jslMatch(128) & 1)) {
     HEAP8[$1 + 95 | 0] = 0;
     break label$1;
    }
    if (HEAP16[HEAP32[35539] + 2 >> 1] != 41) {
     if (!(jslMatch(44) & 1)) {
      HEAP8[$1 + 95 | 0] = 0;
      break label$1;
     }
    }
    continue;
   }
   break;
  }
  if (!(jslMatch(41) & 1)) {
   HEAP8[$1 + 95 | 0] = 0;
   break label$1;
  }
  HEAP8[$1 + 95 | 0] = 1;
 }
 global$0 = $1 + 96 | 0;
 return HEAP8[$1 + 95 | 0] & 1;
}
function jspEvaluateVar($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 176 | 0;
 global$0 = $3;
 HEAP32[$3 + 172 >> 2] = $0;
 HEAP32[$3 + 168 >> 2] = $1;
 HEAP16[$3 + 166 >> 1] = $2;
 $0 = $3 + 16 | 0;
 HEAP32[$3 + 36 >> 2] = jslSetLex($3 + 40 | 0);
 jslInit(HEAP32[$3 + 172 >> 2]);
 HEAP32[$0 + 16 >> 2] = HEAP32[80549];
 $1 = HEAP32[80548];
 HEAP32[$0 + 8 >> 2] = HEAP32[80547];
 HEAP32[$0 + 12 >> 2] = $1;
 $1 = HEAP32[80546];
 HEAP32[$0 >> 2] = HEAP32[80545];
 HEAP32[$0 + 4 >> 2] = $1;
 HEAP32[80549] = 1;
 if (HEAP32[$3 + 168 >> 2]) {
  HEAP32[80547] = 0;
  jspeiAddScope(HEAP32[$3 + 168 >> 2]);
 }
 HEAP32[$3 + 12 >> 2] = jspParse();
 if (HEAP32[$3 + 168 >> 2]) {
  jspeiClearScopes();
 }
 $0 = $3 + 16 | 0;
 jslKill();
 jslSetLex(HEAP32[$3 + 36 >> 2]);
 HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 32 >> 2] | HEAP32[80549] & 6256;
 $1 = HEAP32[$0 + 4 >> 2];
 HEAP32[80545] = HEAP32[$0 >> 2];
 HEAP32[80546] = $1;
 HEAP32[80549] = HEAP32[$0 + 16 >> 2];
 $1 = HEAP32[$0 + 12 >> 2];
 HEAP32[80547] = HEAP32[$0 + 8 >> 2];
 HEAP32[80548] = $1;
 $0 = jsvSkipNameAndUnLock(HEAP32[$3 + 12 >> 2]);
 global$0 = $3 + 176 | 0;
 return $0;
}
function tflite__SimpleMemoryAllocator__AllocateFromTail_28unsigned_20long_2c_20unsigned_20long_29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP32[$3 + 40 >> 2] = $0;
 HEAP32[$3 + 36 >> 2] = $1;
 HEAP32[$3 + 32 >> 2] = $2;
 $0 = HEAP32[$3 + 40 >> 2];
 HEAP32[$3 + 28 >> 2] = tflite__AlignPointerDown_28unsigned_20char__2c_20unsigned_20long_29(HEAP32[$0 + 20 >> 2] - HEAP32[$3 + 36 >> 2] | 0, HEAP32[$3 + 32 >> 2]);
 label$1 : {
  if (HEAPU32[$3 + 28 >> 2] < HEAPU32[$0 + 16 >> 2]) {
   HEAP32[$3 + 24 >> 2] = HEAP32[$0 + 16 >> 2] - HEAP32[$3 + 28 >> 2];
   $0 = HEAP32[$0 + 4 >> 2];
   $1 = HEAP32[$3 + 36 >> 2];
   $2 = HEAP32[$3 + 36 >> 2] - HEAP32[$3 + 24 >> 2] | 0;
   HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 24 >> 2];
   HEAP32[$3 + 4 >> 2] = $2;
   HEAP32[$3 >> 2] = $1;
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 128966, $3);
   HEAP32[$3 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$0 + 20 >> 2] = HEAP32[$3 + 28 >> 2];
  HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 28 >> 2];
 }
 global$0 = $3 + 48 | 0;
 return HEAP32[$3 + 44 >> 2];
}
function jswrap_string_substring($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 $0 = $3;
 $2 = jsvIsUndefined(HEAP32[$3 + 16 >> 2]) & 1;
 $1 = 2147483647;
 label$1 : {
  if ($2) {
   break label$1;
  }
  $1 = jsvGetInteger(HEAP32[$3 + 16 >> 2]);
 }
 HEAP32[$0 + 8 >> 2] = $1;
 if (HEAP32[$3 + 20 >> 2] < 0) {
  HEAP32[$3 + 20 >> 2] = 0;
 }
 if (HEAP32[$3 + 8 >> 2] < 0) {
  HEAP32[$3 + 8 >> 2] = 0;
 }
 if (HEAP32[$3 + 8 >> 2] < HEAP32[$3 + 20 >> 2]) {
  HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 20 >> 2];
  HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 8 >> 2];
  HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 4 >> 2];
 }
 HEAP32[$3 + 12 >> 2] = jsvNewWithFlags(27);
 label$5 : {
  if (!HEAP32[$3 + 12 >> 2]) {
   HEAP32[$3 + 28 >> 2] = 0;
   break label$5;
  }
  jsvAppendStringVar(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 8 >> 2] - HEAP32[$3 + 20 >> 2] | 0);
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2];
 }
 global$0 = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}
function jswrap_banglejs_project($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 + -64 | 0;
 global$0 = $1;
 HEAP32[$1 + 60 >> 2] = $0;
 HEAPF64[$1 + 48 >> 3] = .017453292519943295;
 HEAPF64[$1 + 40 >> 3] = 85.0511287798;
 HEAPF64[$1 + 32 >> 3] = 6378137;
 HEAPF64[$1 + 24 >> 3] = jsvGetFloatAndUnLock(jsvObjectGetChild(HEAP32[$1 + 60 >> 2], 111037, 0));
 HEAPF64[$1 + 16 >> 3] = jsvGetFloatAndUnLock(jsvObjectGetChild(HEAP32[$1 + 60 >> 2], 111041, 0));
 if (HEAPF64[$1 + 24 >> 3] > 85.0511287798) {
  HEAPF64[$1 + 24 >> 3] = 85.0511287798;
 }
 if (HEAPF64[$1 + 24 >> 3] < -85.0511287798) {
  HEAPF64[$1 + 24 >> 3] = -85.0511287798;
 }
 HEAPF64[$1 + 8 >> 3] = sin(HEAPF64[$1 + 24 >> 3] * .017453292519943295);
 HEAP32[$1 + 4 >> 2] = jsvNewWithFlags(5);
 if (HEAP32[$1 + 4 >> 2]) {
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 4 >> 2], 110430, jsvNewFromFloat(6378137 * HEAPF64[$1 + 16 >> 3] * .017453292519943295));
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 4 >> 2], 110432, jsvNewFromFloat(6378137 * log((1 + HEAPF64[$1 + 8 >> 3]) / (1 - HEAPF64[$1 + 8 >> 3])) / 2));
 }
 global$0 = $1 - -64 | 0;
 return HEAP32[$1 + 4 >> 2];
}
function jsspiFastSoftwareFunc($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 global$0 = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 16 >> 2];
 HEAP32[$4 + 8 >> 2] = 0;
 while (1) {
  if (HEAPU32[$4 + 8 >> 2] < HEAPU32[$4 + 20 >> 2]) {
   HEAP32[$4 + 4 >> 2] = HEAPU8[HEAP32[$4 + 28 >> 2] + HEAP32[$4 + 8 >> 2] | 0];
   $0 = HEAP32[$4 + 12 >> 2];
   HEAP32[$4 >> 2] = (HEAPU8[$0 + 10 | 0] | HEAPU8[$0 + 11 | 0] << 8 | (HEAPU8[$0 + 12 | 0] << 16 | HEAPU8[$0 + 13 | 0] << 24)) - 1;
   while (1) {
    if (HEAP32[$4 >> 2] >= 0) {
     jshPinSetValue(HEAPU8[HEAP32[$4 + 12 >> 2] + 7 | 0], (HEAP32[$4 + 4 >> 2] >> HEAP32[$4 >> 2] & 1) != 0);
     jshPinSetValue(HEAPU8[HEAP32[$4 + 12 >> 2] + 5 | 0], 1);
     jshPinSetValue(HEAPU8[HEAP32[$4 + 12 >> 2] + 5 | 0], 0);
     HEAP32[$4 >> 2] = HEAP32[$4 >> 2] + -1;
     continue;
    }
    break;
   }
   HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 8 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $4 + 32 | 0;
}
function graphicsToDeviceCoordinates($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 16) {
  HEAP32[$3 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] >> 2];
  HEAP32[HEAP32[$3 + 8 >> 2] >> 2] = HEAP32[HEAP32[$3 + 4 >> 2] >> 2];
  HEAP32[HEAP32[$3 + 4 >> 2] >> 2] = HEAP32[$3 >> 2];
 }
 $0 = HEAP32[$3 + 12 >> 2];
 if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 32) {
  $0 = HEAP32[$3 + 12 >> 2];
  HEAP32[HEAP32[$3 + 8 >> 2] >> 2] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) - (HEAP32[HEAP32[$3 + 8 >> 2] >> 2] + 1 | 0);
 }
 $0 = HEAP32[$3 + 12 >> 2];
 if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 64) {
  $0 = HEAP32[$3 + 12 >> 2];
  HEAP32[HEAP32[$3 + 4 >> 2] >> 2] = (HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8) - (HEAP32[HEAP32[$3 + 4 >> 2] >> 2] + 1 | 0);
 }
}
function _jswrap_object_keys_or_property_names_iterator($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 label$1 : {
  if (!HEAP32[$3 + 28 >> 2]) {
   break label$1;
  }
  HEAP8[$3 + 15 | 0] = HEAPU8[HEAP32[$3 + 28 >> 2] + 8 | 0];
  HEAP32[$3 + 16 >> 2] = 0;
  while (1) {
   if (HEAPU32[$3 + 16 >> 2] >= HEAPU8[$3 + 15 | 0]) {
    break label$1;
   }
   $0 = HEAP32[$3 + 28 >> 2];
   $0 = (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) + (HEAP32[$3 + 16 >> 2] << 3) | 0;
   HEAP16[$3 + 12 >> 1] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8;
   $0 = HEAP32[$3 + 28 >> 2];
   HEAP32[$3 + 8 >> 2] = jsvNewFromString(HEAPU16[$3 + 12 >> 1] + (HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24)) | 0);
   FUNCTION_TABLE[HEAP32[$3 + 24 >> 2]](HEAP32[$3 + 20 >> 2], HEAP32[$3 + 8 >> 2]);
   jsvUnLock(HEAP32[$3 + 8 >> 2]);
   HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 16 >> 2] + 1;
   continue;
  }
 }
 global$0 = $3 + 32 | 0;
}
function jswrap_heatshrink_compress($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = global$0 - 128 | 0;
 global$0 = $1;
 HEAP32[$1 + 120 >> 2] = $0;
 label$1 : {
  if (!(jsvIsIterable(HEAP32[$1 + 120 >> 2]) & 1)) {
   HEAP32[$1 >> 2] = HEAP32[$1 + 120 >> 2];
   jsExceptionHere(3, 126418, $1);
   HEAP32[$1 + 124 >> 2] = 0;
   break label$1;
  }
  $0 = $1 + 56 | 0;
  jsvIteratorNew($0, HEAP32[$1 + 120 >> 2], 1);
  HEAP32[$1 + 12 >> 2] = heatshrink_encode_cb($0, 0, 0);
  jsvIteratorFree($0);
  HEAP32[$1 + 8 >> 2] = jsvNewStringOfLength(HEAP32[$1 + 12 >> 2], 0);
  if (!HEAP32[$1 + 8 >> 2]) {
   jsError(126455, 0);
   HEAP32[$1 + 124 >> 2] = 0;
   break label$1;
  }
  $0 = $1 + 16 | 0;
  $2 = $1 + 56 | 0;
  jsvIteratorNew($2, HEAP32[$1 + 120 >> 2], 1);
  jsvStringIteratorNew($0, HEAP32[$1 + 8 >> 2], 0);
  heatshrink_encode_cb($2, 594, $0);
  jsvStringIteratorFree($0);
  jsvIteratorFree($2);
  HEAP32[$1 + 4 >> 2] = jsvNewArrayBufferFromString(HEAP32[$1 + 8 >> 2], 0);
  jsvUnLock(HEAP32[$1 + 8 >> 2]);
  HEAP32[$1 + 124 >> 2] = HEAP32[$1 + 4 >> 2];
 }
 global$0 = $1 + 128 | 0;
 return HEAP32[$1 + 124 >> 2];
}
function jswrap_heatshrink_decompress($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = global$0 - 128 | 0;
 global$0 = $1;
 HEAP32[$1 + 120 >> 2] = $0;
 label$1 : {
  if (!(jsvIsIterable(HEAP32[$1 + 120 >> 2]) & 1)) {
   HEAP32[$1 >> 2] = HEAP32[$1 + 120 >> 2];
   jsExceptionHere(3, 126418, $1);
   HEAP32[$1 + 124 >> 2] = 0;
   break label$1;
  }
  $0 = $1 + 56 | 0;
  jsvIteratorNew($0, HEAP32[$1 + 120 >> 2], 1);
  HEAP32[$1 + 12 >> 2] = heatshrink_decode($0);
  jsvIteratorFree($0);
  HEAP32[$1 + 8 >> 2] = jsvNewStringOfLength(HEAP32[$1 + 12 >> 2], 0);
  if (!HEAP32[$1 + 8 >> 2]) {
   jsError(126455, 0);
   HEAP32[$1 + 124 >> 2] = 0;
   break label$1;
  }
  $0 = $1 + 16 | 0;
  $2 = $1 + 56 | 0;
  jsvIteratorNew($2, HEAP32[$1 + 120 >> 2], 1);
  jsvStringIteratorNew($0, HEAP32[$1 + 8 >> 2], 0);
  heatshrink_decode_cb(593, $2, 594, $0);
  jsvStringIteratorFree($0);
  jsvIteratorFree($2);
  HEAP32[$1 + 4 >> 2] = jsvNewArrayBufferFromString(HEAP32[$1 + 8 >> 2], 0);
  jsvUnLock(HEAP32[$1 + 8 >> 2]);
  HEAP32[$1 + 124 >> 2] = HEAP32[$1 + 4 >> 2];
 }
 global$0 = $1 + 128 | 0;
 return HEAP32[$1 + 124 >> 2];
}
function jsvGetTypeOf($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (jsvIsUndefined(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 78366;
   break label$1;
  }
  label$3 : {
   label$4 : {
    if (jsvIsNull(HEAP32[$1 + 8 >> 2]) & 1) {
     break label$4;
    }
    if (jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1) {
     break label$4;
    }
    if (jsvIsArray(HEAP32[$1 + 8 >> 2]) & 1) {
     break label$4;
    }
    if (!(jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1)) {
     break label$3;
    }
   }
   HEAP32[$1 + 12 >> 2] = 78392;
   break label$1;
  }
  if (jsvIsFunction(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 78399;
   break label$1;
  }
  if (jsvIsString(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 78408;
   break label$1;
  }
  if (jsvIsBoolean(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 78415;
   break label$1;
  }
  if (jsvIsNumeric(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 78423;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 78430;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jswrap_object_hasOwnProperty($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 80 | 0;
 global$0 = $2;
 HEAP32[$2 + 76 >> 2] = $0;
 HEAP32[$2 + 72 >> 2] = $1;
 HEAP32[$2 + 68 >> 2] = jsvAsArrayIndex(HEAP32[$2 + 72 >> 2]);
 HEAP8[$2 + 67 | 0] = 0;
 if (jsvHasChildren(HEAP32[$2 + 76 >> 2]) & 1) {
  HEAP32[$2 + 60 >> 2] = jsvFindChildFromVar(HEAP32[$2 + 76 >> 2], HEAP32[$2 + 68 >> 2], 0);
  if (HEAP32[$2 + 60 >> 2]) {
   HEAP8[$2 + 67 | 0] = 1;
   jsvUnLock(HEAP32[$2 + 60 >> 2]);
  }
 }
 label$3 : {
  if (HEAP8[$2 + 67 | 0] & 1) {
   break label$3;
  }
  if (jsvIsObject(HEAP32[$2 + 76 >> 2]) & 1) {
   break label$3;
  }
  HEAP32[$2 + 56 >> 2] = jswGetSymbolListForObject(HEAP32[$2 + 76 >> 2]);
  if (HEAP32[$2 + 56 >> 2]) {
   $0 = $2 + 16 | 0;
   jsvGetString(HEAP32[$2 + 68 >> 2], $0, 32);
   HEAP32[$2 + 12 >> 2] = jswBinarySearch(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 76 >> 2], $0);
   if (HEAP32[$2 + 12 >> 2]) {
    HEAP8[$2 + 67 | 0] = 1;
   }
   jsvUnLock(HEAP32[$2 + 12 >> 2]);
  }
 }
 jsvUnLock(HEAP32[$2 + 68 >> 2]);
 global$0 = $2 + 80 | 0;
 return HEAP8[$2 + 67 | 0] & 1;
}
function nomatchfound($0, $1) {
 var $2 = 0;
 $2 = global$0 - 144 | 0;
 global$0 = $2;
 HEAP32[$2 + 136 >> 2] = $0;
 label$1 : {
  if (!(jspCheckStackPosition() & 1)) {
   HEAP32[$2 + 140 >> 2] = 0;
   break label$1;
  }
  while (1) {
   if (HEAP8[HEAP32[$2 + 136 >> 2]] ? HEAP8[HEAP32[$2 + 136 >> 2]] != 124 : 0) {
    if (HEAP8[HEAP32[$2 + 136 >> 2]] == 92) {
     HEAP32[$2 + 136 >> 2] = HEAP32[$2 + 136 >> 2] + 1;
     if (!HEAPU8[HEAP32[$2 + 136 >> 2]]) {
      HEAP32[$2 + 140 >> 2] = 0;
      break label$1;
     }
    }
    HEAP32[$2 + 136 >> 2] = HEAP32[$2 + 136 >> 2] + 1;
    continue;
   }
   break;
  }
  if (HEAP8[HEAP32[$2 + 136 >> 2]] != 124) {
   HEAP32[$2 + 140 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 136 >> 2] = HEAP32[$2 + 136 >> 2] + 1;
  jsvStringIteratorNew($2 + 96 | 0, HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2]);
  $0 = HEAP32[$2 + 136 >> 2];
  memcpy($2 + 4 | 0, $1, 88);
  HEAP32[$2 + 92 >> 2] = matchhere($0, $2 + 96 | 0, $2 + 4 | 0);
  jsvStringIteratorFree($2 + 96 | 0);
  HEAP32[$2 + 140 >> 2] = HEAP32[$2 + 92 >> 2];
 }
 global$0 = $2 + 144 | 0;
 return HEAP32[$2 + 140 >> 2];
}
function jswrap_array_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 label$1 : {
  if ((jsvGetArrayLength(HEAP32[$1 + 24 >> 2]) | 0) == 1) {
   HEAP32[$1 + 20 >> 2] = jsvSkipNameAndUnLock(jsvGetArrayItem(HEAP32[$1 + 24 >> 2], 0));
   if (jsvIsNumeric(HEAP32[$1 + 20 >> 2]) & 1) {
    HEAPF64[$1 + 8 >> 3] = jsvGetFloat(HEAP32[$1 + 20 >> 2]);
    HEAP32[$1 + 4 >> 2] = jsvGetInteger(HEAP32[$1 + 20 >> 2]);
    jsvUnLock(HEAP32[$1 + 20 >> 2]);
    if (!(HEAP32[$1 + 4 >> 2] >= 0 ? HEAPF64[$1 + 8 >> 3] == +HEAP32[$1 + 4 >> 2] : 0)) {
     jsExceptionHere(1, 118800, 0);
     HEAP32[$1 + 28 >> 2] = 0;
     break label$1;
    }
    HEAP32[$1 >> 2] = jsvNewWithFlags(3);
    if (!HEAP32[$1 >> 2]) {
     HEAP32[$1 + 28 >> 2] = 0;
     break label$1;
    }
    jsvSetArrayLength(HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2]);
    HEAP32[$1 + 28 >> 2] = HEAP32[$1 >> 2];
    break label$1;
   }
   jsvUnLock(HEAP32[$1 + 20 >> 2]);
  }
  HEAP32[$1 + 28 >> 2] = jsvLockAgain(HEAP32[$1 + 24 >> 2]);
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function tflite__SimpleMemoryAllocator__AllocateTemp_28unsigned_20long_2c_20unsigned_20long_29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP32[$3 + 40 >> 2] = $0;
 HEAP32[$3 + 36 >> 2] = $1;
 HEAP32[$3 + 32 >> 2] = $2;
 $0 = HEAP32[$3 + 40 >> 2];
 HEAP32[$3 + 28 >> 2] = tflite__AlignPointerUp_28unsigned_20char__2c_20unsigned_20long_29(HEAP32[$0 + 24 >> 2], HEAP32[$3 + 32 >> 2]);
 HEAP32[$3 + 24 >> 2] = HEAP32[$0 + 20 >> 2] - HEAP32[$3 + 28 >> 2];
 label$1 : {
  if (HEAPU32[$3 + 24 >> 2] < HEAPU32[$3 + 36 >> 2]) {
   $0 = HEAP32[$0 + 4 >> 2];
   $1 = HEAP32[$3 + 36 >> 2];
   $2 = HEAP32[$3 + 24 >> 2];
   HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 36 >> 2] - HEAP32[$3 + 24 >> 2];
   HEAP32[$3 + 4 >> 2] = $2;
   HEAP32[$3 >> 2] = $1;
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 129039, $3);
   HEAP32[$3 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$0 + 24 >> 2] = HEAP32[$3 + 28 >> 2] + HEAP32[$3 + 36 >> 2];
  HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 28 >> 2];
 }
 global$0 = $3 + 48 | 0;
 return HEAP32[$3 + 44 >> 2];
}
function i2c_start($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP8[HEAP32[$1 + 12 >> 2] + 2 | 0] & 1) {
  i2c_pin_wr1(HEAPU8[HEAP32[$1 + 12 >> 2] + 1 | 0]);
  dly(HEAP32[$1 + 12 >> 2]);
  i2c_pin_wr1(HEAPU8[HEAP32[$1 + 12 >> 2]]);
  HEAP32[$1 + 8 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2];
  while (1) {
   if (jshPinGetValue(HEAPU8[HEAP32[$1 + 12 >> 2]]) & 1) {
    $0 = 0;
   } else {
    $0 = HEAP32[$1 + 8 >> 2];
   }
   if ($0) {
    HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + -1;
    continue;
   }
   break;
  }
  if (!(HEAP32[$1 + 8 >> 2] | !HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2])) {
   err(83279);
  }
  dly(HEAP32[$1 + 12 >> 2]);
 }
 label$7 : {
  if (!HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2]) {
   break label$7;
  }
  if (jshPinGetValue(HEAPU8[HEAP32[$1 + 12 >> 2] + 1 | 0]) & 1) {
   break label$7;
  }
  err(83295);
 }
 i2c_pin_wr0(HEAPU8[HEAP32[$1 + 12 >> 2] + 1 | 0]);
 dly(HEAP32[$1 + 12 >> 2]);
 i2c_pin_wr0(HEAPU8[HEAP32[$1 + 12 >> 2]]);
 dly(HEAP32[$1 + 12 >> 2]);
 HEAP8[HEAP32[$1 + 12 >> 2] + 2 | 0] = 1;
 global$0 = $1 + 16 | 0;
}
function __ashlti3($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 label$1 : {
  if ($5 & 64) {
   $3 = $1;
   $4 = $5 + -64 | 0;
   $1 = $4 & 31;
   if (32 <= ($4 & 63) >>> 0) {
    $4 = $3 << $1;
    $3 = 0;
   } else {
    $4 = (1 << $1) - 1 & $3 >>> 32 - $1 | $2 << $1;
    $3 = $3 << $1;
   }
   $1 = 0;
   $2 = 0;
   break label$1;
  }
  if (!$5) {
   break label$1;
  }
  $6 = $3;
  $8 = $5;
  $3 = $5 & 31;
  if (32 <= ($5 & 63) >>> 0) {
   $7 = $6 << $3;
   $9 = 0;
  } else {
   $7 = (1 << $3) - 1 & $6 >>> 32 - $3 | $4 << $3;
   $9 = $6 << $3;
  }
  $3 = $2;
  $6 = $1;
  $5 = 64 - $5 | 0;
  $4 = $5 & 31;
  if (32 <= ($5 & 63) >>> 0) {
   $5 = 0;
   $3 = $3 >>> $4;
  } else {
   $5 = $3 >>> $4;
   $3 = ((1 << $4) - 1 & $3) << 32 - $4 | $6 >>> $4;
  }
  $3 = $9 | $3;
  $4 = $5 | $7;
  $5 = $1;
  $1 = $8 & 31;
  if (32 <= ($8 & 63) >>> 0) {
   $7 = $5 << $1;
   $1 = 0;
  } else {
   $7 = (1 << $1) - 1 & $5 >>> 32 - $1 | $2 << $1;
   $1 = $5 << $1;
  }
  $2 = $7;
 }
 HEAP32[$0 >> 2] = $1;
 HEAP32[$0 + 4 >> 2] = $2;
 HEAP32[$0 + 8 >> 2] = $3;
 HEAP32[$0 + 12 >> 2] = $4;
}
function jsvAsFlatString($0) {
 var $1 = 0;
 $1 = global$0 - 96 | 0;
 global$0 = $1;
 HEAP32[$1 + 88 >> 2] = $0;
 label$1 : {
  if (jsvIsFlatString(HEAP32[$1 + 88 >> 2]) & 1) {
   HEAP32[$1 + 92 >> 2] = jsvLockAgain(HEAP32[$1 + 88 >> 2]);
   break label$1;
  }
  HEAP32[$1 + 84 >> 2] = jsvAsString(HEAP32[$1 + 88 >> 2]);
  HEAP32[$1 + 80 >> 2] = jsvGetStringLength(HEAP32[$1 + 84 >> 2]);
  HEAP32[$1 + 76 >> 2] = jsvNewFlatStringOfLength(HEAP32[$1 + 80 >> 2]);
  if (HEAP32[$1 + 76 >> 2]) {
   jsvStringIteratorNew($1 + 40 | 0, HEAP32[$1 + 84 >> 2], 0);
   jsvStringIteratorNew($1, HEAP32[$1 + 76 >> 2], 0);
   while (1) {
    label$5 : {
     $0 = HEAP32[$1 + 80 >> 2];
     HEAP32[$1 + 80 >> 2] = $0 + -1;
     if (!$0) {
      break label$5;
     }
     jsvStringIteratorSetCharAndNext($1, jsvStringIteratorGetCharAndNext($1 + 40 | 0) << 24 >> 24);
     continue;
    }
    break;
   }
   jsvStringIteratorFree($1 + 40 | 0);
   jsvStringIteratorFree($1);
  }
  jsvUnLock(HEAP32[$1 + 84 >> 2]);
  HEAP32[$1 + 92 >> 2] = HEAP32[$1 + 76 >> 2];
 }
 global$0 = $1 + 96 | 0;
 return HEAP32[$1 + 92 >> 2];
}
function jsvGetCharactersInVar($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 $0 = HEAP32[$1 + 8 >> 2];
 HEAP32[$1 + 4 >> 2] = (HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63;
 label$1 : {
  if (HEAP32[$1 + 4 >> 2] == 38) {
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP32[$1 + 12 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
   break label$1;
  }
  if (!(HEAP32[$1 + 4 >> 2] != 40 ? HEAP32[$1 + 4 >> 2] != 39 : 0)) {
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP32[$1 + 12 >> 2] = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
   break label$1;
  }
  if (HEAPU32[$1 + 4 >> 2] <= 26) {
   if (HEAPU32[$1 + 4 >> 2] <= 21) {
    HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2] - 17;
    break label$1;
   }
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2] - 22;
   break label$1;
  }
  if (HEAPU32[$1 + 4 >> 2] <= 37) {
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2] - 27;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2] - 41;
 }
 return HEAP32[$1 + 12 >> 2];
}
function jswrap_object_length($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  label$2 : {
   if (jsvIsArray(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 4 >> 2] = jsvGetArrayLength(HEAP32[$1 + 8 >> 2]);
    break label$2;
   }
   label$4 : {
    if (jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1) {
     HEAP32[$1 + 4 >> 2] = jsvGetArrayBufferLength(HEAP32[$1 + 8 >> 2]);
     break label$4;
    }
    label$6 : {
     if (jsvIsString(HEAP32[$1 + 8 >> 2]) & 1) {
      HEAP32[$1 + 4 >> 2] = jsvGetStringLength(HEAP32[$1 + 8 >> 2]);
      break label$6;
     }
     label$8 : {
      if (jsvIsFunction(HEAP32[$1 + 8 >> 2]) & 1) {
       HEAP32[$1 >> 2] = jsvGetFunctionArgumentLength(HEAP32[$1 + 8 >> 2]);
       HEAP32[$1 + 4 >> 2] = jsvGetArrayLength(HEAP32[$1 >> 2]);
       jsvUnLock(HEAP32[$1 >> 2]);
       break label$8;
      }
      HEAP32[$1 + 12 >> 2] = 0;
      break label$1;
     }
    }
   }
  }
  HEAP32[$1 + 12 >> 2] = jsvNewFromInteger(HEAP32[$1 + 4 >> 2]);
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jsfEraseFile($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 112 | 0;
 global$0 = $1;
 HEAP32[$1 + 64 >> 2] = HEAP32[$0 + 24 >> 2];
 $2 = HEAP32[$0 + 20 >> 2];
 HEAP32[$1 + 56 >> 2] = HEAP32[$0 + 16 >> 2];
 HEAP32[$1 + 60 >> 2] = $2;
 $2 = HEAP32[$0 + 12 >> 2];
 HEAP32[$1 + 48 >> 2] = HEAP32[$0 + 8 >> 2];
 HEAP32[$1 + 52 >> 2] = $2;
 $2 = HEAP32[$0 + 4 >> 2];
 HEAP32[$1 + 40 >> 2] = HEAP32[$0 >> 2];
 HEAP32[$1 + 44 >> 2] = $2;
 HEAP32[$1 + 68 >> 2] = jsfFindFile($1 + 40 | 0, $1 + 72 | 0);
 label$1 : {
  if (!HEAP32[$1 + 68 >> 2]) {
   HEAP8[$1 + 111 | 0] = 0;
   break label$1;
  }
  HEAP32[$1 + 32 >> 2] = HEAP32[$0 + 24 >> 2];
  $2 = HEAP32[$0 + 20 >> 2];
  HEAP32[$1 + 24 >> 2] = HEAP32[$0 + 16 >> 2];
  HEAP32[$1 + 28 >> 2] = $2;
  $2 = HEAP32[$0 + 12 >> 2];
  HEAP32[$1 + 16 >> 2] = HEAP32[$0 + 8 >> 2];
  HEAP32[$1 + 20 >> 2] = $2;
  $2 = HEAP32[$0 + 4 >> 2];
  HEAP32[$1 + 8 >> 2] = HEAP32[$0 >> 2];
  HEAP32[$1 + 12 >> 2] = $2;
  jsfEraseFileInternal(HEAP32[$1 + 68 >> 2], $1 + 72 | 0);
  HEAP8[$1 + 111 | 0] = 1;
 }
 global$0 = $1 + 112 | 0;
 return HEAP8[$1 + 111 | 0] & 1;
}
function tflite___28anonymous_20namespace_29__AllocationInfoBuilder__AddScratchBuffers_28tflite__internal__ScratchBufferHandle__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 $0 = HEAP32[$2 + 28 >> 2];
 HEAP32[$2 + 20 >> 2] = HEAP32[$0 + 8 >> 2];
 while (1) {
  if (HEAPU32[$2 + 20 >> 2] < HEAP32[$0 + 8 >> 2] + HEAP32[$0 + 12 >> 2] >>> 0) {
   HEAP32[$2 + 16 >> 2] = HEAP32[$0 + 16 >> 2] + Math_imul(HEAP32[$2 + 20 >> 2], 24);
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 24 >> 2] + Math_imul(HEAP32[$2 + 20 >> 2] - HEAP32[$0 + 8 >> 2] | 0, 12);
   HEAP32[HEAP32[$2 + 16 >> 2] + 4 >> 2] = HEAP32[$2 + 12 >> 2];
   HEAP32[HEAP32[$2 + 16 >> 2] >> 2] = HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2];
   HEAP32[HEAP32[$2 + 16 >> 2] + 8 >> 2] = HEAP32[HEAP32[$2 + 12 >> 2] + 8 >> 2];
   HEAP32[HEAP32[$2 + 16 >> 2] + 12 >> 2] = HEAP32[HEAP32[$2 + 12 >> 2] + 8 >> 2];
   HEAP8[HEAP32[$2 + 16 >> 2] + 20 | 0] = 1;
   HEAP32[HEAP32[$2 + 16 >> 2] + 16 >> 2] = -1;
   HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 20 >> 2] + 1;
   continue;
  }
  break;
 }
 return 0;
}
function jsi2cRead($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 48 | 0;
 global$0 = $5;
 HEAP32[$5 + 40 >> 2] = $0;
 HEAP8[$5 + 39 | 0] = $1;
 HEAP32[$5 + 32 >> 2] = $2;
 HEAP32[$5 + 28 >> 2] = $3;
 HEAP8[$5 + 27 | 0] = $4;
 label$1 : {
  if (!(HEAPU8[HEAP32[$5 + 40 >> 2] + 5 | 0] != 255 ? HEAPU8[HEAP32[$5 + 40 >> 2] + 4 | 0] != 255 : 0)) {
   HEAP8[$5 + 47 | 0] = 0;
   break label$1;
  }
  $0 = $5 + 8 | 0;
  i2c_initstruct($0, HEAP32[$5 + 40 >> 2]);
  i2c_start($0);
  if (!(i2c_wr($0, HEAPU8[$5 + 39 | 0] << 1 | 1) & 1)) {
   HEAP8[$5 + 47 | 0] = 0;
   break label$1;
  }
  HEAP32[$5 + 4 >> 2] = 0;
  while (1) {
   if (HEAP32[$5 + 4 >> 2] < HEAP32[$5 + 32 >> 2]) {
    $0 = i2c_rd($5 + 8 | 0, HEAP32[$5 + 4 >> 2] == (HEAP32[$5 + 32 >> 2] - 1 | 0));
    HEAP8[HEAP32[$5 + 28 >> 2] + HEAP32[$5 + 4 >> 2] | 0] = $0;
    HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 4 >> 2] + 1;
    continue;
   }
   break;
  }
  if (HEAP8[$5 + 27 | 0] & 1) {
   i2c_stop($5 + 8 | 0);
  }
  HEAP8[HEAP32[$5 + 40 >> 2] + 6 | 0] = HEAP8[$5 + 10 | 0] & 1;
  HEAP8[$5 + 47 | 0] = 1;
 }
 global$0 = $5 + 48 | 0;
}
function heatshrink_decoder_sink($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 global$0 = $4;
 HEAP32[$4 + 24 >> 2] = $0;
 HEAP32[$4 + 20 >> 2] = $1;
 HEAP32[$4 + 16 >> 2] = $2;
 HEAP32[$4 + 12 >> 2] = $3;
 label$1 : {
  if (!(HEAP32[$4 + 12 >> 2] ? !(!HEAP32[$4 + 24 >> 2] | !HEAP32[$4 + 20 >> 2]) : 0)) {
   HEAP32[$4 + 28 >> 2] = -1;
   break label$1;
  }
  HEAP32[$4 + 8 >> 2] = 32 - HEAPU16[HEAP32[$4 + 24 >> 2] >> 1];
  if (!HEAP32[$4 + 8 >> 2]) {
   HEAP32[HEAP32[$4 + 12 >> 2] >> 2] = 0;
   HEAP32[$4 + 28 >> 2] = 1;
   break label$1;
  }
  $0 = $4;
  if (HEAPU32[$4 + 8 >> 2] < HEAPU32[$4 + 16 >> 2]) {
   $1 = HEAP32[$4 + 8 >> 2];
  } else {
   $1 = HEAP32[$4 + 16 >> 2];
  }
  HEAP32[$0 + 16 >> 2] = $1;
  memcpy(HEAPU16[HEAP32[$4 + 24 >> 2] >> 1] + (HEAP32[$4 + 24 >> 2] + 13 | 0) | 0, HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2]);
  $0 = HEAP32[$4 + 24 >> 2];
  HEAP16[$0 >> 1] = HEAP32[$4 + 16 >> 2] + HEAPU16[$0 >> 1];
  HEAP32[HEAP32[$4 + 12 >> 2] >> 2] = HEAP32[$4 + 16 >> 2];
  HEAP32[$4 + 28 >> 2] = 0;
 }
 global$0 = $4 + 32 | 0;
 return HEAP32[$4 + 28 >> 2];
}
function jswrap_graphics_setColorX($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 112 | 0;
 global$0 = $5;
 HEAP32[$5 + 104 >> 2] = $0;
 HEAP32[$5 + 100 >> 2] = $1;
 HEAP32[$5 + 96 >> 2] = $2;
 HEAP32[$5 + 92 >> 2] = $3;
 HEAP8[$5 + 91 | 0] = $4;
 label$1 : {
  if (!(graphicsGetFromVar($5 + 16 | 0, HEAP32[$5 + 104 >> 2]) & 1)) {
   HEAP32[$5 + 108 >> 2] = 0;
   break label$1;
  }
  HEAP32[$5 + 12 >> 2] = jswrap_graphics_toColor(HEAP32[$5 + 104 >> 2], HEAP32[$5 + 100 >> 2], HEAP32[$5 + 96 >> 2], HEAP32[$5 + 92 >> 2]);
  label$3 : {
   if (HEAP8[$5 + 91 | 0] & 1) {
    $0 = HEAP32[$5 + 12 >> 2];
    HEAP8[$5 + 33 | 0] = $0;
    HEAP8[$5 + 34 | 0] = $0 >>> 8;
    HEAP8[$5 + 35 | 0] = $0 >>> 16;
    HEAP8[$5 + 36 | 0] = $0 >>> 24;
    break label$3;
   }
   $0 = HEAP32[$5 + 12 >> 2];
   HEAP8[$5 + 37 | 0] = $0;
   HEAP8[$5 + 38 | 0] = $0 >>> 8;
   HEAP8[$5 + 39 | 0] = $0 >>> 16;
   HEAP8[$5 + 40 | 0] = $0 >>> 24;
  }
  graphicsSetVar($5 + 16 | 0);
  HEAP32[$5 + 108 >> 2] = jsvLockAgain(HEAP32[$5 + 104 >> 2]);
 }
 global$0 = $5 + 112 | 0;
 return HEAP32[$5 + 108 >> 2];
}
function std____2__unique_ptr_TfLiteFullyConnectedParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__Allocate_TfLiteFullyConnectedParams__28_29($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $1 = HEAP32[$2 + 8 >> 2];
 $3 = TfLiteFullyConnectedParams__20tflite__BuiltinDataAllocator__AllocatePOD_TfLiteFullyConnectedParams__28_29(HEAP32[$1 >> 2]);
 tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__SafeBuiltinDataAllocator_28tflite__BuiltinDataAllocator__29($2, HEAP32[$1 >> 2]);
 std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___unique_ptr_true_2c_20void__28TfLiteConvParams__2c_20std____2____dependent_type_std____2____unique_ptr_deleter_sfinae_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__2c_20true_____good_rval_ref_type_29($0, $3, $2);
 global$0 = $2 + 16 | 0;
}
function std____2__unique_ptr_TfLiteDepthwiseConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__Allocate_TfLiteDepthwiseConvParams__28_29($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $1 = HEAP32[$2 + 8 >> 2];
 $3 = TfLiteDepthwiseConvParams__20tflite__BuiltinDataAllocator__AllocatePOD_TfLiteDepthwiseConvParams__28_29(HEAP32[$1 >> 2]);
 tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__SafeBuiltinDataAllocator_28tflite__BuiltinDataAllocator__29($2, HEAP32[$1 >> 2]);
 std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___unique_ptr_true_2c_20void__28TfLiteConvParams__2c_20std____2____dependent_type_std____2____unique_ptr_deleter_sfinae_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__2c_20true_____good_rval_ref_type_29($0, $3, $2);
 global$0 = $2 + 16 | 0;
}
function jspGetNamedVariable($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = $1;
 label$1 : {
  if ((HEAP32[80549] & 63) == 1) {
   $2 = jspeiFindInScopes(HEAP32[$1 + 12 >> 2]);
   break label$1;
  }
  $2 = 0;
 }
 HEAP32[$0 + 8 >> 2] = $2;
 if (!(HEAP32[$1 + 8 >> 2] | (HEAP32[80549] & 63) != 1)) {
  label$4 : {
   if (jswIsBuiltInObject(HEAP32[$1 + 12 >> 2]) & 1) {
    HEAP32[$1 + 4 >> 2] = jswFindBuiltInFunction(0, HEAP32[$1 + 12 >> 2]);
    if (!HEAP32[$1 + 4 >> 2]) {
     HEAP32[$1 + 4 >> 2] = jspNewBuiltin(HEAP32[$1 + 12 >> 2]);
    }
    if (HEAP32[$1 + 4 >> 2]) {
     HEAP32[$1 + 8 >> 2] = jsvAddNamedChild(HEAP32[80545], HEAP32[$1 + 4 >> 2], HEAP32[$1 + 12 >> 2]);
     jsvUnLock(HEAP32[$1 + 4 >> 2]);
    }
    break label$4;
   }
   HEAP32[$1 + 8 >> 2] = jswFindBuiltInFunction(0, HEAP32[$1 + 12 >> 2]);
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP32[$1 + 8 >> 2] = jsvMakeIntoVariableName(jsvNewFromString(HEAP32[$1 + 12 >> 2]), 0);
   }
  }
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function tflite__ops__micro__activations__SoftmaxFloat_28TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__2c_20tflite__SoftmaxParams_20const__29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 80 | 0;
 global$0 = $3;
 HEAP32[$3 + 76 >> 2] = $0;
 HEAP32[$3 + 72 >> 2] = $1;
 HEAP32[$3 + 68 >> 2] = $2;
 $0 = HEAP32[$3 + 68 >> 2];
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($3 + 40 | 0, HEAP32[$3 + 76 >> 2]);
 $1 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$3 + 76 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($3 + 8 | 0, HEAP32[$3 + 72 >> 2]);
 tflite__reference_ops__Softmax_28tflite__SoftmaxParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($0, $3 + 40 | 0, $1, $3 + 8 | 0, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$3 + 72 >> 2]));
 $0 = $3 + 40 | 0;
 tflite__RuntimeShape___RuntimeShape_28_29($3 + 8 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($0);
 global$0 = $3 + 80 | 0;
}
function jswrap_graphics_setFontSizeX($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 96 | 0;
 global$0 = $3;
 HEAP32[$3 + 88 >> 2] = $0;
 HEAP32[$3 + 84 >> 2] = $1;
 HEAP8[$3 + 83 | 0] = $2;
 label$1 : {
  if (!(graphicsGetFromVar($3 + 8 | 0, HEAP32[$3 + 88 >> 2]) & 1)) {
   HEAP32[$3 + 92 >> 2] = 0;
   break label$1;
  }
  if (HEAP8[$3 + 83 | 0] & 1) {
   if (HEAP32[$3 + 84 >> 2] < 1) {
    HEAP32[$3 + 84 >> 2] = 1;
   }
   if (HEAP32[$3 + 84 >> 2] > 8191) {
    HEAP32[$3 + 84 >> 2] = 8191;
   }
  }
  if (!(!((HEAPU8[$3 + 33 | 0] | HEAPU8[$3 + 34 | 0] << 8) & 32768) | HEAP32[$3 + 84 >> 2] & 32768)) {
   jsvObjectRemoveChild(HEAP32[$3 + 88 >> 2], 127547);
   jsvObjectRemoveChild(HEAP32[$3 + 88 >> 2], 127552);
   jsvObjectRemoveChild(HEAP32[$3 + 88 >> 2], 127557);
   jsvObjectRemoveChild(HEAP32[$3 + 88 >> 2], 127562);
  }
  $0 = HEAP32[$3 + 84 >> 2];
  HEAP8[$3 + 33 | 0] = $0;
  HEAP8[$3 + 34 | 0] = $0 >>> 8;
  graphicsSetVar($3 + 8 | 0);
  HEAP32[$3 + 92 >> 2] = jsvLockAgain(HEAP32[$3 + 88 >> 2]);
 }
 global$0 = $3 + 96 | 0;
 return HEAP32[$3 + 92 >> 2];
}
function std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___reset_28TfLiteConvParams__29($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = 0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 4 >> 2] = HEAP32[std____2____compressed_pair_TfLiteConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29_20const($0) >> 2];
 $2 = HEAP32[$1 + 8 >> 2];
 HEAP32[std____2____compressed_pair_TfLiteConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29_20const($0) >> 2] = $2;
 if (HEAP32[$1 + 4 >> 2]) {
  tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__operator_28_29_28void__29(std____2____compressed_pair_TfLiteConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___second_28_29($0), HEAP32[$1 + 4 >> 2]);
 }
 global$0 = $1 + 16 | 0;
}
function std____2__unique_ptr_TfLiteSoftmaxParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__Allocate_TfLiteSoftmaxParams__28_29($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $1 = HEAP32[$2 + 8 >> 2];
 $3 = TfLiteSoftmaxParams__20tflite__BuiltinDataAllocator__AllocatePOD_TfLiteSoftmaxParams__28_29(HEAP32[$1 >> 2]);
 tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__SafeBuiltinDataAllocator_28tflite__BuiltinDataAllocator__29($2, HEAP32[$1 >> 2]);
 std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___unique_ptr_true_2c_20void__28TfLiteConvParams__2c_20std____2____dependent_type_std____2____unique_ptr_deleter_sfinae_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__2c_20true_____good_rval_ref_type_29($0, $3, $2);
 global$0 = $2 + 16 | 0;
}
function std____2__unique_ptr_TfLiteReshapeParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__Allocate_TfLiteReshapeParams__28_29($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $1 = HEAP32[$2 + 8 >> 2];
 $3 = TfLiteReshapeParams__20tflite__BuiltinDataAllocator__AllocatePOD_TfLiteReshapeParams__28_29(HEAP32[$1 >> 2]);
 tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__SafeBuiltinDataAllocator_28tflite__BuiltinDataAllocator__29($2, HEAP32[$1 >> 2]);
 std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___unique_ptr_true_2c_20void__28TfLiteConvParams__2c_20std____2____dependent_type_std____2____unique_ptr_deleter_sfinae_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__2c_20true_____good_rval_ref_type_29($0, $3, $2);
 global$0 = $2 + 16 | 0;
}
function lcdMemLCD_setPixel($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 global$0 = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP8[324605] = 1;
 HEAP32[$4 + 16 >> 2] = lcdMemLCD_convert16to3(HEAP32[$4 + 16 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2]);
 HEAP32[$4 + 12 >> 2] = (Math_imul(HEAP32[$4 + 24 >> 2], 3) + 16 | 0) + (Math_imul(HEAP32[$4 + 20 >> 2], 68) << 3);
 HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 12 >> 2] & 7;
 $0 = HEAP32[$4 + 12 >> 2] >> 3;
 $0 = HEAPU8[$0 + 324608 | 0] | HEAPU8[$0 + 324609 | 0] << 8;
 HEAP16[$4 + 6 >> 1] = ($0 << 24 | $0 << 8 & 16711680) >>> 16;
 HEAP16[$4 + 6 >> 1] = HEAPU16[$4 + 6 >> 1] & 16719871 >> HEAP32[$4 + 8 >> 2] | HEAP32[$4 + 16 >> 2] << 13 - HEAP32[$4 + 8 >> 2];
 $0 = HEAP32[$4 + 12 >> 2] >> 3;
 $1 = HEAPU16[$4 + 6 >> 1];
 $1 = ($1 << 24 | $1 << 8 & 16711680) >>> 16;
 HEAP8[$0 + 324608 | 0] = $1;
 HEAP8[$0 + 324609 | 0] = $1 >>> 8;
 global$0 = $4 + 32 | 0;
}
function jshPushIOWatchEvent($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP8[$1 + 31 | 0] = $0;
 HEAP8[$1 + 30 | 0] = jshGetWatchedPinState(HEAPU8[$1 + 31 | 0]) & 1;
 HEAP32[$1 + 24 >> 2] = HEAPU8[$1 + 31 | 0] - 1;
 label$1 : {
  if (HEAP32[(HEAP32[$1 + 24 >> 2] << 2) + 322320 >> 2]) {
   label$3 : {
    if ((HEAP32[(HEAP32[$1 + 24 >> 2] << 2) + 322320 >> 2] & -256) == -256) {
     HEAP8[$1 + 23 | 0] = HEAP32[(HEAP32[$1 + 24 >> 2] << 2) + 322320 >> 2];
     if (jshPinGetValue(HEAPU8[$1 + 23 | 0]) & 1) {
      HEAP8[$1 + 31 | 0] = HEAPU8[$1 + 31 | 0] | 64;
     }
     break label$3;
    }
    FUNCTION_TABLE[HEAP32[(HEAP32[$1 + 24 >> 2] << 2) + 322320 >> 2]](HEAP8[$1 + 30 | 0] & 1, HEAPU8[$1 + 31 | 0]);
    break label$1;
   }
  }
  if (HEAP8[$1 + 30 | 0] & 1) {
   HEAP8[$1 + 31 | 0] = HEAPU8[$1 + 31 | 0] | 32;
  }
  HEAP32[$1 + 8 >> 2] = jshGetSystemTime();
  HEAP32[$1 + 12 >> 2] = i64toi32_i32$HIGH_BITS;
  jshPushIOEvent(HEAPU8[$1 + 31 | 0], HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2]);
 }
 global$0 = $1 + 32 | 0;
}
function jswrap_spi_setup($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 $3 = $2 + 8 | 0;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP8[$2 + 23 | 0] = jsiGetDeviceFromClass(HEAP32[$2 + 28 >> 2]);
 label$1 : {
  if (!(jsspiPopulateSPIInfo($3, HEAP32[$2 + 24 >> 2]) & 1)) {
   break label$1;
  }
  label$2 : {
   if (!(HEAPU8[$2 + 23 | 0] < 24 | HEAPU8[$2 + 23 | 0] > 24)) {
    jshUSARTSetup(HEAPU8[$2 + 23 | 0], $2 + 8 | 0);
    break label$2;
   }
   if (HEAPU8[$2 + 23 | 0]) {
    break label$1;
   }
   if (HEAPU8[$2 + 13 | 0] != 255) {
    jshPinSetState(HEAPU8[$2 + 13 | 0], 1);
   }
   if (HEAPU8[$2 + 14 | 0] != 255) {
    jshPinSetState(HEAPU8[$2 + 14 | 0], 4);
   }
   if (HEAPU8[$2 + 15 | 0] != 255) {
    jshPinSetState(HEAPU8[$2 + 15 | 0], 1);
   }
  }
  if (HEAP32[$2 + 24 >> 2]) {
   jsvUnLock(jsvSetNamedChild(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2]));
   break label$1;
  }
  jsvObjectRemoveChild(HEAP32[$2 + 28 >> 2], 125679);
 }
 global$0 = $2 + 32 | 0;
}
function std____2__unique_ptr_TfLitePoolParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__Allocate_TfLitePoolParams__28_29($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $1 = HEAP32[$2 + 8 >> 2];
 $3 = TfLitePoolParams__20tflite__BuiltinDataAllocator__AllocatePOD_TfLitePoolParams__28_29(HEAP32[$1 >> 2]);
 tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__SafeBuiltinDataAllocator_28tflite__BuiltinDataAllocator__29($2, HEAP32[$1 >> 2]);
 std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___unique_ptr_true_2c_20void__28TfLiteConvParams__2c_20std____2____dependent_type_std____2____unique_ptr_deleter_sfinae_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__2c_20true_____good_rval_ref_type_29($0, $3, $2);
 global$0 = $2 + 16 | 0;
}
function std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__Allocate_TfLiteConvParams__28_29($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $1 = HEAP32[$2 + 8 >> 2];
 $3 = TfLiteConvParams__20tflite__BuiltinDataAllocator__AllocatePOD_TfLiteConvParams__28_29(HEAP32[$1 >> 2]);
 tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__SafeBuiltinDataAllocator_28tflite__BuiltinDataAllocator__29($2, HEAP32[$1 >> 2]);
 std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___unique_ptr_true_2c_20void__28TfLiteConvParams__2c_20std____2____dependent_type_std____2____unique_ptr_deleter_sfinae_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__2c_20true_____good_rval_ref_type_29($0, $3, $2);
 global$0 = $2 + 16 | 0;
}
function jshSetFlowControlXON($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
 if (!(HEAPU8[$2 + 15 | 0] < 21 | HEAPU8[$2 + 15 | 0] > 22)) {
  if (!(HEAP8[$2 + 14 | 0] & 1)) {
   HEAP8[324176] = 1;
  }
  HEAP32[$2 + 8 >> 2] = HEAPU8[$2 + 15 | 0] - 21;
  HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2] + 322308;
  if (HEAPU8[HEAP32[$2 + 4 >> 2]] & 8) {
   label$4 : {
    if (HEAP8[$2 + 14 | 0] & 1) {
     if ((HEAPU8[HEAP32[$2 + 4 >> 2]] & 6) == 4) {
      $0 = HEAP32[$2 + 4 >> 2];
      HEAP8[$0 | 0] = HEAPU8[$0 | 0] | 2;
      jshUSARTUnSetup(HEAPU8[$2 + 15 | 0]);
     }
     break label$4;
    }
    if (!(HEAPU8[HEAP32[$2 + 4 >> 2]] & 5)) {
     $0 = HEAP32[$2 + 4 >> 2];
     HEAP8[$0 | 0] = HEAPU8[$0 | 0] | 1;
     jshUSARTUnSetup(HEAPU8[$2 + 15 | 0]);
    }
   }
  }
  HEAP8[$2 + 3 | 0] = HEAPU8[HEAP32[$2 + 8 >> 2] + 322310 | 0];
  if (HEAPU8[$2 + 3 | 0] != 255) {
   jshPinSetValue(HEAPU8[$2 + 3 | 0], (HEAPU8[$2 + 14 | 0] ^ -1) & 1);
  }
 }
 global$0 = $2 + 16 | 0;
}
function jsvGetLineAndCol($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 80 | 0;
 global$0 = $4;
 HEAP32[$4 + 76 >> 2] = $0;
 HEAP32[$4 + 72 >> 2] = $1;
 HEAP32[$4 + 68 >> 2] = $2;
 HEAP32[$4 + 64 >> 2] = $3;
 HEAP32[$4 + 60 >> 2] = 1;
 HEAP32[$4 + 56 >> 2] = 1;
 HEAP32[$4 + 52 >> 2] = 0;
 jsvStringIteratorNew($4 + 16 | 0, HEAP32[$4 + 76 >> 2], 0);
 while (1) {
  label$2 : {
   if (!(jsvStringIteratorHasChar($4 + 16 | 0) & 1)) {
    break label$2;
   }
   HEAP8[$4 + 15 | 0] = jsvStringIteratorGetCharAndNext($4 + 16 | 0);
   if (HEAP32[$4 + 52 >> 2] == HEAP32[$4 + 72 >> 2]) {
    break label$2;
   }
   HEAP32[$4 + 60 >> 2] = HEAP32[$4 + 60 >> 2] + 1;
   if (HEAP8[$4 + 15 | 0] == 10) {
    HEAP32[$4 + 60 >> 2] = 1;
    HEAP32[$4 + 56 >> 2] = HEAP32[$4 + 56 >> 2] + 1;
   }
   HEAP32[$4 + 52 >> 2] = HEAP32[$4 + 52 >> 2] + 1;
   continue;
  }
  break;
 }
 jsvStringIteratorFree($4 + 16 | 0);
 HEAP32[HEAP32[$4 + 68 >> 2] >> 2] = HEAP32[$4 + 56 >> 2];
 HEAP32[HEAP32[$4 + 64 >> 2] >> 2] = HEAP32[$4 + 60 >> 2];
 global$0 = $4 + 80 | 0;
}
function tflite__MicroAllocator__Create_28unsigned_20char__2c_20unsigned_20long_2c_20tflite__ErrorReporter__29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 HEAP32[$3 + 16 >> 2] = tflite__AlignPointerUp_28unsigned_20char__2c_20unsigned_20long_29(HEAP32[$3 + 28 >> 2], 16);
 if (HEAP32[$3 + 16 >> 2] != HEAP32[$3 + 28 >> 2]) {
  $0 = HEAP32[$3 + 20 >> 2];
  HEAP32[$3 >> 2] = HEAP32[$3 + 16 >> 2] - HEAP32[$3 + 28 >> 2];
  tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 131656, $3);
 }
 HEAP32[$3 + 12 >> 2] = (HEAP32[$3 + 28 >> 2] + HEAP32[$3 + 24 >> 2] | 0) - HEAP32[$3 + 16 >> 2];
 $0 = tflite__MicroAllocator__Create_28tflite__SimpleMemoryAllocator__2c_20tflite__ErrorReporter__29(tflite__SimpleMemoryAllocator__Create_28tflite__ErrorReporter__2c_20unsigned_20char__2c_20unsigned_20long_29(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 16 >> 2], HEAP32[$3 + 12 >> 2]), HEAP32[$3 + 20 >> 2]);
 global$0 = $3 + 32 | 0;
 return $0;
}
function jswrap_flash_write($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $3 = global$0 - 16 | 0;
 $2 = $3;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 label$1 : {
  if (jsvIsUndefined(HEAP32[$2 + 12 >> 2]) & 1) {
   jsExceptionHere(1, 121144, 0);
   break label$1;
  }
  HEAP32[$2 + 4 >> 2] = 0;
  HEAP32[$2 >> 2] = jsvGetDataPointer(HEAP32[$2 + 12 >> 2], $2 + 4 | 0);
  if (!(HEAP32[$2 >> 2] | !HEAP32[$2 + 12 >> 2])) {
   HEAP32[$2 + 4 >> 2] = jsvIterateCallbackCount(HEAP32[$2 + 12 >> 2]);
   label$4 : {
    if (HEAP32[$2 + 4 >> 2] + 256 >>> 0 > 1e6) {
     jsExceptionHere(1, 121164, 0);
     break label$4;
    }
    $0 = $3 - (HEAP32[$2 + 4 >> 2] + 15 & -16) | 0;
    global$0 = $0;
    HEAP32[$2 >> 2] = $0;
    jsvIterateCallbackToBytes(HEAP32[$2 + 12 >> 2], HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]);
   }
  }
  if (!HEAP32[$2 >> 2] | !HEAP32[$2 + 4 >> 2]) {
   break label$1;
  }
  jshFlashWriteAligned(HEAP32[$2 >> 2], HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
 }
 global$0 = $2 + 16 | 0;
}
function OneWireWrite($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 global$0 = $4;
 HEAP8[$4 + 31 | 0] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 16 >> 2] = $2;
 HEAP32[$4 + 20 >> 2] = $3;
 jshPinSetState(HEAPU8[$4 + 31 | 0], 3);
 HEAP32[$4 + 8 >> 2] = 1;
 HEAP32[$4 + 12 >> 2] = 0;
 while (1) {
  label$2 : {
   $0 = HEAP32[$4 + 24 >> 2];
   HEAP32[$4 + 24 >> 2] = $0 + -1;
   if (($0 | 0) <= 0) {
    break label$2;
   }
   label$3 : {
    if (HEAP32[$4 + 16 >> 2] & HEAP32[$4 + 8 >> 2] | HEAP32[$4 + 20 >> 2] & HEAP32[$4 + 12 >> 2]) {
     jshPinSetValue(HEAPU8[$4 + 31 | 0], 0);
     do_indexing(10);
     jshPinSetValue(HEAPU8[$4 + 31 | 0], 1);
     do_indexing(55);
     break label$3;
    }
    jshPinSetValue(HEAPU8[$4 + 31 | 0], 0);
    do_indexing(65);
    jshPinSetValue(HEAPU8[$4 + 31 | 0], 1);
    do_indexing(5);
   }
   $1 = HEAP32[$4 + 8 >> 2];
   $2 = HEAP32[$4 + 12 >> 2] << 1 | $1 >>> 31;
   HEAP32[$4 + 8 >> 2] = $1 << 1;
   HEAP32[$4 + 12 >> 2] = $2;
   continue;
  }
  break;
 }
 global$0 = $4 + 32 | 0;
}
function jshTransmitMove($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 15 | 0] = 19;
 HEAP8[$1 + 14 | 0] = $0;
 label$1 : {
  if (!(HEAPU8[$1 + 14 | 0] != 18 ? HEAPU8[$1 + 14 | 0] != 17 : 0)) {
   HEAP8[$1 + 13 | 0] = HEAPU8[$1 + 14 | 0] == 18 ? 17 : 18;
   HEAP32[$1 + 8 >> 2] = jshGetCharToTransmit(HEAPU8[$1 + 15 | 0]);
   while (1) {
    if (HEAP32[$1 + 8 >> 2] >= 0) {
     jshPushIOCharEvent(HEAPU8[$1 + 13 | 0], HEAP32[$1 + 8 >> 2] << 24 >> 24);
     HEAP32[$1 + 8 >> 2] = jshGetCharToTransmit(HEAPU8[$1 + 15 | 0]);
     continue;
    }
    break;
   }
   break label$1;
  }
  HEAP8[$1 + 7 | 0] = HEAPU8[322305];
  while (1) {
   if (HEAPU8[$1 + 7 | 0] != HEAPU8[322304]) {
    if (HEAPU8[$1 + 15 | 0] == (HEAPU8[(HEAPU8[$1 + 7 | 0] << 1) + 322384 | 0] & 31)) {
     HEAP8[(HEAPU8[$1 + 7 | 0] << 1) + 322384 | 0] = HEAPU8[$1 + 14 | 0] | HEAPU8[(HEAPU8[$1 + 7 | 0] << 1) + 322384 | 0] & -32;
    }
    HEAP8[$1 + 7 | 0] = HEAPU8[$1 + 7 | 0] + 1;
    continue;
   }
   break;
  }
 }
 global$0 = $1 + 16 | 0;
}
function std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___unique_ptr_true_2c_20void__28TfLiteConvParams__2c_20std____2____dependent_type_std____2____unique_ptr_deleter_sfinae_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__2c_20true_____good_rval_ref_type_29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 std____2____compressed_pair_TfLiteConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_____compressed_pair_TfLiteConvParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28TfLiteConvParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___29(HEAP32[$3 + 12 >> 2], $3 + 8 | 0, tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(HEAP32[$3 + 4 >> 2]));
 global$0 = $3 + 16 | 0;
}
function jsvNewWithFlags($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP16[$1 + 10 >> 1] = $0;
 label$1 : {
  if (HEAP32[35541]) {
   HEAP8[322179] = HEAPU8[322179] | 32;
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 4 >> 2] = 0;
  if (HEAPU16[71084]) {
   HEAP32[$1 + 4 >> 2] = jsvGetAddressOf(HEAPU16[71084]);
   HEAP16[71084] = jsvGetNextSibling(HEAP32[$1 + 4 >> 2]);
   HEAP8[142161] = 1;
  }
  if (HEAP32[$1 + 4 >> 2]) {
   jsvResetVariable(HEAP32[$1 + 4 >> 2], HEAPU16[$1 + 10 >> 1]);
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
   break label$1;
  }
  HEAP8[322179] = HEAPU8[322179] | 8;
  if (jsvGarbageCollect()) {
   HEAP32[$1 + 12 >> 2] = jsvNewWithFlags(HEAPU16[$1 + 10 >> 1]);
   break label$1;
  }
  if (jsiFreeMoreMemory() & 1) {
   HEAP32[$1 + 12 >> 2] = jsvNewWithFlags(HEAPU16[$1 + 10 >> 1]);
   break label$1;
  }
  HEAP8[322179] = HEAPU8[322179] | 16;
  jspSetInterrupted(1);
  HEAP32[$1 + 12 >> 2] = 0;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jsfFlashContainsCode() {
 var $0 = 0, $1 = 0, $2 = 0;
 $0 = global$0 - 128 | 0;
 global$0 = $0;
 jsfNameFromString($0 + 96 | 0, 78212);
 HEAP32[$0 + 56 >> 2] = HEAP32[$0 + 120 >> 2];
 $1 = HEAP32[$0 + 116 >> 2];
 HEAP32[$0 + 48 >> 2] = HEAP32[$0 + 112 >> 2];
 HEAP32[$0 + 52 >> 2] = $1;
 $1 = HEAP32[$0 + 108 >> 2];
 HEAP32[$0 + 40 >> 2] = HEAP32[$0 + 104 >> 2];
 HEAP32[$0 + 44 >> 2] = $1;
 $1 = HEAP32[$0 + 100 >> 2];
 HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 96 >> 2];
 HEAP32[$0 + 36 >> 2] = $1;
 $2 = jsfFindFile($0 + 32 | 0, 0);
 $1 = 1;
 if (!$2) {
  jsfNameFromString($0 - -64 | 0, 78221);
  HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 88 >> 2];
  $1 = HEAP32[$0 + 84 >> 2];
  HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 80 >> 2];
  HEAP32[$0 + 20 >> 2] = $1;
  $1 = HEAP32[$0 + 76 >> 2];
  HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 72 >> 2];
  HEAP32[$0 + 12 >> 2] = $1;
  $1 = HEAP32[$0 + 68 >> 2];
  HEAP32[$0 >> 2] = HEAP32[$0 + 64 >> 2];
  HEAP32[$0 + 4 >> 2] = $1;
  $1 = (jsfFindFile($0, 0) | 0) != 0;
 }
 global$0 = $0 + 128 | 0;
 return $1;
}
function jswrap_promise_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 HEAP32[$1 + 24 >> 2] = jspromise_create();
 if (HEAP32[$1 + 24 >> 2]) {
  HEAP32[$1 + 16 >> 2] = jsvNewNativeFunction(585, 32776);
  HEAP32[$1 + 20 >> 2] = jsvNewNativeFunction(584, 32776);
  if (HEAP32[$1 + 16 >> 2]) {
   jsvObjectSetChild(HEAP32[$1 + 16 >> 2], 125115, HEAP32[$1 + 24 >> 2]);
  }
  if (HEAP32[$1 + 20 >> 2]) {
   jsvObjectSetChild(HEAP32[$1 + 20 >> 2], 125115, HEAP32[$1 + 24 >> 2]);
  }
  HEAP32[$1 + 12 >> 2] = HEAP32[80549];
  if (HEAP32[$1 + 28 >> 2]) {
   jsvUnLock(jspeFunctionCall(HEAP32[$1 + 28 >> 2], 0, HEAP32[$1 + 24 >> 2], 0, 2, $1 + 16 | 0));
  }
  HEAP32[80549] = HEAP32[$1 + 12 >> 2];
  jsvUnLockMany(2, $1 + 16 | 0);
  HEAP32[$1 + 8 >> 2] = jspGetException();
  if (HEAP32[$1 + 8 >> 2]) {
   _jswrap_promise_queuereject(HEAP32[$1 + 24 >> 2], HEAP32[$1 + 8 >> 2]);
   jsvUnLock(HEAP32[$1 + 8 >> 2]);
  }
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 24 >> 2];
}
function jswrap_storage_readJSON($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 80 | 0;
 global$0 = $2;
 HEAP32[$2 + 72 >> 2] = $0;
 HEAP8[$2 + 71 | 0] = $1;
 jsfNameFromVar($2 + 32 | 0, HEAP32[$2 + 72 >> 2]);
 HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 56 >> 2];
 $0 = HEAP32[$2 + 52 >> 2];
 HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 48 >> 2];
 HEAP32[$2 + 20 >> 2] = $0;
 $0 = HEAP32[$2 + 44 >> 2];
 HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 40 >> 2];
 HEAP32[$2 + 12 >> 2] = $0;
 $0 = HEAP32[$2 + 36 >> 2];
 HEAP32[$2 >> 2] = HEAP32[$2 + 32 >> 2];
 HEAP32[$2 + 4 >> 2] = $0;
 HEAP32[$2 + 64 >> 2] = jsfReadFile($2, 0, 0);
 label$1 : {
  if (!HEAP32[$2 + 64 >> 2]) {
   HEAP32[$2 + 76 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 28 >> 2] = jswrap_json_parse(HEAP32[$2 + 64 >> 2]);
  jsvUnLock(HEAP32[$2 + 64 >> 2]);
  if (HEAP8[$2 + 71 | 0] & 1) {
   jsvUnLock(jspGetException());
   HEAP32[80549] = HEAP32[80549] & -33;
  }
  HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 28 >> 2];
 }
 global$0 = $2 + 80 | 0;
 return HEAP32[$2 + 76 >> 2];
}
function jsiIsWatchingPin($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP8[$1 + 30 | 0] = $0;
 label$1 : {
  if (jshGetPinShouldStayWatched(HEAPU8[$1 + 30 | 0]) & 1) {
   HEAP8[$1 + 31 | 0] = 1;
   break label$1;
  }
  $0 = $1 + 16 | 0;
  HEAP8[$1 + 29 | 0] = 0;
  HEAP32[$1 + 24 >> 2] = jsvLock(HEAPU16[161111]);
  jsvObjectIteratorNew($0, HEAP32[$1 + 24 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue($1 + 16 | 0) & 1) {
    HEAP32[$1 + 12 >> 2] = jsvObjectIteratorGetValue($1 + 16 | 0);
    HEAP32[$1 + 8 >> 2] = jsvObjectGetChild(HEAP32[$1 + 12 >> 2], 81100, 0);
    if ((jshGetPinFromVar(HEAP32[$1 + 8 >> 2]) & 255) == HEAPU8[$1 + 30 | 0]) {
     HEAP8[$1 + 29 | 0] = 1;
    }
    $0 = $1 + 16 | 0;
    jsvUnLock2(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2]);
    jsvObjectIteratorNext($0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree($1 + 16 | 0);
  jsvUnLock(HEAP32[$1 + 24 >> 2]);
  HEAP8[$1 + 31 | 0] = HEAP8[$1 + 29 | 0] & 1;
 }
 global$0 = $1 + 32 | 0;
 return HEAP8[$1 + 31 | 0] & 1;
}
function tflite__MatchingFlatSize_28tflite__RuntimeShape_20const__2c_20tflite__RuntimeShape_20const__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 label$1 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$2 + 12 >> 2]) | 0) != (tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$2 + 8 >> 2]) | 0)) {
   break label$1;
  }
 }
 HEAP32[$2 + 4 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$2 + 12 >> 2]);
 HEAP32[$2 >> 2] = 0;
 while (1) {
  if (HEAP32[$2 >> 2] < HEAP32[$2 + 4 >> 2]) {
   label$4 : {
    if ((tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$2 + 12 >> 2], HEAP32[$2 >> 2]) | 0) != (tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$2 + 8 >> 2], HEAP32[$2 >> 2]) | 0)) {
     break label$4;
    }
   }
   HEAP32[$2 >> 2] = HEAP32[$2 >> 2] + 1;
   continue;
  }
  break;
 }
 $0 = tflite__RuntimeShape__FlatSize_28_29_20const(HEAP32[$2 + 12 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0;
}
function jswrap_spi_send_cb($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = $3 - (HEAP32[$3 + 8 >> 2] + 15 & -16) | 0;
 global$0 = $0;
 HEAP32[$3 >> 2] = $0;
 FUNCTION_TABLE[HEAP32[HEAP32[$3 + 4 >> 2] >> 2]](HEAP32[$3 + 12 >> 2], HEAP32[$3 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2] + 4 | 0);
 $0 = HEAP32[$3 + 4 >> 2];
 HEAP32[$0 + 24 >> 2] = HEAP32[$3 + 8 >> 2] + HEAP32[$0 + 24 >> 2];
 $0 = HEAP32[$3 + 4 >> 2];
 HEAP32[$0 + 20 >> 2] = HEAP32[$3 + 8 >> 2] + HEAP32[$0 + 20 >> 2];
 while (1) {
  label$2 : {
   $0 = HEAP32[$3 + 8 >> 2];
   HEAP32[$3 + 8 >> 2] = $0 + -1;
   if (!$0) {
    break label$2;
   }
   $0 = HEAP32[$3 + 4 >> 2] + 28 | 0;
   $1 = HEAP32[$3 >> 2];
   HEAP32[$3 >> 2] = $1 + 1;
   jsvArrayBufferIteratorSetByteValue($0, HEAP8[$1 | 0]);
   jsvArrayBufferIteratorNext(HEAP32[$3 + 4 >> 2] + 28 | 0);
   continue;
  }
  break;
 }
 global$0 = $3 + 16 | 0;
}
function jspeBlockNoBrackets() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 label$1 : {
  if ((HEAP32[80549] & 63) == 1) {
   while (1) {
    if (HEAP16[HEAP32[35539] + 2 >> 1] ? HEAP16[HEAP32[35539] + 2 >> 1] != 125 : 0) {
     HEAP32[$0 + 12 >> 2] = jspeStatement();
     jsvCheckReferenceError(HEAP32[$0 + 12 >> 2]);
     jsvUnLock(HEAP32[$0 + 12 >> 2]);
     if (HEAP32[80549] & 112) {
      if (!(!HEAP32[35539] | HEAP32[80549] & 128)) {
       HEAP32[80549] = HEAP32[80549] | 128;
       HEAP32[$0 + 8 >> 2] = jsvObjectGetChild(HEAP32[80546], 79602, 27);
       if (HEAP32[$0 + 8 >> 2]) {
        jsvAppendPrintf(HEAP32[$0 + 8 >> 2], 80561, 0);
        jspAppendStackTrace(HEAP32[$0 + 8 >> 2]);
        jsvUnLock(HEAP32[$0 + 8 >> 2]);
       }
      }
     }
     if (HEAP32[80549] & 80) {
      break label$1;
     }
     if ((HEAP32[80549] & 63) != 1) {
      jspeSkipBlock();
      break label$1;
     }
     continue;
    }
    break;
   }
   break label$1;
  }
  jspeSkipBlock();
 }
 global$0 = $0 + 16 | 0;
}
function jsfRemoveCodeFromFlash() {
 var $0 = 0, $1 = 0;
 $0 = global$0 - 128 | 0;
 global$0 = $0;
 $1 = $0 + 96 | 0;
 jsiConsolePrintString(78237);
 jsfNameFromString($1, 78212);
 HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 120 >> 2];
 $1 = HEAP32[$0 + 116 >> 2];
 HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 112 >> 2];
 HEAP32[$0 + 20 >> 2] = $1;
 $1 = HEAP32[$0 + 108 >> 2];
 HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 104 >> 2];
 HEAP32[$0 + 12 >> 2] = $1;
 $1 = HEAP32[$0 + 100 >> 2];
 HEAP32[$0 >> 2] = HEAP32[$0 + 96 >> 2];
 HEAP32[$0 + 4 >> 2] = $1;
 jsfEraseFile($0);
 jsfNameFromString($0 - -64 | 0, 78221);
 HEAP32[$0 + 56 >> 2] = HEAP32[$0 + 88 >> 2];
 $1 = HEAP32[$0 + 84 >> 2];
 HEAP32[$0 + 48 >> 2] = HEAP32[$0 + 80 >> 2];
 HEAP32[$0 + 52 >> 2] = $1;
 $1 = HEAP32[$0 + 76 >> 2];
 HEAP32[$0 + 40 >> 2] = HEAP32[$0 + 72 >> 2];
 HEAP32[$0 + 44 >> 2] = $1;
 $1 = HEAP32[$0 + 68 >> 2];
 HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 64 >> 2];
 HEAP32[$0 + 36 >> 2] = $1;
 jsfEraseFile($0 + 32 | 0);
 jsiConsolePrintString(78257);
 global$0 = $0 + 128 | 0;
}
function jswrap_string_substr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 $0 = $3;
 $2 = jsvIsUndefined(HEAP32[$3 + 16 >> 2]) & 1;
 $1 = 2147483647;
 label$1 : {
  if ($2) {
   break label$1;
  }
  $1 = jsvGetInteger(HEAP32[$3 + 16 >> 2]);
 }
 HEAP32[$0 + 8 >> 2] = $1;
 if (HEAP32[$3 + 8 >> 2] < 0) {
  HEAP32[$3 + 8 >> 2] = 0;
 }
 if (HEAP32[$3 + 20 >> 2] < 0) {
  HEAP32[$3 + 20 >> 2] = jsvGetStringLength(HEAP32[$3 + 24 >> 2]) + HEAP32[$3 + 20 >> 2];
 }
 if (HEAP32[$3 + 20 >> 2] < 0) {
  HEAP32[$3 + 20 >> 2] = 0;
 }
 HEAP32[$3 + 12 >> 2] = jsvNewWithFlags(27);
 label$5 : {
  if (!HEAP32[$3 + 12 >> 2]) {
   HEAP32[$3 + 28 >> 2] = 0;
   break label$5;
  }
  jsvAppendStringVar(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 8 >> 2]);
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2];
 }
 global$0 = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}
function jslSkipWhiteSpace() {
 var $0 = 0;
 while (1) {
  while (1) {
   if (isWhitespace(HEAP8[HEAP32[35539]]) & 1) {
    jslGetNextCh();
    continue;
   }
   break;
  }
  label$2 : {
   if (HEAP8[HEAP32[35539]] != 47) {
    break label$2;
   }
   if ((jslNextCh() & 255) == 47) {
    while (1) {
     if (HEAP8[HEAP32[35539]] ? HEAP8[HEAP32[35539]] != 10 : 0) {
      jslGetNextCh();
      continue;
     }
     break;
    }
    jslGetNextCh();
    continue;
   }
   if ((jslNextCh() & 255) == 42) {
    jslGetNextCh();
    jslGetNextCh();
    while (1) {
     if (HEAP8[HEAP32[35539]]) {
      if (HEAP8[HEAP32[35539]] == 42) {
       $0 = (jslNextCh() & 255) == 47;
      } else {
       $0 = 0;
      }
      $0 = $0 ^ -1;
     } else {
      $0 = 0;
     }
     if ($0 & 1) {
      jslGetNextCh();
      continue;
     }
     break;
    }
    if (!HEAPU8[HEAP32[35539]]) {
     HEAP16[HEAP32[35539] + 2 >> 1] = 137;
     break label$2;
    }
    jslGetNextCh();
    jslGetNextCh();
    continue;
   }
  }
  break;
 }
}
function graphicsStructInit($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 global$0 = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 $0 = HEAP32[$4 + 12 >> 2];
 HEAP8[$0 + 8 | 0] = 0;
 HEAP8[$0 + 9 | 0] = 0;
 HEAP8[$0 + 10 | 0] = 0;
 HEAP8[$0 + 11 | 0] = 0;
 $0 = HEAP32[$4 + 12 >> 2];
 $1 = HEAP32[$4 + 8 >> 2];
 HEAP8[$0 + 12 | 0] = $1;
 HEAP8[$0 + 13 | 0] = $1 >>> 8;
 $0 = HEAP32[$4 + 12 >> 2];
 $1 = HEAP32[$4 + 4 >> 2];
 HEAP8[$0 + 14 | 0] = $1;
 HEAP8[$0 + 15 | 0] = $1 >>> 8;
 HEAP8[HEAP32[$4 + 12 >> 2] + 16 | 0] = HEAP32[$4 >> 2];
 graphicsStructResetState(HEAP32[$4 + 12 >> 2]);
 $0 = HEAP32[$4 + 12 >> 2];
 HEAP8[$0 + 44 | 0] = 32768;
 HEAP8[$0 + 45 | 0] = 128;
 $0 = HEAP32[$4 + 12 >> 2];
 HEAP8[$0 + 46 | 0] = 32768;
 HEAP8[$0 + 47 | 0] = 128;
 $0 = HEAP32[$4 + 12 >> 2];
 HEAP8[$0 + 40 | 0] = 32767;
 HEAP8[$0 + 41 | 0] = 127;
 $0 = HEAP32[$4 + 12 >> 2];
 HEAP8[$0 + 42 | 0] = 32767;
 HEAP8[$0 + 43 | 0] = 127;
 global$0 = $4 + 16 | 0;
}
function jswrap_i2c_setup($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 $3 = $2 + 8 | 0;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP8[$2 + 23 | 0] = jsiGetDeviceFromClass(HEAP32[$2 + 28 >> 2]);
 if (jsi2cPopulateI2CInfo($3, HEAP32[$2 + 24 >> 2]) & 1) {
  label$2 : {
   if (!(HEAPU8[$2 + 23 | 0] < 25 | HEAPU8[$2 + 23 | 0] > 25)) {
    jshUSARTSetup(HEAPU8[$2 + 23 | 0], $2 + 8 | 0);
    break label$2;
   }
   if (!HEAPU8[$2 + 23 | 0]) {
    if (HEAPU8[$2 + 12 | 0] != 255) {
     jshPinSetValue(HEAPU8[$2 + 12 | 0], 1);
     jshPinSetState(HEAPU8[$2 + 12 | 0], 3);
    }
    if (HEAPU8[$2 + 13 | 0] != 255) {
     jshPinSetValue(HEAPU8[$2 + 13 | 0], 1);
     jshPinSetState(HEAPU8[$2 + 13 | 0], 3);
    }
   }
  }
  label$7 : {
   if (HEAP32[$2 + 24 >> 2]) {
    jsvUnLock(jsvSetNamedChild(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2]));
    break label$7;
   }
   jsvObjectRemoveChild(HEAP32[$2 + 28 >> 2], 125679);
  }
 }
 global$0 = $2 + 32 | 0;
}
function _jswrap_espruino_FFT_getData($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = global$0 - 80 | 0;
 global$0 = $3;
 HEAP32[$3 + 76 >> 2] = $0;
 HEAP32[$3 + 72 >> 2] = $1;
 HEAP32[$3 + 68 >> 2] = $2;
 HEAP32[$3 + 4 >> 2] = 0;
 if (jsvIsIterable(HEAP32[$3 + 72 >> 2]) & 1) {
  jsvIteratorNew($3 + 8 | 0, HEAP32[$3 + 72 >> 2], 1);
  while (1) {
   if (HEAPU32[$3 + 4 >> 2] < HEAPU32[$3 + 68 >> 2]) {
    $0 = jsvIteratorHasElement($3 + 8 | 0);
   } else {
    $0 = 0;
   }
   if ($0 & 1) {
    $0 = $3 + 8 | 0;
    $4 = jsvIteratorGetFloatValue($0);
    $1 = HEAP32[$3 + 76 >> 2];
    $2 = HEAP32[$3 + 4 >> 2];
    HEAP32[$3 + 4 >> 2] = $2 + 1;
    HEAPF64[$1 + ($2 << 3) >> 3] = $4;
    jsvIteratorNext($0);
    continue;
   }
   break;
  }
  jsvIteratorFree($3 + 8 | 0);
 }
 while (1) {
  if (HEAPU32[$3 + 4 >> 2] < HEAPU32[$3 + 68 >> 2]) {
   $0 = HEAP32[$3 + 76 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   HEAP32[$3 + 4 >> 2] = $1 + 1;
   HEAPF64[$0 + ($1 << 3) >> 3] = 0;
   continue;
  }
  break;
 }
 global$0 = $3 + 80 | 0;
}
function jswrap_modules_getCached() {
 var $0 = 0, $1 = 0;
 $0 = global$0 - 32 | 0;
 global$0 = $0;
 HEAP32[$0 + 24 >> 2] = jsvNewWithFlags(3);
 label$1 : {
  if (!HEAP32[$0 + 24 >> 2]) {
   HEAP32[$0 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$0 + 20 >> 2] = jswrap_modules_getModuleList();
  if (!HEAP32[$0 + 20 >> 2]) {
   HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 24 >> 2];
   break label$1;
  }
  jsvObjectIteratorNew($0 + 16 | 0, HEAP32[$0 + 20 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue($0 + 16 | 0) & 1) {
    $1 = $0 + 16 | 0;
    HEAP32[$0 + 12 >> 2] = jsvObjectIteratorGetKey($1);
    HEAP32[$0 + 8 >> 2] = jsvCopyNameOnly(HEAP32[$0 + 12 >> 2], 0, 0);
    jsvArrayPushAndUnLock(HEAP32[$0 + 24 >> 2], HEAP32[$0 + 8 >> 2]);
    jsvUnLock(HEAP32[$0 + 12 >> 2]);
    jsvObjectIteratorNext($1);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree($0 + 16 | 0);
  jsvUnLock(HEAP32[$0 + 20 >> 2]);
  HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 24 >> 2];
 }
 global$0 = $0 + 32 | 0;
 return HEAP32[$0 + 28 >> 2];
}
function jsfIsErased($0, $1) {
 var $2 = 0;
 $2 = global$0 - 160 | 0;
 global$0 = $2;
 HEAP32[$2 + 152 >> 2] = $0;
 HEAP32[$2 + 148 >> 2] = $1;
 label$1 : {
  while (1) {
   if (HEAP32[$2 + 148 >> 2]) {
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 148 >> 2];
    if (HEAPU32[$2 + 12 >> 2] > 128) {
     HEAP32[$2 + 12 >> 2] = 128;
    }
    jshFlashRead($2 + 16 | 0, HEAP32[$2 + 152 >> 2], HEAP32[$2 + 12 >> 2]);
    HEAP32[$2 + 8 >> 2] = 0;
    while (1) {
     if (HEAPU32[$2 + 8 >> 2] < HEAPU32[$2 + 12 >> 2]) {
      if (HEAPU8[HEAP32[$2 + 8 >> 2] + ($2 + 16 | 0) | 0] != 255) {
       HEAP8[$2 + 159 | 0] = 0;
       break label$1;
      } else {
       HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] + 1;
       continue;
      }
     }
     break;
    }
    HEAP32[$2 + 152 >> 2] = HEAP32[$2 + 12 >> 2] + HEAP32[$2 + 152 >> 2];
    HEAP32[$2 + 148 >> 2] = HEAP32[$2 + 148 >> 2] - HEAP32[$2 + 12 >> 2];
    continue;
   }
   break;
  }
  HEAP8[$2 + 159 | 0] = 1;
 }
 global$0 = $2 + 160 | 0;
 return HEAP8[$2 + 159 | 0] & 1;
}
function jsi2cWrite($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 48 | 0;
 global$0 = $5;
 HEAP32[$5 + 40 >> 2] = $0;
 HEAP8[$5 + 39 | 0] = $1;
 HEAP32[$5 + 32 >> 2] = $2;
 HEAP32[$5 + 28 >> 2] = $3;
 HEAP8[$5 + 27 | 0] = $4;
 label$1 : {
  if (!(HEAPU8[HEAP32[$5 + 40 >> 2] + 5 | 0] != 255 ? HEAPU8[HEAP32[$5 + 40 >> 2] + 4 | 0] != 255 : 0)) {
   HEAP8[$5 + 47 | 0] = 0;
   break label$1;
  }
  $0 = $5 + 8 | 0;
  i2c_initstruct($0, HEAP32[$5 + 40 >> 2]);
  i2c_start($0);
  if (!(i2c_wr($0, HEAPU8[$5 + 39 | 0] << 1) & 1)) {
   HEAP8[$5 + 47 | 0] = 0;
   break label$1;
  }
  HEAP32[$5 + 4 >> 2] = 0;
  while (1) {
   if (HEAP32[$5 + 4 >> 2] < HEAP32[$5 + 32 >> 2]) {
    i2c_wr($5 + 8 | 0, HEAPU8[HEAP32[$5 + 28 >> 2] + HEAP32[$5 + 4 >> 2] | 0]);
    HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 4 >> 2] + 1;
    continue;
   }
   break;
  }
  if (HEAP8[$5 + 27 | 0] & 1) {
   i2c_stop($5 + 8 | 0);
  }
  HEAP8[HEAP32[$5 + 40 >> 2] + 6 | 0] = HEAP8[$5 + 10 | 0] & 1;
  HEAP8[$5 + 47 | 0] = 1;
 }
 global$0 = $5 + 48 | 0;
}
function _jswrap_graphics_getFontHeightInternal($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1 : {
  if (!HEAP32[HEAP32[$2 + 4 >> 2] >> 2]) {
   HEAP32[$2 + 12 >> 2] = HEAPU16[HEAP32[$2 + 4 >> 2] + 8 >> 1];
   break label$1;
  }
  if (HEAP32[HEAP32[$2 + 4 >> 2] >> 2] == 8192) {
   HEAP32[$2 + 12 >> 2] = Math_imul(HEAPU16[HEAP32[$2 + 4 >> 2] + 8 >> 1], 6);
   break label$1;
  }
  if (HEAP32[HEAP32[$2 + 4 >> 2] >> 2] == 16384) {
   HEAP32[$2 + 12 >> 2] = HEAPU16[HEAP32[$2 + 4 >> 2] + 8 >> 1] << 3;
   break label$1;
  }
  if (HEAP32[HEAP32[$2 + 4 >> 2] >> 2] & 32768) {
   $0 = HEAP32[$2 + 8 >> 2];
   HEAP32[$2 + 12 >> 2] = Math_imul(HEAPU16[HEAP32[$2 + 4 >> 2] + 8 >> 1], jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 127557, 0)));
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = 0;
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function jswrap_waveform_kill() {
 var $0 = 0, $1 = 0;
 $0 = global$0 - 32 | 0;
 global$0 = $0;
 HEAP32[$0 + 28 >> 2] = jsvObjectGetChild(HEAP32[80546], 126051, 0);
 if (HEAP32[$0 + 28 >> 2]) {
  jsvObjectIteratorNew($0 + 24 | 0, HEAP32[$0 + 28 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue($0 + 24 | 0) & 1) {
    HEAP32[$0 + 20 >> 2] = jsvObjectIteratorGetValue($0 + 24 | 0);
    HEAP8[$0 + 19 | 0] = jsvGetBoolAndUnLock(jsvObjectGetChild(HEAP32[$0 + 20 >> 2], 126056, 0)) & 1;
    if (HEAP8[$0 + 19 | 0] & 1) {
     HEAP32[$0 + 12 >> 2] = jswrap_waveform_getBuffer(HEAP32[$0 + 20 >> 2], 0, 0);
     if (!(jstStopBufferTimerTask(HEAP32[$0 + 12 >> 2]) & 1)) {
      jsExceptionHere(1, 126113, 0);
     }
     jsvUnLock(HEAP32[$0 + 12 >> 2]);
    }
    $1 = $0 + 24 | 0;
    jsvUnLock(HEAP32[$0 + 20 >> 2]);
    jsvObjectIteratorRemoveAndGotoNext($1, HEAP32[$0 + 28 >> 2]);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree($0 + 24 | 0);
  jsvUnLock(HEAP32[$0 + 28 >> 2]);
 }
 global$0 = $0 + 32 | 0;
}
function jsvIsStringNumericStrict($0) {
 var $1 = 0;
 $1 = global$0 + -64 | 0;
 global$0 = $1;
 HEAP32[$1 + 56 >> 2] = $0;
 jsvStringIteratorNew($1 + 16 | 0, HEAP32[$1 + 56 >> 2], 0);
 HEAP8[$1 + 15 | 0] = 0;
 HEAP8[$1 + 14 | 0] = 0;
 HEAP32[$1 + 8 >> 2] = 0;
 label$1 : {
  while (1) {
   if (jsvStringIteratorHasChar($1 + 16 | 0) & 1) {
    HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
    HEAP8[$1 + 7 | 0] = jsvStringIteratorGetCharAndNext($1 + 16 | 0);
    if (!(isNumeric(HEAP8[$1 + 7 | 0]) & 1)) {
     jsvStringIteratorFree($1 + 16 | 0);
     HEAP8[$1 + 63 | 0] = 0;
     break label$1;
    }
    if (!(HEAP8[$1 + 15 | 0] & 1 | HEAP8[$1 + 7 | 0] != 48)) {
     HEAP8[$1 + 14 | 0] = 1;
    }
    if (HEAP8[$1 + 7 | 0] != 48) {
     HEAP8[$1 + 15 | 0] = 1;
    }
    continue;
   }
   break;
  }
  jsvStringIteratorFree($1 + 16 | 0);
  HEAP8[$1 + 63 | 0] = (HEAP32[$1 + 8 >> 2] > 0 ? HEAP8[$1 + 14 | 0] & 1 ? HEAP32[$1 + 8 >> 2] == 1 : 1 : 0) & 1;
 }
 global$0 = $1 - -64 | 0;
 return HEAP8[$1 + 63 | 0] & 1;
}
function lcdMemLCD_init($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 $0 = HEAP32[$1 + 28 >> 2];
 HEAP8[$0 + 12 | 0] = 176;
 HEAP8[$0 + 13 | 0] = 0;
 $0 = HEAP32[$1 + 28 >> 2];
 HEAP8[$0 + 14 | 0] = 176;
 HEAP8[$0 + 15 | 0] = 0;
 HEAP8[HEAP32[$1 + 28 >> 2] + 16 | 0] = 16;
 memset(324608, 0, 11974);
 HEAP32[$1 + 24 >> 2] = 0;
 while (1) {
  if (HEAP32[$1 + 24 >> 2] < 176) {
   HEAP8[Math_imul(HEAP32[$1 + 24 >> 2], 68) + 324608 | 0] = 128;
   HEAP8[(Math_imul(HEAP32[$1 + 24 >> 2], 68) + 1 | 0) + 324608 | 0] = HEAP32[$1 + 24 >> 2] + 1;
   HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 24 >> 2] + 1;
   continue;
  }
  break;
 }
 $0 = $1 + 8 | 0;
 jshPinOutput(5, 0);
 jshPinOutput(26, 0);
 jshPinOutput(27, 1);
 jshPinOutput(7, 1);
 jshPinOutput(6, 1);
 jshSPIInitInfo($0);
 HEAP8[$1 + 8 | 0] = 4e6;
 HEAP8[$1 + 9 | 0] = 15625;
 HEAP8[$1 + 10 | 0] = 61;
 HEAP8[$1 + 11 | 0] = 0;
 HEAP8[$1 + 15 | 0] = 27;
 HEAP8[$1 + 13 | 0] = 26;
 jshUSARTSetup(24, $0);
 global$0 = $1 + 32 | 0;
}
function jswrap_array_concat($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 $3 = $2 + 16 | 0;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 20 >> 2] = jsvNewWithFlags(3);
 jsvObjectIteratorNew($3, HEAP32[$2 + 24 >> 2]);
 HEAP32[$2 + 12 >> 2] = jsvLockAgain(HEAP32[$2 + 28 >> 2]);
 while (1) {
  label$2 : {
   if (jsvIsArray(HEAP32[$2 + 12 >> 2]) & 1) {
    jsvArrayPushAll(HEAP32[$2 + 20 >> 2], HEAP32[$2 + 12 >> 2]);
    break label$2;
   }
   jsvArrayPush(HEAP32[$2 + 20 >> 2], HEAP32[$2 + 12 >> 2]);
  }
  $1 = $2 + 16 | 0;
  jsvUnLock(HEAP32[$2 + 12 >> 2]);
  $0 = $2;
  label$4 : {
   if (jsvObjectIteratorHasValue($1) & 1) {
    $1 = jsvObjectIteratorGetValue($2 + 16 | 0);
    break label$4;
   }
   $1 = 0;
  }
  HEAP32[$0 + 12 >> 2] = $1;
  jsvObjectIteratorNext($2 + 16 | 0);
  if (HEAP32[$2 + 12 >> 2]) {
   continue;
  }
  break;
 }
 jsvObjectIteratorFree($2 + 16 | 0);
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 20 >> 2];
}
function tflite__MatchingFlatSizeSkipDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 HEAP32[$3 + 16 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$3 + 28 >> 2]);
 HEAP32[$3 + 12 >> 2] = 0;
 while (1) {
  if (HEAP32[$3 + 12 >> 2] < HEAP32[$3 + 16 >> 2]) {
   if (HEAP32[$3 + 12 >> 2] != HEAP32[$3 + 24 >> 2]) {
    label$4 : {
     if ((tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 12 >> 2]) | 0) != (tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 12 >> 2]) | 0)) {
      break label$4;
     }
    }
   }
   HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 $0 = tflite__FlatSizeSkipDim_28tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2]);
 global$0 = $3 + 32 | 0;
 return $0;
}
function jswrap_graphics_theme($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvNewWithFlags(5);
 jsvObjectSetChildAndUnLock(HEAP32[$1 + 8 >> 2], 128156, jsvNewFromInteger(HEAPU8[324592] | HEAPU8[324593] << 8));
 jsvObjectSetChildAndUnLock(HEAP32[$1 + 8 >> 2], 128159, jsvNewFromInteger(HEAPU8[324594] | HEAPU8[324595] << 8));
 jsvObjectSetChildAndUnLock(HEAP32[$1 + 8 >> 2], 128162, jsvNewFromInteger(HEAPU8[324596] | HEAPU8[324597] << 8));
 jsvObjectSetChildAndUnLock(HEAP32[$1 + 8 >> 2], 128166, jsvNewFromInteger(HEAPU8[324598] | HEAPU8[324599] << 8));
 jsvObjectSetChildAndUnLock(HEAP32[$1 + 8 >> 2], 128170, jsvNewFromInteger(HEAPU8[324600] | HEAPU8[324601] << 8));
 jsvObjectSetChildAndUnLock(HEAP32[$1 + 8 >> 2], 128174, jsvNewFromInteger(HEAPU8[324602] | HEAPU8[324603] << 8));
 jsvObjectSetChildAndUnLock(HEAP32[$1 + 8 >> 2], 128178, jsvNewFromBool(HEAP8[324604] & 1));
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function jsvCreateEmptyVarList() {
 var $0 = 0, $1 = 0;
 $0 = global$0 - 32 | 0;
 global$0 = $0;
 HEAP32[35541] = 1;
 HEAP16[71084] = 0;
 $1 = $0 + 16 | 0;
 jsvSetNextSibling($1, 0);
 HEAP32[$0 + 12 >> 2] = $1;
 HEAP16[$0 + 10 >> 1] = 1;
 while (1) {
  if (HEAPU16[$0 + 10 >> 1] <= HEAPU32[35415]) {
   HEAP32[$0 + 4 >> 2] = jsvGetAddressOf(HEAPU16[$0 + 10 >> 1]);
   $1 = HEAP32[$0 + 4 >> 2];
   label$3 : {
    if (!((HEAPU8[$1 + 13 | 0] | HEAPU8[$1 + 14 | 0] << 8) & 63)) {
     jsvSetNextSibling(HEAP32[$0 + 12 >> 2], HEAPU16[$0 + 10 >> 1]);
     HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 4 >> 2];
     break label$3;
    }
    if (jsvIsFlatString(HEAP32[$0 + 4 >> 2]) & 1) {
     HEAP16[$0 + 10 >> 1] = HEAPU16[$0 + 10 >> 1] + jsvGetFlatStringBlocks(HEAP32[$0 + 4 >> 2]);
    }
   }
   HEAP16[$0 + 10 >> 1] = HEAPU16[$0 + 10 >> 1] + 1;
   continue;
  }
  break;
 }
 $1 = $0 + 16 | 0;
 jsvSetNextSibling(HEAP32[$0 + 12 >> 2], 0);
 HEAP16[71084] = jsvGetNextSibling($1);
 HEAP32[35541] = 0;
 global$0 = $0 + 32 | 0;
}
function jsvArrayBufferIteratorClone($0, $1) {
 var $2 = 0, $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 $0 = HEAP32[$3 + 8 >> 2];
 $2 = HEAP32[$0 + 4 >> 2];
 $1 = HEAP32[$3 + 12 >> 2];
 HEAP32[$1 >> 2] = HEAP32[$0 >> 2];
 HEAP32[$1 + 4 >> 2] = $2;
 $2 = HEAP32[$0 + 52 >> 2];
 HEAP32[$1 + 48 >> 2] = HEAP32[$0 + 48 >> 2];
 HEAP32[$1 + 52 >> 2] = $2;
 $2 = HEAP32[$0 + 44 >> 2];
 HEAP32[$1 + 40 >> 2] = HEAP32[$0 + 40 >> 2];
 HEAP32[$1 + 44 >> 2] = $2;
 $2 = HEAP32[$0 + 36 >> 2];
 HEAP32[$1 + 32 >> 2] = HEAP32[$0 + 32 >> 2];
 HEAP32[$1 + 36 >> 2] = $2;
 $2 = HEAP32[$0 + 28 >> 2];
 HEAP32[$1 + 24 >> 2] = HEAP32[$0 + 24 >> 2];
 HEAP32[$1 + 28 >> 2] = $2;
 $2 = HEAP32[$0 + 20 >> 2];
 HEAP32[$1 + 16 >> 2] = HEAP32[$0 + 16 >> 2];
 HEAP32[$1 + 20 >> 2] = $2;
 $2 = HEAP32[$0 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = HEAP32[$0 + 8 >> 2];
 HEAP32[$1 + 12 >> 2] = $2;
 jsvStringIteratorClone(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
 global$0 = $3 + 16 | 0;
}
function jswrap_regexp_constructor($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 label$1 : {
  if (!(jsvIsString(HEAP32[$2 + 40 >> 2]) & 1)) {
   HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 40 >> 2];
   jsExceptionHere(3, 125321, $2 + 16 | 0);
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 32 >> 2] = jspNewObject(0, 125364);
  jsvObjectSetChild(HEAP32[$2 + 32 >> 2], 125371, HEAP32[$2 + 40 >> 2]);
  if (!(jsvIsUndefined(HEAP32[$2 + 36 >> 2]) & 1)) {
   label$4 : {
    if (!(jsvIsString(HEAP32[$2 + 36 >> 2]) & 1)) {
     HEAP32[$2 >> 2] = HEAP32[$2 + 40 >> 2];
     jsExceptionHere(3, 125321, $2);
     break label$4;
    }
    jsvObjectSetChild(HEAP32[$2 + 32 >> 2], 125378, HEAP32[$2 + 36 >> 2]);
   }
  }
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 32 >> 2], 125384, jsvNewFromInteger(0));
  HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
 }
 global$0 = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}
function jsi2cPopulateI2CInfo($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 + -64 | 0;
 global$0 = $2;
 $3 = $2 + 16 | 0;
 HEAP32[$2 + 56 >> 2] = $0;
 HEAP32[$2 + 52 >> 2] = $1;
 jshI2CInitInfo(HEAP32[$2 + 56 >> 2]);
 HEAP32[$2 + 16 >> 2] = 83243;
 HEAP16[$2 + 20 >> 1] = 12;
 HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 56 >> 2] + 4;
 HEAP32[$2 + 28 >> 2] = 83247;
 HEAP16[$2 + 32 >> 1] = 12;
 HEAP32[$2 + 36 >> 2] = HEAP32[$2 + 56 >> 2] + 5;
 HEAP32[$2 + 40 >> 2] = 83251;
 HEAP16[$2 + 44 >> 1] = 9;
 HEAP32[$2 + 48 >> 2] = HEAP32[$2 + 56 >> 2];
 label$1 : {
  if (jsvReadConfigObject(HEAP32[$2 + 52 >> 2], $3, 3) & 1) {
   HEAP8[$2 + 15 | 0] = 1;
   $0 = HEAP32[$2 + 56 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) < 100) {
    jsExceptionHere(1, 83259, 0);
    HEAP8[$2 + 15 | 0] = 0;
   }
   HEAP8[$2 + 63 | 0] = HEAP8[$2 + 15 | 0] & 1;
   break label$1;
  }
  HEAP8[$2 + 63 | 0] = 0;
 }
 global$0 = $2 - -64 | 0;
 return HEAP8[$2 + 63 | 0] & 1;
}
function jswrap_pipe_close_listener($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 label$1 : {
  if (!(jsvIsObject(HEAP32[$2 + 28 >> 2]) & 1)) {
   break label$1;
  }
  HEAP32[$2 + 20 >> 2] = pipeGetArray(0);
  if (!HEAP32[$2 + 20 >> 2]) {
   break label$1;
  }
  jsvObjectIteratorNew($2 + 16 | 0, HEAP32[$2 + 20 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue($2 + 16 | 0) & 1) {
    HEAP32[$2 + 12 >> 2] = jsvObjectIteratorGetValue($2 + 16 | 0);
    HEAP32[$2 + 8 >> 2] = jsvObjectGetChild(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 24 >> 2], 0);
    if (HEAP32[$2 + 8 >> 2] == HEAP32[$2 + 28 >> 2]) {
     handlePipeClose(HEAP32[$2 + 20 >> 2], $2 + 16 | 0, HEAP32[$2 + 12 >> 2]);
    }
    $0 = $2 + 16 | 0;
    jsvUnLock2(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 12 >> 2]);
    jsvObjectIteratorNext($0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree($2 + 16 | 0);
  jsvUnLock(HEAP32[$2 + 20 >> 2]);
 }
 global$0 = $2 + 32 | 0;
}
function jspExecuteFunction($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 48 | 0;
 global$0 = $4;
 HEAP32[$4 + 44 >> 2] = $0;
 HEAP32[$4 + 40 >> 2] = $1;
 HEAP32[$4 + 36 >> 2] = $2;
 HEAP32[$4 + 32 >> 2] = $3;
 $0 = $4 + 8 | 0;
 HEAP32[$0 + 16 >> 2] = HEAP32[80549];
 $1 = HEAP32[80548];
 HEAP32[$0 + 8 >> 2] = HEAP32[80547];
 HEAP32[$0 + 12 >> 2] = $1;
 $1 = HEAP32[80546];
 HEAP32[$0 >> 2] = HEAP32[80545];
 HEAP32[$0 + 4 >> 2] = $1;
 HEAP32[80547] = 0;
 HEAP32[80549] = 1;
 HEAP32[80548] = 0;
 HEAP32[$4 + 4 >> 2] = jspeFunctionCall(HEAP32[$4 + 44 >> 2], 0, HEAP32[$4 + 40 >> 2], 0, HEAP32[$4 + 36 >> 2], HEAP32[$4 + 32 >> 2]);
 jspeiClearScopes();
 HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 24 >> 2] | HEAP32[80549] & 6256;
 jspeiClearScopes();
 $1 = HEAP32[$0 + 4 >> 2];
 HEAP32[80545] = HEAP32[$0 >> 2];
 HEAP32[80546] = $1;
 HEAP32[80549] = HEAP32[$0 + 16 >> 2];
 $1 = HEAP32[$0 + 12 >> 2];
 HEAP32[80547] = HEAP32[$0 + 8 >> 2];
 HEAP32[80548] = $1;
 global$0 = $4 + 48 | 0;
 return HEAP32[$4 + 4 >> 2];
}
function jsvStringIteratorGotoEnd($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 while (1) {
  if (jsvGetLastChild(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) & 65535) {
   HEAP32[$1 + 8 >> 2] = jsvLock(jsvGetLastChild(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) & 65535);
   jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
   HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2] = HEAP32[$1 + 8 >> 2];
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$0 + 8 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] + HEAP32[$0 + 8 >> 2];
   $0 = jsvGetCharactersInVar(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
   HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] = $0;
   continue;
  }
  break;
 }
 HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2];
 label$3 : {
  if (HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2]) {
   HEAP32[HEAP32[$1 + 12 >> 2] >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] - 1;
   break label$3;
  }
  HEAP32[HEAP32[$1 + 12 >> 2] >> 2] = 0;
 }
 global$0 = $1 + 16 | 0;
}
function lcdSetPixel_ArrayBuffer_flat1($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 $0 = HEAP32[$4 + 28 >> 2];
 HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 24 >> 2] + Math_imul(HEAP32[$4 + 20 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
 label$1 : {
  if (HEAP32[$4 + 16 >> 2]) {
   $0 = HEAP32[$4 + 28 >> 2];
   $0 = (HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24)) + (HEAP32[$4 + 12 >> 2] >> 3) | 0;
   HEAP8[$0 | 0] = HEAPU8[$0 | 0] | 128 >> (HEAP32[$4 + 12 >> 2] & 7) & 255;
   break label$1;
  }
  $0 = HEAP32[$4 + 28 >> 2];
  $0 = (HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24)) + (HEAP32[$4 + 12 >> 2] >> 3) | 0;
  HEAP8[$0 | 0] = HEAPU8[$0 | 0] & (65407 >> (HEAP32[$4 + 12 >> 2] & 7) & 255);
 }
}
function jsiExecuteEventCallbackArgsArray($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $4 = global$0 - 32 | 0;
 $3 = $4;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 HEAP32[$3 + 12 >> 2] = 0;
 HEAP32[$3 + 8 >> 2] = 0;
 label$1 : {
  if (HEAP32[$3 + 16 >> 2]) {
   HEAP32[$3 + 12 >> 2] = jsvGetArrayLength(HEAP32[$3 + 16 >> 2]);
   if (HEAP32[$3 + 12 >> 2]) {
    $0 = $4 - ((HEAP32[$3 + 12 >> 2] << 2) + 15 & -16) | 0;
    global$0 = $0;
    HEAP32[$3 + 8 >> 2] = $0;
    if (!HEAP32[$3 + 8 >> 2]) {
     HEAP8[$3 + 31 | 0] = 0;
     break label$1;
    }
    jsvGetArrayItems(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
   }
  }
  HEAP8[$3 + 7 | 0] = jsiExecuteEventCallback(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]) & 1;
  jsvUnLockMany(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
  HEAP8[$3 + 31 | 0] = HEAP8[$3 + 7 | 0] & 1;
 }
 global$0 = $3 + 32 | 0;
 return HEAP8[$3 + 31 | 0] & 1;
}
function jsvIteratorNext($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[HEAP32[$1 + 12 >> 2] >> 2] + -1 | 0;
 label$1 : {
  if ($0 >>> 0 > 3) {
   break label$1;
  }
  label$2 : {
   switch ($0 - 1 | 0) {
   case 2:
    $0 = HEAP32[$1 + 12 >> 2];
    HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
    label$6 : {
     if (!(jsvIsIntegerish(HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2]) & 1)) {
      break label$6;
     }
     if ((jsvGetInteger(HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2]) | 0) >= HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) {
      break label$6;
     }
     jsvObjectIteratorNext(HEAP32[$1 + 12 >> 2] + 4 | 0);
    }
    break label$1;
   case 0:
    jsvObjectIteratorNext(HEAP32[$1 + 12 >> 2] + 4 | 0);
    break label$1;
   default:
    jsvStringIteratorNext(HEAP32[$1 + 12 >> 2] + 4 | 0);
    break label$1;
   case 1:
    break label$2;
   }
  }
  jsvArrayBufferIteratorNext(HEAP32[$1 + 12 >> 2] + 4 | 0);
 }
 global$0 = $1 + 16 | 0;
}
function jshGetSerialNumber($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 32 | 0;
 HEAP32[$1 + 28 >> 2] = $0;
 HEAP32[$1 + 24 >> 2] = 32;
 HEAP32[$1 + 20 >> 2] = 0;
 HEAP32[$1 + 8 >> 2] = -559030611;
 HEAP32[$1 + 12 >> 2] = -559030611;
 $0 = HEAP32[$1 + 28 >> 2];
 $2 = HEAPU8[$1 + 20 | 0] | HEAPU8[$1 + 21 | 0] << 8 | (HEAPU8[$1 + 22 | 0] << 16 | HEAPU8[$1 + 23 | 0] << 24);
 HEAP8[$0 | 0] = $2;
 HEAP8[$0 + 1 | 0] = $2 >>> 8;
 HEAP8[$0 + 2 | 0] = $2 >>> 16;
 HEAP8[$0 + 3 | 0] = $2 >>> 24;
 $2 = HEAP32[$1 + 28 >> 2];
 $0 = HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8 | (HEAPU8[$1 + 14 | 0] << 16 | HEAPU8[$1 + 15 | 0] << 24);
 $1 = HEAPU8[$1 + 8 | 0] | HEAPU8[$1 + 9 | 0] << 8 | (HEAPU8[$1 + 10 | 0] << 16 | HEAPU8[$1 + 11 | 0] << 24);
 HEAP8[$2 + 4 | 0] = $1;
 HEAP8[$2 + 5 | 0] = $1 >>> 8;
 HEAP8[$2 + 6 | 0] = $1 >>> 16;
 HEAP8[$2 + 7 | 0] = $1 >>> 24;
 HEAP8[$2 + 8 | 0] = $0;
 HEAP8[$2 + 9 | 0] = $0 >>> 8;
 HEAP8[$2 + 10 | 0] = $0 >>> 16;
 HEAP8[$2 + 11 | 0] = $0 >>> 24;
 return 12;
}
function tflite__GetQuantizedConvolutionMultipler_28TfLiteContext__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor__2c_20double__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 48 | 0;
 global$0 = $5;
 HEAP32[$5 + 40 >> 2] = $0;
 HEAP32[$5 + 36 >> 2] = $1;
 HEAP32[$5 + 32 >> 2] = $2;
 HEAP32[$5 + 28 >> 2] = $3;
 HEAP32[$5 + 24 >> 2] = $4;
 HEAPF64[$5 + 16 >> 3] = Math_fround(HEAPF32[HEAP32[$5 + 36 >> 2] + 8 >> 2] * HEAPF32[HEAP32[$5 + 32 >> 2] + 8 >> 2]);
 label$1 : {
  if (!(HEAPF64[$5 + 16 >> 3] >= 0)) {
   $0 = HEAP32[HEAP32[$5 + 40 >> 2] + 20 >> 2];
   $1 = HEAP32[$5 + 40 >> 2];
   HEAP32[$5 + 8 >> 2] = 137587;
   HEAP32[$5 + 4 >> 2] = 210;
   HEAP32[$5 >> 2] = 137133;
   FUNCTION_TABLE[$0]($1, 137293, $5);
   HEAP32[$5 + 44 >> 2] = 1;
   break label$1;
  }
  HEAPF64[HEAP32[$5 + 24 >> 2] >> 3] = HEAPF64[$5 + 16 >> 3] / +HEAPF32[HEAP32[$5 + 28 >> 2] + 8 >> 2];
  HEAP32[$5 + 44 >> 2] = 0;
 }
 global$0 = $5 + 48 | 0;
 return HEAP32[$5 + 44 >> 2];
}
function jswrap_modules_addCached($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 label$1 : {
  label$2 : {
   if (jsvIsString(HEAP32[$2 + 28 >> 2]) & 1) {
    if (jsvIsString(HEAP32[$2 + 24 >> 2]) & 1) {
     break label$2;
    }
    if (jsvIsFunction(HEAP32[$2 + 24 >> 2]) & 1) {
     break label$2;
    }
   }
   jsExceptionHere(1, 123083, 0);
   break label$1;
  }
  HEAP32[$2 + 20 >> 2] = jswrap_modules_getModuleList();
  if (!HEAP32[$2 + 20 >> 2]) {
   break label$1;
  }
  HEAP32[$2 + 16 >> 2] = jspEvaluateModule(HEAP32[$2 + 24 >> 2]);
  label$4 : {
   if (!HEAP32[$2 + 16 >> 2]) {
    HEAP32[$2 >> 2] = HEAP32[$2 + 28 >> 2];
    jsExceptionHere(1, 123131, $2);
    break label$4;
   }
   jsvObjectSetChildVar(HEAP32[$2 + 20 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 16 >> 2]);
   jsvUnLock(HEAP32[$2 + 16 >> 2]);
  }
  jsvUnLock(HEAP32[$2 + 20 >> 2]);
 }
 global$0 = $2 + 32 | 0;
}
function i2c_stop($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 i2c_pin_wr0(HEAPU8[HEAP32[$1 + 12 >> 2] + 1 | 0]);
 dly(HEAP32[$1 + 12 >> 2]);
 i2c_pin_wr1(HEAPU8[HEAP32[$1 + 12 >> 2]]);
 HEAP32[$1 + 8 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2];
 while (1) {
  if (jshPinGetValue(HEAPU8[HEAP32[$1 + 12 >> 2]]) & 1) {
   $0 = 0;
  } else {
   $0 = HEAP32[$1 + 8 >> 2];
  }
  if ($0) {
   HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + -1;
   continue;
  }
  break;
 }
 if (!(HEAP32[$1 + 8 >> 2] | !HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2])) {
  err(83355);
 }
 dly(HEAP32[$1 + 12 >> 2]);
 i2c_pin_wr1(HEAPU8[HEAP32[$1 + 12 >> 2] + 1 | 0]);
 dly(HEAP32[$1 + 12 >> 2]);
 label$6 : {
  if (!HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2]) {
   break label$6;
  }
  if (jshPinGetValue(HEAPU8[HEAP32[$1 + 12 >> 2] + 1 | 0]) & 1) {
   break label$6;
  }
  err(83370);
 }
 dly(HEAP32[$1 + 12 >> 2]);
 HEAP8[HEAP32[$1 + 12 >> 2] + 2 | 0] = 0;
 global$0 = $1 + 16 | 0;
}
function tflite__GreedyMemoryPlanner__GetOffsetForBuffer_28tflite__ErrorReporter__2c_20int_2c_20int__29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 global$0 = $4;
 HEAP32[$4 + 24 >> 2] = $0;
 HEAP32[$4 + 20 >> 2] = $1;
 HEAP32[$4 + 16 >> 2] = $2;
 HEAP32[$4 + 12 >> 2] = $3;
 $0 = HEAP32[$4 + 24 >> 2];
 tflite__GreedyMemoryPlanner__CalculateOffsetsIfNeeded_28_29($0);
 label$1 : {
  if (!(HEAP32[$4 + 16 >> 2] < HEAP32[$0 + 8 >> 2] ? HEAP32[$4 + 16 >> 2] >= 0 : 0)) {
   $1 = HEAP32[$4 + 20 >> 2];
   $2 = HEAP32[$4 + 16 >> 2];
   HEAP32[$4 + 4 >> 2] = HEAP32[$0 + 8 >> 2];
   HEAP32[$4 >> 2] = $2;
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($1, 136541, $4);
   HEAP32[$4 + 28 >> 2] = 1;
   break label$1;
  }
  HEAP32[HEAP32[$4 + 12 >> 2] >> 2] = HEAP32[HEAP32[$0 + 36 >> 2] + (HEAP32[$4 + 16 >> 2] << 2) >> 2];
  HEAP32[$4 + 28 >> 2] = 0;
 }
 global$0 = $4 + 32 | 0;
 return HEAP32[$4 + 28 >> 2];
}
function _jswrap_array_sort_compare($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP32[$3 + 40 >> 2] = $0;
 HEAP32[$3 + 36 >> 2] = $1;
 HEAP32[$3 + 32 >> 2] = $2;
 label$1 : {
  if (HEAP32[$3 + 32 >> 2]) {
   HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 40 >> 2];
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 36 >> 2];
   HEAPF64[$3 + 16 >> 3] = jsvGetFloatAndUnLock(jspeFunctionCall(HEAP32[$3 + 32 >> 2], 0, 0, 0, 2, $3 + 24 | 0));
   if (HEAPF64[$3 + 16 >> 3] == 0) {
    HEAP32[$3 + 44 >> 2] = 0;
    break label$1;
   }
   HEAP32[$3 + 44 >> 2] = HEAPF64[$3 + 16 >> 3] < 0 ? -1 : 1;
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = jsvAsString(HEAP32[$3 + 40 >> 2]);
  HEAP32[$3 + 8 >> 2] = jsvAsString(HEAP32[$3 + 36 >> 2]);
  HEAP32[$3 + 4 >> 2] = jsvCompareString(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], 0, 0);
  jsvUnLock2(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
  HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 4 >> 2];
 }
 global$0 = $3 + 48 | 0;
 return HEAP32[$3 + 44 >> 2];
}
function st_yield_literal_1($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1 : {
  if (HEAPU32[HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2] >> 2] < HEAPU32[HEAP32[$2 + 20 >> 2] + 4 >> 2]) {
   HEAP16[$2 + 18 >> 1] = get_bits(HEAP32[$2 + 24 >> 2], 8);
   if (HEAPU16[$2 + 18 >> 1] == 65535) {
    HEAP32[$2 + 28 >> 2] = 1;
    break label$1;
   }
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 24 >> 2] + 45;
   HEAP16[$2 + 10 >> 1] = 255;
   HEAP8[$2 + 9 | 0] = HEAPU16[$2 + 18 >> 1];
   $1 = HEAPU8[$2 + 9 | 0];
   $4 = HEAP32[$2 + 12 >> 2];
   $3 = HEAP32[$2 + 24 >> 2];
   $0 = HEAPU16[$3 + 8 >> 1];
   HEAP16[$3 + 8 >> 1] = $0 + 1;
   HEAP8[($0 & HEAPU16[$2 + 10 >> 1]) + $4 | 0] = $1;
   push_byte(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], HEAPU8[$2 + 9 | 0]);
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 28 >> 2] = 1;
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function jswrap_promise_resolve($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = 0;
 label$1 : {
  if (_jswrap_promise_is_promise(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[$1 + 8 >> 2]);
   break label$1;
  }
  if (jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 >> 2] = jsvObjectGetChild(HEAP32[$1 + 8 >> 2], 125217, 0);
   if (jsvIsFunction(HEAP32[$1 >> 2]) & 1) {
    HEAP32[$1 + 4 >> 2] = jswrap_promise_constructor(HEAP32[$1 >> 2]);
   }
   jsvUnLock(HEAP32[$1 >> 2]);
   if (HEAP32[$1 + 4 >> 2]) {
    HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
    break label$1;
   }
  }
  HEAP32[$1 + 4 >> 2] = jspromise_create();
  if (!HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  jspromise_resolve(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 8 >> 2]);
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jswrap_espruino_variance($0, $1) {
 $0 = $0 | 0;
 $1 = +$1;
 var $2 = 0;
 $2 = global$0 - 112 | 0;
 global$0 = $2;
 HEAP32[$2 + 100 >> 2] = $0;
 HEAPF64[$2 + 88 >> 3] = $1;
 label$1 : {
  if (!(jsvIsIterable(HEAP32[$2 + 100 >> 2]) & 1)) {
   HEAP32[$2 >> 2] = HEAP32[$2 + 100 >> 2];
   jsExceptionHere(1, 120139, $2);
   HEAPF64[$2 + 104 >> 3] = nan;
   break label$1;
  }
  HEAPF64[$2 + 80 >> 3] = 0;
  jsvIteratorNew($2 + 16 | 0, HEAP32[$2 + 100 >> 2], 1);
  while (1) {
   if (jsvIteratorHasElement($2 + 16 | 0) & 1) {
    $0 = $2 + 16 | 0;
    HEAPF64[$2 + 8 >> 3] = jsvIteratorGetFloatValue($0);
    HEAPF64[$2 + 8 >> 3] = HEAPF64[$2 + 8 >> 3] - HEAPF64[$2 + 88 >> 3];
    HEAPF64[$2 + 80 >> 3] = HEAPF64[$2 + 80 >> 3] + HEAPF64[$2 + 8 >> 3] * HEAPF64[$2 + 8 >> 3];
    jsvIteratorNext($0);
    continue;
   }
   break;
  }
  jsvIteratorFree($2 + 16 | 0);
  HEAPF64[$2 + 104 >> 3] = HEAPF64[$2 + 80 >> 3];
 }
 global$0 = $2 + 112 | 0;
 return +HEAPF64[$2 + 104 >> 3];
}
function jswrap_arraybufferview_sort($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1 : {
  if (!(jsvIsArrayBuffer(HEAP32[$2 + 24 >> 2]) & 1)) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  $0 = HEAP32[$2 + 24 >> 2];
  HEAP8[$2 + 19 | 0] = ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8) & 32) != 0;
  if (HEAP32[$2 + 20 >> 2]) {
   HEAP32[$2 + 28 >> 2] = jswrap_array_sort(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2]);
   break label$1;
  }
  $0 = $2;
  label$4 : {
   if (HEAP8[$2 + 19 | 0] & 1) {
    $1 = jsvNewNativeFunction(557, 438);
    break label$4;
   }
   $1 = jsvNewNativeFunction(558, 292);
  }
  HEAP32[$0 + 20 >> 2] = $1;
  HEAP32[$2 + 12 >> 2] = jswrap_array_sort(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2]);
  jsvUnLock(HEAP32[$2 + 20 >> 2]);
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function jswrap_arraybuffer_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!(HEAP32[$1 + 8 >> 2] <= 65535 ? HEAP32[$1 + 8 >> 2] >= 0 : 0)) {
   jsExceptionHere(1, 119124, 0);
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$1 + 8 >> 2] > 65535) {
   jsExceptionHere(1, 119156, 0);
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 4 >> 2] = 0;
  if (HEAP32[$1 + 8 >> 2] > 21) {
   HEAP32[$1 + 4 >> 2] = jsvNewFlatStringOfLength(HEAP32[$1 + 8 >> 2]);
  }
  if (!HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 + 4 >> 2] = jsvNewStringOfLength(HEAP32[$1 + 8 >> 2], 0);
  }
  if (!HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 >> 2] = jsvNewArrayBufferFromString(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 8 >> 2]);
  jsvUnLock(HEAP32[$1 + 4 >> 2]);
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jswrap_pipe_drain_listener($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 label$1 : {
  if (!(jsvIsObject(HEAP32[$1 + 28 >> 2]) & 1)) {
   break label$1;
  }
  HEAP32[$1 + 24 >> 2] = pipeGetArray(0);
  if (!HEAP32[$1 + 24 >> 2]) {
   break label$1;
  }
  jsvObjectIteratorNew($1 + 16 | 0, HEAP32[$1 + 24 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue($1 + 16 | 0) & 1) {
    HEAP32[$1 + 12 >> 2] = jsvObjectIteratorGetValue($1 + 16 | 0);
    HEAP32[$1 + 8 >> 2] = jsvObjectGetChild(HEAP32[$1 + 12 >> 2], 124510, 0);
    if (HEAP32[$1 + 8 >> 2] == HEAP32[$1 + 28 >> 2]) {
     jsvObjectSetChildAndUnLock(HEAP32[$1 + 12 >> 2], 124704, jsvNewFromBool(0));
    }
    $0 = $1 + 16 | 0;
    jsvUnLock2(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2]);
    jsvObjectIteratorNext($0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree($1 + 16 | 0);
  jsvUnLock(HEAP32[$1 + 24 >> 2]);
 }
 global$0 = $1 + 32 | 0;
}
function jswrap_espruino_sum($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = global$0 - 96 | 0;
 global$0 = $1;
 HEAP32[$1 + 84 >> 2] = $0;
 label$1 : {
  label$2 : {
   if (jsvIsString(HEAP32[$1 + 84 >> 2]) & 1) {
    break label$2;
   }
   if (jsvIsArray(HEAP32[$1 + 84 >> 2]) & 1) {
    break label$2;
   }
   if (jsvIsArrayBuffer(HEAP32[$1 + 84 >> 2]) & 1) {
    break label$2;
   }
   HEAP32[$1 >> 2] = HEAP32[$1 + 84 >> 2];
   jsExceptionHere(1, 120091, $1);
   HEAPF64[$1 + 88 >> 3] = nan;
   break label$1;
  }
  HEAPF64[$1 + 72 >> 3] = 0;
  jsvIteratorNew($1 + 8 | 0, HEAP32[$1 + 84 >> 2], 0);
  while (1) {
   if (jsvIteratorHasElement($1 + 8 | 0) & 1) {
    $0 = $1 + 8 | 0;
    $2 = jsvIteratorGetFloatValue($0);
    HEAPF64[$1 + 72 >> 3] = HEAPF64[$1 + 72 >> 3] + $2;
    jsvIteratorNext($0);
    continue;
   }
   break;
  }
  jsvIteratorFree($1 + 8 | 0);
  HEAPF64[$1 + 88 >> 3] = HEAPF64[$1 + 72 >> 3];
 }
 global$0 = $1 + 96 | 0;
 return +HEAPF64[$1 + 88 >> 3];
}
function jspeFunctionDefinition($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP8[$1 + 27 | 0] = $0;
 HEAP32[$1 + 20 >> 2] = 0;
 HEAP8[$1 + 19 | 0] = (HEAP32[80549] & 63) == 1;
 if (HEAP8[$1 + 19 | 0] & 1) {
  HEAP32[$1 + 20 >> 2] = jsvNewWithFlags(7);
 }
 HEAP32[$1 + 12 >> 2] = 0;
 if (!(!(HEAP8[$1 + 27 | 0] & 1) | HEAP16[HEAP32[35539] + 2 >> 1] != 128)) {
  if (HEAP32[$1 + 20 >> 2]) {
   HEAP32[$1 + 12 >> 2] = jslGetTokenValueAsVar();
  }
  jslGetNextToken();
 }
 label$4 : {
  if (!(jspeFunctionArguments(HEAP32[$1 + 20 >> 2]) & 1)) {
   jsvUnLock2(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 20 >> 2]);
   HEAP32[$1 + 28 >> 2] = 0;
   break label$4;
  }
  jspeFunctionDefinitionInternal(HEAP32[$1 + 20 >> 2], 0);
  if (!(!HEAP32[$1 + 20 >> 2] | !HEAP32[$1 + 12 >> 2])) {
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 20 >> 2], 79699, HEAP32[$1 + 12 >> 2]);
  }
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function jsiSemiInit($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 15 | 0] = $0;
 jspSoftInit();
 HEAP8[322300] = 0;
 HEAP16[161112] = HEAPU16[161112] & 7904;
 HEAP8[141673] = 255;
 $0 = $1;
 if (HEAP8[$1 + 15 | 0] & 1) {
  $2 = jsfFlashContainsCode();
 } else {
  $2 = 0;
 }
 HEAP8[$0 + 14 | 0] = $2 & 1;
 if (HEAP8[$1 + 14 | 0] & 1) {
  HEAP16[161112] = HEAPU16[161112] & -2049;
  jspSoftKill();
  jsvClearEmptyVarList();
  jsvCreateEmptyVarList();
  jspSoftInit();
 }
 HEAP32[$1 + 8 >> 2] = jsvObjectGetChild(HEAP32[80546], 81366, 0);
 if (HEAP32[$1 + 8 >> 2]) {
  HEAP16[161112] = HEAPU16[161112] | 1024;
 }
 jsvUnLock(HEAP32[$1 + 8 >> 2]);
 jsiSoftInit((HEAPU8[$1 + 15 | 0] ^ -1) & 1);
 if (jsiEcho() & 1) {
  if (!(HEAP8[$1 + 14 | 0] & 1)) {
   if (HEAPU8[141672] != 20) {
    jsiConsolePrintString(81370);
   }
  }
  if (HEAPU8[141672] != 20) {
   jsiConsolePrintString(81553);
  }
  HEAP8[322232] = 1;
 }
 global$0 = $1 + 16 | 0;
}
function jsiTabComplete_findCommon($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 12 >> 2];
 label$1 : {
  if (jsvGetStringLength(HEAP32[$2 + 8 >> 2]) >>> 0 <= HEAPU32[HEAP32[$2 + 4 >> 2] >> 2]) {
   break label$1;
  }
  if (jsvCompareString(HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2], HEAP32[$2 + 8 >> 2], 0, 1)) {
   break label$1;
  }
  $0 = HEAP32[$2 + 4 >> 2];
  HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
  label$2 : {
   if (HEAP32[HEAP32[$2 + 4 >> 2] + 8 >> 2]) {
    HEAP32[$2 >> 2] = jsvGetCommonCharacters(HEAP32[HEAP32[$2 + 4 >> 2] + 8 >> 2], HEAP32[$2 + 8 >> 2]);
    jsvUnLock(HEAP32[HEAP32[$2 + 4 >> 2] + 8 >> 2]);
    HEAP32[HEAP32[$2 + 4 >> 2] + 8 >> 2] = HEAP32[$2 >> 2];
    break label$2;
   }
   $0 = jsvLockAgain(HEAP32[$2 + 8 >> 2]);
   HEAP32[HEAP32[$2 + 4 >> 2] + 8 >> 2] = $0;
  }
 }
 global$0 = $2 + 16 | 0;
}
function jsiHandleMoveUpDown($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 $2 = $1 + 20 | 0;
 $3 = $1 + 24 | 0;
 HEAP32[$1 + 28 >> 2] = $0;
 HEAP32[$1 + 16 >> 2] = jsvGetLinesInString(HEAP32[80557]);
 jsvGetLineAndCol(HEAP32[80557], HEAP32[80559], $2, $3);
 HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 24 >> 2];
 HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 20 >> 2];
 HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + HEAP32[$1 + 28 >> 2];
 if (HEAPU32[$1 + 8 >> 2] < 1) {
  HEAP32[$1 + 8 >> 2] = 1;
 }
 if (HEAPU32[$1 + 8 >> 2] > HEAPU32[$1 + 16 >> 2]) {
  HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 16 >> 2];
 }
 $0 = $1 + 8 | 0;
 $2 = $1 + 12 | 0;
 HEAP32[80559] = jsvGetIndexFromLineAndCol(HEAP32[80557], HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2]);
 jsvGetLineAndCol(HEAP32[80557], HEAP32[80559], $0, $2);
 if (jsiShowInputLine() & 1) {
  jsiMoveCursor(HEAP32[$1 + 24 >> 2], HEAP32[$1 + 20 >> 2], HEAP32[$1 + 12 >> 2], HEAP32[$1 + 8 >> 2]);
 }
 global$0 = $1 + 32 | 0;
}
function int_20gemmlowp__RoundingHalfSum_int__28int_2c_20int_29($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 48 | 0;
 HEAP32[$2 + 44 >> 2] = $0;
 HEAP32[$2 + 40 >> 2] = $1;
 $0 = HEAP32[$2 + 44 >> 2];
 HEAP32[$2 + 32 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $0 >> 31;
 $0 = HEAP32[$2 + 40 >> 2];
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 28 >> 2] = $0 >> 31;
 $1 = HEAP32[$2 + 36 >> 2] + HEAP32[$2 + 28 >> 2] | 0;
 $0 = HEAP32[$2 + 24 >> 2];
 $3 = $0 + HEAP32[$2 + 32 >> 2] | 0;
 if ($3 >>> 0 < $0 >>> 0) {
  $1 = $1 + 1 | 0;
 }
 HEAP32[$2 + 16 >> 2] = $3;
 HEAP32[$2 + 20 >> 2] = $1;
 $0 = HEAP32[$2 + 20 >> 2];
 $0 = (($0 | 0) > 0 ? 1 : ($0 | 0) >= 0 ? HEAPU32[$2 + 16 >> 2] < 0 ? 0 : 1 : 0) ? 1 : -1;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 12 >> 2] = $0 >> 31;
 $0 = HEAP32[$2 + 20 >> 2] + HEAP32[$2 + 12 >> 2] | 0;
 $1 = HEAP32[$2 + 8 >> 2];
 $2 = $1 + HEAP32[$2 + 16 >> 2] | 0;
 if ($2 >>> 0 < $1 >>> 0) {
  $0 = $0 + 1 | 0;
 }
 return __wasm_i64_sdiv($2, $0, 2);
}
function jslPreserveSpaceBetweenTokens($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1 : {
  if (!((HEAP32[$2 + 8 >> 2] != 129 ? !(HEAP32[$2 + 8 >> 2] == 128 | HEAP32[$2 + 8 >> 2] == 130) : 0) | (HEAP32[$2 + 4 >> 2] != 129 ? !(HEAP32[$2 + 4 >> 2] == 128 | HEAP32[$2 + 4 >> 2] == 130) : 0))) {
   HEAP8[$2 + 15 | 0] = 1;
   break label$1;
  }
  label$5 : {
   label$6 : {
    if ((HEAP32[$2 + 4 >> 2] == 45 ? HEAP32[$2 + 8 >> 2] == 45 : 0) | (HEAP32[$2 + 4 >> 2] == 43 ? HEAP32[$2 + 8 >> 2] == 43 : 0) | (HEAP32[$2 + 4 >> 2] == 135 ? HEAP32[$2 + 8 >> 2] == 47 : 0)) {
     break label$6;
    }
    if (HEAP32[$2 + 8 >> 2] != 135) {
     break label$5;
    }
    if (HEAP32[$2 + 4 >> 2] == 47) {
     break label$6;
    }
    if (HEAP32[$2 + 4 >> 2] != 128) {
     break label$5;
    }
   }
   HEAP8[$2 + 15 | 0] = 1;
   break label$1;
  }
  HEAP8[$2 + 15 | 0] = 0;
 }
 return HEAP8[$2 + 15 | 0] & 1;
}
function jswrap_graphics_clearRect($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0, $6 = 0;
 $5 = global$0 - 112 | 0;
 global$0 = $5;
 $6 = $5 + 8 | 0;
 HEAP32[$5 + 104 >> 2] = $0;
 HEAP32[$5 + 100 >> 2] = $1;
 HEAP32[$5 + 96 >> 2] = $2;
 HEAP32[$5 + 92 >> 2] = $3;
 HEAP32[$5 + 88 >> 2] = $4;
 _jswrap_graphics_getRect(HEAP32[$5 + 100 >> 2], $5 + 84 | 0, $5 + 96 | 0, $5 + 92 | 0, $5 + 88 | 0);
 label$1 : {
  if (!(graphicsGetFromVar($6, HEAP32[$5 + 104 >> 2]) & 1)) {
   HEAP32[$5 + 108 >> 2] = 0;
   break label$1;
  }
  $0 = $5 + 8 | 0;
  graphicsFillRect($0, HEAP32[$5 + 84 >> 2], HEAP32[$5 + 96 >> 2], HEAP32[$5 + 92 >> 2], HEAP32[$5 + 88 >> 2], HEAPU8[$5 + 29 | 0] | HEAPU8[$5 + 30 | 0] << 8 | (HEAPU8[$5 + 31 | 0] << 16 | HEAPU8[$5 + 32 | 0] << 24));
  graphicsSetVar($0);
  HEAP32[$5 + 108 >> 2] = jsvLockAgain(HEAP32[$5 + 104 >> 2]);
 }
 global$0 = $5 + 112 | 0;
 return HEAP32[$5 + 108 >> 2];
}
function jsvArrayPopFirst($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (jsvGetFirstChild(HEAP32[$1 + 8 >> 2]) & 65535) {
   HEAP32[$1 + 4 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$1 + 8 >> 2]) & 65535);
   if ((jsvGetFirstChild(HEAP32[$1 + 8 >> 2]) & 65535) == (jsvGetLastChild(HEAP32[$1 + 8 >> 2]) & 65535)) {
    jsvSetLastChild(HEAP32[$1 + 8 >> 2], 0);
   }
   jsvSetFirstChild(HEAP32[$1 + 8 >> 2], jsvGetNextSibling(HEAP32[$1 + 4 >> 2]) & 65535);
   jsvUnRef(HEAP32[$1 + 4 >> 2]);
   if (jsvGetNextSibling(HEAP32[$1 + 4 >> 2]) & 65535) {
    HEAP32[$1 >> 2] = jsvLock(jsvGetNextSibling(HEAP32[$1 + 4 >> 2]) & 65535);
    jsvSetPrevSibling(HEAP32[$1 >> 2], 0);
    jsvUnLock(HEAP32[$1 >> 2]);
   }
   jsvSetNextSibling(HEAP32[$1 + 4 >> 2], 0);
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function i2c_wr_bit($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 label$1 : {
  if (HEAP8[$2 + 11 | 0] & 1) {
   i2c_pin_wr1(HEAPU8[HEAP32[$2 + 12 >> 2] + 1 | 0]);
   break label$1;
  }
  i2c_pin_wr0(HEAPU8[HEAP32[$2 + 12 >> 2] + 1 | 0]);
 }
 dly(HEAP32[$2 + 12 >> 2]);
 i2c_pin_wr1(HEAPU8[HEAP32[$2 + 12 >> 2]]);
 dly(HEAP32[$2 + 12 >> 2]);
 dly(HEAP32[$2 + 12 >> 2]);
 HEAP32[$2 + 4 >> 2] = HEAP32[HEAP32[$2 + 12 >> 2] + 8 >> 2];
 while (1) {
  if (jshPinGetValue(HEAPU8[HEAP32[$2 + 12 >> 2]]) & 1) {
   $0 = 0;
  } else {
   $0 = HEAP32[$2 + 4 >> 2];
  }
  if ($0) {
   HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + -1;
   continue;
  }
  break;
 }
 if (!(HEAP32[$2 + 4 >> 2] | !HEAP32[HEAP32[$2 + 12 >> 2] + 8 >> 2])) {
  err(83329);
 }
 i2c_pin_wr0(HEAPU8[HEAP32[$2 + 12 >> 2]]);
 i2c_pin_wr1(HEAPU8[HEAP32[$2 + 12 >> 2] + 1 | 0]);
 dly(HEAP32[$2 + 12 >> 2]);
 global$0 = $2 + 16 | 0;
}
function _jswrap_drawImageLayerNextXRepeat($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP8[HEAP32[$1 + 12 >> 2] + 33 | 0] & 1) {
  if (HEAP32[HEAP32[$1 + 12 >> 2] + 180 >> 2] < 0) {
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$0 + 180 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 156 >> 2] + HEAP32[$0 + 180 >> 2];
  }
  if (HEAP32[HEAP32[$1 + 12 >> 2] + 180 >> 2] >= HEAP32[HEAP32[$1 + 12 >> 2] + 156 >> 2]) {
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$0 + 180 >> 2] = HEAP32[$0 + 180 >> 2] - HEAP32[HEAP32[$1 + 12 >> 2] + 156 >> 2];
  }
  if (HEAP32[HEAP32[$1 + 12 >> 2] + 184 >> 2] < 0) {
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$0 + 184 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 160 >> 2] + HEAP32[$0 + 184 >> 2];
  }
  if (HEAP32[HEAP32[$1 + 12 >> 2] + 184 >> 2] >= HEAP32[HEAP32[$1 + 12 >> 2] + 160 >> 2]) {
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$0 + 184 >> 2] = HEAP32[$0 + 184 >> 2] - HEAP32[HEAP32[$1 + 12 >> 2] + 160 >> 2];
  }
 }
}
function jswrap_graphics_fillRect($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0, $6 = 0;
 $5 = global$0 - 112 | 0;
 global$0 = $5;
 $6 = $5 + 8 | 0;
 HEAP32[$5 + 104 >> 2] = $0;
 HEAP32[$5 + 100 >> 2] = $1;
 HEAP32[$5 + 96 >> 2] = $2;
 HEAP32[$5 + 92 >> 2] = $3;
 HEAP32[$5 + 88 >> 2] = $4;
 _jswrap_graphics_getRect(HEAP32[$5 + 100 >> 2], $5 + 84 | 0, $5 + 96 | 0, $5 + 92 | 0, $5 + 88 | 0);
 label$1 : {
  if (!(graphicsGetFromVar($6, HEAP32[$5 + 104 >> 2]) & 1)) {
   HEAP32[$5 + 108 >> 2] = 0;
   break label$1;
  }
  $0 = $5 + 8 | 0;
  graphicsFillRect($0, HEAP32[$5 + 84 >> 2], HEAP32[$5 + 96 >> 2], HEAP32[$5 + 92 >> 2], HEAP32[$5 + 88 >> 2], HEAPU8[$5 + 25 | 0] | HEAPU8[$5 + 26 | 0] << 8 | (HEAPU8[$5 + 27 | 0] << 16 | HEAPU8[$5 + 28 | 0] << 24));
  graphicsSetVar($0);
  HEAP32[$5 + 108 >> 2] = jsvLockAgain(HEAP32[$5 + 104 >> 2]);
 }
 global$0 = $5 + 112 | 0;
 return HEAP32[$5 + 108 >> 2];
}
function jshPinWatch($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP8[$2 + 14 | 0] = $0;
 HEAP8[$2 + 13 | 0] = $1;
 label$1 : {
  if (HEAP8[$2 + 13 | 0] & 1) {
   HEAP32[$2 + 8 >> 2] = 0;
   while (1) {
    if (HEAP32[$2 + 8 >> 2] < 16) {
     if (HEAPU8[HEAP32[$2 + 8 >> 2] + 336592 | 0] == 255) {
      HEAP8[HEAP32[$2 + 8 >> 2] + 336592 | 0] = HEAPU8[$2 + 14 | 0];
      HEAP8[$2 + 15 | 0] = HEAP32[$2 + 8 >> 2] + 1;
      break label$1;
     } else {
      HEAP32[$2 + 4 >> 2] = 0;
      while (1) {
       if (HEAP32[$2 + 4 >> 2] < 16) {
        if (HEAPU8[HEAP32[$2 + 4 >> 2] + 336592 | 0] == HEAPU8[$2 + 14 | 0]) {
         HEAP8[HEAP32[$2 + 4 >> 2] + 336592 | 0] = 255;
        }
        HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + 1;
        continue;
       }
       break;
      }
      HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] + 1;
      continue;
     }
    }
    break;
   }
  }
  HEAP8[$2 + 15 | 0] = 0;
 }
 return HEAPU8[$2 + 15 | 0];
}
function jsvIteratorClone($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[HEAP32[$2 + 12 >> 2] >> 2] = HEAP32[HEAP32[$2 + 8 >> 2] >> 2];
 $0 = HEAP32[HEAP32[$2 + 8 >> 2] >> 2] + -1 | 0;
 label$1 : {
  if ($0 >>> 0 > 3) {
   break label$1;
  }
  label$2 : {
   switch ($0 - 1 | 0) {
   case 2:
    HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2] = HEAP32[HEAP32[$2 + 8 >> 2] + 12 >> 2];
    $0 = jsvLockAgain(HEAP32[HEAP32[$2 + 8 >> 2] + 8 >> 2]);
    HEAP32[HEAP32[$2 + 12 >> 2] + 8 >> 2] = $0;
   case 0:
    jsvObjectIteratorClone(HEAP32[$2 + 12 >> 2] + 4 | 0, HEAP32[$2 + 8 >> 2] + 4 | 0);
    break label$1;
   default:
    jsvStringIteratorClone(HEAP32[$2 + 12 >> 2] + 4 | 0, HEAP32[$2 + 8 >> 2] + 4 | 0);
    break label$1;
   case 1:
    break label$2;
   }
  }
  jsvArrayBufferIteratorClone(HEAP32[$2 + 12 >> 2] + 4 | 0, HEAP32[$2 + 8 >> 2] + 4 | 0);
 }
 global$0 = $2 + 16 | 0;
}
function jspNewPrototype($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP32[$1 + 20 >> 2] = jsvFindChildFromString(HEAP32[80545], HEAP32[$1 + 24 >> 2], 1);
 label$1 : {
  if (!HEAP32[$1 + 20 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 16 >> 2] = jsvSkipName(HEAP32[$1 + 20 >> 2]);
  if (!HEAP32[$1 + 16 >> 2]) {
   HEAP32[$1 + 16 >> 2] = jspNewBuiltin(HEAP32[$1 + 24 >> 2]);
   if (!HEAP32[$1 + 16 >> 2]) {
    jsvUnLock(HEAP32[$1 + 20 >> 2]);
    HEAP32[$1 + 28 >> 2] = 0;
    break label$1;
   }
   jsvSetValueOfName(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 16 >> 2]);
  }
  HEAP32[$1 + 12 >> 2] = jsvFindChildFromString(HEAP32[$1 + 16 >> 2], 79516, 1);
  jspEnsureIsPrototype(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 12 >> 2]);
  jsvUnLock2(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 20 >> 2]);
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 12 >> 2];
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function tflite__MicroInterpreter__Init_28tflite__Profiler__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 + 4 >> 2] = tflite__Model__subgraphs_28_29_20const(HEAP32[$0 + 4 >> 2]);
 label$1 : {
  if ((flatbuffers__Vector_int___size_28_29_20const(HEAP32[$2 + 4 >> 2]) | 0) != 1) {
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$0 + 12 >> 2], 129112, 0);
   HEAP32[$0 + 112 >> 2] = 1;
   break label$1;
  }
  HEAP32[$0 + 116 >> 2] = flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph__20___operator_5b_5d_28unsigned_20int_29_20const(HEAP32[$2 + 4 >> 2], 0);
  HEAP32[$0 + 28 >> 2] = $0 + 124;
  HEAP32[$0 + 36 >> 2] = 607;
  HEAP32[$0 + 96 >> 2] = 606;
  HEAP32[$0 + 100 >> 2] = 605;
  HEAP32[$0 + 52 >> 2] = 1;
  HEAP32[$0 + 68 >> 2] = HEAP32[$2 + 8 >> 2];
  HEAP32[$0 + 112 >> 2] = 0;
 }
 global$0 = $2 + 16 | 0;
}
function jswrap_array_push($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1 : {
  if (!(jsvIsArray(HEAP32[$2 + 24 >> 2]) & 1)) {
   HEAP32[$2 + 28 >> 2] = -1;
   break label$1;
  }
  HEAP32[$2 + 16 >> 2] = -1;
  jsvObjectIteratorNew($2 + 8 | 0, HEAP32[$2 + 20 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue($2 + 8 | 0) & 1) {
    $0 = $2 + 8 | 0;
    HEAP32[$2 + 4 >> 2] = jsvObjectIteratorGetValue($0);
    HEAP32[$2 + 16 >> 2] = jsvArrayPush(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 4 >> 2]);
    jsvUnLock(HEAP32[$2 + 4 >> 2]);
    jsvObjectIteratorNext($0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree($2 + 8 | 0);
  if (HEAP32[$2 + 16 >> 2] < 0) {
   HEAP32[$2 + 16 >> 2] = jsvGetArrayLength(HEAP32[$2 + 24 >> 2]);
  }
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 16 >> 2];
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function cos($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 wasm2js_scratch_store_f64(+$0);
 $3 = wasm2js_scratch_load_i32(1) | 0;
 wasm2js_scratch_load_i32(0) | 0;
 $3 = $3 & 2147483647;
 label$1 : {
  if ($3 >>> 0 <= 1072243195) {
   $2 = 1;
   if ($3 >>> 0 < 1044816030) {
    break label$1;
   }
   $2 = __cos($0, 0);
   break label$1;
  }
  $2 = $0 - $0;
  if ($3 >>> 0 >= 2146435072) {
   break label$1;
  }
  $3 = __rem_pio2($0, $1) & 3;
  if ($3 >>> 0 <= 2) {
   label$4 : {
    switch ($3 - 1 | 0) {
    default:
     $2 = __cos(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3]);
     break label$1;
    case 0:
     $2 = -__sin(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3], 1);
     break label$1;
    case 1:
     break label$4;
    }
   }
   $2 = -__cos(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3]);
   break label$1;
  }
  $2 = __sin(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3], 1);
 }
 $0 = $2;
 global$0 = $1 + 16 | 0;
 return $0;
}
function jspEnsureIsPrototype($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 if (HEAP32[$2 + 24 >> 2]) {
  HEAP32[$2 + 20 >> 2] = jsvSkipName(HEAP32[$2 + 24 >> 2]);
  if (!(jsvIsObject(HEAP32[$2 + 20 >> 2]) & 1)) {
   if (!(jsvIsUndefined(HEAP32[$2 + 20 >> 2]) & 1)) {
    HEAP32[$2 >> 2] = HEAP32[$2 + 20 >> 2];
    jsExceptionHere(3, 80161, $2);
   }
   jsvUnLock(HEAP32[$2 + 20 >> 2]);
   HEAP32[$2 + 20 >> 2] = jsvNewWithFlags(5);
   HEAP32[$2 + 16 >> 2] = jsvSkipToLastName(HEAP32[$2 + 24 >> 2]);
   jsvSetValueOfName(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 20 >> 2]);
   jsvUnLock(HEAP32[$2 + 16 >> 2]);
  }
  HEAP32[$2 + 12 >> 2] = jsvFindChildFromString(HEAP32[$2 + 20 >> 2], 80199, 1);
  if (HEAP32[$2 + 12 >> 2]) {
   jsvSetValueOfName(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 28 >> 2]);
  }
  jsvUnLock2(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 20 >> 2]);
 }
 global$0 = $2 + 32 | 0;
}
function jswrap_waveform_getBuffer($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 HEAP32[$3 + 12 >> 2] = jsvObjectGetChild(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2] ? 126095 : 126064, 0);
 label$1 : {
  if (!HEAP32[$3 + 12 >> 2]) {
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$3 + 16 >> 2]) {
   HEAP8[HEAP32[$3 + 16 >> 2]] = 0;
   label$4 : {
    if (!(jsvIsArrayBuffer(HEAP32[$3 + 12 >> 2]) & 1)) {
     break label$4;
    }
    $0 = HEAP32[$3 + 12 >> 2];
    if (((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8) & 15) != 2) {
     break label$4;
    }
    HEAP8[HEAP32[$3 + 16 >> 2]] = 1;
   }
  }
  HEAP32[$3 + 8 >> 2] = jsvGetArrayBufferBackingString(HEAP32[$3 + 12 >> 2], 0);
  jsvUnLock(HEAP32[$3 + 12 >> 2]);
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 8 >> 2];
 }
 global$0 = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}
function jswrap_object_toString($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 96 | 0;
 global$0 = $2;
 HEAP32[$2 + 88 >> 2] = $0;
 HEAP32[$2 + 84 >> 2] = $1;
 label$1 : {
  label$2 : {
   if (!(jsvIsInt(HEAP32[$2 + 84 >> 2]) & 1)) {
    break label$2;
   }
   if (!(jsvIsNumeric(HEAP32[$2 + 88 >> 2]) & 1)) {
    break label$2;
   }
   HEAP32[$2 + 80 >> 2] = jsvGetInteger(HEAP32[$2 + 84 >> 2]);
   if (!(HEAP32[$2 + 80 >> 2] < 2 | HEAP32[$2 + 80 >> 2] > 36)) {
    label$4 : {
     if (jsvIsInt(HEAP32[$2 + 88 >> 2]) & 1) {
      itostr(jsvGetInteger(HEAP32[$2 + 88 >> 2]), $2, HEAP32[$2 + 80 >> 2]);
      break label$4;
     }
     ftoa_bounded_extra(jsvGetFloat(HEAP32[$2 + 88 >> 2]), $2, 70, HEAP32[$2 + 80 >> 2], -1);
    }
    HEAP32[$2 + 92 >> 2] = jsvNewFromString($2);
    break label$1;
   }
  }
  HEAP32[$2 + 92 >> 2] = jsvAsString(HEAP32[$2 + 88 >> 2]);
 }
 global$0 = $2 + 96 | 0;
 return HEAP32[$2 + 92 >> 2];
}
function jswrap_espruino_HSBtoRGB($0, $1, $2, $3) {
 $0 = +$0;
 $1 = +$1;
 $2 = +$2;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 + -64 | 0;
 global$0 = $4;
 HEAPF64[$4 + 48 >> 3] = $0;
 HEAPF64[$4 + 40 >> 3] = $1;
 HEAPF64[$4 + 32 >> 3] = $2;
 HEAP8[$4 + 31 | 0] = $3;
 HEAP32[$4 + 24 >> 2] = jswrap_espruino_HSBtoRGB_int(HEAPF64[$4 + 48 >> 3], HEAPF64[$4 + 40 >> 3], HEAPF64[$4 + 32 >> 3]);
 label$1 : {
  if (!(HEAP8[$4 + 31 | 0] & 1)) {
   HEAP32[$4 + 60 >> 2] = jsvNewFromInteger(HEAP32[$4 + 24 >> 2]);
   break label$1;
  }
  $3 = $4 + 12 | 0;
  HEAP32[$4 + 12 >> 2] = jsvNewFromInteger(HEAP32[$4 + 24 >> 2] & 255);
  HEAP32[$4 + 16 >> 2] = jsvNewFromInteger(HEAP32[$4 + 24 >> 2] >> 8 & 255);
  HEAP32[$4 + 20 >> 2] = jsvNewFromInteger(HEAP32[$4 + 24 >> 2] >> 16 & 255);
  HEAP32[$4 + 8 >> 2] = jsvNewArray($3, 3);
  jsvUnLockMany(3, $3);
  HEAP32[$4 + 60 >> 2] = HEAP32[$4 + 8 >> 2];
 }
 global$0 = $4 - -64 | 0;
 return HEAP32[$4 + 60 >> 2];
}
function jswrap_graphics_setClipRect($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0;
 $5 = global$0 - 96 | 0;
 global$0 = $5;
 HEAP32[$5 + 88 >> 2] = $0;
 HEAP32[$5 + 84 >> 2] = $1;
 HEAP32[$5 + 80 >> 2] = $2;
 HEAP32[$5 + 76 >> 2] = $3;
 HEAP32[$5 + 72 >> 2] = $4;
 label$1 : {
  if (!(graphicsGetFromVar($5, HEAP32[$5 + 88 >> 2]) & 1)) {
   HEAP32[$5 + 92 >> 2] = 0;
   break label$1;
  }
  $0 = HEAP32[$5 + 84 >> 2];
  HEAP8[$5 + 32 | 0] = $0;
  HEAP8[$5 + 33 | 0] = $0 >>> 8;
  $0 = HEAP32[$5 + 80 >> 2];
  HEAP8[$5 + 34 | 0] = $0;
  HEAP8[$5 + 35 | 0] = $0 >>> 8;
  $0 = HEAP32[$5 + 76 >> 2];
  HEAP8[$5 + 36 | 0] = $0;
  HEAP8[$5 + 37 | 0] = $0 >>> 8;
  $0 = HEAP32[$5 + 72 >> 2];
  HEAP8[$5 + 38 | 0] = $0;
  HEAP8[$5 + 39 | 0] = $0 >>> 8;
  graphicsSetVar($5);
  HEAP32[$5 + 92 >> 2] = jsvLockAgain(HEAP32[$5 + 88 >> 2]);
 }
 global$0 = $5 + 96 | 0;
 return HEAP32[$5 + 92 >> 2];
}
function jsvStringIteratorClone($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 8 >> 2];
 $3 = HEAP32[$0 + 4 >> 2];
 $1 = HEAP32[$2 + 12 >> 2];
 HEAP32[$1 >> 2] = HEAP32[$0 >> 2];
 HEAP32[$1 + 4 >> 2] = $3;
 HEAP32[$1 + 32 >> 2] = HEAP32[$0 + 32 >> 2];
 $3 = HEAP32[$0 + 28 >> 2];
 HEAP32[$1 + 24 >> 2] = HEAP32[$0 + 24 >> 2];
 HEAP32[$1 + 28 >> 2] = $3;
 $3 = HEAP32[$0 + 20 >> 2];
 HEAP32[$1 + 16 >> 2] = HEAP32[$0 + 16 >> 2];
 HEAP32[$1 + 20 >> 2] = $3;
 $3 = HEAP32[$0 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = HEAP32[$0 + 8 >> 2];
 HEAP32[$1 + 12 >> 2] = $3;
 if (HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2]) {
  jsvLockAgain(HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2]);
  if (HEAP32[HEAP32[$2 + 8 >> 2] + 16 >> 2] == (HEAP32[$2 + 8 >> 2] + 20 | 0)) {
   HEAP32[HEAP32[$2 + 12 >> 2] + 16 >> 2] = HEAP32[$2 + 12 >> 2] + 20;
  }
 }
 global$0 = $2 + 16 | 0;
}
function lcdSetPixel_JS($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 global$0 = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 $0 = HEAP32[$4 + 28 >> 2];
 HEAP32[$4 + 12 >> 2] = jsvObjectGetChild(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 108450, 0);
 if (HEAP32[$4 + 12 >> 2]) {
  HEAP32[$4 >> 2] = jsvNewFromInteger(HEAP32[$4 + 24 >> 2]);
  HEAP32[$4 + 4 >> 2] = jsvNewFromInteger(HEAP32[$4 + 20 >> 2]);
  HEAP32[$4 + 8 >> 2] = jsvNewFromInteger(HEAP32[$4 + 16 >> 2]);
  $0 = HEAP32[$4 + 28 >> 2];
  jsvUnLock(jspExecuteFunction(HEAP32[$4 + 12 >> 2], HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 3, $4));
  jsvUnLockMany(3, $4);
  jsvUnLock(HEAP32[$4 + 12 >> 2]);
 }
 global$0 = $4 + 32 | 0;
}
function fromCalenderDate($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 HEAP32[$1 + 28 >> 2] = $0;
 HEAP32[$1 + 24 >> 2] = HEAP32[HEAP32[$1 + 28 >> 2] + 12 >> 2] - 1970;
 HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 24 >> 2] >> 2;
 HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 24 >> 2] & 3;
 HEAP32[$1 + 8 >> 2] = Math_imul(HEAP32[$1 + 16 >> 2], 365);
 label$1 : {
  if (HEAP32[$1 + 16 >> 2] == 2) {
   HEAP32[$1 + 12 >> 2] = 119632;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 119600;
 }
 if (HEAP32[$1 + 16 >> 2] >= 2) {
  HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
 }
 HEAP32[$1 + 4 >> 2] = HEAP32[HEAP32[$1 + 28 >> 2] + 8 >> 2] % 12;
 if (HEAP32[$1 + 4 >> 2] < 0) {
  HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + 12;
 }
 return (HEAP32[HEAP32[$1 + 28 >> 2] + 4 >> 2] + (HEAP16[HEAP32[$1 + 12 >> 2] + (HEAP32[$1 + 4 >> 2] << 1) >> 1] + (HEAP16[(HEAP32[$1 + 16 >> 2] << 1) + 119658 >> 1] + Math_imul(HEAP32[$1 + 20 >> 2], 1461) | 0) | 0) | 0) - 1 | 0;
}
function jsvGetValueOfName($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  if (jsvIsArrayBufferName(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = jsvArrayBufferGetFromName(HEAP32[$1 + 8 >> 2]);
   break label$1;
  }
  if (jsvIsNameInt(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = jsvNewFromInteger(jsvGetFirstChildSigned(HEAP32[$1 + 8 >> 2]) << 16 >> 16);
   break label$1;
  }
  if (jsvIsNameIntBool(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = jsvNewFromBool((jsvGetFirstChild(HEAP32[$1 + 8 >> 2]) & 65535) != 0);
   break label$1;
  }
  if (jsvIsName(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = jsvLockSafe(jsvGetFirstChild(HEAP32[$1 + 8 >> 2]) & 65535);
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jsiMoveCursor($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 global$0 = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 while (1) {
  if (HEAPU32[$4 + 12 >> 2] < HEAPU32[$4 + 4 >> 2]) {
   jsiConsolePrintString(81043);
   HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 while (1) {
  if (HEAPU32[$4 + 12 >> 2] > HEAPU32[$4 + 4 >> 2]) {
   jsiConsolePrintString(81047);
   HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 12 >> 2] + -1;
   continue;
  }
  break;
 }
 while (1) {
  if (HEAPU32[$4 + 8 >> 2] < HEAPU32[$4 >> 2]) {
   jsiConsolePrintString(81051);
   HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 8 >> 2] + 1;
   continue;
  }
  break;
 }
 while (1) {
  if (HEAPU32[$4 + 8 >> 2] > HEAPU32[$4 >> 2]) {
   jsiConsolePrintString(81055);
   HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 8 >> 2] + -1;
   continue;
  }
  break;
 }
 global$0 = $4 + 16 | 0;
}
function tflite__GetReciprocal_28int_2c_20int_2c_20int__29($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 $3 = $2 + 8 | 0;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = 12;
 HEAP32[$2 + 20 >> 2] = $1;
 $0 = global$0 - 16 | 0;
 HEAP32[$0 + 12 >> 2] = HEAP32[$2 + 28 >> 2];
 HEAP32[$2 + 16 >> 2] = HEAP32[$0 + 12 >> 2] ? Math_clz32(HEAP32[$0 + 12 >> 2]) : 32;
 HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = HEAP32[$2 + 24 >> 2] - HEAP32[$2 + 16 >> 2];
 HEAP32[$2 + 12 >> 2] = (HEAP32[$2 + 28 >> 2] << HEAP32[$2 + 16 >> 2]) + -2147483648;
 HEAP32[$2 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29(HEAP32[$2 + 12 >> 2]);
 HEAP32[$2 + 8 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__one_over_one_plus_x_for_x_in_0_1_int__28gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$2 >> 2]);
 $0 = HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($3) >> 2];
 global$0 = $2 + 32 | 0;
 return $0;
}
function jsfIsEqual($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 160 | 0;
 global$0 = $3;
 HEAP32[$3 + 152 >> 2] = $0;
 HEAP32[$3 + 148 >> 2] = $1;
 HEAP32[$3 + 144 >> 2] = $2;
 HEAP32[$3 + 12 >> 2] = 0;
 label$1 : {
  while (1) {
   if (HEAP32[$3 + 144 >> 2]) {
    HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 144 >> 2];
    if (HEAPU32[$3 + 8 >> 2] > 128) {
     HEAP32[$3 + 8 >> 2] = 128;
    }
    $0 = $3 + 16 | 0;
    jshFlashRead($0, HEAP32[$3 + 152 >> 2] + HEAP32[$3 + 12 >> 2] | 0, HEAP32[$3 + 8 >> 2]);
    if (memcmp($0, HEAP32[$3 + 148 >> 2] + HEAP32[$3 + 12 >> 2] | 0, HEAP32[$3 + 8 >> 2])) {
     HEAP8[$3 + 159 | 0] = 0;
     break label$1;
    } else {
     HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 8 >> 2] + HEAP32[$3 + 12 >> 2];
     HEAP32[$3 + 144 >> 2] = HEAP32[$3 + 144 >> 2] - HEAP32[$3 + 8 >> 2];
     continue;
    }
   }
   break;
  }
  HEAP8[$3 + 159 | 0] = 1;
 }
 global$0 = $3 + 160 | 0;
 return HEAP8[$3 + 159 | 0] & 1;
}
function jsvGetArrayItems($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 jsvObjectIteratorNew($3 + 16 | 0, HEAP32[$3 + 28 >> 2]);
 HEAP32[$3 + 12 >> 2] = 0;
 while (1) {
  if (jsvObjectIteratorHasValue($3 + 16 | 0) & 1) {
   if (HEAPU32[$3 + 12 >> 2] < HEAPU32[$3 + 24 >> 2]) {
    $0 = jsvObjectIteratorGetValue($3 + 16 | 0);
    $1 = HEAP32[$3 + 20 >> 2];
    $2 = HEAP32[$3 + 12 >> 2];
    HEAP32[$3 + 12 >> 2] = $2 + 1;
    HEAP32[$1 + ($2 << 2) >> 2] = $0;
   }
   jsvObjectIteratorNext($3 + 16 | 0);
   continue;
  }
  break;
 }
 jsvObjectIteratorFree($3 + 16 | 0);
 while (1) {
  if (HEAPU32[$3 + 12 >> 2] < HEAPU32[$3 + 24 >> 2]) {
   $0 = HEAP32[$3 + 20 >> 2];
   $1 = HEAP32[$3 + 12 >> 2];
   HEAP32[$3 + 12 >> 2] = $1 + 1;
   HEAP32[$0 + ($1 << 2) >> 2] = 0;
   continue;
  }
  break;
 }
 global$0 = $3 + 32 | 0;
}
function jspeiFindInScopes($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 label$1 : {
  if (HEAP32[80547]) {
   HEAP32[$1 + 20 >> 2] = jsvLockSafe(jsvGetLastChild(HEAP32[80547]) & 65535);
   while (1) {
    if (HEAP32[$1 + 20 >> 2]) {
     HEAP32[$1 + 16 >> 2] = jsvSkipName(HEAP32[$1 + 20 >> 2]);
     HEAP16[$1 + 14 >> 1] = jsvGetPrevSibling(HEAP32[$1 + 20 >> 2]);
     HEAP32[$1 + 8 >> 2] = jsvFindChildFromString(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 24 >> 2], 0);
     jsvUnLock2(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 16 >> 2]);
     if (HEAP32[$1 + 8 >> 2]) {
      HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 8 >> 2];
      break label$1;
     }
     HEAP32[$1 + 20 >> 2] = jsvLockSafe(HEAPU16[$1 + 14 >> 1]);
     continue;
    }
    break;
   }
  }
  HEAP32[$1 + 28 >> 2] = jsvFindChildFromString(HEAP32[80545], HEAP32[$1 + 24 >> 2], 0);
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function void_20tflite__CalculateActivationRange_float__28TfLiteFusedActivation_2c_20float__2c_20float__29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 label$1 : {
  if (HEAP32[$3 + 12 >> 2] == 1) {
   HEAPF32[HEAP32[$3 + 8 >> 2] >> 2] = 0;
   HEAPF32[HEAP32[$3 + 4 >> 2] >> 2] = 3.4028234663852886e+38;
   break label$1;
  }
  label$3 : {
   if (HEAP32[$3 + 12 >> 2] == 3) {
    HEAPF32[HEAP32[$3 + 8 >> 2] >> 2] = 0;
    HEAPF32[HEAP32[$3 + 4 >> 2] >> 2] = 6;
    break label$3;
   }
   label$5 : {
    if (HEAP32[$3 + 12 >> 2] == 2) {
     HEAPF32[HEAP32[$3 + 8 >> 2] >> 2] = -1;
     HEAPF32[HEAP32[$3 + 4 >> 2] >> 2] = 1;
     break label$5;
    }
    HEAPF32[HEAP32[$3 + 8 >> 2] >> 2] = -3.4028234663852886e+38;
    HEAPF32[HEAP32[$3 + 4 >> 2] >> 2] = 3.4028234663852886e+38;
   }
  }
 }
 global$0 = $3 + 16 | 0;
}
function sin($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 wasm2js_scratch_store_f64(+$0);
 $2 = wasm2js_scratch_load_i32(1) | 0;
 wasm2js_scratch_load_i32(0) | 0;
 $2 = $2 & 2147483647;
 label$1 : {
  if ($2 >>> 0 <= 1072243195) {
   if ($2 >>> 0 < 1045430272) {
    break label$1;
   }
   $0 = __sin($0, 0, 0);
   break label$1;
  }
  if ($2 >>> 0 >= 2146435072) {
   $0 = $0 - $0;
   break label$1;
  }
  $2 = __rem_pio2($0, $1) & 3;
  if ($2 >>> 0 <= 2) {
   label$5 : {
    switch ($2 - 1 | 0) {
    default:
     $0 = __sin(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3], 1);
     break label$1;
    case 0:
     $0 = __cos(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3]);
     break label$1;
    case 1:
     break label$5;
    }
   }
   $0 = -__sin(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3], 1);
   break label$1;
  }
  $0 = -__cos(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3]);
 }
 global$0 = $1 + 16 | 0;
 return $0;
}
function jsvGetFunctionArgumentLength($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP32[$1 + 20 >> 2] = jsvNewWithFlags(3);
 label$1 : {
  if (!HEAP32[$1 + 20 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  jsvObjectIteratorNew($1 + 16 | 0, HEAP32[$1 + 24 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue($1 + 16 | 0) & 1) {
    HEAP32[$1 + 12 >> 2] = jsvObjectIteratorGetKey($1 + 16 | 0);
    if (jsvIsFunctionParameter(HEAP32[$1 + 12 >> 2]) & 1) {
     HEAP32[$1 + 8 >> 2] = jsvSkipOneName(HEAP32[$1 + 12 >> 2]);
     jsvArrayPushAndUnLock(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 8 >> 2]);
    }
    $0 = $1 + 16 | 0;
    jsvUnLock(HEAP32[$1 + 12 >> 2]);
    jsvObjectIteratorNext($0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree($1 + 16 | 0);
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function graphicsGetPixelDevice($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 8 >> 2] = $0;
 HEAP32[$3 + 4 >> 2] = $1;
 HEAP32[$3 >> 2] = $2;
 label$1 : {
  label$2 : {
   label$3 : {
    if (HEAP32[$3 + 4 >> 2] < 0 | HEAP32[$3 >> 2] < 0) {
     break label$3;
    }
    $0 = HEAP32[$3 + 8 >> 2];
    if (HEAP32[$3 + 4 >> 2] >= (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8)) {
     break label$3;
    }
    $0 = HEAP32[$3 + 8 >> 2];
    if (HEAP32[$3 >> 2] < (HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8)) {
     break label$2;
    }
   }
   HEAP32[$3 + 12 >> 2] = 0;
   break label$1;
  }
  $0 = HEAP32[$3 + 8 >> 2];
  HEAP32[$3 + 12 >> 2] = FUNCTION_TABLE[HEAPU8[$0 + 60 | 0] | HEAPU8[$0 + 61 | 0] << 8 | (HEAPU8[$0 + 62 | 0] << 16 | HEAPU8[$0 + 63 | 0] << 24)](HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], HEAP32[$3 >> 2]);
 }
 global$0 = $3 + 16 | 0;
 return HEAP32[$3 + 12 >> 2];
}
function nativeCallGetCType() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 label$1 : {
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 192) {
   jslMatch(192);
   HEAP32[$0 + 12 >> 2] = 0;
   break label$1;
  }
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 128) {
   HEAP32[$0 + 8 >> 2] = -1;
   HEAP32[$0 + 4 >> 2] = jslGetTokenValueAsString();
   if (!strcmp(HEAP32[$0 + 4 >> 2], 119996)) {
    HEAP32[$0 + 8 >> 2] = 4;
   }
   if (!strcmp(HEAP32[$0 + 4 >> 2], 12e4)) {
    HEAP32[$0 + 8 >> 2] = 6;
   }
   if (!strcmp(HEAP32[$0 + 4 >> 2], 120007)) {
    HEAP32[$0 + 8 >> 2] = 3;
   }
   if (!strcmp(HEAP32[$0 + 4 >> 2], 120012)) {
    HEAP32[$0 + 8 >> 2] = 5;
   }
   if (!strcmp(HEAP32[$0 + 4 >> 2], 120016)) {
    HEAP32[$0 + 8 >> 2] = 1;
   }
   jslMatch(128);
   HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 8 >> 2];
   break label$1;
  }
  HEAP32[$0 + 12 >> 2] = -1;
 }
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}
function jsvGetStringChars($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 + -64 | 0;
 global$0 = $3;
 HEAP32[$3 + 56 >> 2] = $0;
 HEAP32[$3 + 52 >> 2] = 0;
 HEAP32[$3 + 48 >> 2] = $1;
 HEAP32[$3 + 44 >> 2] = $2;
 HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 44 >> 2];
 jsvStringIteratorNew($3, HEAP32[$3 + 56 >> 2], HEAP32[$3 + 52 >> 2]);
 label$1 : {
  while (1) {
   if (jsvStringIteratorHasChar($3) & 1) {
    $0 = HEAP32[$3 + 40 >> 2];
    HEAP32[$3 + 40 >> 2] = $0 + -1;
    if ($0 >>> 0 <= 0) {
     jsvStringIteratorFree($3);
     HEAP32[$3 + 60 >> 2] = HEAP32[$3 + 44 >> 2];
     break label$1;
    }
    $0 = jsvStringIteratorGetCharAndNext($3);
    $1 = HEAP32[$3 + 48 >> 2];
    HEAP32[$3 + 48 >> 2] = $1 + 1;
    HEAP8[$1 | 0] = $0;
    continue;
   }
   break;
  }
  jsvStringIteratorFree($3);
  HEAP32[$3 + 60 >> 2] = HEAP32[$3 + 44 >> 2] - HEAP32[$3 + 40 >> 2];
 }
 global$0 = $3 - -64 | 0;
 return HEAP32[$3 + 60 >> 2];
}
function wcrtomb($0, $1) {
 label$1 : {
  if ($0) {
   if ($1 >>> 0 <= 127) {
    break label$1;
   }
   label$3 : {
    if (!HEAP32[HEAP32[35515] >> 2]) {
     if (($1 & -128) == 57216) {
      break label$1;
     }
     break label$3;
    }
    if ($1 >>> 0 <= 2047) {
     HEAP8[$0 + 1 | 0] = $1 & 63 | 128;
     HEAP8[$0 | 0] = $1 >>> 6 | 192;
     return 2;
    }
    if (!(($1 & -8192) != 57344 ? $1 >>> 0 >= 55296 : 0)) {
     HEAP8[$0 + 2 | 0] = $1 & 63 | 128;
     HEAP8[$0 | 0] = $1 >>> 12 | 224;
     HEAP8[$0 + 1 | 0] = $1 >>> 6 & 63 | 128;
     return 3;
    }
    if ($1 + -65536 >>> 0 <= 1048575) {
     HEAP8[$0 + 3 | 0] = $1 & 63 | 128;
     HEAP8[$0 | 0] = $1 >>> 18 | 240;
     HEAP8[$0 + 2 | 0] = $1 >>> 6 & 63 | 128;
     HEAP8[$0 + 1 | 0] = $1 >>> 12 & 63 | 128;
     return 4;
    }
   }
   HEAP32[84242] = 25;
   $0 = -1;
  } else {
   $0 = 1;
  }
  return $0;
 }
 HEAP8[$0 | 0] = $1;
 return 1;
}
function jsvFindChildFromVar($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP8[$3 + 19 | 0] = $2;
 HEAP16[$3 + 10 >> 1] = jsvGetFirstChild(HEAP32[$3 + 24 >> 2]);
 label$1 : {
  while (1) {
   if (HEAPU16[$3 + 10 >> 1]) {
    HEAP32[$3 + 12 >> 2] = jsvLock(HEAPU16[$3 + 10 >> 1]);
    if (jsvIsBasicVarEqual(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 20 >> 2]) & 1) {
     break label$1;
    }
    HEAP16[$3 + 10 >> 1] = jsvGetNextSibling(HEAP32[$3 + 12 >> 2]);
    jsvUnLock(HEAP32[$3 + 12 >> 2]);
    continue;
   }
   break;
  }
  HEAP32[$3 + 12 >> 2] = 0;
  if (!(!(HEAP8[$3 + 19 | 0] & 1) | !HEAP32[$3 + 20 >> 2])) {
   HEAP32[$3 + 12 >> 2] = jsvAsName(HEAP32[$3 + 20 >> 2]);
   jsvAddName(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 12 >> 2]);
  }
 }
 HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2];
 global$0 = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}
function jswrap_object_create($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1 : {
  label$2 : {
   if (jsvIsObject(HEAP32[$2 + 24 >> 2]) & 1) {
    break label$2;
   }
   if (jsvIsNull(HEAP32[$2 + 24 >> 2]) & 1) {
    break label$2;
   }
   HEAP32[$2 >> 2] = HEAP32[$2 + 24 >> 2];
   jsExceptionHere(3, 123261, $2);
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  if (jsvIsObject(HEAP32[$2 + 20 >> 2]) & 1) {
   jsExceptionHere(1, 123312, 0);
  }
  HEAP32[$2 + 16 >> 2] = jsvNewWithFlags(5);
  if (!HEAP32[$2 + 16 >> 2]) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  if (jsvIsObject(HEAP32[$2 + 24 >> 2]) & 1) {
   jsvObjectSetChild(HEAP32[$2 + 16 >> 2], 123244, HEAP32[$2 + 24 >> 2]);
  }
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 16 >> 2];
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function __jspePostfixExpression($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 while (1) {
  if (HEAP16[HEAP32[35539] + 2 >> 1] != 152 ? HEAP16[HEAP32[35539] + 2 >> 1] == 153 : 1) {
   HEAP32[$1 + 24 >> 2] = HEAP16[HEAP32[35539] + 2 >> 1];
   jslGetNextToken();
   if ((HEAP32[80549] & 63) == 1) {
    HEAP32[$1 + 20 >> 2] = jsvNewFromInteger(1);
    HEAP32[$1 + 16 >> 2] = jsvAsNumberAndUnLock(jsvSkipName(HEAP32[$1 + 28 >> 2]));
    HEAP32[$1 + 12 >> 2] = jsvMathsOpSkipNames(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 20 >> 2], HEAP32[$1 + 24 >> 2] == 152 ? 43 : 45);
    jsvUnLock(HEAP32[$1 + 20 >> 2]);
    jsvReplaceWith(HEAP32[$1 + 28 >> 2], HEAP32[$1 + 12 >> 2]);
    jsvUnLock(HEAP32[$1 + 12 >> 2]);
    jsvUnLock(HEAP32[$1 + 28 >> 2]);
    HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 16 >> 2];
   }
   continue;
  }
  break;
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function jswrap_espruino_lookupNoCase($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 96 | 0;
 global$0 = $3;
 HEAP32[$3 + 88 >> 2] = $0;
 HEAP32[$3 + 84 >> 2] = $1;
 HEAP8[$3 + 83 | 0] = $2;
 label$1 : {
  if (!(jsvHasChildren(HEAP32[$3 + 88 >> 2]) & 1)) {
   HEAP32[$3 + 92 >> 2] = 0;
   break label$1;
  }
  if ((jsvGetString(HEAP32[$3 + 84 >> 2], $3 + 16 | 0, 64) | 0) == 64) {
   HEAP32[$3 >> 2] = 64;
   jsExceptionHere(1, 120667, $3);
  }
  if (HEAP8[$3 + 83 | 0] & 1) {
   HEAP32[$3 + 12 >> 2] = jsvFindChildFromStringI(HEAP32[$3 + 88 >> 2], $3 + 16 | 0);
   if (HEAP32[$3 + 12 >> 2]) {
    HEAP32[$3 + 92 >> 2] = jsvAsStringAndUnLock(HEAP32[$3 + 12 >> 2]);
    break label$1;
   }
   HEAP32[$3 + 92 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 92 >> 2] = jsvObjectGetChildI(HEAP32[$3 + 88 >> 2], $3 + 16 | 0);
 }
 global$0 = $3 + 96 | 0;
 return HEAP32[$3 + 92 >> 2];
}
function tflite__CalculateInputRadius_28int_2c_20int_2c_20int_29($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $2 = global$0 - 32 | 0;
 HEAP32[$2 + 28 >> 2] = 5;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = 31;
 $1 = HEAP32[$2 + 20 >> 2] - HEAP32[$2 + 28 >> 2] | 0;
 $0 = $1 & 31;
 $4 = $2;
 $3 = 1 * +((1 << HEAP32[$2 + 28 >> 2]) - 1 | 0);
 if (32 <= ($1 & 63) >>> 0) {
  $1 = 1 << $0;
  $0 = 0;
 } else {
  $1 = (1 << $0) - 1 & 1 >>> 32 - $0;
  $0 = 1 << $0;
 }
 $3 = $3 * (+($0 >>> 0) + 4294967296 * +($1 | 0));
 $1 = HEAP32[$2 + 24 >> 2];
 $0 = $1 & 31;
 if (32 <= ($1 & 63) >>> 0) {
  $1 = 1 << $0;
  $0 = 0;
 } else {
  $1 = (1 << $0) - 1 & 1 >>> 32 - $0;
  $0 = 1 << $0;
 }
 HEAPF64[$4 + 8 >> 3] = $3 / (+($0 >>> 0) + 4294967296 * +($1 | 0));
 $3 = Math_floor(HEAPF64[$2 + 8 >> 3]);
 label$1 : {
  if (Math_abs($3) < 2147483648) {
   $0 = ~~$3;
   break label$1;
  }
  $0 = -2147483648;
 }
 return $0;
}
function jswrap_storage_readArrayBuffer($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 80 | 0;
 global$0 = $1;
 HEAP32[$1 + 72 >> 2] = $0;
 jsfNameFromVar($1 + 40 | 0, HEAP32[$1 + 72 >> 2]);
 HEAP32[$1 + 32 >> 2] = HEAP32[$1 + 64 >> 2];
 $0 = HEAP32[$1 + 60 >> 2];
 HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 56 >> 2];
 HEAP32[$1 + 28 >> 2] = $0;
 $0 = HEAP32[$1 + 52 >> 2];
 HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 48 >> 2];
 HEAP32[$1 + 20 >> 2] = $0;
 $0 = HEAP32[$1 + 44 >> 2];
 HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 40 >> 2];
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 68 >> 2] = jsfReadFile($1 + 8 | 0, 0, 0);
 label$1 : {
  if (!HEAP32[$1 + 68 >> 2]) {
   HEAP32[$1 + 76 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 36 >> 2] = jsvNewArrayBufferFromString(HEAP32[$1 + 68 >> 2], 0);
  jsvUnLock(HEAP32[$1 + 68 >> 2]);
  HEAP32[$1 + 76 >> 2] = HEAP32[$1 + 36 >> 2];
 }
 global$0 = $1 + 80 | 0;
 return HEAP32[$1 + 76 >> 2];
}
function jsvObjectGetChild($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP16[$3 + 18 >> 1] = $2;
 label$1 : {
  if (!HEAP32[$3 + 24 >> 2]) {
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = jsvFindChildFromString(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAPU16[$3 + 18 >> 1] != 0);
  HEAP32[$3 + 8 >> 2] = jsvSkipName(HEAP32[$3 + 12 >> 2]);
  if (!(!HEAP32[$3 + 12 >> 2] | (HEAP32[$3 + 8 >> 2] | !HEAPU16[$3 + 18 >> 1]))) {
   HEAP32[$3 + 8 >> 2] = jsvNewWithFlags(HEAPU16[$3 + 18 >> 1]);
   jsvSetValueOfName(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
   jsvUnLock(HEAP32[$3 + 12 >> 2]);
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 8 >> 2];
   break label$1;
  }
  jsvUnLock(HEAP32[$3 + 12 >> 2]);
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 8 >> 2];
 }
 global$0 = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}
function tflite__internal__GetFlatbufferTensorBuffer_28tflite__Tensor_20const__2c_20flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer__20__20const__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 20 >> 2] = 0;
 HEAP32[$2 + 16 >> 2] = flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph__20___operator_5b_5d_28unsigned_20int_29_20const(HEAP32[$2 + 24 >> 2], tflite__Tensor__buffer_28_29_20const(HEAP32[$2 + 28 >> 2]));
 if (HEAP32[$2 + 16 >> 2]) {
  HEAP32[$2 + 12 >> 2] = tflite__Tensor__shape_28_29_20const(HEAP32[$2 + 16 >> 2]);
  if (HEAP32[$2 + 12 >> 2]) {
   if (flatbuffers__Vector_int___size_28_29_20const(HEAP32[$2 + 12 >> 2])) {
    HEAP32[$2 + 20 >> 2] = flatbuffers__Vector_unsigned_20char___data_28_29_20const(HEAP32[$2 + 12 >> 2]);
   }
  }
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 20 >> 2];
}
function jswrap_string_startsWith($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 label$1 : {
  if (!(jsvIsString(HEAP32[$3 + 24 >> 2]) & 1)) {
   HEAP8[$3 + 31 | 0] = 0;
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = jsvAsString(HEAP32[$3 + 20 >> 2]);
  HEAP8[$3 + 11 | 0] = 0;
  label$3 : {
   if (HEAP32[$3 + 16 >> 2] < 0) {
    break label$3;
   }
   if ((jsvGetStringLength(HEAP32[$3 + 12 >> 2]) + HEAP32[$3 + 16 >> 2] | 0) > (jsvGetStringLength(HEAP32[$3 + 24 >> 2]) | 0)) {
    break label$3;
   }
   HEAP8[$3 + 11 | 0] = !jsvCompareString(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 12 >> 2], HEAP32[$3 + 16 >> 2], 1);
  }
  jsvUnLock(HEAP32[$3 + 12 >> 2]);
  HEAP8[$3 + 31 | 0] = HEAP8[$3 + 11 | 0] & 1;
 }
 global$0 = $3 + 32 | 0;
 return HEAP8[$3 + 31 | 0] & 1;
}
function jsvArrayBufferIteratorGetValueAndRewind($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = global$0 - 48 | 0;
 global$0 = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 $0 = $1 + 8 | 0;
 jsvStringIteratorClone($0, HEAP32[$1 + 44 >> 2]);
 HEAP32[$1 + 4 >> 2] = jsvArrayBufferIteratorGetValue(HEAP32[$1 + 44 >> 2]);
 jsvStringIteratorFree(HEAP32[$1 + 44 >> 2]);
 $3 = HEAP32[$0 + 4 >> 2];
 $2 = HEAP32[$1 + 44 >> 2];
 HEAP32[$2 >> 2] = HEAP32[$0 >> 2];
 HEAP32[$2 + 4 >> 2] = $3;
 HEAP32[$2 + 32 >> 2] = HEAP32[$0 + 32 >> 2];
 $3 = HEAP32[$0 + 28 >> 2];
 HEAP32[$2 + 24 >> 2] = HEAP32[$0 + 24 >> 2];
 HEAP32[$2 + 28 >> 2] = $3;
 $3 = HEAP32[$0 + 20 >> 2];
 HEAP32[$2 + 16 >> 2] = HEAP32[$0 + 16 >> 2];
 HEAP32[$2 + 20 >> 2] = $3;
 $3 = HEAP32[$0 + 12 >> 2];
 HEAP32[$2 + 8 >> 2] = HEAP32[$0 + 8 >> 2];
 HEAP32[$2 + 12 >> 2] = $3;
 HEAP8[HEAP32[$1 + 44 >> 2] + 52 | 0] = 0;
 global$0 = $1 + 48 | 0;
 return HEAP32[$1 + 4 >> 2];
}
function jsvIteratorGetKey($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 $0 = HEAP32[HEAP32[$1 + 8 >> 2] >> 2] + -1 | 0;
 label$1 : {
  if ($0 >>> 0 <= 3) {
   label$3 : {
    switch ($0 - 1 | 0) {
    case 2:
     HEAP32[$1 + 12 >> 2] = jsvNewFromInteger(HEAP32[HEAP32[$1 + 8 >> 2] + 12 >> 2]);
     break label$1;
    case 0:
     HEAP32[$1 + 12 >> 2] = jsvObjectIteratorGetKey(HEAP32[$1 + 8 >> 2] + 4 | 0);
     break label$1;
    default:
     HEAP32[$1 + 12 >> 2] = jsvMakeIntoVariableName(jsvNewFromInteger(jsvStringIteratorGetIndex(HEAP32[$1 + 8 >> 2] + 4 | 0)), 0);
     break label$1;
    case 1:
     break label$3;
    }
   }
   HEAP32[$1 + 12 >> 2] = jsvMakeIntoVariableName(jsvArrayBufferIteratorGetIndex(HEAP32[$1 + 8 >> 2] + 4 | 0), 0);
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function __stpcpy($0, $1) {
 var $2 = 0;
 label$1 : {
  label$2 : {
   if (($0 ^ $1) & 3) {
    break label$2;
   }
   if ($1 & 3) {
    while (1) {
     $2 = HEAPU8[$1 | 0];
     HEAP8[$0 | 0] = $2;
     if (!$2) {
      break label$1;
     }
     $0 = $0 + 1 | 0;
     $1 = $1 + 1 | 0;
     if ($1 & 3) {
      continue;
     }
     break;
    }
   }
   $2 = HEAP32[$1 >> 2];
   if (($2 ^ -1) & $2 + -16843009 & -2139062144) {
    break label$2;
   }
   while (1) {
    HEAP32[$0 >> 2] = $2;
    $2 = HEAP32[$1 + 4 >> 2];
    $0 = $0 + 4 | 0;
    $1 = $1 + 4 | 0;
    if (!($2 + -16843009 & ($2 ^ -1) & -2139062144)) {
     continue;
    }
    break;
   }
  }
  $2 = HEAPU8[$1 | 0];
  HEAP8[$0 | 0] = $2;
  if (!$2) {
   break label$1;
  }
  while (1) {
   $2 = HEAPU8[$1 + 1 | 0];
   HEAP8[$0 + 1 | 0] = $2;
   $0 = $0 + 1 | 0;
   $1 = $1 + 1 | 0;
   if ($2) {
    continue;
   }
   break;
  }
 }
}
function int_20gemmlowp__ShiftLeft_int__28int_2c_20int_29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 $0 = HEAP32[$2 + 28 >> 2];
 HEAP32[$2 + 16 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $0 >> 31;
 $0 = 1 << HEAP32[$2 + 24 >> 2];
 HEAP32[$2 + 8 >> 2] = __wasm_i64_mul(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 20 >> 2], $0, $0 >> 31);
 HEAP32[$2 + 12 >> 2] = i64toi32_i32$HIGH_BITS;
 HEAP32[$2 + 4 >> 2] = -2147483648;
 HEAP32[$2 >> 2] = 2147483647;
 $1 = HEAP32[$2 + 12 >> 2];
 $0 = -2147483648;
 label$1 : {
  if (($1 | 0) < -1 ? 1 : ($1 | 0) <= -1 ? HEAPU32[$2 + 8 >> 2] >= 2147483648 ? 0 : 1 : 0) {
   break label$1;
  }
  $1 = HEAP32[$2 + 12 >> 2];
  $0 = 2147483647;
  label$2 : {
   if (($1 | 0) > 0 ? 1 : ($1 | 0) >= 0 ? HEAPU32[$2 + 8 >> 2] <= 2147483647 ? 0 : 1 : 0) {
    break label$2;
   }
   $0 = HEAP32[$2 + 8 >> 2];
  }
 }
 return $0;
}
function tflite__MicroMutableOpResolver_9u___FindOp_28char_20const__29_20const($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 $0 = HEAP32[$2 + 24 >> 2];
 HEAP32[$2 + 16 >> 2] = 0;
 label$1 : {
  while (1) {
   if (HEAPU32[$2 + 16 >> 2] < HEAPU32[$0 + 292 >> 2]) {
    HEAP32[$2 + 12 >> 2] = ($0 + 4 | 0) + (HEAP32[$2 + 16 >> 2] << 5);
    label$4 : {
     if (HEAP32[HEAP32[$2 + 12 >> 2] + 20 >> 2] != 32) {
      break label$4;
     }
     if (strcmp(HEAP32[HEAP32[$2 + 12 >> 2] + 24 >> 2], HEAP32[$2 + 20 >> 2])) {
      break label$4;
     }
     HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
     break label$1;
    }
    HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 16 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$2 + 28 >> 2] = 0;
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function jsvArrayPushAll($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP8[$2 + 23 | 0] = 0;
 jsvObjectIteratorNew($2 + 16 | 0, HEAP32[$2 + 24 >> 2]);
 while (1) {
  if (jsvObjectIteratorHasValue($2 + 16 | 0) & 1) {
   HEAP32[$2 + 12 >> 2] = jsvObjectIteratorGetValue($2 + 16 | 0);
   HEAP8[$2 + 11 | 0] = 1;
   if (HEAP8[$2 + 23 | 0] & 1) {
    HEAP32[$2 + 4 >> 2] = jsvGetIndexOf(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 12 >> 2], 0);
    if (HEAP32[$2 + 4 >> 2]) {
     HEAP8[$2 + 11 | 0] = 0;
     jsvUnLock(HEAP32[$2 + 4 >> 2]);
    }
   }
   if (HEAP8[$2 + 11 | 0] & 1) {
    jsvArrayPush(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 12 >> 2]);
   }
   $0 = $2 + 16 | 0;
   jsvUnLock(HEAP32[$2 + 12 >> 2]);
   jsvObjectIteratorNext($0);
   continue;
  }
  break;
 }
 jsvObjectIteratorFree($2 + 16 | 0);
 global$0 = $2 + 32 | 0;
}
function jshGetDeviceFor($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP16[$3 + 12 >> 1] = $0;
 HEAP16[$3 + 10 >> 1] = $1;
 HEAP8[$3 + 9 | 0] = $2;
 label$1 : {
  if (!(jshIsPinValid(HEAPU8[$3 + 9 | 0]) & 1)) {
   HEAP16[$3 + 14 >> 1] = 0;
   break label$1;
  }
  HEAP32[$3 + 4 >> 2] = 0;
  while (1) {
   if (HEAP32[$3 + 4 >> 2] < 0) {
    $0 = (Math_imul(HEAPU8[$3 + 9 | 0], 3) + 109875 | 0) + (HEAP32[$3 + 4 >> 2] << 1) | 0;
    HEAP16[$3 + 2 >> 1] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8;
    if (!((HEAPU16[$3 + 2 >> 1] & 4080) < HEAPU16[$3 + 12 >> 1] | (HEAPU16[$3 + 2 >> 1] & 4080) > HEAPU16[$3 + 10 >> 1])) {
     HEAP16[$3 + 14 >> 1] = HEAPU16[$3 + 2 >> 1];
     break label$1;
    }
    HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP16[$3 + 14 >> 1] = 0;
 }
 global$0 = $3 + 16 | 0;
 return HEAPU16[$3 + 14 >> 1];
}
function jshPushIOCharEventAppend($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP8[$2 + 14 | 0] = $0;
 HEAP8[$2 + 13 | 0] = $1;
 HEAP8[$2 + 12 | 0] = HEAPU8[322306] + 255;
 label$1 : {
  if (!(HEAPU8[322306] == HEAPU8[322307] | HEAPU8[$2 + 12 | 0] == HEAPU8[322307])) {
   if (HEAPU8[$2 + 14 | 0] == (HEAPU8[Math_imul(HEAPU8[$2 + 12 | 0], 5) + 322896 | 0] & 31)) {
    HEAP8[$2 + 11 | 0] = ((HEAPU8[Math_imul(HEAPU8[$2 + 12 | 0], 5) + 322896 | 0] & 96) >> 5) + 1;
    if (HEAPU8[$2 + 11 | 0] < 4) {
     HEAP8[HEAPU8[$2 + 11 | 0] + (Math_imul(HEAPU8[$2 + 12 | 0], 5) + 322897 | 0) | 0] = HEAPU8[$2 + 13 | 0];
     HEAP8[Math_imul(HEAPU8[$2 + 12 | 0], 5) + 322896 | 0] = HEAPU8[Math_imul(HEAPU8[$2 + 12 | 0], 5) + 322896 | 0] & 159 | HEAPU8[$2 + 11 | 0] << 5;
     HEAP8[$2 + 15 | 0] = 1;
     break label$1;
    }
   }
  }
  HEAP8[$2 + 15 | 0] = 0;
 }
 return HEAP8[$2 + 15 | 0] & 1;
}
function jswrap_graphics_lineTo($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 96 | 0;
 global$0 = $3;
 HEAP32[$3 + 88 >> 2] = $0;
 HEAP32[$3 + 84 >> 2] = $1;
 HEAP32[$3 + 80 >> 2] = $2;
 label$1 : {
  if (!(graphicsGetFromVar($3 + 8 | 0, HEAP32[$3 + 88 >> 2]) & 1)) {
   HEAP32[$3 + 92 >> 2] = 0;
   break label$1;
  }
  $0 = $3 + 8 | 0;
  graphicsDrawLine($0, (HEAPU8[$3 + 35 | 0] | HEAPU8[$3 + 36 | 0] << 8) << 16 >> 16, (HEAPU8[$3 + 37 | 0] | HEAPU8[$3 + 38 | 0] << 8) << 16 >> 16, HEAP32[$3 + 84 >> 2], HEAP32[$3 + 80 >> 2]);
  $1 = HEAP32[$3 + 84 >> 2];
  HEAP8[$3 + 35 | 0] = $1;
  HEAP8[$3 + 36 | 0] = $1 >>> 8;
  $1 = HEAP32[$3 + 80 >> 2];
  HEAP8[$3 + 37 | 0] = $1;
  HEAP8[$3 + 38 | 0] = $1 >>> 8;
  graphicsSetVar($0);
  HEAP32[$3 + 92 >> 2] = jsvLockAgain(HEAP32[$3 + 88 >> 2]);
 }
 global$0 = $3 + 96 | 0;
 return HEAP32[$3 + 92 >> 2];
}
function jswrap_io_analogWrite($0, $1, $2) {
 $0 = $0 | 0;
 $1 = +$1;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP8[$3 + 47 | 0] = $0;
 HEAPF64[$3 + 32 >> 3] = $1;
 HEAP32[$3 + 28 >> 2] = $2;
 HEAPF64[$3 + 16 >> 3] = 0;
 HEAP32[$3 + 12 >> 2] = 0;
 if (jsvIsObject(HEAP32[$3 + 28 >> 2]) & 1) {
  HEAPF64[$3 + 16 >> 3] = jsvGetFloatAndUnLock(jsvObjectGetChild(HEAP32[$3 + 28 >> 2], 121798, 0));
  label$2 : {
   if (jsvGetBoolAndUnLock(jsvObjectGetChild(HEAP32[$3 + 28 >> 2], 121803, 0)) & 1) {
    HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] | 2;
    break label$2;
   }
   if (jsvGetBoolAndUnLock(jsvObjectGetChild(HEAP32[$3 + 28 >> 2], 121813, 0)) & 1) {
    HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] | 1;
   }
  }
 }
 jshPinAnalogOutput(HEAPU8[$3 + 47 | 0], HEAPF64[$3 + 32 >> 3], HEAPF64[$3 + 16 >> 3], HEAP32[$3 + 12 >> 2]);
 global$0 = $3 + 48 | 0;
}
function jswrap_espruino_enableWatchdog($0, $1) {
 $0 = +$0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAPF64[$2 + 24 >> 3] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1 : {
  label$2 : {
   if (HEAPF64[$2 + 24 >> 3] < 0) {
    break label$2;
   }
   $1 = __DOUBLE_BITS(HEAPF64[$2 + 24 >> 3]);
   $3 = i64toi32_i32$HIGH_BITS & 2147483647;
   if (($3 | 0) == 2146435072 & $1 >>> 0 > 0 | $3 >>> 0 > 2146435072) {
    break label$2;
   }
   break label$1;
  }
  HEAPF64[$2 + 24 >> 3] = 1;
 }
 label$3 : {
  label$4 : {
   if (!(jsvIsUndefined(HEAP32[$2 + 20 >> 2]) & 1)) {
    if (!(jsvGetBool(HEAP32[$2 + 20 >> 2]) & 1)) {
     break label$4;
    }
   }
   HEAP16[161112] = HEAPU16[161112] | 512;
   break label$3;
  }
  HEAP16[161112] = HEAPU16[161112] & -513;
 }
 HEAPF64[(global$0 - 16 | 0) + 8 >> 3] = HEAPF64[$2 + 24 >> 3];
 global$0 = $2 + 32 | 0;
}
function jswrap_banglejs_getHealthStatus($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  label$2 : {
   if (!(jsvIsUndefined(HEAP32[$1 + 8 >> 2]) & 1)) {
    if (!(jsvIsStringEqual(HEAP32[$1 + 8 >> 2], 110445) & 1)) {
     break label$2;
    }
   }
   HEAP32[$1 + 12 >> 2] = _jswrap_banglejs_getHealthStatusObject(336692);
   break label$1;
  }
  if (jsvIsStringEqual(HEAP32[$1 + 8 >> 2], 110451) & 1) {
   HEAP32[$1 + 12 >> 2] = _jswrap_banglejs_getHealthStatusObject(336708);
   break label$1;
  }
  if (jsvIsStringEqual(HEAP32[$1 + 8 >> 2], 110456) & 1) {
   HEAP32[$1 + 12 >> 2] = _jswrap_banglejs_getHealthStatusObject(336724);
   break label$1;
  }
  HEAP32[$1 >> 2] = HEAP32[$1 + 8 >> 2];
  jsExceptionHere(1, 110460, $1);
  HEAP32[$1 + 12 >> 2] = 0;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jsvIteratorHasElement($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 $0 = HEAP32[HEAP32[$1 + 8 >> 2] >> 2] + -1 | 0;
 label$1 : {
  if ($0 >>> 0 <= 3) {
   label$3 : {
    switch ($0 - 1 | 0) {
    case 2:
     HEAP8[$1 + 15 | 0] = HEAP32[HEAP32[$1 + 8 >> 2] + 12 >> 2] < (jsvGetArrayLength(HEAP32[HEAP32[$1 + 8 >> 2] + 8 >> 2]) | 0);
     break label$1;
    case 0:
     HEAP8[$1 + 15 | 0] = jsvObjectIteratorHasValue(HEAP32[$1 + 8 >> 2] + 4 | 0) & 1;
     break label$1;
    default:
     HEAP8[$1 + 15 | 0] = jsvStringIteratorHasChar(HEAP32[$1 + 8 >> 2] + 4 | 0) & 1;
     break label$1;
    case 1:
     break label$3;
    }
   }
   HEAP8[$1 + 15 | 0] = jsvArrayBufferIteratorHasElement(HEAP32[$1 + 8 >> 2] + 4 | 0) & 1;
   break label$1;
  }
  HEAP8[$1 + 15 | 0] = 0;
 }
 global$0 = $1 + 16 | 0;
 return HEAP8[$1 + 15 | 0] & 1;
}
function jsvAppendStringVar($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 112 | 0;
 global$0 = $4;
 HEAP32[$4 + 108 >> 2] = $0;
 HEAP32[$4 + 104 >> 2] = $1;
 HEAP32[$4 + 100 >> 2] = $2;
 HEAP32[$4 + 96 >> 2] = $3;
 $0 = $4 + 16 | 0;
 $1 = $4 + 56 | 0;
 jsvStringIteratorNew($1, HEAP32[$4 + 108 >> 2], 0);
 jsvStringIteratorGotoEnd($1);
 jsvStringIteratorNew($0, HEAP32[$4 + 104 >> 2], HEAP32[$4 + 100 >> 2]);
 while (1) {
  if (jsvStringIteratorHasChar($4 + 16 | 0) & 1) {
   $0 = HEAP32[$4 + 96 >> 2];
   HEAP32[$4 + 96 >> 2] = $0 + -1;
   $0 = $0 >>> 0 > 0;
  } else {
   $0 = 0;
  }
  if ($0) {
   $0 = $4 + 56 | 0;
   HEAP8[$4 + 15 | 0] = jsvStringIteratorGetCharAndNext($4 + 16 | 0);
   jsvStringIteratorAppend($0, HEAP8[$4 + 15 | 0]);
   continue;
  }
  break;
 }
 $0 = $4 + 56 | 0;
 jsvStringIteratorFree($4 + 16 | 0);
 jsvStringIteratorFree($0);
 global$0 = $4 + 112 | 0;
}
function jsvArrayBufferIteratorGetValue($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 label$1 : {
  if (!HEAPU16[HEAP32[$1 + 24 >> 2] + 36 >> 1]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  jsvArrayBufferIteratorGetValueData(HEAP32[$1 + 24 >> 2], $1 + 16 | 0);
  if (HEAPU16[HEAP32[$1 + 24 >> 2] + 36 >> 1] & 32) {
   HEAP32[$1 + 28 >> 2] = jsvNewFromFloat(jsvArrayBufferIteratorDataToFloat(HEAP32[$1 + 24 >> 2], $1 + 16 | 0));
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvArrayBufferIteratorDataToInt(HEAP32[$1 + 24 >> 2], $1 + 16 | 0);
  if ((HEAPU16[HEAP32[$1 + 24 >> 2] + 36 >> 1] & -257) == 4) {
   HEAP32[$1 + 28 >> 2] = jsvNewFromLongInteger(HEAP32[$1 + 12 >> 2], 0);
   break label$1;
  }
  HEAP32[$1 + 28 >> 2] = jsvNewFromInteger(HEAP32[$1 + 12 >> 2]);
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function graphicsFallbackFillRect($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0;
 $6 = global$0 - 32 | 0;
 global$0 = $6;
 HEAP32[$6 + 28 >> 2] = $0;
 HEAP32[$6 + 24 >> 2] = $1;
 HEAP32[$6 + 20 >> 2] = $2;
 HEAP32[$6 + 16 >> 2] = $3;
 HEAP32[$6 + 12 >> 2] = $4;
 HEAP32[$6 + 8 >> 2] = $5;
 HEAP32[$6 >> 2] = HEAP32[$6 + 20 >> 2];
 while (1) {
  if (HEAP32[$6 >> 2] <= HEAP32[$6 + 12 >> 2]) {
   HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 24 >> 2];
   while (1) {
    if (HEAP32[$6 + 4 >> 2] <= HEAP32[$6 + 16 >> 2]) {
     graphicsSetPixelDevice(HEAP32[$6 + 28 >> 2], HEAP32[$6 + 4 >> 2], HEAP32[$6 >> 2], HEAP32[$6 + 8 >> 2]);
     HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 4 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$6 >> 2] = HEAP32[$6 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $6 + 32 | 0;
}
function jsfNameFromVar($0, $1) {
 var $2 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP32[$2 + 44 >> 2] = $1;
 HEAP32[$2 >> 2] = 0;
 HEAP32[$2 + 4 >> 2] = 0;
 HEAP8[$2 + 21 | 0] = 0;
 HEAP8[$2 + 22 | 0] = 0;
 HEAP8[$2 + 23 | 0] = 0;
 HEAP8[$2 + 24 | 0] = 0;
 HEAP8[$2 + 25 | 0] = 0;
 HEAP8[$2 + 26 | 0] = 0;
 HEAP8[$2 + 27 | 0] = 0;
 HEAP8[$2 + 28 | 0] = 0;
 HEAP32[$2 + 16 >> 2] = 0;
 HEAP32[$2 + 20 >> 2] = 0;
 HEAP32[$2 + 8 >> 2] = 0;
 HEAP32[$2 + 12 >> 2] = 0;
 jsvGetString(HEAP32[$2 + 44 >> 2], $2, 29);
 $1 = HEAP32[$2 + 4 >> 2];
 HEAP32[$0 >> 2] = HEAP32[$2 >> 2];
 HEAP32[$0 + 4 >> 2] = $1;
 HEAP32[$0 + 24 >> 2] = HEAP32[$2 + 24 >> 2];
 $1 = HEAP32[$2 + 20 >> 2];
 HEAP32[$0 + 16 >> 2] = HEAP32[$2 + 16 >> 2];
 HEAP32[$0 + 20 >> 2] = $1;
 $1 = HEAP32[$2 + 12 >> 2];
 HEAP32[$0 + 8 >> 2] = HEAP32[$2 + 8 >> 2];
 HEAP32[$0 + 12 >> 2] = $1;
 global$0 = $2 + 48 | 0;
}
function jsvAddGetterOrSetter($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 global$0 = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP8[$4 + 23 | 0] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP32[$4 + 12 >> 2] = jsvFindChildFromVar(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2], 1);
 if (jsvIsName(HEAP32[$4 + 12 >> 2]) & 1) {
  HEAP32[$4 + 8 >> 2] = jsvGetValueOfName(HEAP32[$4 + 12 >> 2]);
  if (!(jsvIsGetterOrSetter(HEAP32[$4 + 8 >> 2]) & 1)) {
   jsvUnLock(HEAP32[$4 + 8 >> 2]);
   HEAP32[$4 + 8 >> 2] = jsvNewWithFlags(6);
   jsvSetValueOfName(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2]);
  }
  if (jsvIsGetterOrSetter(HEAP32[$4 + 8 >> 2]) & 1) {
   jsvObjectSetChild(HEAP32[$4 + 8 >> 2], HEAP8[$4 + 23 | 0] & 1 ? 78604 : 78608, HEAP32[$4 + 16 >> 2]);
  }
  jsvUnLock(HEAP32[$4 + 8 >> 2]);
 }
 jsvUnLock(HEAP32[$4 + 12 >> 2]);
 global$0 = $4 + 32 | 0;
}
function tflite__SimpleMemoryAllocator__Create_28tflite__ErrorReporter__2c_20unsigned_20char__2c_20unsigned_20long_29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 + -64 | 0;
 global$0 = $3;
 HEAP32[$3 + 60 >> 2] = $0;
 HEAP32[$3 + 56 >> 2] = $1;
 HEAP32[$3 + 52 >> 2] = $2;
 label$1 : {
  if (!HEAP32[$3 + 60 >> 2]) {
   break label$1;
  }
 }
 label$2 : {
  if (!HEAP32[$3 + 56 >> 2]) {
   break label$2;
  }
 }
 $0 = $3 + 24 | 0;
 FUNCTION_TABLE[597]($0, HEAP32[$3 + 60 >> 2], HEAP32[$3 + 56 >> 2], HEAP32[$3 + 52 >> 2]) | 0;
 HEAP32[$3 + 20 >> 2] = tflite__SimpleMemoryAllocator__AllocateFromTail_28unsigned_20long_2c_20unsigned_20long_29($0, 28, 4);
 $0 = HEAP32[$3 + 20 >> 2];
 $1 = $3 + 24 | 0;
 tflite__SimpleMemoryAllocator__SimpleMemoryAllocator_28tflite__SimpleMemoryAllocator_20const__29($0, $1);
 FUNCTION_TABLE[598]($1) | 0;
 global$0 = $3 - -64 | 0;
 return $0;
}
function jsfNameFromString($0, $1) {
 var $2 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP32[$2 + 44 >> 2] = $1;
 HEAP32[$2 >> 2] = 0;
 HEAP32[$2 + 4 >> 2] = 0;
 HEAP8[$2 + 21 | 0] = 0;
 HEAP8[$2 + 22 | 0] = 0;
 HEAP8[$2 + 23 | 0] = 0;
 HEAP8[$2 + 24 | 0] = 0;
 HEAP8[$2 + 25 | 0] = 0;
 HEAP8[$2 + 26 | 0] = 0;
 HEAP8[$2 + 27 | 0] = 0;
 HEAP8[$2 + 28 | 0] = 0;
 HEAP32[$2 + 16 >> 2] = 0;
 HEAP32[$2 + 20 >> 2] = 0;
 HEAP32[$2 + 8 >> 2] = 0;
 HEAP32[$2 + 12 >> 2] = 0;
 strcpy($2, HEAP32[$2 + 44 >> 2]);
 $1 = HEAP32[$2 + 4 >> 2];
 HEAP32[$0 >> 2] = HEAP32[$2 >> 2];
 HEAP32[$0 + 4 >> 2] = $1;
 HEAP32[$0 + 24 >> 2] = HEAP32[$2 + 24 >> 2];
 $1 = HEAP32[$2 + 20 >> 2];
 HEAP32[$0 + 16 >> 2] = HEAP32[$2 + 16 >> 2];
 HEAP32[$0 + 20 >> 2] = $1;
 $1 = HEAP32[$2 + 12 >> 2];
 HEAP32[$0 + 8 >> 2] = HEAP32[$2 + 8 >> 2];
 HEAP32[$0 + 12 >> 2] = $1;
 global$0 = $2 + 48 | 0;
}
function jswrap_error_toString($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP32[$1 + 20 >> 2] = jsvObjectGetChild(HEAP32[$1 + 24 >> 2], 119927, 0);
 if (!HEAP32[$1 + 20 >> 2]) {
  HEAP32[$1 + 20 >> 2] = jsvNewFromString(119932);
 }
 label$2 : {
  if (!HEAP32[$1 + 20 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$2;
  }
  HEAP32[$1 + 16 >> 2] = jsvObjectGetChild(HEAP32[$1 + 24 >> 2], 119919, 0);
  if (HEAP32[$1 + 16 >> 2]) {
   $0 = HEAP32[$1 + 20 >> 2];
   HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 16 >> 2];
   HEAP32[$1 >> 2] = $0;
   HEAP32[$1 + 12 >> 2] = jsvVarPrintf(119989, $1);
   jsvUnLock2(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 20 >> 2]);
   HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 12 >> 2];
  }
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function tflite__FlatSizeSkipDim_28tflite__RuntimeShape_20const__2c_20int_29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 20 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$2 + 28 >> 2]);
 HEAP32[$2 + 16 >> 2] = tflite__RuntimeShape__DimsData_28_29(HEAP32[$2 + 28 >> 2]);
 HEAP32[$2 + 12 >> 2] = 1;
 HEAP32[$2 + 8 >> 2] = 0;
 while (1) {
  if (HEAP32[$2 + 8 >> 2] < HEAP32[$2 + 20 >> 2]) {
   $0 = $2;
   if (HEAP32[$2 + 8 >> 2] == HEAP32[$2 + 24 >> 2]) {
    $1 = 1;
   } else {
    $1 = HEAP32[HEAP32[$2 + 16 >> 2] + (HEAP32[$2 + 8 >> 2] << 2) >> 2];
   }
   HEAP32[$0 + 12 >> 2] = Math_imul($1, HEAP32[$2 + 12 >> 2]);
   HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function jswrap_graphics_getFonts_callback($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 12 >> 2];
 label$1 : {
  if (jsvGetStringLength(HEAP32[$2 + 8 >> 2]) >>> 0 <= 7) {
   break label$1;
  }
  if (!(jsvIsStringEqualOrStartsWith(HEAP32[$2 + 8 >> 2], 127760, 1) & 1)) {
   break label$1;
  }
  if (jsvIsStringEqual(HEAP32[$2 + 8 >> 2], 127768) & 1) {
   break label$1;
  }
  if (jsvIsStringEqual(HEAP32[$2 + 8 >> 2], 127782) & 1) {
   break label$1;
  }
  if (jsvIsStringEqual(HEAP32[$2 + 8 >> 2], 127795) & 1) {
   break label$1;
  }
  HEAP32[$2 >> 2] = jsvNewFromStringVar(HEAP32[$2 + 8 >> 2], 7, 2147483647);
  jsvArrayPush(HEAP32[$2 + 4 >> 2], HEAP32[$2 >> 2]);
  jsvUnLock(HEAP32[$2 >> 2]);
 }
 global$0 = $2 + 16 | 0;
}
function jsvGetStringLength($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP32[$1 + 20 >> 2] = 0;
 HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 24 >> 2];
 HEAP32[$1 + 12 >> 2] = 0;
 label$1 : {
  if (!(jsvHasCharacterData(HEAP32[$1 + 24 >> 2]) & 1)) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  while (1) {
   if (HEAP32[$1 + 16 >> 2]) {
    HEAP16[$1 + 10 >> 1] = jsvGetLastChild(HEAP32[$1 + 16 >> 2]);
    HEAP32[$1 + 20 >> 2] = jsvGetCharactersInVar(HEAP32[$1 + 16 >> 2]) + HEAP32[$1 + 20 >> 2];
    jsvUnLock(HEAP32[$1 + 12 >> 2]);
    $0 = jsvLockSafe(HEAPU16[$1 + 10 >> 1]);
    HEAP32[$1 + 12 >> 2] = $0;
    HEAP32[$1 + 16 >> 2] = $0;
    continue;
   }
   break;
  }
  jsvUnLock(HEAP32[$1 + 12 >> 2]);
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function std____2____compressed_pair_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29___2c_20std____2__allocator_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29__20__20_____compressed_pair_std__nullptr_t_2c_20true__28std__nullptr_t___29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 std____2____compressed_pair_elem_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29___2c_200_2c_20false_____compressed_pair_elem_std__nullptr_t_2c_20void__28std__nullptr_t___29($0, tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(HEAP32[$2 + 8 >> 2]));
 tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator___MicroBuiltinDataAllocator_28_29($0);
 global$0 = $2 + 16 | 0;
}
function jswrap_date_setHours($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0, $6 = 0;
 $5 = global$0 - 48 | 0;
 global$0 = $5;
 HEAP32[$5 + 44 >> 2] = $0;
 HEAP32[$5 + 40 >> 2] = $1;
 HEAP32[$5 + 36 >> 2] = $2;
 HEAP32[$5 + 32 >> 2] = $3;
 HEAP32[$5 + 28 >> 2] = $4;
 getTimeFromDateVar($5, HEAP32[$5 + 44 >> 2], 0);
 HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 40 >> 2];
 if (jsvIsNumeric(HEAP32[$5 + 36 >> 2]) & 1) {
  HEAP32[$5 + 12 >> 2] = jsvGetInteger(HEAP32[$5 + 36 >> 2]);
 }
 if (jsvIsNumeric(HEAP32[$5 + 32 >> 2]) & 1) {
  HEAP32[$5 + 8 >> 2] = jsvGetInteger(HEAP32[$5 + 32 >> 2]);
 }
 if (jsvIsNumeric(HEAP32[$5 + 28 >> 2]) & 1) {
  HEAP32[$5 + 4 >> 2] = jsvGetInteger(HEAP32[$5 + 28 >> 2]);
 }
 $6 = jswrap_date_setTime(HEAP32[$5 + 44 >> 2], fromTimeInDay($5));
 global$0 = $5 + 48 | 0;
 return +$6;
}
function jsvArrayAddToEnd($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = 1;
 HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 16 >> 2];
 if (jsvGetLastChild(HEAP32[$2 + 24 >> 2]) & 65535) {
  HEAP32[$2 + 8 >> 2] = jsvLock(jsvGetLastChild(HEAP32[$2 + 24 >> 2]) & 65535);
  HEAP32[$2 + 12 >> 2] = jsvGetInteger(HEAP32[$2 + 8 >> 2]) + 1;
  jsvUnLock(HEAP32[$2 + 8 >> 2]);
 }
 HEAP32[$2 + 4 >> 2] = jsvMakeIntoVariableName(jsvNewFromInteger(HEAP32[$2 + 12 >> 2]), HEAP32[$2 + 20 >> 2]);
 label$2 : {
  if (!HEAP32[$2 + 4 >> 2]) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$2;
  }
  jsvAddName(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 4 >> 2]);
  jsvUnLock(HEAP32[$2 + 4 >> 2]);
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function jsvGetLongInteger($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 4 >> 2] = $0;
 label$1 : {
  if (jsvIsInt(HEAP32[$1 + 4 >> 2]) & 1) {
   $0 = jsvGetInteger(HEAP32[$1 + 4 >> 2]);
   HEAP32[$1 + 8 >> 2] = $0;
   HEAP32[$1 + 12 >> 2] = $0 >> 31;
   break label$1;
  }
  $0 = $1;
  $5 = $1;
  $2 = jsvGetFloat(HEAP32[$1 + 4 >> 2]);
  label$3 : {
   if (Math_abs($2) < 0x8000000000000000) {
    $3 = Math_abs($2) >= 1 ? $2 > 0 ? ~~Math_min(Math_floor($2 / 4294967296), 4294967295) >>> 0 : ~~Math_ceil(($2 - +(~~$2 >>> 0 >>> 0)) / 4294967296) >>> 0 : 0;
    $4 = ~~$2 >>> 0;
    break label$3;
   }
   $3 = -2147483648;
   $4 = 0;
  }
  HEAP32[$5 + 8 >> 2] = $4;
  HEAP32[$0 + 12 >> 2] = $3;
 }
 global$0 = $1 + 16 | 0;
 i64toi32_i32$HIGH_BITS = HEAP32[$1 + 12 >> 2];
 return HEAP32[$1 + 8 >> 2];
}
function jsvGetCharsOnLine($0, $1) {
 var $2 = 0;
 $2 = global$0 + -64 | 0;
 global$0 = $2;
 HEAP32[$2 + 60 >> 2] = $0;
 HEAP32[$2 + 56 >> 2] = $1;
 HEAP32[$2 + 52 >> 2] = 1;
 HEAP32[$2 + 48 >> 2] = 0;
 jsvStringIteratorNew($2 + 8 | 0, HEAP32[$2 + 60 >> 2], 0);
 while (1) {
  label$2 : {
   if (!(jsvStringIteratorHasChar($2 + 8 | 0) & 1)) {
    break label$2;
   }
   label$3 : {
    if ((jsvStringIteratorGetCharAndNext($2 + 8 | 0) & 255) == 10) {
     HEAP32[$2 + 52 >> 2] = HEAP32[$2 + 52 >> 2] + 1;
     if (HEAPU32[$2 + 52 >> 2] > HEAPU32[$2 + 56 >> 2]) {
      break label$2;
     }
     break label$3;
    }
    if (HEAP32[$2 + 52 >> 2] == HEAP32[$2 + 56 >> 2]) {
     HEAP32[$2 + 48 >> 2] = HEAP32[$2 + 48 >> 2] + 1;
    }
   }
   continue;
  }
  break;
 }
 jsvStringIteratorFree($2 + 8 | 0);
 global$0 = $2 - -64 | 0;
 return HEAP32[$2 + 48 >> 2];
}
function jstPinTaskChecker($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1 : {
  if (HEAPU8[HEAP32[$2 + 24 >> 2] + 24 | 0] != 1) {
   HEAP8[$2 + 31 | 0] = 0;
   break label$1;
  }
  HEAP8[$2 + 19 | 0] = HEAPU8[HEAP32[$2 + 20 >> 2]];
  HEAP32[$2 + 12 >> 2] = 0;
  while (1) {
   if (HEAP32[$2 + 12 >> 2] < 4) {
    if (HEAPU8[HEAP32[$2 + 12 >> 2] + (HEAP32[$2 + 24 >> 2] + 8 | 0) | 0] == HEAPU8[$2 + 19 | 0]) {
     HEAP8[$2 + 31 | 0] = 1;
     break label$1;
    }
    if (HEAPU8[HEAP32[$2 + 12 >> 2] + (HEAP32[$2 + 24 >> 2] + 8 | 0) | 0] == 255) {
     HEAP8[$2 + 31 | 0] = 0;
     break label$1;
    } else {
     HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
     continue;
    }
   }
   break;
  }
  HEAP8[$2 + 31 | 0] = 0;
 }
 return HEAP8[$2 + 31 | 0] & 1;
}
function jsiDumpDeviceInitialisation($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 HEAP32[$3 + 16 >> 2] = jsvObjectGetChild(HEAP32[80545], HEAP32[$3 + 20 >> 2], 0);
 if (HEAP32[$3 + 16 >> 2]) {
  HEAP32[$3 + 12 >> 2] = jsvObjectGetChild(HEAP32[$3 + 16 >> 2], 81192, 0);
  if (HEAP32[$3 + 12 >> 2]) {
   $0 = HEAP32[$3 + 28 >> 2];
   $1 = HEAP32[$3 + 24 >> 2];
   HEAP32[$3 >> 2] = HEAP32[$3 + 20 >> 2];
   cbprintf($0, $1, 81220, $3);
   if (jsvIsObject(HEAP32[$3 + 12 >> 2]) & 1) {
    jsfGetJSONWithCallback(HEAP32[$3 + 12 >> 2], 0, 32, 0, HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2]);
   }
   FUNCTION_TABLE[HEAP32[$3 + 28 >> 2]](81216, HEAP32[$3 + 24 >> 2]);
  }
  jsvUnLock2(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 16 >> 2]);
 }
 global$0 = $3 + 32 | 0;
}
function jsvFindChildFromStringI($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP16[$2 + 18 >> 1] = jsvGetFirstChild(HEAP32[$2 + 24 >> 2]);
 label$1 : {
  while (1) {
   if (HEAPU16[$2 + 18 >> 1]) {
    HEAP32[$2 + 12 >> 2] = jsvGetAddressOf(HEAPU16[$2 + 18 >> 1]);
    label$4 : {
     if (!(jsvHasCharacterData(HEAP32[$2 + 12 >> 2]) & 1)) {
      break label$4;
     }
     if (!(jsvIsStringEqualOrStartsWithOffset(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 20 >> 2], 0, 1) & 1)) {
      break label$4;
     }
     HEAP32[$2 + 28 >> 2] = jsvLockAgain(HEAP32[$2 + 12 >> 2]);
     break label$1;
    }
    HEAP16[$2 + 18 >> 1] = jsvGetNextSibling(HEAP32[$2 + 12 >> 2]);
    continue;
   }
   break;
  }
  HEAP32[$2 + 28 >> 2] = 0;
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function graphicsGetSetPixelUnclippedFn($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 32 | 0;
 global$0 = $5;
 HEAP32[$5 + 24 >> 2] = $0;
 HEAP32[$5 + 20 >> 2] = $1;
 HEAP32[$5 + 16 >> 2] = $2;
 HEAP32[$5 + 12 >> 2] = $3;
 HEAP32[$5 + 8 >> 2] = $4;
 label$1 : {
  label$2 : {
   $0 = HEAP32[$5 + 24 >> 2];
   if (!((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 112)) {
    if (!(graphicsSetModifiedAndClip(HEAP32[$5 + 24 >> 2], $5 + 20 | 0, $5 + 16 | 0, $5 + 12 | 0, $5 + 8 | 0) & 1)) {
     break label$2;
    }
   }
   HEAP32[$5 + 28 >> 2] = 533;
   break label$1;
  }
  $0 = HEAP32[$5 + 24 >> 2];
  HEAP32[$5 + 28 >> 2] = HEAPU8[$0 + 52 | 0] | HEAPU8[$0 + 53 | 0] << 8 | (HEAPU8[$0 + 54 | 0] << 16 | HEAPU8[$0 + 55 | 0] << 24);
 }
 global$0 = $5 + 32 | 0;
 return HEAP32[$5 + 28 >> 2];
}
function jswrap_interface_getSerial() {
 var $0 = 0, $1 = 0;
 $0 = global$0 + -64 | 0;
 global$0 = $0;
 HEAP32[$0 + 8 >> 2] = jshGetSerialNumber($0 + 16 | 0);
 HEAP32[$0 + 4 >> 2] = jsvNewWithFlags(27);
 label$1 : {
  if (!HEAP32[$0 + 4 >> 2]) {
   HEAP32[$0 + 60 >> 2] = 0;
   break label$1;
  }
  HEAP32[$0 + 12 >> 2] = 0;
  while (1) {
   if (HEAP32[$0 + 12 >> 2] < HEAP32[$0 + 8 >> 2]) {
    if (!(!HEAP32[$0 + 12 >> 2] | HEAP32[$0 + 12 >> 2] & 3)) {
     jsvAppendString(HEAP32[$0 + 4 >> 2], 121606);
    }
    $1 = $0 + 52 | 0;
    itostr(HEAPU8[HEAP32[$0 + 12 >> 2] + ($0 + 16 | 0) | 0] | 256, $1, 16);
    jsvAppendString(HEAP32[$0 + 4 >> 2], $1 + 1 | 0);
    HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$0 + 60 >> 2] = HEAP32[$0 + 4 >> 2];
 }
 global$0 = $0 - -64 | 0;
 return HEAP32[$0 + 60 >> 2];
}
function jswrap_graphics_drawRect($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0, $6 = 0;
 $5 = global$0 - 112 | 0;
 global$0 = $5;
 $6 = $5 + 8 | 0;
 HEAP32[$5 + 104 >> 2] = $0;
 HEAP32[$5 + 100 >> 2] = $1;
 HEAP32[$5 + 96 >> 2] = $2;
 HEAP32[$5 + 92 >> 2] = $3;
 HEAP32[$5 + 88 >> 2] = $4;
 _jswrap_graphics_getRect(HEAP32[$5 + 100 >> 2], $5 + 84 | 0, $5 + 96 | 0, $5 + 92 | 0, $5 + 88 | 0);
 label$1 : {
  if (!(graphicsGetFromVar($6, HEAP32[$5 + 104 >> 2]) & 1)) {
   HEAP32[$5 + 108 >> 2] = 0;
   break label$1;
  }
  $0 = $5 + 8 | 0;
  graphicsDrawRect($0, HEAP32[$5 + 84 >> 2], HEAP32[$5 + 96 >> 2], HEAP32[$5 + 92 >> 2], HEAP32[$5 + 88 >> 2]);
  graphicsSetVar($0);
  HEAP32[$5 + 108 >> 2] = jsvLockAgain(HEAP32[$5 + 104 >> 2]);
 }
 global$0 = $5 + 112 | 0;
 return HEAP32[$5 + 108 >> 2];
}
function jsvGetLength($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (jsvIsArray(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = jsvGetArrayLength(HEAP32[$1 + 8 >> 2]);
   break label$1;
  }
  if (jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = jsvGetArrayBufferLength(HEAP32[$1 + 8 >> 2]);
   break label$1;
  }
  if (jsvIsString(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = jsvGetStringLength(HEAP32[$1 + 8 >> 2]);
   break label$1;
  }
  label$5 : {
   if (!(jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1)) {
    if (!(jsvIsFunction(HEAP32[$1 + 8 >> 2]) & 1)) {
     break label$5;
    }
   }
   HEAP32[$1 + 12 >> 2] = jsvGetChildren(HEAP32[$1 + 8 >> 2]);
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 1;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jswrap_io_poke($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 80 | 0;
 global$0 = $3;
 HEAP32[$3 + 76 >> 2] = $0;
 HEAP32[$3 + 72 >> 2] = $1;
 HEAP32[$3 + 68 >> 2] = $2;
 label$1 : {
  if (jsvIsNumeric(HEAP32[$3 + 72 >> 2]) & 1) {
   _jswrap_io_poke(HEAP32[$3 + 76 >> 2], jsvGetInteger(HEAP32[$3 + 72 >> 2]), HEAP32[$3 + 68 >> 2]);
   break label$1;
  }
  if (jsvIsIterable(HEAP32[$3 + 72 >> 2]) & 1) {
   jsvIteratorNew($3 + 8 | 0, HEAP32[$3 + 72 >> 2], 1);
   while (1) {
    if (jsvIteratorHasElement($3 + 8 | 0) & 1) {
     $0 = $3 + 8 | 0;
     _jswrap_io_poke(HEAP32[$3 + 76 >> 2], jsvIteratorGetIntegerValue($0), HEAP32[$3 + 68 >> 2]);
     HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 68 >> 2] + HEAP32[$3 + 76 >> 2];
     jsvIteratorNext($0);
     continue;
    }
    break;
   }
   jsvIteratorFree($3 + 8 | 0);
  }
 }
 global$0 = $3 + 80 | 0;
}
function jswrap_storage_writeJSON($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = global$0 - 80 | 0;
 global$0 = $2;
 $3 = $2 + 32 | 0;
 HEAP32[$2 + 76 >> 2] = $0;
 HEAP32[$2 + 72 >> 2] = $1;
 HEAP32[$2 + 68 >> 2] = jswrap_json_stringify(HEAP32[$2 + 72 >> 2], 0, 0);
 jsfNameFromVar($3, HEAP32[$2 + 76 >> 2]);
 $0 = HEAP32[$2 + 68 >> 2];
 HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 56 >> 2];
 $1 = HEAP32[$2 + 52 >> 2];
 HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 48 >> 2];
 HEAP32[$2 + 20 >> 2] = $1;
 $1 = HEAP32[$2 + 44 >> 2];
 HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 40 >> 2];
 HEAP32[$2 + 12 >> 2] = $1;
 $1 = HEAP32[$2 + 36 >> 2];
 HEAP32[$2 >> 2] = HEAP32[$2 + 32 >> 2];
 HEAP32[$2 + 4 >> 2] = $1;
 HEAP8[$2 + 67 | 0] = jsfWriteFile($2, $0, 0, 0, 0) & 1;
 jsvUnLock(HEAP32[$2 + 68 >> 2]);
 global$0 = $2 + 80 | 0;
 return HEAP8[$2 + 67 | 0] & 1;
}
function jswrap_promise_all_resolve($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 HEAP32[$3 + 16 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$3 + 28 >> 2], 125161, 0));
 HEAP32[$3 + 12 >> 2] = jsvObjectGetChild(HEAP32[$3 + 28 >> 2], 125167, 0);
 if (HEAP32[$3 + 12 >> 2]) {
  jsvSetArrayItem(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
  HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 16 >> 2] + -1;
  jsvObjectSetChildAndUnLock(HEAP32[$3 + 28 >> 2], 125161, jsvNewFromInteger(HEAP32[$3 + 16 >> 2]));
  if (!HEAP32[$3 + 16 >> 2]) {
   _jswrap_promise_queueresolve(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 12 >> 2]);
  }
  jsvUnLock(HEAP32[$3 + 12 >> 2]);
 }
 global$0 = $3 + 32 | 0;
}
function jswrap_banglejs_setLCDPower($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 15 | 0] = $0;
 jswrap_banglejs_setLCDPowerController(HEAP8[$1 + 15 | 0] & 1);
 jswrap_banglejs_setLCDPowerBacklight(HEAP8[$1 + 15 | 0] & 1);
 if ((HEAP32[84152] & 32768) != (HEAP8[$1 + 15 | 0] & 1)) {
  HEAP32[$1 + 8 >> 2] = jsvObjectGetChild(HEAP32[80545], 110020, 0);
  if (HEAP32[$1 + 8 >> 2]) {
   $0 = $1 + 4 | 0;
   HEAP32[$1 + 4 >> 2] = jsvNewFromBool(HEAP8[$1 + 15 | 0] & 1);
   jsiQueueObjectCallbacks(HEAP32[$1 + 8 >> 2], 110027, $0, 1);
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
  }
  jsvUnLock(HEAP32[$1 + 8 >> 2]);
 }
 HEAP16[168314] = 0;
 label$3 : {
  if (HEAP8[$1 + 15 | 0] & 1) {
   HEAP32[84152] = HEAP32[84152] | 32768;
   break label$3;
  }
  HEAP32[84152] = HEAP32[84152] & -32769;
 }
 global$0 = $1 + 16 | 0;
}
function i2c_rd_bit($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 i2c_pin_wr1(HEAPU8[HEAP32[$1 + 12 >> 2] + 1 | 0]);
 dly(HEAP32[$1 + 12 >> 2]);
 i2c_pin_wr1(HEAPU8[HEAP32[$1 + 12 >> 2]]);
 dly(HEAP32[$1 + 12 >> 2]);
 HEAP32[$1 + 8 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2];
 while (1) {
  if (jshPinGetValue(HEAPU8[HEAP32[$1 + 12 >> 2]]) & 1) {
   $0 = 0;
  } else {
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP32[$1 + 8 >> 2] = $0 + -1;
  }
  if ($0) {
   continue;
  }
  break;
 }
 if (!(HEAP32[$1 + 8 >> 2] | !HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2])) {
  err(83342);
 }
 dly(HEAP32[$1 + 12 >> 2]);
 HEAP8[$1 + 7 | 0] = jshPinGetValue(HEAPU8[HEAP32[$1 + 12 >> 2] + 1 | 0]) & 1;
 i2c_pin_wr0(HEAPU8[HEAP32[$1 + 12 >> 2]]);
 dly(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return HEAP8[$1 + 7 | 0] & 1;
}
function jswrap_interface_print($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = $1 + 8 | 0;
 jsiConsoleRemoveInputLine();
 jsvObjectIteratorNew($0, HEAP32[$1 + 12 >> 2]);
 while (1) {
  if (jsvObjectIteratorHasValue($1 + 8 | 0) & 1) {
   HEAP32[$1 + 4 >> 2] = jsvObjectIteratorGetValue($1 + 8 | 0);
   label$3 : {
    if (jsvIsString(HEAP32[$1 + 4 >> 2]) & 1) {
     jsiConsolePrintStringVar(HEAP32[$1 + 4 >> 2]);
     break label$3;
    }
    jsfPrintJSON(HEAP32[$1 + 4 >> 2], 261);
   }
   $0 = $1 + 8 | 0;
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
   jsvObjectIteratorNext($0);
   if (jsvObjectIteratorHasValue($0) & 1) {
    jsiConsolePrintString(121458);
   }
   continue;
  }
  break;
 }
 jsvObjectIteratorFree($1 + 8 | 0);
 jsiConsolePrintString(121460);
 global$0 = $1 + 16 | 0;
}
function jspePostfixExpression() {
 var $0 = 0, $1 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 label$1 : {
  if (!(HEAP16[HEAP32[35539] + 2 >> 1] != 153 ? HEAP16[HEAP32[35539] + 2 >> 1] != 152 : 0)) {
   HEAP32[$0 + 8 >> 2] = HEAP16[HEAP32[35539] + 2 >> 1];
   jslGetNextToken();
   HEAP32[$0 + 12 >> 2] = jspePostfixExpression();
   if ((HEAP32[80549] & 63) == 1) {
    HEAP32[$0 + 4 >> 2] = jsvNewFromInteger(1);
    HEAP32[$0 >> 2] = jsvMathsOpSkipNames(HEAP32[$0 + 12 >> 2], HEAP32[$0 + 4 >> 2], HEAP32[$0 + 8 >> 2] == 152 ? 43 : 45);
    jsvUnLock(HEAP32[$0 + 4 >> 2]);
    jsvReplaceWith(HEAP32[$0 + 12 >> 2], HEAP32[$0 >> 2]);
    jsvUnLock(HEAP32[$0 >> 2]);
   }
   break label$1;
  }
  HEAP32[$0 + 12 >> 2] = jspeFactorFunctionCall();
 }
 $1 = __jspePostfixExpression(HEAP32[$0 + 12 >> 2]);
 global$0 = $0 + 16 | 0;
 return $1;
}
function jsfEraseArea($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1 : {
  if (!(jshFlashGetPage(HEAP32[$2 + 24 >> 2], $2 + 16 | 0, $2 + 12 | 0) & 1)) {
   HEAP8[$2 + 31 | 0] = 0;
   break label$1;
  }
  while (1) {
   if (HEAPU32[$2 + 16 >> 2] < HEAPU32[$2 + 20 >> 2]) {
    $0 = jspIsInterrupted() ^ -1;
   } else {
    $0 = 0;
   }
   if ($0 & 1) {
    if (!(jsfIsErased(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 12 >> 2]) & 1)) {
     jshFlashErasePage(HEAP32[$2 + 16 >> 2]);
    }
    if (!(jshFlashGetPage(HEAP32[$2 + 16 >> 2] + HEAP32[$2 + 12 >> 2] | 0, $2 + 16 | 0, $2 + 12 | 0) & 1)) {
     HEAP8[$2 + 31 | 0] = 1;
     break label$1;
    }
    continue;
   }
   break;
  }
  HEAP8[$2 + 31 | 0] = (jspIsInterrupted() ^ -1) & 1;
 }
 global$0 = $2 + 32 | 0;
}
function std____2____vector_base_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29__2c_20std____2__allocator_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29__20__20_____vector_base_28_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($0);
 HEAP32[$0 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$1 + 8 >> 2] = 0;
 std____2____compressed_pair_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29___2c_20std____2__allocator_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29__20__20_____compressed_pair_std__nullptr_t_2c_20true__28std__nullptr_t___29($0 + 8 | 0, $1 + 8 | 0);
 global$0 = $1 + 16 | 0;
}
function jswrap_espruino_CRC32($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 80 | 0;
 global$0 = $1;
 HEAP32[$1 + 76 >> 2] = $0;
 jsvIteratorNew($1 + 16 | 0, HEAP32[$1 + 76 >> 2], 1);
 HEAP32[$1 + 12 >> 2] = -1;
 while (1) {
  if (jsvIteratorHasElement($1 + 16 | 0) & 1) {
   HEAP32[$1 + 12 >> 2] = jsvIteratorGetIntegerValue($1 + 16 | 0) & 255 ^ HEAP32[$1 + 12 >> 2];
   HEAP32[$1 + 8 >> 2] = 0;
   while (1) {
    if (HEAP32[$1 + 8 >> 2] < 8) {
     HEAP32[$1 + 12 >> 2] = 0 - (HEAP32[$1 + 12 >> 2] & 1) & -306674912 ^ HEAP32[$1 + 12 >> 2] >>> 1;
     HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
     continue;
    }
    break;
   }
   jsvIteratorNext($1 + 16 | 0);
   continue;
  }
  break;
 }
 jsvIteratorFree($1 + 16 | 0);
 $0 = jsvNewFromLongInteger(HEAP32[$1 + 12 >> 2] ^ -1, 0);
 global$0 = $1 + 80 | 0;
 return $0 | 0;
}
function jshSetFlowControlEnabled($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 15 | 0] = $0;
 HEAP8[$1 + 14 | 0] = 0;
 HEAP8[$1 + 13 | 0] = 255;
 if (!(HEAPU8[$1 + 15 | 0] < 21 | HEAPU8[$1 + 15 | 0] > 22)) {
  HEAP32[$1 + 8 >> 2] = HEAPU8[$1 + 15 | 0] - 21;
  HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 8 >> 2] + 322308;
  label$2 : {
   if (HEAP8[$1 + 14 | 0] & 1) {
    $0 = HEAP32[$1 + 4 >> 2];
    HEAP8[$0 | 0] = HEAPU8[$0 | 0] | 8;
    break label$2;
   }
   $0 = HEAP32[$1 + 4 >> 2];
   HEAP8[$0 | 0] = HEAPU8[$0 | 0] & -9;
  }
  HEAP8[HEAP32[$1 + 8 >> 2] + 322310 | 0] = 255;
  if (jshIsPinValid(HEAPU8[$1 + 13 | 0]) & 1) {
   jshPinSetState(HEAPU8[$1 + 13 | 0], 1);
   jshPinSetValue(HEAPU8[$1 + 13 | 0], 0);
   HEAP8[HEAP32[$1 + 8 >> 2] + 322310 | 0] = HEAPU8[$1 + 13 | 0];
  }
 }
 global$0 = $1 + 16 | 0;
}
function __fwritex($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = HEAP32[$2 + 16 >> 2];
 label$1 : {
  if (!$3) {
   if (__towrite($2)) {
    break label$1;
   }
   $3 = HEAP32[$2 + 16 >> 2];
  }
  $5 = HEAP32[$2 + 20 >> 2];
  if ($3 - $5 >>> 0 < $1 >>> 0) {
   FUNCTION_TABLE[HEAP32[$2 + 36 >> 2]]($2, $0, $1) | 0;
   return;
  }
  label$5 : {
   if (HEAP8[$2 + 75 | 0] < 0) {
    break label$5;
   }
   $3 = $1;
   while (1) {
    $4 = $3;
    if (!$4) {
     break label$5;
    }
    $3 = $4 + -1 | 0;
    if (HEAPU8[$3 + $0 | 0] != 10) {
     continue;
    }
    break;
   }
   if (FUNCTION_TABLE[HEAP32[$2 + 36 >> 2]]($2, $0, $4) >>> 0 < $4 >>> 0) {
    break label$1;
   }
   $1 = $1 - $4 | 0;
   $0 = $0 + $4 | 0;
   $5 = HEAP32[$2 + 20 >> 2];
  }
  memcpy($5, $0, $1);
  HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 20 >> 2] + $1;
 }
}
function tflite__MicroMutableOpResolver_9u___FindOp_28tflite__BuiltinOperator_29_20const($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 $0 = HEAP32[$2 + 24 >> 2];
 label$1 : {
  if (HEAP32[$2 + 20 >> 2] == 32) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 16 >> 2] = 0;
  while (1) {
   if (HEAPU32[$2 + 16 >> 2] < HEAPU32[$0 + 292 >> 2]) {
    HEAP32[$2 + 12 >> 2] = ($0 + 4 | 0) + (HEAP32[$2 + 16 >> 2] << 5);
    if (HEAP32[HEAP32[$2 + 12 >> 2] + 20 >> 2] == HEAP32[$2 + 20 >> 2]) {
     HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
     break label$1;
    } else {
     HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 16 >> 2] + 1;
     continue;
    }
   }
   break;
  }
  HEAP32[$2 + 28 >> 2] = 0;
 }
 return HEAP32[$2 + 28 >> 2];
}
function jswrap_object_setPrototypeOf($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = $2;
 label$1 : {
  label$2 : {
   if (!(jsvIsFunction(HEAP32[$2 + 12 >> 2]) & 1)) {
    if (!(jsvIsObject(HEAP32[$2 + 12 >> 2]) & 1)) {
     break label$2;
    }
   }
   $1 = jsvFindChildFromString(HEAP32[$2 + 12 >> 2], 123244, 1);
   break label$1;
  }
  $1 = 0;
 }
 HEAP32[$0 + 4 >> 2] = $1;
 label$4 : {
  if (!(jsvIsName(HEAP32[$2 + 4 >> 2]) & 1)) {
   HEAP32[$2 >> 2] = HEAP32[$2 + 4 >> 2];
   jsExceptionHere(3, 123570, $2);
   break label$4;
  }
  jsvSetValueOfName(HEAP32[$2 + 4 >> 2], HEAP32[$2 + 8 >> 2]);
 }
 jsvUnLock(HEAP32[$2 + 4 >> 2]);
 $0 = jsvLockAgainSafe(HEAP32[$2 + 12 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0 | 0;
}
function jsvIsInt($0) {
 var $1 = 0, $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 if (HEAP32[$2 + 12 >> 2]) {
  $0 = HEAP32[$2 + 12 >> 2];
  $1 = 1;
  label$2 : {
   if (((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) == 9) {
    break label$2;
   }
   $0 = HEAP32[$2 + 12 >> 2];
   $1 = 1;
   if (((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) == 12) {
    break label$2;
   }
   $0 = HEAP32[$2 + 12 >> 2];
   $1 = 1;
   if (((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) == 14) {
    break label$2;
   }
   $0 = HEAP32[$2 + 12 >> 2];
   $1 = 1;
   if (((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) == 15) {
    break label$2;
   }
   $0 = HEAP32[$2 + 12 >> 2];
   $1 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) == 16;
  }
 } else {
  $1 = 0;
 }
 return $1 & 1;
}
function jslPrintTokenisedString($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 96 | 0;
 global$0 = $3;
 HEAP32[$3 + 92 >> 2] = $0;
 HEAP32[$3 + 88 >> 2] = $1;
 HEAP32[$3 + 84 >> 2] = $2;
 HEAP8[$3 + 47 | 0] = 0;
 jsvStringIteratorNew($3 + 8 | 0, HEAP32[$3 + 92 >> 2], 0);
 while (1) {
  if (jsvStringIteratorHasChar($3 + 8 | 0) & 1) {
   HEAP8[$3 + 7 | 0] = jsvStringIteratorGetCharAndNext($3 + 8 | 0);
   if (jslNeedSpaceBetween(HEAPU8[$3 + 47 | 0], HEAPU8[$3 + 7 | 0]) & 1) {
    FUNCTION_TABLE[HEAP32[$3 + 88 >> 2]](77918, HEAP32[$3 + 84 >> 2]);
   }
   $0 = $3 + 48 | 0;
   jslFunctionCharAsString(HEAPU8[$3 + 7 | 0], $0);
   FUNCTION_TABLE[HEAP32[$3 + 88 >> 2]]($0, HEAP32[$3 + 84 >> 2]);
   HEAP8[$3 + 47 | 0] = HEAPU8[$3 + 7 | 0];
   continue;
  }
  break;
 }
 jsvStringIteratorFree($3 + 8 | 0);
 global$0 = $3 + 96 | 0;
}
function jsiQueueEvents($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 global$0 = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP32[$4 + 12 >> 2] = jsvNewWithFlags(5);
 if (HEAP32[$4 + 12 >> 2]) {
  jsvUnLock(jsvAddNamedChild(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 24 >> 2], 81793));
  if (HEAP32[$4 + 16 >> 2]) {
   HEAP32[$4 + 8 >> 2] = jsvNewArray(HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2]);
   if (HEAP32[$4 + 8 >> 2]) {
    jsvUnLock2(jsvAddNamedChild(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], 81798), HEAP32[$4 + 8 >> 2]);
   }
  }
  if (HEAP32[$4 + 28 >> 2]) {
   jsvUnLock(jsvAddNamedChild(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 28 >> 2], 81803));
  }
  jsvArrayPushAndUnLock(HEAP32[80554], HEAP32[$4 + 12 >> 2]);
 }
 global$0 = $4 + 32 | 0;
}
function jswrap_date_setFullYear($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0, $5 = 0;
 $4 = global$0 + -64 | 0;
 global$0 = $4;
 HEAP32[$4 + 60 >> 2] = $0;
 HEAP32[$4 + 56 >> 2] = $1;
 HEAP32[$4 + 52 >> 2] = $2;
 HEAP32[$4 + 48 >> 2] = $3;
 getTimeFromDateVar($4 + 24 | 0, HEAP32[$4 + 60 >> 2], 0);
 getCalendarDate($4, HEAP32[$4 + 24 >> 2]);
 HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 56 >> 2];
 if (jsvIsNumeric(HEAP32[$4 + 52 >> 2]) & 1) {
  HEAP32[$4 + 8 >> 2] = jsvGetInteger(HEAP32[$4 + 52 >> 2]);
 }
 if (jsvIsNumeric(HEAP32[$4 + 48 >> 2]) & 1) {
  HEAP32[$4 + 4 >> 2] = jsvGetInteger(HEAP32[$4 + 48 >> 2]);
 }
 $0 = $4 + 24 | 0;
 HEAP32[$4 + 24 >> 2] = fromCalenderDate($4);
 $5 = jswrap_date_setTime(HEAP32[$4 + 60 >> 2], fromTimeInDay($0));
 global$0 = $4 - -64 | 0;
 return +$5;
}
function jsvGetMemoryUsage() {
 var $0 = 0, $1 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 1;
 while (1) {
  if (HEAPU32[$0 + 8 >> 2] <= HEAPU32[35415]) {
   HEAP32[$0 + 4 >> 2] = jsvGetAddressOf(HEAP32[$0 + 8 >> 2] & 65535);
   $1 = HEAP32[$0 + 4 >> 2];
   if ((HEAPU8[$1 + 13 | 0] | HEAPU8[$1 + 14 | 0] << 8) & 63) {
    HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
    if (jsvIsFlatString(HEAP32[$0 + 4 >> 2]) & 1) {
     HEAP32[$0 >> 2] = jsvGetFlatStringBlocks(HEAP32[$0 + 4 >> 2]);
     HEAP32[$0 + 8 >> 2] = HEAP32[$0 >> 2] + HEAP32[$0 + 8 >> 2];
     HEAP32[$0 + 12 >> 2] = HEAP32[$0 >> 2] + HEAP32[$0 + 12 >> 2];
    }
   }
   HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 8 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}
function jsserialEventCallbackKill($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 20 >> 2] = jsvObjectGetChild(HEAP32[$2 + 28 >> 2], 83606, 0);
 if (HEAP32[$2 + 20 >> 2]) {
  HEAP8[$2 + 19 | 0] = jsvGetIntegerAndUnLock(HEAP32[$2 + 20 >> 2]);
  jshPinWatch(HEAPU8[$2 + 19 | 0], 0);
  HEAP32[$2 + 12 >> 2] = jsserialGetSerialList(0);
  if (HEAP32[$2 + 12 >> 2]) {
   HEAP32[$2 + 8 >> 2] = jsvGetArrayIndex(HEAP32[$2 + 12 >> 2], HEAPU8[$2 + 19 | 0]);
   if (HEAP32[$2 + 8 >> 2]) {
    jsvRemoveChild(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
   }
   if (!jsvGetChildren(HEAP32[$2 + 12 >> 2])) {
    jsvObjectRemoveChild(HEAP32[80546], 83551);
   }
   jsvUnLock2(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 12 >> 2]);
  }
 }
 global$0 = $2 + 32 | 0;
}
function tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 32 | 0;
 global$0 = $5;
 HEAP32[$5 + 28 >> 2] = $0;
 HEAP32[$5 + 24 >> 2] = $1;
 HEAP32[$5 + 20 >> 2] = $2;
 HEAP32[$5 + 16 >> 2] = $3;
 HEAP32[$5 + 12 >> 2] = $4;
 label$1 : {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 28 >> 2]) | 0) != 4) {
   break label$1;
  }
 }
 HEAP32[$5 + 8 >> 2] = flatbuffers__Vector_int___Data_28_29_20const(HEAP32[$5 + 28 >> 2]);
 global$0 = $5 + 32 | 0;
 return HEAP32[$5 + 12 >> 2] + Math_imul(HEAP32[HEAP32[$5 + 8 >> 2] + 12 >> 2], HEAP32[$5 + 16 >> 2] + Math_imul(HEAP32[HEAP32[$5 + 8 >> 2] + 8 >> 2], HEAP32[$5 + 20 >> 2] + Math_imul(HEAP32[$5 + 24 >> 2], HEAP32[HEAP32[$5 + 8 >> 2] + 4 >> 2]) | 0) | 0) | 0;
}
function push_outgoing_bits($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP8[$2 + 7 | 0] = 0;
 HEAP8[$2 + 6 | 0] = 0;
 label$1 : {
  if (HEAPU8[HEAP32[$2 + 12 >> 2] + 10 | 0] > 8) {
   HEAP8[$2 + 7 | 0] = 8;
   HEAP8[$2 + 6 | 0] = HEAPU16[HEAP32[$2 + 12 >> 2] + 8 >> 1] >> HEAPU8[HEAP32[$2 + 12 >> 2] + 10 | 0] - 8;
   break label$1;
  }
  HEAP8[$2 + 7 | 0] = HEAPU8[HEAP32[$2 + 12 >> 2] + 10 | 0];
  HEAP8[$2 + 6 | 0] = HEAPU16[HEAP32[$2 + 12 >> 2] + 8 >> 1];
 }
 if (HEAPU8[$2 + 7 | 0] > 0) {
  push_bits(HEAP32[$2 + 12 >> 2], HEAPU8[$2 + 7 | 0], HEAPU8[$2 + 6 | 0], HEAP32[$2 + 8 >> 2]);
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP8[$0 + 10 | 0] = HEAPU8[$0 + 10 | 0] - HEAPU8[$2 + 7 | 0];
 }
 global$0 = $2 + 16 | 0;
 return HEAPU8[$2 + 7 | 0];
}
function jswrap_graphics_stringMetrics($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 112 | 0;
 global$0 = $2;
 HEAP32[$2 + 104 >> 2] = $0;
 HEAP32[$2 + 100 >> 2] = $1;
 label$1 : {
  if (!(graphicsGetFromVar($2 + 24 | 0, HEAP32[$2 + 104 >> 2]) & 1)) {
   HEAP32[$2 + 108 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jsvNewWithFlags(5);
  if (HEAP32[$2 + 12 >> 2]) {
   _jswrap_graphics_stringMetrics($2 + 24 | 0, HEAP32[$2 + 100 >> 2], -1, $2 + 20 | 0, $2 + 16 | 0);
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 12 >> 2], 127442, jsvNewFromInteger(HEAP32[$2 + 20 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 12 >> 2], 127448, jsvNewFromInteger(HEAP32[$2 + 16 >> 2]));
  }
  HEAP32[$2 + 108 >> 2] = HEAP32[$2 + 12 >> 2];
 }
 global$0 = $2 + 112 | 0;
 return HEAP32[$2 + 108 >> 2];
}
function jsvGetNativeFunctionPtr($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = jsvFindChildFromString(HEAP32[$1 + 8 >> 2], 78361, 0);
 label$1 : {
  if (HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 + 4 >> 2] = jsvSkipNameAndUnLock(HEAP32[$1 + 4 >> 2]);
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP32[$1 >> 2] = (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) + jsvGetFlatStringPointer(HEAP32[$1 + 4 >> 2]);
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP32[$1 + 12 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function tflite__GreedyMemoryPlanner__AddBuffer_28tflite__ErrorReporter__2c_20int_2c_20int_2c_20int_2c_20int_29($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = global$0 - 32 | 0;
 global$0 = $6;
 HEAP32[$6 + 24 >> 2] = $0;
 HEAP32[$6 + 20 >> 2] = $1;
 HEAP32[$6 + 16 >> 2] = $2;
 HEAP32[$6 + 12 >> 2] = $3;
 HEAP32[$6 + 8 >> 2] = $4;
 HEAP32[$6 + 4 >> 2] = $5;
 $0 = HEAP32[$6 + 24 >> 2];
 HEAP32[$6 >> 2] = HEAP32[$0 + 12 >> 2] + (HEAP32[$0 + 8 >> 2] << 4);
 label$1 : {
  if (FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 8 >> 2]]($0, HEAP32[$6 + 20 >> 2], HEAP32[$6 + 16 >> 2], HEAP32[$6 + 12 >> 2], HEAP32[$6 + 8 >> 2])) {
   HEAP32[$6 + 28 >> 2] = 1;
   break label$1;
  }
  HEAP32[HEAP32[$6 >> 2] + 4 >> 2] = HEAP32[$6 + 4 >> 2];
  HEAP32[$6 + 28 >> 2] = 0;
 }
 global$0 = $6 + 32 | 0;
 return HEAP32[$6 + 28 >> 2];
}
function jswrap_atob_decode($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] & 255;
 label$1 : {
  if (!(HEAP32[$1 + 8 >> 2] < 65 | HEAP32[$1 + 8 >> 2] > 90)) {
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2] - 65;
   break label$1;
  }
  if (!(HEAP32[$1 + 8 >> 2] < 97 | HEAP32[$1 + 8 >> 2] > 122)) {
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2] + -71;
   break label$1;
  }
  if (!(HEAP32[$1 + 8 >> 2] < 48 | HEAP32[$1 + 8 >> 2] > 57)) {
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2] + 4;
   break label$1;
  }
  if (HEAP32[$1 + 8 >> 2] == 43) {
   HEAP32[$1 + 12 >> 2] = 62;
   break label$1;
  }
  if (HEAP32[$1 + 8 >> 2] == 47) {
   HEAP32[$1 + 12 >> 2] = 63;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = -1;
 }
 return HEAP32[$1 + 12 >> 2];
}
function jsvNewArrayBufferWithPtr($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = 0;
 HEAP32[$2 + 16 >> 2] = jsvNewFlatStringOfLength(HEAP32[$2 + 24 >> 2]);
 label$1 : {
  if (!HEAP32[$2 + 16 >> 2]) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jsvNewArrayBufferFromString(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 24 >> 2]);
  if (!HEAP32[$2 + 12 >> 2]) {
   jsvUnLock(HEAP32[$2 + 16 >> 2]);
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  $0 = jsvGetFlatStringPointer(HEAP32[$2 + 16 >> 2]);
  HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = $0;
  jsvUnLock(HEAP32[$2 + 16 >> 2]);
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function tflite__ComputeOutSize_28TfLitePadding_2c_20int_2c_20int_2c_20int_2c_20int_29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 32 | 0;
 HEAP32[$5 + 24 >> 2] = $0;
 HEAP32[$5 + 20 >> 2] = $1;
 HEAP32[$5 + 16 >> 2] = $2;
 HEAP32[$5 + 12 >> 2] = $3;
 HEAP32[$5 + 8 >> 2] = $4;
 HEAP32[$5 + 4 >> 2] = Math_imul(HEAP32[$5 + 8 >> 2], HEAP32[$5 + 16 >> 2] + -1 | 0) + 1;
 $0 = HEAP32[$5 + 24 >> 2] + -1 | 0;
 label$1 : {
  if ($0 >>> 0 <= 1) {
   if ($0 - 1) {
    HEAP32[$5 + 28 >> 2] = ((HEAP32[$5 + 20 >> 2] + HEAP32[$5 + 12 >> 2] | 0) - 1 | 0) / HEAP32[$5 + 12 >> 2];
    break label$1;
   }
   HEAP32[$5 + 28 >> 2] = ((HEAP32[$5 + 20 >> 2] + HEAP32[$5 + 12 >> 2] | 0) - HEAP32[$5 + 4 >> 2] | 0) / HEAP32[$5 + 12 >> 2];
   break label$1;
  }
  HEAP32[$5 + 28 >> 2] = 0;
 }
 return HEAP32[$5 + 28 >> 2];
}
function jswrap_date_toUTCString($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $1 = global$0 - 96 | 0;
 global$0 = $1;
 $2 = $1 + 40 | 0;
 HEAP32[$1 + 92 >> 2] = $0;
 getTimeFromDateVar($1 - -64 | 0, HEAP32[$1 + 92 >> 2], 1);
 getCalendarDate($2, HEAP32[$1 + 64 >> 2]);
 $0 = HEAP32[35429] + (HEAP32[$1 + 56 >> 2] << 2) | 0;
 $2 = HEAP32[$1 + 44 >> 2];
 $3 = HEAP32[35428];
 $4 = HEAP32[$1 + 48 >> 2] << 2;
 $5 = HEAP32[$1 + 52 >> 2];
 $6 = HEAP32[$1 + 80 >> 2];
 $7 = HEAP32[$1 + 76 >> 2];
 HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 72 >> 2];
 HEAP32[$1 + 20 >> 2] = $7;
 HEAP32[$1 + 16 >> 2] = $6;
 HEAP32[$1 + 12 >> 2] = $5;
 HEAP32[$1 + 8 >> 2] = $3 + $4;
 HEAP32[$1 + 4 >> 2] = $2;
 HEAP32[$1 >> 2] = $0;
 $0 = jsvVarPrintf(119849, $1);
 global$0 = $1 + 96 | 0;
 return $0 | 0;
}
function vfGetCharPtr($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 HEAP8[$2 + 27 | 0] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP8[$2 + 19 | 0] = HEAPU8[$2 + 27 | 0];
 label$1 : {
  if (!(HEAPU8[$2 + 19 | 0] <= 255 ? HEAPU8[$2 + 19 | 0] >= 33 : 0)) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP8[$2 + 19 | 0] = HEAPU8[$2 + 19 | 0] - 33;
  HEAP32[$2 + 12 >> 2] = 107840;
  HEAP8[$2 + 11 | 0] = 0;
  while (1) {
   if (HEAPU8[$2 + 11 | 0] < HEAPU8[$2 + 19 | 0]) {
    HEAP32[$2 + 12 >> 2] = HEAPU8[HEAPU8[$2 + 11 | 0] + 108192 | 0] + HEAP32[$2 + 12 >> 2];
    HEAP8[$2 + 11 | 0] = HEAPU8[$2 + 11 | 0] + 1;
    continue;
   }
   break;
  }
  HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = HEAPU8[HEAPU8[$2 + 19 | 0] + 108192 | 0];
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
 }
 return HEAP32[$2 + 28 >> 2];
}
function lcd_flip($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 96 | 0;
 global$0 = $2;
 HEAP32[$2 + 92 >> 2] = $0;
 HEAP8[$2 + 91 | 0] = $1;
 HEAP32[$2 + 84 >> 2] = jsvObjectGetChild(HEAP32[80546], 110016, 0);
 label$1 : {
  if (!HEAP32[$2 + 84 >> 2]) {
   break label$1;
  }
  if (!(graphicsGetFromVar($2 + 8 | 0, HEAP32[$2 + 84 >> 2]) & 1)) {
   jsvUnLock(HEAP32[$2 + 84 >> 2]);
   break label$1;
  }
  if (HEAP8[$2 + 91 | 0] & 1) {
   HEAP8[$2 + 48 | 0] = 0;
   HEAP8[$2 + 49 | 0] = 0;
   HEAP8[$2 + 50 | 0] = 0;
   HEAP8[$2 + 51 | 0] = 0;
   HEAP8[$2 + 52 | 0] = 175;
   HEAP8[$2 + 53 | 0] = 0;
   HEAP8[$2 + 54 | 0] = 175;
   HEAP8[$2 + 55 | 0] = 0;
  }
  $0 = $2 + 8 | 0;
  lcdMemLCD_flip($0);
  graphicsSetVar($0);
  jsvUnLock(HEAP32[$2 + 84 >> 2]);
 }
 global$0 = $2 + 96 | 0;
}
function _jswrap_drawImageLayerSetStart($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 24 >> 2] - HEAP32[HEAP32[$3 + 28 >> 2] >> 2];
 HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 20 >> 2] - HEAP32[HEAP32[$3 + 28 >> 2] + 4 >> 2];
 $0 = HEAP32[$3 + 28 >> 2];
 HEAP32[$0 + 172 >> 2] = HEAP32[$0 + 172 >> 2] + (Math_imul(HEAP32[HEAP32[$3 + 28 >> 2] + 164 >> 2], HEAP32[$3 + 16 >> 2]) + Math_imul(HEAP32[HEAP32[$3 + 28 >> 2] + 168 >> 2], HEAP32[$3 + 12 >> 2]) | 0);
 $0 = HEAP32[$3 + 28 >> 2];
 HEAP32[$0 + 176 >> 2] = HEAP32[$0 + 176 >> 2] + (Math_imul(HEAP32[HEAP32[$3 + 28 >> 2] + 164 >> 2], HEAP32[$3 + 12 >> 2]) - Math_imul(HEAP32[HEAP32[$3 + 28 >> 2] + 168 >> 2], HEAP32[$3 + 16 >> 2]) | 0);
}
function jshFlashWrite($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 label$1 : {
  if (HEAPU32[$3 + 24 >> 2] < 134217728) {
   break label$1;
  }
  HEAP32[$3 + 16 >> 2] = 0;
  while (1) {
   if (HEAPU32[$3 + 16 >> 2] >= HEAPU32[$3 + 20 >> 2]) {
    break label$1;
   }
   HEAP8[$3 + 13 | 0] = 105;
   HEAP8[$3 + 14 | 0] = 105;
   HEAP8[$3 + 15 | 0] = 0;
   $0 = (HEAP32[$3 + 24 >> 2] + HEAP32[$3 + 16 >> 2] | 0) + -134217728 | 0;
   HEAP32[$3 + 4 >> 2] = HEAPU8[HEAP32[$3 + 28 >> 2] + HEAP32[$3 + 16 >> 2] | 0];
   HEAP32[$3 >> 2] = $0;
   emscripten_asm_const_iii(109823, $3 + 13 | 0, $3 | 0) | 0;
   HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 16 >> 2] + 1;
   continue;
  }
 }
 global$0 = $3 + 32 | 0;
}
function tflite__GetOptionalInputTensor_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = 2;
 HEAP8[$2 + 15 | 0] = HEAP32[$2 + 16 >> 2] < HEAP32[HEAP32[HEAP32[$2 + 20 >> 2] >> 2] >> 2] ? HEAP32[(HEAP32[HEAP32[$2 + 20 >> 2] >> 2] + 4 | 0) + (HEAP32[$2 + 16 >> 2] << 2) >> 2] != -1 : 0;
 label$3 : {
  if (HEAP8[$2 + 15 | 0] & 1) {
   HEAP32[$2 + 28 >> 2] = tflite___28anonymous_20namespace_29__GetMutableInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2]);
   break label$3;
  }
  HEAP32[$2 + 28 >> 2] = 0;
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function jswrap_banglejs_setLCDTimeout($0) {
 $0 = +$0;
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAPF64[$1 + 24 >> 3] = $0;
 $2 = __DOUBLE_BITS(HEAPF64[$1 + 24 >> 3]);
 $3 = i64toi32_i32$HIGH_BITS & 2147483647;
 label$1 : {
  if (($3 | 0) == 2146435072 & $2 >>> 0 >= 0 | $3 >>> 0 > 2146435072) {
   HEAPF64[$1 + 24 >> 3] = 0;
   break label$1;
  }
  if (HEAPF64[$1 + 24 >> 3] < 0) {
   HEAPF64[$1 + 24 >> 3] = 0;
  }
 }
 $0 = HEAPF64[$1 + 24 >> 3] * 1e3;
 label$4 : {
  if (Math_abs($0) < 2147483648) {
   $2 = ~~$0;
   break label$4;
  }
  $2 = -2147483648;
 }
 HEAP32[84155] = $2;
 $0 = HEAPF64[$1 + 24 >> 3] * 1e3;
 label$6 : {
  if (Math_abs($0) < 2147483648) {
   $2 = ~~$0;
   break label$6;
  }
  $2 = -2147483648;
 }
 HEAP32[84156] = $2;
 global$0 = $1 + 32 | 0;
}
function jsvNewFromFloat($0) {
 $0 = +$0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAPF64[$1 + 16 >> 3] = $0;
 HEAP32[$1 + 12 >> 2] = jsvNewWithFlags(10);
 label$1 : {
  if (!HEAP32[$1 + 12 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  $2 = HEAP32[$1 + 12 >> 2];
  wasm2js_scratch_store_f64(+HEAPF64[$1 + 16 >> 3]);
  $3 = wasm2js_scratch_load_i32(1) | 0;
  $4 = wasm2js_scratch_load_i32(0) | 0;
  HEAP8[$2 | 0] = $4;
  HEAP8[$2 + 1 | 0] = $4 >>> 8;
  HEAP8[$2 + 2 | 0] = $4 >>> 16;
  HEAP8[$2 + 3 | 0] = $4 >>> 24;
  HEAP8[$2 + 4 | 0] = $3;
  HEAP8[$2 + 5 | 0] = $3 >>> 8;
  HEAP8[$2 + 6 | 0] = $3 >>> 16;
  HEAP8[$2 + 7 | 0] = $3 >>> 24;
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 12 >> 2];
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function jsvNewNativeString($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 if (HEAPU32[$2 + 4 >> 2] > 4294967295) {
  HEAP32[$2 + 4 >> 2] = -1;
 }
 HEAP32[$2 >> 2] = jsvNewWithFlags(39);
 label$2 : {
  if (!HEAP32[$2 >> 2]) {
   HEAP32[$2 + 12 >> 2] = 0;
   break label$2;
  }
  $0 = HEAP32[$2 >> 2];
  $1 = HEAP32[$2 + 8 >> 2];
  HEAP8[$0 | 0] = $1;
  HEAP8[$0 + 1 | 0] = $1 >>> 8;
  HEAP8[$0 + 2 | 0] = $1 >>> 16;
  HEAP8[$0 + 3 | 0] = $1 >>> 24;
  $0 = HEAP32[$2 >> 2];
  $1 = HEAP32[$2 + 4 >> 2];
  HEAP8[$0 + 4 | 0] = $1;
  HEAP8[$0 + 5 | 0] = $1 >>> 8;
  HEAP8[$0 + 6 | 0] = $1 >>> 16;
  HEAP8[$0 + 7 | 0] = $1 >>> 24;
  HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function jswrap_string_fromCharCode($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP32[$1 + 20 >> 2] = jsvNewWithFlags(27);
 label$1 : {
  if (!HEAP32[$1 + 20 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  jsvObjectIteratorNew($1 + 16 | 0, HEAP32[$1 + 24 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue($1 + 16 | 0) & 1) {
    $0 = $1 + 15 | 0;
    $2 = $1 + 16 | 0;
    HEAP8[$1 + 15 | 0] = jsvGetIntegerAndUnLock(jsvObjectIteratorGetValue($2));
    jsvAppendStringBuf(HEAP32[$1 + 20 >> 2], $0, 1);
    jsvObjectIteratorNext($2);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree($1 + 16 | 0);
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function jsvNewFlashString($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 if (HEAPU32[$2 + 4 >> 2] > 4294967295) {
  HEAP32[$2 + 4 >> 2] = -1;
 }
 HEAP32[$2 >> 2] = jsvNewWithFlags(40);
 label$2 : {
  if (!HEAP32[$2 >> 2]) {
   HEAP32[$2 + 12 >> 2] = 0;
   break label$2;
  }
  $0 = HEAP32[$2 >> 2];
  $1 = HEAP32[$2 + 8 >> 2];
  HEAP8[$0 | 0] = $1;
  HEAP8[$0 + 1 | 0] = $1 >>> 8;
  HEAP8[$0 + 2 | 0] = $1 >>> 16;
  HEAP8[$0 + 3 | 0] = $1 >>> 24;
  $0 = HEAP32[$2 >> 2];
  $1 = HEAP32[$2 + 4 >> 2];
  HEAP8[$0 + 4 | 0] = $1;
  HEAP8[$0 + 5 | 0] = $1 >>> 8;
  HEAP8[$0 + 6 | 0] = $1 >>> 16;
  HEAP8[$0 + 7 | 0] = $1 >>> 24;
  HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function jspGetException() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 8 >> 2] = jsvFindChildFromString(HEAP32[80546], 79595, 0);
 label$1 : {
  if (HEAP32[$0 + 8 >> 2]) {
   HEAP32[$0 + 4 >> 2] = jsvSkipName(HEAP32[$0 + 8 >> 2]);
   jsvRemoveChild(HEAP32[80546], HEAP32[$0 + 8 >> 2]);
   jsvUnLock(HEAP32[$0 + 8 >> 2]);
   HEAP32[$0 >> 2] = jspGetStackTrace();
   label$3 : {
    if (!HEAP32[$0 >> 2]) {
     break label$3;
    }
    if (!(jsvHasChildren(HEAP32[$0 + 4 >> 2]) & 1)) {
     break label$3;
    }
    jsvObjectSetChild(HEAP32[$0 + 4 >> 2], 79614, HEAP32[$0 >> 2]);
   }
   jsvUnLock(HEAP32[$0 >> 2]);
   HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 4 >> 2];
   break label$1;
  }
  HEAP32[$0 + 12 >> 2] = 0;
 }
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}
function jspGetBuiltinPrototype($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (jsvIsArray(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 4 >> 2] = jspFindPrototypeFor(80609);
   if (HEAP32[$1 + 4 >> 2]) {
    HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
    break label$1;
   }
  }
  label$4 : {
   if (!(jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1)) {
    if (!(jsvIsArray(HEAP32[$1 + 8 >> 2]) & 1)) {
     break label$4;
    }
   }
   HEAP32[$1 >> 2] = jspFindPrototypeFor(79536);
   if (HEAP32[$1 >> 2] == HEAP32[$1 + 8 >> 2]) {
    jsvUnLock(HEAP32[$1 >> 2]);
    HEAP32[$1 >> 2] = 0;
   }
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jsvIsInstanceOf($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP8[$2 + 19 | 0] = 0;
 label$1 : {
  if (!(jsvHasChildren(HEAP32[$2 + 24 >> 2]) & 1)) {
   HEAP8[$2 + 31 | 0] = 0;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jsvObjectGetChild(HEAP32[$2 + 24 >> 2], 79158, 0);
  if (jsvIsObject(HEAP32[$2 + 12 >> 2]) & 1) {
   HEAP32[$2 + 8 >> 2] = jsvObjectGetChild(HEAP32[$2 + 12 >> 2], 79168, 0);
   if (HEAP32[$2 + 8 >> 2]) {
    HEAP8[$2 + 19 | 0] = jspIsConstructor(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 20 >> 2]) & 1;
   }
   jsvUnLock(HEAP32[$2 + 8 >> 2]);
  }
  jsvUnLock(HEAP32[$2 + 12 >> 2]);
  HEAP8[$2 + 31 | 0] = HEAP8[$2 + 19 | 0] & 1;
 }
 global$0 = $2 + 32 | 0;
 return HEAP8[$2 + 31 | 0] & 1;
}
function jstBufferTaskChecker($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1 : {
  if (!(HEAPU8[HEAP32[$2 + 8 >> 2] + 24 | 0] == 3 | HEAPU8[HEAP32[$2 + 8 >> 2] + 24 | 0] == 4 | (HEAPU8[HEAP32[$2 + 8 >> 2] + 24 | 0] == 5 | HEAPU8[HEAP32[$2 + 8 >> 2] + 24 | 0] == 6))) {
   HEAP8[$2 + 15 | 0] = 0;
   break label$1;
  }
  HEAP16[$2 + 2 >> 1] = HEAPU16[HEAP32[$2 + 4 >> 2] >> 1];
  $0 = $2;
  $1 = HEAP32[$2 + 8 >> 2];
  if (HEAPU16[$2 + 2 >> 1] != (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8)) {
   $1 = HEAP32[$2 + 8 >> 2];
   $1 = HEAPU16[$2 + 2 >> 1] == (HEAPU8[$1 + 14 | 0] | HEAPU8[$1 + 15 | 0] << 8);
  } else {
   $1 = 1;
  }
  HEAP8[$0 + 15 | 0] = $1;
 }
 return HEAP8[$2 + 15 | 0] & 1;
}
function jsvArrayBufferIteratorNext($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 + 48 >> 2] = HEAP32[$0 + 48 >> 2] + 1;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 44 >> 2] + (HEAPU16[HEAP32[$1 + 12 >> 2] + 36 >> 1] & 15);
 label$1 : {
  if (!(HEAP8[HEAP32[$1 + 12 >> 2] + 52 | 0] & 1)) {
   HEAP32[$1 + 8 >> 2] = HEAPU16[HEAP32[$1 + 12 >> 2] + 36 >> 1] & 15;
   while (1) {
    label$4 : {
     $0 = HEAP32[$1 + 8 >> 2];
     HEAP32[$1 + 8 >> 2] = $0 + -1;
     if (!$0) {
      break label$4;
     }
     jsvStringIteratorNext(HEAP32[$1 + 12 >> 2]);
     continue;
    }
    break;
   }
   break label$1;
  }
  HEAP8[HEAP32[$1 + 12 >> 2] + 52 | 0] = 0;
 }
 global$0 = $1 + 16 | 0;
}
function tflite___28anonymous_20namespace_29__AllocationInfoBuilder__Allocate_28_29($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 $0 = HEAP32[$1 + 8 >> 2];
 HEAP32[$1 + 4 >> 2] = Math_imul(tflite___28anonymous_20namespace_29__AllocationInfoBuilder__Size_28_29_20const($0), 24);
 $2 = HEAP32[$0 + 4 >> 2];
 HEAP32[$0 + 16 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$2 >> 2] + 12 >> 2]]($2, HEAP32[$1 + 4 >> 2], 4);
 label$1 : {
  if (!HEAP32[$0 + 16 >> 2]) {
   $0 = HEAP32[$0 >> 2];
   HEAP32[$1 >> 2] = HEAP32[$1 + 4 >> 2];
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 132988, $1);
   HEAP32[$1 + 12 >> 2] = 1;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jswrap_array_join($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1 : {
  if (!(jsvIsIterable(HEAP32[$2 + 8 >> 2]) & 1)) {
   HEAP32[$2 + 12 >> 2] = 0;
   break label$1;
  }
  label$3 : {
   if (jsvIsUndefined(HEAP32[$2 + 4 >> 2]) & 1) {
    HEAP32[$2 + 4 >> 2] = jsvNewFromString(118821);
    break label$3;
   }
   HEAP32[$2 + 4 >> 2] = jsvAsString(HEAP32[$2 + 4 >> 2]);
  }
  if (!HEAP32[$2 + 4 >> 2]) {
   HEAP32[$2 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 >> 2] = jsvArrayJoin(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
  jsvUnLock(HEAP32[$2 + 4 >> 2]);
  HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function jsvSetPrevSibling($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 $1 = $0;
 $3 = (HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8 | (HEAPU8[$1 + 6 | 0] << 16 | HEAPU8[$1 + 7 | 0] << 24)) & 65535;
 $4 = HEAPU8[$1 + 8 | 0] | HEAPU8[$1 + 9 | 0] << 8 | (HEAPU8[$1 + 10 | 0] << 16 | HEAPU8[$1 + 11 | 0] << 24);
 $1 = HEAPU16[$2 + 10 >> 1];
 $2 = $1 >>> 16;
 $1 = $1 << 16 | $3;
 HEAP8[$0 + 12 | 0] = HEAPU8[$0 + 12 | 0];
 HEAP8[$0 + 4 | 0] = $1;
 HEAP8[$0 + 5 | 0] = $1 >>> 8;
 HEAP8[$0 + 6 | 0] = $1 >>> 16;
 HEAP8[$0 + 7 | 0] = $1 >>> 24;
 $1 = $2 | $4;
 HEAP8[$0 + 8 | 0] = $1;
 HEAP8[$0 + 9 | 0] = $1 >>> 8;
 HEAP8[$0 + 10 | 0] = $1 >>> 16;
 HEAP8[$0 + 11 | 0] = $1 >>> 24;
}
function jsvSetLastChild($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $3 = global$0 - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP16[$3 + 10 >> 1] = $1;
 $2 = HEAP32[$3 + 12 >> 2];
 $1 = $2;
 $0 = HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8 | (HEAPU8[$1 + 6 | 0] << 16 | HEAPU8[$1 + 7 | 0] << 24);
 $4 = (HEAPU8[$1 + 8 | 0] | HEAPU8[$1 + 9 | 0] << 8 | (HEAPU8[$1 + 10 | 0] << 16 | HEAPU8[$1 + 11 | 0] << 24)) & 16777215;
 $5 = $0;
 $0 = HEAPU16[$3 + 10 >> 1];
 $1 = $0 << 24;
 $3 = $5 | 0;
 HEAP8[$2 + 12 | 0] = $0 >>> 8;
 HEAP8[$2 + 4 | 0] = $3;
 HEAP8[$2 + 5 | 0] = $3 >>> 8;
 HEAP8[$2 + 6 | 0] = $3 >>> 16;
 HEAP8[$2 + 7 | 0] = $3 >>> 24;
 $1 = $1 | $4;
 HEAP8[$2 + 8 | 0] = $1;
 HEAP8[$2 + 9 | 0] = $1 >>> 8;
 HEAP8[$2 + 10 | 0] = $1 >>> 16;
 HEAP8[$2 + 11 | 0] = $1 >>> 24;
}
function st_backref_index_lsb($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP8[$1 + 7 | 0] = 8;
 $0 = $1;
 $3 = HEAP32[$1 + 8 >> 2];
 if (HEAPU8[$1 + 7 | 0] < 8) {
  $2 = HEAPU8[$1 + 7 | 0];
 } else {
  $2 = 8;
 }
 HEAP16[$0 + 4 >> 1] = get_bits($3, $2);
 label$3 : {
  if (HEAPU16[$1 + 4 >> 1] == 65535) {
   HEAP32[$1 + 12 >> 2] = 3;
   break label$3;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP16[$0 + 6 >> 1] = HEAPU16[$1 + 4 >> 1] | HEAPU16[$0 + 6 >> 1];
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP16[$0 + 6 >> 1] = HEAPU16[$0 + 6 >> 1] + 1;
  HEAP8[$1 + 3 | 0] = 6;
  HEAP16[HEAP32[$1 + 8 >> 2] + 4 >> 1] = 0;
  HEAP32[$1 + 12 >> 2] = HEAPU8[$1 + 3 | 0] > 8 ? 4 : 5;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function tflite__MicroMutableOpResolver_9u___GetOpDataParser_28tflite__BuiltinOperator_29_20const($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 $0 = HEAP32[$2 + 8 >> 2];
 label$1 : {
  if (HEAPU32[$0 + 368 >> 2] > 9) {
   break label$1;
  }
 }
 HEAP32[$2 >> 2] = 0;
 label$2 : {
  while (1) {
   if (HEAPU32[$2 >> 2] < HEAPU32[$0 + 368 >> 2]) {
    if (HEAP32[($0 + 296 | 0) + (HEAP32[$2 >> 2] << 2) >> 2] == HEAP32[$2 + 4 >> 2]) {
     HEAP32[$2 + 12 >> 2] = HEAP32[($0 + 332 | 0) + (HEAP32[$2 >> 2] << 2) >> 2];
     break label$2;
    } else {
     HEAP32[$2 >> 2] = HEAP32[$2 >> 2] + 1;
     continue;
    }
   }
   break;
  }
  HEAP32[$2 + 12 >> 2] = 0;
 }
 return HEAP32[$2 + 12 >> 2];
}
function scalbnf($0, $1) {
 var $2 = 0;
 label$1 : {
  if (($1 | 0) >= 128) {
   $0 = Math_fround($0 * Math_fround(1.7014118346046923e+38));
   $2 = $1 + -127 | 0;
   if (($2 | 0) < 128) {
    $1 = $2;
    break label$1;
   }
   $0 = Math_fround($0 * Math_fround(1.7014118346046923e+38));
   $1 = (($1 | 0) < 381 ? $1 : 381) + -254 | 0;
   break label$1;
  }
  if (($1 | 0) > -127) {
   break label$1;
  }
  $0 = Math_fround($0 * Math_fround(1.1754943508222875e-38));
  $2 = $1 + 126 | 0;
  if (($2 | 0) > -127) {
   $1 = $2;
   break label$1;
  }
  $0 = Math_fround($0 * Math_fround(1.1754943508222875e-38));
  $1 = (($1 | 0) > -378 ? $1 : -378) + 252 | 0;
 }
 return Math_fround($0 * (wasm2js_scratch_store_i32(0, ($1 << 23) + 1065353216 | 0), wasm2js_scratch_load_f32()));
}
function jsiDumpJSON($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 global$0 = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP32[$4 + 12 >> 2] = jsvGetIndexOf(HEAP32[80545], HEAP32[$4 + 20 >> 2], 1);
 label$1 : {
  label$2 : {
   if (!HEAP32[$4 + 12 >> 2]) {
    break label$2;
   }
   if (!(jsvIsString(HEAP32[$4 + 12 >> 2]) & 1) | HEAP32[$4 + 12 >> 2] == HEAP32[$4 + 16 >> 2]) {
    break label$2;
   }
   $0 = HEAP32[$4 + 28 >> 2];
   $1 = HEAP32[$4 + 24 >> 2];
   HEAP32[$4 >> 2] = HEAP32[$4 + 12 >> 2];
   cbprintf($0, $1, 81142, $4);
   break label$1;
  }
  jsfGetJSONWithCallback(HEAP32[$4 + 20 >> 2], 0, 37, 0, HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2]);
 }
 global$0 = $4 + 32 | 0;
}
function jsvArrayBufferIteratorGetIntegerValue($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!HEAPU16[HEAP32[$1 + 8 >> 2] + 36 >> 1]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  jsvArrayBufferIteratorGetValueData(HEAP32[$1 + 8 >> 2], $1);
  if (HEAPU16[HEAP32[$1 + 8 >> 2] + 36 >> 1] & 32) {
   $0 = $1;
   $2 = jsvArrayBufferIteratorDataToFloat(HEAP32[$1 + 8 >> 2], $1);
   label$4 : {
    if (Math_abs($2) < 2147483648) {
     $3 = ~~$2;
     break label$4;
    }
    $3 = -2147483648;
   }
   HEAP32[$0 + 12 >> 2] = $3;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvArrayBufferIteratorDataToInt(HEAP32[$1 + 8 >> 2], $1);
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jsspiSend4bit($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 global$0 = $4;
 HEAP8[$4 + 15 | 0] = $0;
 HEAP8[$4 + 14 | 0] = $1;
 HEAP32[$4 + 8 >> 2] = $2;
 HEAP32[$4 + 4 >> 2] = $3;
 HEAP8[$4 | 0] = HEAP32[$4 + 8 >> 2] | HEAP32[$4 + 8 >> 2] << 4;
 HEAP8[$4 + 1 | 0] = HEAP32[$4 + 4 >> 2] | HEAP32[$4 + 8 >> 2] << 4;
 HEAP8[$4 + 2 | 0] = HEAP32[$4 + 8 >> 2] | HEAP32[$4 + 4 >> 2] << 4;
 HEAP8[$4 + 3 | 0] = HEAP32[$4 + 4 >> 2] | HEAP32[$4 + 4 >> 2] << 4;
 jshUSARTSetup(HEAPU8[$4 + 15 | 0], HEAPU8[(HEAPU8[$4 + 14 | 0] >> 4 & 3) + $4 | 0] | HEAPU8[(HEAPU8[$4 + 14 | 0] >> 6) + $4 | 0] << 8);
 jshUSARTSetup(HEAPU8[$4 + 15 | 0], HEAPU8[(HEAPU8[$4 + 14 | 0] & 3) + $4 | 0] | HEAPU8[(HEAPU8[$4 + 14 | 0] >> 2 & 3) + $4 | 0] << 8);
 global$0 = $4 + 16 | 0;
}
function jsfGetSpaceLeftInPage($0) {
 var $1 = 0;
 $1 = global$0 + -64 | 0;
 global$0 = $1;
 HEAP32[$1 + 56 >> 2] = $0;
 label$1 : {
  if (!(jshFlashGetPage(HEAP32[$1 + 56 >> 2], $1 + 52 | 0, $1 + 48 | 0) & 1)) {
   HEAP32[$1 + 60 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 44 >> 2] = jsfGetBankEndAddress(HEAP32[$1 + 56 >> 2]);
  HEAP32[$1 + 40 >> 2] = HEAP32[$1 + 52 >> 2] + HEAP32[$1 + 48 >> 2];
  label$3 : {
   if (HEAPU32[$1 + 40 >> 2] >= HEAPU32[$1 + 44 >> 2]) {
    break label$3;
   }
   if (jsfGetFileHeader(HEAP32[$1 + 40 >> 2], $1 + 8 | 0, 0) & 1) {
    break label$3;
   }
   HEAP32[$1 + 40 >> 2] = HEAP32[$1 + 44 >> 2];
  }
  HEAP32[$1 + 60 >> 2] = HEAP32[$1 + 40 >> 2] - HEAP32[$1 + 56 >> 2];
 }
 global$0 = $1 - -64 | 0;
 return HEAP32[$1 + 60 >> 2];
}
function tflite__PreprocessSoftmaxScaling_28double_2c_20double_2c_20int_2c_20int__2c_20int__29($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 + -64 | 0;
 global$0 = $4;
 HEAPF64[$4 + 56 >> 3] = $0;
 HEAPF64[$4 + 48 >> 3] = $1;
 HEAP32[$4 + 44 >> 2] = 5;
 HEAP32[$4 + 40 >> 2] = $2;
 HEAP32[$4 + 36 >> 2] = $3;
 HEAPF64[$4 + 16 >> 3] = HEAPF64[$4 + 56 >> 3] * HEAPF64[$4 + 48 >> 3] * +(1 << 31 - HEAP32[$4 + 44 >> 2]);
 HEAPF64[$4 + 8 >> 3] = 2147483647;
 HEAPF64[$4 + 24 >> 3] = HEAPF64[double_20const__20std____2__min_double__28double_20const__2c_20double_20const__29($4 + 16 | 0, $4 + 8 | 0) >> 3];
 tflite__QuantizeMultiplierGreaterThanOne_28double_2c_20int__2c_20int__29(HEAPF64[$4 + 24 >> 3], HEAP32[$4 + 40 >> 2], HEAP32[$4 + 36 >> 2]);
 global$0 = $4 - -64 | 0;
}
function jswrap_modules_removeCached($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1 : {
  if (!(jsvIsString(HEAP32[$1 + 12 >> 2]) & 1)) {
   jsExceptionHere(1, 123017, 0);
   break label$1;
  }
  HEAP32[$1 + 8 >> 2] = jswrap_modules_getModuleList();
  if (!HEAP32[$1 + 8 >> 2]) {
   break label$1;
  }
  HEAP32[$1 + 4 >> 2] = jsvFindChildFromVar(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2], 0);
  label$3 : {
   if (!HEAP32[$1 + 4 >> 2]) {
    HEAP32[$1 >> 2] = HEAP32[$1 + 12 >> 2];
    jsExceptionHere(1, 123063, $1);
    break label$3;
   }
   jsvRemoveChild(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 4 >> 2]);
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
  }
  jsvUnLock(HEAP32[$1 + 8 >> 2]);
 }
 global$0 = $1 + 16 | 0;
}
function jslNeedSpaceBetween($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
 label$1 : {
  if (HEAPU8[$2 + 15 | 0] < 163) {
   $0 = 0;
   if (HEAPU8[$2 + 14 | 0] < 163) {
    break label$1;
   }
  }
  label$3 : {
   if (HEAPU8[$2 + 15 | 0] >= 163) {
    break label$3;
   }
   if (isAlpha(HEAP8[$2 + 15 | 0]) & 1) {
    break label$3;
   }
   $1 = !(isNumeric(HEAP8[$2 + 15 | 0]) & 1);
   $0 = 0;
   if ($1) {
    break label$1;
   }
  }
  $0 = 1;
  label$4 : {
   if (HEAPU8[$2 + 14 | 0] >= 163) {
    break label$4;
   }
   $1 = isAlpha(HEAP8[$2 + 14 | 0]) & 1;
   $0 = 1;
   if ($1) {
    break label$4;
   }
   $0 = isNumeric(HEAP8[$2 + 14 | 0]);
  }
 }
 global$0 = $2 + 16 | 0;
 return $0 & 1;
}
function jslGetTokenString($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 HEAP32[$1 + 24 >> 2] = 30;
 label$1 : {
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 128) {
   $0 = HEAP32[$1 + 28 >> 2];
   $2 = HEAP32[$1 + 24 >> 2];
   HEAP32[$1 >> 2] = jslGetTokenValueAsString();
   espruino_snprintf($0, $2, 77900, $1);
   break label$1;
  }
  label$3 : {
   if (HEAP16[HEAP32[35539] + 2 >> 1] == 131) {
    $0 = HEAP32[$1 + 28 >> 2];
    $2 = HEAP32[$1 + 24 >> 2];
    HEAP32[$1 + 16 >> 2] = jslGetTokenValueAsString();
    espruino_snprintf($0, $2, 77906, $1 + 16 | 0);
    break label$3;
   }
   jslTokenAsString(HEAP16[HEAP32[35539] + 2 >> 1], HEAP32[$1 + 28 >> 2], HEAP32[$1 + 24 >> 2]);
  }
 }
 global$0 = $1 + 32 | 0;
}
function lcdFillRect_ArrayBuffer_flat($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0;
 $6 = global$0 - 32 | 0;
 global$0 = $6;
 HEAP32[$6 + 28 >> 2] = $0;
 HEAP32[$6 + 24 >> 2] = $1;
 HEAP32[$6 + 20 >> 2] = $2;
 HEAP32[$6 + 16 >> 2] = $3;
 HEAP32[$6 + 12 >> 2] = $4;
 HEAP32[$6 + 8 >> 2] = $5;
 HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 20 >> 2];
 while (1) {
  if (HEAP32[$6 + 4 >> 2] <= HEAP32[$6 + 12 >> 2]) {
   lcdSetPixels_ArrayBuffer_flat(HEAP32[$6 + 28 >> 2], HEAP32[$6 + 24 >> 2], HEAP32[$6 + 4 >> 2], (HEAP32[$6 + 16 >> 2] + 1 | 0) - HEAP32[$6 + 24 >> 2] | 0, HEAP32[$6 + 8 >> 2]);
   HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 4 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $6 + 32 | 0;
}
function jswrap_storage_read($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 80 | 0;
 global$0 = $3;
 HEAP32[$3 + 76 >> 2] = $0;
 HEAP32[$3 + 72 >> 2] = $1;
 HEAP32[$3 + 68 >> 2] = $2;
 jsfNameFromVar($3 + 40 | 0, HEAP32[$3 + 76 >> 2]);
 $0 = HEAP32[$3 + 72 >> 2];
 $1 = HEAP32[$3 + 68 >> 2];
 HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 64 >> 2];
 $2 = HEAP32[$3 + 60 >> 2];
 HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 56 >> 2];
 HEAP32[$3 + 28 >> 2] = $2;
 $2 = HEAP32[$3 + 52 >> 2];
 HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 48 >> 2];
 HEAP32[$3 + 20 >> 2] = $2;
 $2 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 40 >> 2];
 HEAP32[$3 + 12 >> 2] = $2;
 $0 = jsfReadFile($3 + 8 | 0, $0, $1);
 global$0 = $3 + 80 | 0;
 return $0 | 0;
}
function tflite__MultiplyByQuantizedMultiplier_28int_2c_20int_2c_20int_29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 $0 = $3;
 if (HEAP32[$3 + 20 >> 2] > 0) {
  $1 = HEAP32[$3 + 20 >> 2];
 } else {
  $1 = 0;
 }
 HEAP32[$0 + 16 >> 2] = $1;
 $0 = $3;
 if (HEAP32[$3 + 20 >> 2] > 0) {
  $1 = 0;
 } else {
  $1 = 0 - HEAP32[$3 + 20 >> 2] | 0;
 }
 HEAP32[$0 + 12 >> 2] = $1;
 $0 = int_20gemmlowp__RoundingDivideByPOT_int__28int_2c_20int_29(int_20gemmlowp__SaturatingRoundingDoublingHighMul_int__28int_2c_20int_29(Math_imul(HEAP32[$3 + 28 >> 2], 1 << HEAP32[$3 + 16 >> 2]), HEAP32[$3 + 24 >> 2]), HEAP32[$3 + 12 >> 2]);
 global$0 = $3 + 32 | 0;
 return $0;
}
function jsvGetArrayBufferBackingString($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jsvLockAgain(HEAP32[$2 + 12 >> 2]);
 if (HEAP32[$2 + 8 >> 2]) {
  HEAP32[HEAP32[$2 + 8 >> 2] >> 2] = 0;
 }
 while (1) {
  if (jsvIsArrayBuffer(HEAP32[$2 + 12 >> 2]) & 1) {
   if (HEAP32[$2 + 8 >> 2]) {
    $0 = HEAP32[$2 + 8 >> 2];
    $1 = HEAP32[$2 + 12 >> 2];
    HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + (HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8);
   }
   HEAP32[$2 + 4 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$2 + 12 >> 2]) & 65535);
   jsvUnLock(HEAP32[$2 + 12 >> 2]);
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 4 >> 2];
   continue;
  }
  break;
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function jswrap_string_charAt($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 + -64 | 0;
 global$0 = $2;
 HEAP32[$2 + 60 >> 2] = $0;
 HEAP32[$2 + 56 >> 2] = $1;
 HEAP32[$2 + 52 >> 2] = jsvNewWithFlags(27);
 label$1 : {
  if (!HEAP32[$2 + 52 >> 2]) {
   break label$1;
  }
  if (!(jsvIsString(HEAP32[$2 + 60 >> 2]) & 1) | HEAP32[$2 + 56 >> 2] < 0) {
   break label$1;
  }
  $0 = $2 + 16 | 0;
  jsvStringIteratorNew($0, HEAP32[$2 + 60 >> 2], HEAP32[$2 + 56 >> 2]);
  if (jsvStringIteratorHasChar($0) & 1) {
   $0 = $2 + 15 | 0;
   HEAP8[$2 + 15 | 0] = jsvStringIteratorGetChar($2 + 16 | 0);
   jsvAppendStringBuf(HEAP32[$2 + 52 >> 2], $0, 1);
  }
  jsvStringIteratorFree($2 + 16 | 0);
 }
 global$0 = $2 - -64 | 0;
 return HEAP32[$2 + 52 >> 2];
}
function terminalScroll() {
 var $0 = 0, $1 = 0, $2 = 0;
 $0 = global$0 - 80 | 0;
 global$0 = $0;
 HEAP8[141724] = HEAPU8[141724] + -1;
 if (terminalGetGFX($0 + 8 | 0) & 1) {
  HEAP32[$0 + 4 >> 2] = HEAPU8[$0 + 29 | 0] | HEAPU8[$0 + 30 | 0] << 8 | (HEAPU8[$0 + 31 | 0] << 16 | HEAPU8[$0 + 32 | 0] << 24);
  $1 = HEAPU8[324594] | HEAPU8[324595] << 8;
  HEAP8[$0 + 29 | 0] = $1;
  HEAP8[$0 + 30 | 0] = $1 >>> 8;
  HEAP8[$0 + 31 | 0] = $1 >>> 16;
  HEAP8[$0 + 32 | 0] = $1 >>> 24;
  $2 = $0 + 8 | 0;
  graphicsScroll($2, 0, -8);
  $1 = HEAP32[$0 + 4 >> 2];
  HEAP8[$0 + 29 | 0] = $1;
  HEAP8[$0 + 30 | 0] = $1 >>> 8;
  HEAP8[$0 + 31 | 0] = $1 >>> 16;
  HEAP8[$0 + 32 | 0] = $1 >>> 24;
  terminalSetGFX($2);
  jswrap_terminal_idle();
 }
 global$0 = $0 + 80 | 0;
}
function tflite__MicroAllocator__GetSubGraphFromModel_28tflite__Model_20const__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 $0 = HEAP32[$2 + 8 >> 2];
 HEAP32[$2 >> 2] = tflite__Model__subgraphs_28_29_20const(HEAP32[$2 + 4 >> 2]);
 label$1 : {
  if ((flatbuffers__Vector_int___size_28_29_20const(HEAP32[$2 >> 2]) | 0) != 1) {
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$0 + 8 >> 2], 132680, 0);
   HEAP32[$2 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph__20___operator_5b_5d_28unsigned_20int_29_20const(HEAP32[$2 >> 2], 0);
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function jsvGetStringIndexOf($0, $1) {
 var $2 = 0;
 $2 = global$0 + -64 | 0;
 global$0 = $2;
 HEAP32[$2 + 56 >> 2] = $0;
 HEAP8[$2 + 55 | 0] = $1;
 jsvStringIteratorNew($2 + 16 | 0, HEAP32[$2 + 56 >> 2], 0);
 label$1 : {
  while (1) {
   if (jsvStringIteratorHasChar($2 + 16 | 0) & 1) {
    if ((jsvStringIteratorGetChar($2 + 16 | 0) & 255) == HEAPU8[$2 + 55 | 0]) {
     $0 = $2 + 16 | 0;
     HEAP32[$2 + 12 >> 2] = jsvStringIteratorGetIndex($0);
     jsvStringIteratorFree($0);
     HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 12 >> 2];
     break label$1;
    }
    jsvStringIteratorNext($2 + 16 | 0);
    continue;
   }
   break;
  }
  jsvStringIteratorFree($2 + 16 | 0);
  HEAP32[$2 + 60 >> 2] = -1;
 }
 global$0 = $2 - -64 | 0;
 return HEAP32[$2 + 60 >> 2];
}
function OneWireRead($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jshPinSetState(HEAPU8[$2 + 15 | 0], 3);
 HEAP32[$2 + 4 >> 2] = 0;
 HEAP32[$2 >> 2] = 1;
 while (1) {
  label$2 : {
   $0 = HEAP32[$2 + 8 >> 2];
   HEAP32[$2 + 8 >> 2] = $0 + -1;
   if (($0 | 0) <= 0) {
    break label$2;
   }
   jshPinSetValue(HEAPU8[$2 + 15 | 0], 0);
   do_indexing(3);
   jshPinSetValue(HEAPU8[$2 + 15 | 0], 1);
   do_indexing(10);
   if (jshPinGetValue(HEAPU8[$2 + 15 | 0]) & 1) {
    HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] | HEAP32[$2 >> 2];
   }
   do_indexing(53);
   HEAP32[$2 >> 2] = HEAP32[$2 >> 2] << 1;
   continue;
  }
  break;
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 4 >> 2];
}
function jsvNewArrayBufferFromString($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 HEAP32[$2 >> 2] = jsvNewWithFlags(4);
 label$1 : {
  if (!HEAP32[$2 >> 2]) {
   HEAP32[$2 + 12 >> 2] = 0;
   break label$1;
  }
  jsvSetFirstChild(HEAP32[$2 >> 2], jsvGetRef(jsvRef(HEAP32[$2 + 8 >> 2])) & 65535);
  $0 = HEAP32[$2 >> 2];
  HEAP8[$0 + 4 | 0] = 129;
  HEAP8[$0 + 5 | 0] = 0;
  if (!HEAP32[$2 + 4 >> 2]) {
   HEAP32[$2 + 4 >> 2] = jsvGetStringLength(HEAP32[$2 + 8 >> 2]);
  }
  $0 = HEAP32[$2 >> 2];
  $1 = HEAP32[$2 + 4 >> 2];
  HEAP8[$0 + 2 | 0] = $1;
  HEAP8[$0 + 3 | 0] = $1 >>> 8;
  HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function jswrap_date_toISOString($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $1 = global$0 - 96 | 0;
 global$0 = $1;
 $2 = $1 + 40 | 0;
 HEAP32[$1 + 92 >> 2] = $0;
 getTimeFromDateVar($1 - -64 | 0, HEAP32[$1 + 92 >> 2], 1);
 getCalendarDate($2, HEAP32[$1 + 64 >> 2]);
 $0 = HEAP32[$1 + 52 >> 2];
 $2 = HEAP32[$1 + 48 >> 2] + 1 | 0;
 $3 = HEAP32[$1 + 44 >> 2];
 $4 = HEAP32[$1 + 80 >> 2];
 $5 = HEAP32[$1 + 76 >> 2];
 $6 = HEAP32[$1 + 72 >> 2];
 HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 68 >> 2];
 HEAP32[$1 + 20 >> 2] = $6;
 HEAP32[$1 + 16 >> 2] = $5;
 HEAP32[$1 + 12 >> 2] = $4;
 HEAP32[$1 + 8 >> 2] = $3;
 HEAP32[$1 + 4 >> 2] = $2;
 HEAP32[$1 >> 2] = $0;
 $0 = jsvVarPrintf(119881, $1);
 global$0 = $1 + 96 | 0;
 return $0 | 0;
}
function tflite___28anonymous_20namespace_29__GetMutableInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 8 >> 2] = $0;
 HEAP32[$3 + 4 >> 2] = $1;
 HEAP32[$3 >> 2] = $2;
 label$1 : {
  if (HEAP32[HEAP32[$3 + 8 >> 2] + 8 >> 2]) {
   HEAP32[$3 + 12 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 8 >> 2] + Math_imul(HEAP32[(HEAP32[HEAP32[$3 + 4 >> 2] >> 2] + 4 | 0) + (HEAP32[$3 >> 2] << 2) >> 2], 40);
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$3 + 8 >> 2] + 80 >> 2]](HEAP32[$3 + 8 >> 2], HEAP32[(HEAP32[HEAP32[$3 + 4 >> 2] >> 2] + 4 | 0) + (HEAP32[$3 >> 2] << 2) >> 2]);
 }
 global$0 = $3 + 16 | 0;
 return HEAP32[$3 + 12 >> 2];
}
function lcdFillRect_ArrayBuffer($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0;
 $6 = global$0 - 32 | 0;
 global$0 = $6;
 HEAP32[$6 + 28 >> 2] = $0;
 HEAP32[$6 + 24 >> 2] = $1;
 HEAP32[$6 + 20 >> 2] = $2;
 HEAP32[$6 + 16 >> 2] = $3;
 HEAP32[$6 + 12 >> 2] = $4;
 HEAP32[$6 + 8 >> 2] = $5;
 HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 20 >> 2];
 while (1) {
  if (HEAP32[$6 + 4 >> 2] <= HEAP32[$6 + 12 >> 2]) {
   lcdSetPixels_ArrayBuffer(HEAP32[$6 + 28 >> 2], HEAP32[$6 + 24 >> 2], HEAP32[$6 + 4 >> 2], (HEAP32[$6 + 16 >> 2] + 1 | 0) - HEAP32[$6 + 24 >> 2] | 0, HEAP32[$6 + 8 >> 2]);
   HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 4 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $6 + 32 | 0;
}
function jsvObjectAppendAll($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 jsvObjectIteratorNew($2 + 16 | 0, HEAP32[$2 + 24 >> 2]);
 while (1) {
  if (jsvObjectIteratorHasValue($2 + 16 | 0) & 1) {
   HEAP32[$2 + 12 >> 2] = jsvObjectIteratorGetKey($2 + 16 | 0);
   HEAP32[$2 + 8 >> 2] = jsvSkipName(HEAP32[$2 + 12 >> 2]);
   if (!(jsvIsInternalObjectKey(HEAP32[$2 + 12 >> 2]) & 1)) {
    jsvObjectSetChildVar(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
   }
   $0 = $2 + 16 | 0;
   jsvUnLock2(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
   jsvObjectIteratorNext($0);
   continue;
  }
  break;
 }
 jsvObjectIteratorFree($2 + 16 | 0);
 global$0 = $2 + 32 | 0;
}
function jshGetDeviceObjectFor($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP16[$3 + 42 >> 1] = $0;
 HEAP16[$3 + 40 >> 1] = $1;
 HEAP8[$3 + 39 | 0] = $2;
 HEAP16[$3 + 36 >> 1] = jshGetDeviceFor(HEAPU16[$3 + 42 >> 1], HEAPU16[$3 + 40 >> 1], HEAPU8[$3 + 39 | 0]);
 label$1 : {
  if (!HEAPU16[$3 + 36 >> 1]) {
   HEAP32[$3 + 44 >> 2] = 0;
   break label$1;
  }
  $0 = $3 + 16 | 0;
  jshPinFunctionToString(HEAPU16[$3 + 36 >> 1], 19, $0);
  HEAP32[$3 + 12 >> 2] = jsvObjectGetChild(HEAP32[80545], $0, 0);
  if (HEAP32[$3 + 12 >> 2]) {
   HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 12 >> 2];
   break label$1;
  }
  HEAP32[$3 + 44 >> 2] = jswFindBuiltInFunction(0, $3 + 16 | 0);
 }
 global$0 = $3 + 48 | 0;
 return HEAP32[$3 + 44 >> 2];
}
function tflite__ComputePaddingWithOffset_28int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int__29($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = global$0 - 32 | 0;
 HEAP32[$6 + 28 >> 2] = $0;
 HEAP32[$6 + 24 >> 2] = $1;
 HEAP32[$6 + 20 >> 2] = $2;
 HEAP32[$6 + 16 >> 2] = $3;
 HEAP32[$6 + 12 >> 2] = $4;
 HEAP32[$6 + 8 >> 2] = $5;
 HEAP32[$6 + 4 >> 2] = Math_imul(HEAP32[$6 + 24 >> 2], HEAP32[$6 + 16 >> 2] - 1 | 0) + 1;
 HEAP32[$6 >> 2] = (HEAP32[$6 + 4 >> 2] + Math_imul(HEAP32[$6 + 28 >> 2], HEAP32[$6 + 12 >> 2] - 1 | 0) | 0) - HEAP32[$6 + 20 >> 2];
 $0 = $6;
 if (HEAP32[$6 >> 2] > 0) {
  $1 = HEAP32[$6 >> 2];
 } else {
  $1 = 0;
 }
 HEAP32[$0 >> 2] = $1;
 HEAP32[HEAP32[$6 + 8 >> 2] >> 2] = HEAP32[$6 >> 2] % 2;
 return HEAP32[$6 >> 2] / 2 | 0;
}
function jswrap_banglejs_lcdWr($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $3 = global$0 - 16 | 0;
 $2 = $3;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = 0;
 HEAP32[$2 >> 2] = jsvGetDataPointer(HEAP32[$2 + 8 >> 2], $2 + 4 | 0);
 if (!(HEAP32[$2 >> 2] | !HEAP32[$2 + 8 >> 2])) {
  HEAP32[$2 + 4 >> 2] = jsvIterateCallbackCount(HEAP32[$2 + 8 >> 2]);
  label$2 : {
   if (HEAP32[$2 + 4 >> 2] + 256 >>> 0 > 1e6) {
    jsExceptionHere(1, 110391, 0);
    break label$2;
   }
   $0 = $3 - (HEAP32[$2 + 4 >> 2] + 15 & -16) | 0;
   global$0 = $0;
   HEAP32[$2 >> 2] = $0;
   jsvIterateCallbackToBytes(HEAP32[$2 + 8 >> 2], HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]);
  }
 }
 global$0 = $2 + 16 | 0;
}
function jswrap_pipe_idle() {
 var $0 = 0, $1 = 0;
 $0 = global$0 - 32 | 0;
 global$0 = $0;
 HEAP8[$0 + 31 | 0] = 0;
 HEAP32[$0 + 24 >> 2] = pipeGetArray(0);
 if (HEAP32[$0 + 24 >> 2]) {
  jsvObjectIteratorNew($0 + 16 | 0, HEAP32[$0 + 24 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue($0 + 16 | 0) & 1) {
    $1 = $0 + 16 | 0;
    HEAP32[$0 + 12 >> 2] = jsvObjectIteratorGetValue($1);
    HEAP8[$0 + 31 | 0] = (handlePipe(HEAP32[$0 + 24 >> 2], $1, HEAP32[$0 + 12 >> 2]) & 1 | HEAP8[$0 + 31 | 0] & 1) != 0;
    jsvUnLock(HEAP32[$0 + 12 >> 2]);
    jsvObjectIteratorNext($1);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree($0 + 16 | 0);
  jsvUnLock(HEAP32[$0 + 24 >> 2]);
 }
 global$0 = $0 + 32 | 0;
 return HEAP8[$0 + 31 | 0] & 1;
}
function jspEvaluate($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP8[$1 + 23 | 0] = 1;
 label$1 : {
  if (HEAP8[$1 + 23 | 0] & 1) {
   HEAP32[$1 + 16 >> 2] = jsvNewNativeString(HEAP32[$1 + 24 >> 2], strlen(HEAP32[$1 + 24 >> 2]));
   break label$1;
  }
  HEAP32[$1 + 16 >> 2] = jsvNewFromString(HEAP32[$1 + 24 >> 2]);
 }
 label$3 : {
  if (!HEAP32[$1 + 16 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$3;
  }
  HEAP32[$1 + 12 >> 2] = 0;
  if (!((HEAPU16[71084] != 0 ^ -1) & 1)) {
   HEAP32[$1 + 12 >> 2] = jspEvaluateVar(HEAP32[$1 + 16 >> 2], 0, 0);
  }
  jsvUnLock(HEAP32[$1 + 16 >> 2]);
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 12 >> 2];
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function tflite___28anonymous_20namespace_29__ConvertActivation_28tflite__ActivationFunctionType_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 $0 = HEAP32[$1 + 8 >> 2];
 label$1 : {
  if ($0 >>> 0 <= 5) {
   label$3 : {
    switch ($0 - 1 | 0) {
    default:
     HEAP32[$1 + 12 >> 2] = 0;
     break label$1;
    case 0:
     HEAP32[$1 + 12 >> 2] = 1;
     break label$1;
    case 1:
     HEAP32[$1 + 12 >> 2] = 2;
     break label$1;
    case 2:
     HEAP32[$1 + 12 >> 2] = 3;
     break label$1;
    case 3:
     HEAP32[$1 + 12 >> 2] = 4;
     break label$1;
    case 4:
     break label$3;
    }
   }
   HEAP32[$1 + 12 >> 2] = 5;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 return HEAP32[$1 + 12 >> 2];
}
function jswrap_graphics_getFonts($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 96 | 0;
 global$0 = $1;
 HEAP32[$1 + 88 >> 2] = $0;
 label$1 : {
  if (!(graphicsGetFromVar($1 + 16 | 0, HEAP32[$1 + 88 >> 2]) & 1)) {
   HEAP32[$1 + 92 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvNewWithFlags(3);
  if (!HEAP32[$1 + 12 >> 2]) {
   HEAP32[$1 + 92 >> 2] = 0;
   break label$1;
  }
  jsvArrayPushAndUnLock(HEAP32[$1 + 12 >> 2], jsvNewFromString(127704));
  jsvArrayPushAndUnLock(HEAP32[$1 + 12 >> 2], jsvNewFromString(127708));
  jswrap_object_keys_or_property_names_cb(HEAP32[$1 + 88 >> 2], 1, 1, 595, HEAP32[$1 + 12 >> 2]);
  HEAP32[$1 + 92 >> 2] = HEAP32[$1 + 12 >> 2];
 }
 global$0 = $1 + 96 | 0;
 return HEAP32[$1 + 92 >> 2];
}
function tflite__MicroAllocator__GetScratchBuffer_28int_29_20const($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 $0 = HEAP32[$2 + 24 >> 2];
 label$1 : {
  if (HEAPU32[$2 + 20 >> 2] >= HEAPU32[$0 + 20 >> 2]) {
   $1 = HEAP32[$0 + 8 >> 2];
   $3 = HEAP32[$2 + 20 >> 2];
   HEAP32[$2 + 4 >> 2] = HEAP32[$0 + 20 >> 2];
   HEAP32[$2 >> 2] = $3;
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($1, 132074, $2);
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 28 >> 2] = HEAP32[HEAP32[$0 + 16 >> 2] + Math_imul((HEAP32[$0 + 20 >> 2] - HEAP32[$2 + 20 >> 2] | 0) - 1 | 0, 12) >> 2];
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function jshResetDevices() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[80550] = 0;
 HEAP32[80551] = 0;
 HEAP32[80552] = 0;
 HEAP32[80553] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
 while (1) {
  if (!(!HEAP32[$0 + 12 >> 2] | HEAPU32[$0 + 12 >> 2] >= 2)) {
   HEAP8[HEAP32[$0 + 12 >> 2] + 322308 | 0] = 0;
   HEAP8[HEAP32[$0 + 12 >> 2] + 322310 | 0] = 255;
   HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[$0 + 12 >> 2] = 1;
 while (1) {
  if (HEAPU32[$0 + 12 >> 2] <= 16) {
   HEAP32[(HEAP32[$0 + 12 >> 2] << 2) + 322316 >> 2] = 0;
   HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 jshSetPinStateIsManual(17, 1);
 jshPinSetState(17, 6);
 global$0 = $0 + 16 | 0;
}
function jshFlashRead($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 label$1 : {
  if (HEAPU32[$3 + 24 >> 2] < 134217728) {
   break label$1;
  }
  HEAP32[$3 + 16 >> 2] = 0;
  while (1) {
   if (HEAPU32[$3 + 16 >> 2] >= HEAPU32[$3 + 20 >> 2]) {
    break label$1;
   }
   HEAP8[$3 + 14 | 0] = 105;
   HEAP8[$3 + 15 | 0] = 0;
   HEAP32[$3 >> 2] = (HEAP32[$3 + 24 >> 2] + HEAP32[$3 + 16 >> 2] | 0) + -134217728;
   $0 = emscripten_asm_const_iii(109796, $3 + 14 | 0, $3 | 0) | 0;
   HEAP8[HEAP32[$3 + 28 >> 2] + HEAP32[$3 + 16 >> 2] | 0] = $0;
   HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 16 >> 2] + 1;
   continue;
  }
 }
 global$0 = $3 + 32 | 0;
}
function _jswrap_serial_print($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 global$0 = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP8[$4 + 23 | 0] = $2;
 HEAP8[$4 + 22 | 0] = $3;
 label$1 : {
  if (!(jsserialGetSendFunction(HEAP32[$4 + 28 >> 2], $4 + 16 | 0, $4) & 1)) {
   break label$1;
  }
  if (HEAP8[$4 + 23 | 0] & 1) {
   HEAP32[$4 + 24 >> 2] = jsvAsString(HEAP32[$4 + 24 >> 2]);
  }
  jsvIterateCallback(HEAP32[$4 + 24 >> 2], HEAP32[$4 + 16 >> 2], $4);
  if (HEAP8[$4 + 23 | 0] & 1) {
   jsvUnLock(HEAP32[$4 + 24 >> 2]);
  }
  if (!(HEAP8[$4 + 22 | 0] & 1)) {
   break label$1;
  }
  FUNCTION_TABLE[HEAP32[$4 + 16 >> 2]](13, $4);
  FUNCTION_TABLE[HEAP32[$4 + 16 >> 2]](10, $4);
 }
 global$0 = $4 + 32 | 0;
}
function jsvCreateNewChild($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 HEAP32[$3 + 12 >> 2] = jsvAsName(HEAP32[$3 + 20 >> 2]);
 label$1 : {
  if (!HEAP32[$3 + 12 >> 2]) {
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$3 + 16 >> 2]) {
   jsvSetValueOfName(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 16 >> 2]);
  }
  HEAP16[$3 + 10 >> 1] = jsvGetRef(jsvRef(jsvRef(HEAP32[$3 + 24 >> 2])));
  jsvSetNextSibling(HEAP32[$3 + 12 >> 2], HEAPU16[$3 + 10 >> 1]);
  jsvSetPrevSibling(HEAP32[$3 + 12 >> 2], HEAPU16[$3 + 10 >> 1]);
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2];
 }
 global$0 = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}
function jsfGetFlags() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 8 >> 2] = jsvNewWithFlags(5);
 label$1 : {
  if (!HEAP32[$0 + 8 >> 2]) {
   HEAP32[$0 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$0 + 4 >> 2] = HEAP32[35414];
  HEAP8[$0 + 3 | 0] = 1;
  while (1) {
   if (HEAPU8[HEAP32[$0 + 4 >> 2]]) {
    jsvObjectSetChildAndUnLock(HEAP32[$0 + 8 >> 2], HEAP32[$0 + 4 >> 2], jsvNewFromInteger(jsfGetFlag(HEAPU8[$0 + 3 | 0]) & 1 ? 1 : 0));
    HEAP32[$0 + 4 >> 2] = (strlen(HEAP32[$0 + 4 >> 2]) + 1 | 0) + HEAP32[$0 + 4 >> 2];
    HEAP8[$0 + 3 | 0] = HEAPU8[$0 + 3 | 0] << 1;
    continue;
   }
   break;
  }
  HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 8 >> 2];
 }
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}
function lcdMemLCD_getPixel($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 HEAP32[$3 + 16 >> 2] = (Math_imul(HEAP32[$3 + 24 >> 2], 3) + 16 | 0) + (Math_imul(HEAP32[$3 + 20 >> 2], 68) << 3);
 HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 16 >> 2] & 7;
 $0 = HEAP32[$3 + 16 >> 2] >> 3;
 $0 = HEAPU8[$0 + 324608 | 0] | HEAPU8[$0 + 324609 | 0] << 8;
 HEAP16[$3 + 10 >> 1] = ($0 << 24 | $0 << 8 & 16711680) >>> 16;
 HEAP32[$3 + 4 >> 2] = (HEAPU16[$3 + 10 >> 1] << HEAP32[$3 + 12 >> 2] & 57344) >> 13;
 return (HEAP32[$3 + 4 >> 2] & 4 ? 63488 : 0) | (HEAP32[$3 + 4 >> 2] & 2 ? 2016 : 0) | (HEAP32[$3 + 4 >> 2] & 1 ? 31 : 0);
}
function jsiHistoryAddLine($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1 : {
  if (!HEAP32[$1 + 12 >> 2]) {
   break label$1;
  }
  HEAP32[$1 + 8 >> 2] = jsvGetStringLength(HEAP32[$1 + 12 >> 2]);
  if (!HEAP32[$1 + 8 >> 2] | HEAPU32[$1 + 8 >> 2] > 500) {
   break label$1;
  }
  HEAP32[$1 + 4 >> 2] = jsiGetHistory();
  if (!HEAP32[$1 + 4 >> 2]) {
   break label$1;
  }
  HEAP32[$1 >> 2] = jsvGetIndexOf(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 12 >> 2], 0);
  if (HEAP32[$1 >> 2]) {
   jsvRemoveChild(HEAP32[$1 + 4 >> 2], HEAP32[$1 >> 2]);
   jsvUnLock(HEAP32[$1 >> 2]);
  }
  jsvArrayPush(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 12 >> 2]);
  jsvUnLock(HEAP32[$1 + 4 >> 2]);
 }
 global$0 = $1 + 16 | 0;
}
function jsvCountJsVarsUsed($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (!(!HEAP32[80545] | HEAP32[$1 + 12 >> 2] == HEAP32[80545])) {
  $0 = HEAP32[80545];
  $2 = HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8 | 256;
  HEAP8[$0 + 13 | 0] = $2;
  HEAP8[$0 + 14 | 0] = $2 >>> 8;
 }
 HEAP32[$1 + 8 >> 2] = _jsvCountJsVarsUsedRecursive(HEAP32[$1 + 12 >> 2], 0);
 _jsvCountJsVarsUsedRecursive(HEAP32[$1 + 12 >> 2], 1);
 if (!(!HEAP32[80545] | HEAP32[$1 + 12 >> 2] == HEAP32[80545])) {
  $0 = HEAP32[80545];
  $2 = (HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & -257;
  HEAP8[$0 + 13 | 0] = $2;
  HEAP8[$0 + 14 | 0] = $2 >>> 8;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function jswrap_banglejs_getAccel() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 12 >> 2] = jsvNewWithFlags(5);
 if (HEAP32[$0 + 12 >> 2]) {
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 110430, jsvNewFromFloat(+HEAP16[168338] / 8192));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 110432, jsvNewFromFloat(+HEAP16[168339] / 8192));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 110434, jsvNewFromFloat(+HEAP16[168340] / 8192));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 110436, jsvNewFromFloat(Math_sqrt(+HEAP32[84171]) / 8192));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 110440, jsvNewFromFloat(+HEAPU32[84172] / 8192));
 }
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}
function jsvGetValueOf($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!(jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1)) {
   HEAP32[$1 + 12 >> 2] = jsvLockAgainSafe(HEAP32[$1 + 8 >> 2]);
   break label$1;
  }
  HEAP32[$1 + 4 >> 2] = jspGetNamedField(HEAP32[$1 + 8 >> 2], 78432, 0);
  if (!(jsvIsFunction(HEAP32[$1 + 4 >> 2]) & 1)) {
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
   HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[$1 + 8 >> 2]);
   break label$1;
  }
  HEAP32[$1 + 8 >> 2] = jspeFunctionCall(HEAP32[$1 + 4 >> 2], 0, HEAP32[$1 + 8 >> 2], 0, 0, 0);
  jsvUnLock(HEAP32[$1 + 4 >> 2]);
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2];
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function gemmlowp__FixedPoint_int_2c_20_280_29_20__20_280_29__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 $3 = $2 + 24 | 0;
 $4 = $2 + 8 | 0;
 HEAP32[$2 + 16 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = int_20gemmlowp__SaturatingRoundingDoublingHighMul_int__28int_2c_20int_29(HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($2 + 16 | 0) >> 2], HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($4) >> 2]);
 HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($3) >> 2] = $0;
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 24 >> 2];
}
function jsvSetRefs($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 $1 = $0;
 $3 = (HEAPU8[$1 + 8 | 0] | HEAPU8[$1 + 9 | 0] << 8 | (HEAPU8[$1 + 10 | 0] << 16 | HEAPU8[$1 + 11 | 0] << 24)) & -16711681;
 $2 = HEAPU8[$2 + 11 | 0] << 16;
 $1 = HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8 | (HEAPU8[$1 + 6 | 0] << 16 | HEAPU8[$1 + 7 | 0] << 24);
 HEAP8[$0 + 12 | 0] = HEAPU8[$0 + 12 | 0];
 HEAP8[$0 + 4 | 0] = $1;
 HEAP8[$0 + 5 | 0] = $1 >>> 8;
 HEAP8[$0 + 6 | 0] = $1 >>> 16;
 HEAP8[$0 + 7 | 0] = $1 >>> 24;
 $1 = $2 | $3;
 HEAP8[$0 + 8 | 0] = $1;
 HEAP8[$0 + 9 | 0] = $1 >>> 8;
 HEAP8[$0 + 10 | 0] = $1 >>> 16;
 HEAP8[$0 + 11 | 0] = $1 >>> 24;
}
function jswrap_storage_list($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 20 >> 2] = 0;
 HEAP32[$2 + 16 >> 2] = 0;
 if (jsvIsObject(HEAP32[$2 + 24 >> 2]) & 1) {
  HEAP32[$2 + 12 >> 2] = jsvObjectGetChild(HEAP32[$2 + 24 >> 2], 125515, 0);
  if (HEAP32[$2 + 12 >> 2]) {
   label$3 : {
    if (jsvGetBoolAndUnLock(HEAP32[$2 + 12 >> 2]) & 1) {
     HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 20 >> 2] | 64;
     break label$3;
    }
    HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 16 >> 2] | 64;
   }
  }
 }
 $0 = jsfListFiles(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2]);
 global$0 = $2 + 32 | 0;
 return $0 | 0;
}
function tflite__GreedyMemoryPlanner__DoesEntryOverlapInTime_28tflite__GreedyMemoryPlanner__ListEntry_20const__2c_20int_2c_20int_29_20const($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 HEAP32[$4 + 24 >> 2] = $0;
 HEAP32[$4 + 20 >> 2] = $1;
 HEAP32[$4 + 16 >> 2] = $2;
 HEAP32[$4 + 12 >> 2] = $3;
 HEAP32[$4 + 8 >> 2] = HEAP32[HEAP32[$4 + 24 >> 2] + 12 >> 2] + (HEAP32[HEAP32[$4 + 20 >> 2] + 4 >> 2] << 4);
 label$1 : {
  if (HEAP32[HEAP32[$4 + 8 >> 2] + 8 >> 2] > HEAP32[$4 + 12 >> 2]) {
   HEAP8[$4 + 31 | 0] = 0;
   break label$1;
  }
  if (HEAP32[$4 + 16 >> 2] > HEAP32[HEAP32[$4 + 8 >> 2] + 12 >> 2]) {
   HEAP8[$4 + 31 | 0] = 0;
   break label$1;
  }
  HEAP8[$4 + 31 | 0] = 1;
 }
 return HEAP8[$4 + 31 | 0] & 1;
}
function jsvInitJsVars($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP16[$1 + 14 >> 1] = 1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP16[$1 + 6 >> 1] = HEAPU16[$1 + 14 >> 1];
 while (1) {
  if (HEAPU16[$1 + 6 >> 1] < HEAPU16[$1 + 14 >> 1] + HEAP32[$1 + 8 >> 2] >>> 0) {
   HEAP32[$1 >> 2] = jsvGetAddressOf(HEAPU16[$1 + 6 >> 1]);
   $0 = HEAP32[$1 >> 2];
   HEAP8[$0 + 13 | 0] = 0;
   HEAP8[$0 + 14 | 0] = 0;
   jsvSetNextSibling(HEAP32[$1 >> 2], HEAPU16[$1 + 6 >> 1] + 1 & 65535);
   HEAP16[$1 + 6 >> 1] = HEAPU16[$1 + 6 >> 1] + 1;
   continue;
  }
  break;
 }
 jsvSetNextSibling(jsvGetAddressOf((HEAPU16[$1 + 14 >> 1] + HEAP32[$1 + 8 >> 2] | 0) - 1 & 65535), 0);
 global$0 = $1 + 16 | 0;
 return HEAPU16[$1 + 14 >> 1];
}
function jsiConsolePrintStringVarWithNewLineChar($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 + -64 | 0;
 global$0 = $3;
 HEAP32[$3 + 60 >> 2] = $0;
 HEAP32[$3 + 56 >> 2] = $1;
 HEAP8[$3 + 55 | 0] = $2;
 jsvStringIteratorNew($3 + 16 | 0, HEAP32[$3 + 60 >> 2], HEAP32[$3 + 56 >> 2]);
 while (1) {
  if (jsvStringIteratorHasChar($3 + 16 | 0) & 1) {
   HEAP8[$3 + 15 | 0] = jsvStringIteratorGetCharAndNext($3 + 16 | 0);
   if (HEAP8[$3 + 15 | 0] == 10) {
    jsiConsolePrintChar(13);
   }
   jsiConsolePrintChar(HEAP8[$3 + 15 | 0]);
   if (!(!HEAP8[$3 + 55 | 0] | HEAP8[$3 + 15 | 0] != 10)) {
    jsiConsolePrintChar(HEAP8[$3 + 55 | 0]);
   }
   continue;
  }
  break;
 }
 jsvStringIteratorFree($3 + 16 | 0);
 global$0 = $3 - -64 | 0;
}
function gemmlowp__FixedPoint_int_2c_200__20gemmlowp__SelectUsingMask_int_2c_200__28int_2c_20gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 $4 = $3 + 8 | 0;
 HEAP32[$3 + 16 >> 2] = $1;
 HEAP32[$3 + 8 >> 2] = $2;
 HEAP32[$3 + 4 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29(int_20gemmlowp__SelectUsingMask_int__28int_2c_20int_2c_20int_29(HEAP32[$3 + 4 >> 2], HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($3 + 16 | 0) >> 2], HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($4) >> 2]));
 global$0 = $3 + 32 | 0;
 return HEAP32[$3 + 24 >> 2];
}
function jsvSkipToLastName($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvLockAgain(HEAP32[$1 + 8 >> 2]);
 while (1) {
  label$2 : {
   if (!(jsvGetFirstChild(HEAP32[$1 + 8 >> 2]) & 65535)) {
    break label$2;
   }
   HEAP32[$1 + 4 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$1 + 8 >> 2]) & 65535);
   label$4 : {
    if (jsvIsName(HEAP32[$1 + 4 >> 2]) & 1) {
     jsvUnLock(HEAP32[$1 + 8 >> 2]);
     HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 4 >> 2];
     break label$4;
    }
    jsvUnLock(HEAP32[$1 + 4 >> 2]);
    break label$2;
   }
   continue;
  }
  break;
 }
 HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2];
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jsvSetFirstChild($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 $1 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
 $3 = (HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & -65536;
 $2 = HEAPU16[$2 + 10 >> 1];
 HEAP8[$0 + 12 | 0] = HEAPU8[$0 + 12 | 0];
 HEAP8[$0 + 4 | 0] = $1;
 HEAP8[$0 + 5 | 0] = $1 >>> 8;
 HEAP8[$0 + 6 | 0] = $1 >>> 16;
 HEAP8[$0 + 7 | 0] = $1 >>> 24;
 $1 = $3 | $2;
 HEAP8[$0 + 8 | 0] = $1;
 HEAP8[$0 + 9 | 0] = $1 >>> 8;
 HEAP8[$0 + 10 | 0] = $1 >>> 16;
 HEAP8[$0 + 11 | 0] = $1 >>> 24;
}
function jsfSetFlags($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1 : {
  if (!(jsvIsObject(HEAP32[$1 + 12 >> 2]) & 1)) {
   break label$1;
  }
  HEAP32[$1 + 8 >> 2] = HEAP32[35414];
  HEAP8[$1 + 7 | 0] = 1;
  while (1) {
   if (!HEAPU8[HEAP32[$1 + 8 >> 2]]) {
    break label$1;
   }
   HEAP32[$1 >> 2] = jsvObjectGetChild(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 8 >> 2], 0);
   if (HEAP32[$1 >> 2]) {
    jsfSetFlag(HEAPU8[$1 + 7 | 0], jsvGetBoolAndUnLock(HEAP32[$1 >> 2]) & 1);
   }
   HEAP32[$1 + 8 >> 2] = (strlen(HEAP32[$1 + 8 >> 2]) + 1 | 0) + HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = HEAPU8[$1 + 7 | 0] << 1;
   continue;
  }
 }
 global$0 = $1 + 16 | 0;
}
function jswrap_parseFloat($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 112 | 0;
 global$0 = $1;
 HEAP32[$1 + 100 >> 2] = $0;
 $0 = $1 + 16 | 0;
 jsvGetString(HEAP32[$1 + 100 >> 2], $0, 70);
 label$1 : {
  if (!strcmp($0, 121310)) {
   HEAPF64[$1 + 104 >> 3] = infinity;
   break label$1;
  }
  if (!strcmp($1 + 16 | 0, 121319)) {
   HEAPF64[$1 + 104 >> 3] = -infinity;
   break label$1;
  }
  $0 = $1 + 16 | 0;
  HEAPF64[$1 >> 3] = stringToFloatWithRadix($0, $1 + 12 | 0);
  if (HEAP32[$1 + 12 >> 2] == ($0 + 69 | 0)) {
   jsExceptionHere(1, 121329, 0);
   HEAPF64[$1 + 104 >> 3] = nan;
   break label$1;
  }
  HEAPF64[$1 + 104 >> 3] = HEAPF64[$1 >> 3];
 }
 global$0 = $1 + 112 | 0;
 return +HEAPF64[$1 + 104 >> 3];
}
function jswrap_date_setMinutes($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0, $5 = 0;
 $4 = global$0 - 48 | 0;
 global$0 = $4;
 HEAP32[$4 + 44 >> 2] = $0;
 HEAP32[$4 + 40 >> 2] = $1;
 HEAP32[$4 + 36 >> 2] = $2;
 HEAP32[$4 + 32 >> 2] = $3;
 getTimeFromDateVar($4 + 8 | 0, HEAP32[$4 + 44 >> 2], 0);
 HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 40 >> 2];
 if (jsvIsNumeric(HEAP32[$4 + 36 >> 2]) & 1) {
  HEAP32[$4 + 16 >> 2] = jsvGetInteger(HEAP32[$4 + 36 >> 2]);
 }
 if (jsvIsNumeric(HEAP32[$4 + 32 >> 2]) & 1) {
  HEAP32[$4 + 12 >> 2] = jsvGetInteger(HEAP32[$4 + 32 >> 2]);
 }
 $5 = jswrap_date_setTime(HEAP32[$4 + 44 >> 2], fromTimeInDay($4 + 8 | 0));
 global$0 = $4 + 48 | 0;
 return +$5;
}
function jswrap_string_repeat($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1 : {
  if (HEAP32[$2 + 4 >> 2] < 0) {
   jsExceptionHere(1, 126029, 0);
   HEAP32[$2 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 >> 2] = jsvNewWithFlags(27);
  while (1) {
   $0 = HEAP32[$2 + 4 >> 2];
   HEAP32[$2 + 4 >> 2] = $0 + -1;
   if ($0) {
    $0 = jspIsInterrupted() ^ -1;
   } else {
    $0 = 0;
   }
   if ($0 & 1) {
    jsvAppendStringVarComplete(HEAP32[$2 >> 2], HEAP32[$2 + 8 >> 2]);
    continue;
   }
   break;
  }
  HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function jswrap_regexp_hasFlag($0, $1) {
 var $2 = 0;
 $2 = global$0 + -64 | 0;
 global$0 = $2;
 HEAP32[$2 + 60 >> 2] = $0;
 HEAP8[$2 + 59 | 0] = $1;
 HEAP32[$2 + 52 >> 2] = jsvObjectGetChild(HEAP32[$2 + 60 >> 2], 125378, 0);
 HEAP8[$2 + 51 | 0] = 0;
 if (jsvIsString(HEAP32[$2 + 52 >> 2]) & 1) {
  jsvStringIteratorNew($2 + 8 | 0, HEAP32[$2 + 52 >> 2], 0);
  while (1) {
   if (jsvStringIteratorHasChar($2 + 8 | 0) & 1) {
    HEAP8[$2 + 51 | 0] = ((jsvStringIteratorGetCharAndNext($2 + 8 | 0) & 255) == HEAPU8[$2 + 59 | 0] | HEAP8[$2 + 51 | 0] & 1) != 0;
    continue;
   }
   break;
  }
  jsvStringIteratorFree($2 + 8 | 0);
 }
 jsvUnLock(HEAP32[$2 + 52 >> 2]);
 global$0 = $2 - -64 | 0;
 return HEAP8[$2 + 51 | 0] & 1;
}
function jswrap_banglejs_setLocked($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 15 | 0] = $0;
 if ((HEAP32[84152] & 131072) != (HEAP8[$1 + 15 | 0] & 1)) {
  HEAP32[$1 + 8 >> 2] = jsvObjectGetChild(HEAP32[80545], 110020, 0);
  if (HEAP32[$1 + 8 >> 2]) {
   $0 = $1 + 4 | 0;
   HEAP32[$1 + 4 >> 2] = jsvNewFromBool(HEAP8[$1 + 15 | 0] & 1);
   jsiQueueObjectCallbacks(HEAP32[$1 + 8 >> 2], 110383, $0, 1);
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
  }
  jsvUnLock(HEAP32[$1 + 8 >> 2]);
 }
 label$3 : {
  if (HEAP8[$1 + 15 | 0] & 1) {
   HEAP32[84152] = HEAP32[84152] | 131072;
   break label$3;
  }
  HEAP32[84152] = HEAP32[84152] & -131073;
 }
 HEAP16[168314] = 0;
 global$0 = $1 + 16 | 0;
}
function tf_get($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $1;
 HEAP8[$3 + 11 | 0] = $2;
 HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 12 >> 2];
 HEAP32[$0 >> 2] = 0;
 $1 = $3;
 label$1 : {
  if (HEAP8[$3 + 11 | 0] & 1) {
   $2 = tflite__MicroInterpreter__input_28unsigned_20long_29(HEAP32[$3 + 4 >> 2] + 400 | 0);
   break label$1;
  }
  $2 = tflite__MicroInterpreter__output_28unsigned_20long_29(HEAP32[$3 + 4 >> 2] + 400 | 0);
 }
 HEAP32[$1 >> 2] = $2;
 if (HEAP32[$3 >> 2]) {
  HEAP32[$0 + 4 >> 2] = HEAP32[HEAP32[$3 >> 2] + 28 >> 2];
  HEAP32[$0 >> 2] = HEAP32[HEAP32[$3 >> 2] + 16 >> 2];
  HEAP32[$0 + 8 >> 2] = HEAP32[HEAP32[$3 >> 2] + 24 >> 2];
 }
 global$0 = $3 + 16 | 0;
}
function jswrap_terminal_idle() {
 var $0 = 0;
 $0 = global$0 - 80 | 0;
 global$0 = $0;
 if (HEAP8[336939] & 1) {
  if (terminalGetGFX($0 + 8 | 0) & 1) {
   HEAP32[$0 + 4 >> 2] = jsvObjectGetChild(HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24), 128411, 0);
   if (HEAP32[$0 + 4 >> 2]) {
    jsvUnLock2(jspExecuteFunction(HEAP32[$0 + 4 >> 2], HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24), 0, 0), HEAP32[$0 + 4 >> 2]);
   }
   jsvUnLock(HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24));
   HEAP8[336939] = 0;
  }
 }
 global$0 = $0 + 80 | 0;
 return 0;
}
function jswrap_banglejs_setPollInterval($0) {
 $0 = +$0;
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAPF64[$1 + 24 >> 3] = $0;
 $2 = __DOUBLE_BITS(HEAPF64[$1 + 24 >> 3]);
 $3 = i64toi32_i32$HIGH_BITS & 2147483647;
 label$1 : {
  if (!(HEAPF64[$1 + 24 >> 3] > 4e3 ? 0 : !(($3 | 0) == 2146435072 & $2 >>> 0 >= 0 | $3 >>> 0 > 2146435072 | HEAPF64[$1 + 24 >> 3] < 10))) {
   jsExceptionHere(1, 110080, 0);
   break label$1;
  }
  HEAP32[84152] = HEAP32[84152] & -1025;
  $0 = HEAPF64[$1 + 24 >> 3];
  label$5 : {
   if ($0 < 4294967296 & $0 >= 0) {
    $2 = ~~$0 >>> 0;
    break label$5;
   }
   $2 = 0;
  }
  jswrap_banglejs_setPollInterval_internal($2 & 65535);
 }
 global$0 = $1 + 32 | 0;
}
function jswrap_interactive_setTime($0) {
 $0 = +$0;
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAPF64[$1 + 24 >> 3] = $0;
 HEAP32[$1 + 16 >> 2] = jshGetTimeFromMilliseconds(HEAPF64[$1 + 24 >> 3] * 1e3);
 HEAP32[$1 + 20 >> 2] = i64toi32_i32$HIGH_BITS;
 $2 = HEAP32[$1 + 20 >> 2];
 HEAP32[80572] = HEAP32[$1 + 16 >> 2];
 HEAP32[80573] = $2;
 HEAP32[$1 + 8 >> 2] = jshGetSystemTime();
 HEAP32[$1 + 12 >> 2] = i64toi32_i32$HIGH_BITS;
 jshSetSystemTime(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 20 >> 2]);
 $2 = HEAP32[$1 + 16 >> 2];
 $3 = HEAP32[$1 + 8 >> 2];
 jstSystemTimeChanged($2 - $3 | 0, HEAP32[$1 + 20 >> 2] - (HEAP32[$1 + 12 >> 2] + ($2 >>> 0 < $3 >>> 0) | 0) | 0);
 global$0 = $1 + 32 | 0;
}
function jsvExecuteGetter($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1 : {
  if (!(jsvIsGetterOrSetter(HEAP32[$2 + 20 >> 2]) & 1)) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 16 >> 2] = jsvObjectGetChild(HEAP32[$2 + 20 >> 2], 78604, 0);
  if (!(jsvIsFunction(HEAP32[$2 + 16 >> 2]) & 1)) {
   jsvUnLock(HEAP32[$2 + 16 >> 2]);
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jspExecuteFunction(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 24 >> 2], 0, 0);
  jsvUnLock(HEAP32[$2 + 16 >> 2]);
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function heatshrink_decoder_finish($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP32[$1 + 12 >> 2] = -1;
   break label$1;
  }
  $0 = HEAPU8[HEAP32[$1 + 8 >> 2] + 10 | 0];
  if ($0 >>> 0 <= 5) {
   label$4 : {
    switch ($0 - 1 | 0) {
    default:
     HEAP32[$1 + 12 >> 2] = HEAPU16[HEAP32[$1 + 8 >> 2] >> 1] ? 1 : 0;
     break label$1;
    case 1:
    case 2:
    case 3:
    case 4:
     HEAP32[$1 + 12 >> 2] = HEAPU16[HEAP32[$1 + 8 >> 2] >> 1] ? 1 : 0;
     break label$1;
    case 0:
     break label$4;
    }
   }
   HEAP32[$1 + 12 >> 2] = HEAPU16[HEAP32[$1 + 8 >> 2] >> 1] ? 1 : 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 1;
 }
}
function tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 label$1 : {
  if (!(HEAP32[HEAP32[$2 + 24 >> 2] + 4 >> 2] ? HEAP32[$2 + 24 >> 2] : 0)) {
   $1 = global$0 - 16 | 0;
   HEAP32[$1 + 12 >> 2] = $0;
   HEAP32[HEAP32[$1 + 12 >> 2] >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 20 >> 2] = HEAP32[HEAP32[$2 + 24 >> 2] + 4 >> 2];
  HEAP32[$2 + 16 >> 2] = HEAP32[HEAP32[$2 + 20 >> 2] >> 2];
  HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 20 >> 2] + 4;
  tflite__RuntimeShape__RuntimeShape_28int_2c_20int_20const__29($0, HEAP32[$2 + 16 >> 2], HEAP32[$2 + 12 >> 2]);
 }
 global$0 = $2 + 32 | 0;
}
function jsvIsChild($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP16[$2 + 18 >> 1] = jsvGetRef(HEAP32[$2 + 20 >> 2]);
 HEAP16[$2 + 16 >> 1] = jsvGetFirstChild(HEAP32[$2 + 24 >> 2]);
 label$1 : {
  while (1) {
   if (HEAPU16[$2 + 16 >> 1]) {
    if (HEAPU16[$2 + 16 >> 1] == HEAPU16[$2 + 18 >> 1]) {
     HEAP8[$2 + 31 | 0] = 1;
     break label$1;
    }
    HEAP32[$2 + 12 >> 2] = jsvLock(HEAPU16[$2 + 16 >> 1]);
    HEAP16[$2 + 16 >> 1] = jsvGetNextSibling(HEAP32[$2 + 12 >> 2]);
    jsvUnLock(HEAP32[$2 + 12 >> 2]);
    continue;
   }
   break;
  }
  HEAP8[$2 + 31 | 0] = 0;
 }
 global$0 = $2 + 32 | 0;
 return HEAP8[$2 + 31 | 0] & 1;
}
function jsfGetFileHeader($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP8[$3 + 19 | 0] = $2;
 label$1 : {
  if (!HEAP32[$3 + 24 >> 2]) {
   HEAP8[$3 + 31 | 0] = 0;
   break label$1;
  }
  jshFlashRead(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 24 >> 2], HEAP8[$3 + 19 | 0] & 1 ? 32 : 8);
  HEAP32[$3 + 12 >> 2] = (HEAP32[$3 + 24 >> 2] + 32 | 0) + jsfGetFileSize(HEAP32[$3 + 20 >> 2]);
  $0 = $3;
  if (HEAP32[HEAP32[$3 + 20 >> 2] >> 2] != -1) {
   $1 = HEAPU32[$3 + 12 >> 2] <= jsfGetBankEndAddress(HEAP32[$3 + 24 >> 2]) >>> 0;
  } else {
   $1 = 0;
  }
  HEAP8[$0 + 31 | 0] = $1;
 }
 global$0 = $3 + 32 | 0;
 return HEAP8[$3 + 31 | 0] & 1;
}
function jsvArrayBufferIteratorDataToInt($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 20 >> 2] = HEAPU16[HEAP32[$2 + 28 >> 2] + 36 >> 1] & 15;
 HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 20 >> 2] << 3;
 $0 = HEAP32[$2 + 16 >> 2];
 HEAP32[$2 + 12 >> 2] = (32 <= ($0 & 63) >>> 0 ? 0 : 1 << ($0 & 31)) - 1;
 HEAP32[$2 + 8 >> 2] = HEAP32[HEAP32[$2 + 24 >> 2] >> 2];
 HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] & HEAP32[$2 + 12 >> 2];
 if (!(!(HEAPU16[HEAP32[$2 + 28 >> 2] + 36 >> 1] & 16) | !(HEAP32[$2 + 8 >> 2] & 1 << HEAP32[$2 + 16 >> 2] - 1))) {
  HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] | HEAP32[$2 + 12 >> 2] ^ -1;
 }
 return HEAP32[$2 + 8 >> 2];
}
function tflite__GetOutput_28TfLiteContext__2c_20TfLiteNode_20const__2c_20int_29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 HEAP32[$2 >> 2] = 0;
 label$1 : {
  if (HEAP32[HEAP32[$2 + 8 >> 2] + 8 >> 2]) {
   HEAP32[$2 + 12 >> 2] = HEAP32[HEAP32[$2 + 8 >> 2] + 8 >> 2] + Math_imul(HEAP32[(HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] + 4 | 0) + (HEAP32[$2 >> 2] << 2) >> 2], 40);
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$2 + 8 >> 2] + 80 >> 2]](HEAP32[$2 + 8 >> 2], HEAP32[(HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] + 4 | 0) + (HEAP32[$2 >> 2] << 2) >> 2]);
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function jswrap_flash_getPage($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 label$1 : {
  if (!(jshFlashGetPage(HEAP32[$1 + 24 >> 2], $1 + 20 | 0, $1 + 16 | 0) & 1)) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvNewWithFlags(5);
  if (!HEAP32[$1 + 12 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 12 >> 2], 121095, jsvNewFromInteger(HEAP32[$1 + 20 >> 2]));
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 12 >> 2], 121100, jsvNewFromInteger(HEAP32[$1 + 16 >> 2]));
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 12 >> 2];
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function jsvCompareInteger($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1 : {
  label$2 : {
   if (!(jsvIsInt(HEAP32[$2 + 8 >> 2]) & 1)) {
    break label$2;
   }
   if (!(jsvIsInt(HEAP32[$2 + 4 >> 2]) & 1)) {
    break label$2;
   }
   HEAP32[$2 + 12 >> 2] = jsvGetInteger(HEAP32[$2 + 8 >> 2]) - jsvGetInteger(HEAP32[$2 + 4 >> 2]);
   break label$1;
  }
  if (jsvIsInt(HEAP32[$2 + 8 >> 2]) & 1) {
   HEAP32[$2 + 12 >> 2] = -1;
   break label$1;
  }
  if (jsvIsInt(HEAP32[$2 + 4 >> 2]) & 1) {
   HEAP32[$2 + 12 >> 2] = 1;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = 0;
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function flatbuffers__Table__GetOptionalFieldOffset_28unsigned_20short_29_20const($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 HEAP32[$2 + 4 >> 2] = flatbuffers__Table__GetVTable_28_29_20const(HEAP32[$2 + 12 >> 2]);
 HEAP16[$2 + 2 >> 1] = unsigned_20short_20flatbuffers__ReadScalar_unsigned_20short__28void_20const__29(HEAP32[$2 + 4 >> 2]);
 label$1 : {
  if (HEAPU16[$2 + 10 >> 1] < HEAPU16[$2 + 2 >> 1]) {
   $0 = unsigned_20short_20flatbuffers__ReadScalar_unsigned_20short__28void_20const__29(HEAP32[$2 + 4 >> 2] + HEAPU16[$2 + 10 >> 1] | 0) & 65535;
   break label$1;
  }
  $0 = 0;
 }
 global$0 = $2 + 16 | 0;
 return $0 & 65535;
}
function strlen($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 label$1 : {
  label$2 : {
   $1 = $0;
   if (!($1 & 3)) {
    break label$2;
   }
   if (!HEAPU8[$0 | 0]) {
    break label$1;
   }
   while (1) {
    $1 = $1 + 1 | 0;
    if (!($1 & 3)) {
     break label$2;
    }
    if (HEAPU8[$1 | 0]) {
     continue;
    }
    break;
   }
   break label$1;
  }
  while (1) {
   $2 = $1;
   $1 = $1 + 4 | 0;
   $3 = HEAP32[$2 >> 2];
   if (!(($3 ^ -1) & $3 + -16843009 & -2139062144)) {
    continue;
   }
   break;
  }
  if (!($3 & 255)) {
   $1 = $2;
   break label$1;
  }
  while (1) {
   $3 = HEAPU8[$2 + 1 | 0];
   $1 = $2 + 1 | 0;
   $2 = $1;
   if ($3) {
    continue;
   }
   break;
  }
 }
 return $1 - $0 | 0;
}
function save_backlog($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = get_input_buffer_size(HEAP32[$1 + 12 >> 2]) & 65535;
 HEAP16[$1 + 6 >> 1] = HEAPU16[HEAP32[$1 + 12 >> 2] + 2 >> 1];
 HEAP16[$1 + 4 >> 1] = HEAP32[$1 + 8 >> 2] - HEAPU16[$1 + 6 >> 1];
 HEAP16[$1 + 2 >> 1] = HEAP32[$1 + 8 >> 2] + HEAPU16[$1 + 4 >> 1];
 memmove(HEAP32[$1 + 12 >> 2] + 15 | 0, HEAP32[$1 + 12 >> 2] + 15 + (HEAP32[$1 + 8 >> 2] - HEAPU16[$1 + 4 >> 1]) | 0, HEAPU16[$1 + 2 >> 1]);
 HEAP16[HEAP32[$1 + 12 >> 2] + 2 >> 1] = 0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP16[$0 >> 1] = HEAPU16[$0 >> 1] - (HEAP32[$1 + 8 >> 2] - HEAPU16[$1 + 4 >> 1] | 0);
 global$0 = $1 + 16 | 0;
}
function jsiDumpEvent($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 32 | 0;
 global$0 = $5;
 HEAP32[$5 + 28 >> 2] = $0;
 HEAP32[$5 + 24 >> 2] = $1;
 HEAP32[$5 + 20 >> 2] = $2;
 HEAP32[$5 + 16 >> 2] = $3;
 HEAP32[$5 + 12 >> 2] = $4;
 HEAP32[$5 + 8 >> 2] = jsvNewFromStringVar(HEAP32[$5 + 16 >> 2], 3, 2147483647);
 $0 = HEAP32[$5 + 28 >> 2];
 $1 = HEAP32[$5 + 24 >> 2];
 $2 = HEAP32[$5 + 20 >> 2];
 HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 8 >> 2];
 HEAP32[$5 >> 2] = $2;
 cbprintf($0, $1, 83118, $5);
 jsvUnLock(HEAP32[$5 + 8 >> 2]);
 jsiDumpJSON(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 24 >> 2], HEAP32[$5 + 12 >> 2], 0);
 FUNCTION_TABLE[HEAP32[$5 + 28 >> 2]](81216, HEAP32[$5 + 24 >> 2]);
 global$0 = $5 + 32 | 0;
}
function jswrap_graphics_asURL($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP32[$1 + 20 >> 2] = jswrap_graphics_asBMP(HEAP32[$1 + 24 >> 2]);
 label$1 : {
  if (!HEAP32[$1 + 20 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 16 >> 2] = jswrap_btoa(HEAP32[$1 + 20 >> 2]);
  jsvUnLock(HEAP32[$1 + 20 >> 2]);
  if (!HEAP32[$1 + 16 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 >> 2] = HEAP32[$1 + 16 >> 2];
  HEAP32[$1 + 12 >> 2] = jsvVarPrintf(128050, $1);
  jsvUnLock(HEAP32[$1 + 16 >> 2]);
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 12 >> 2];
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function jsvSetNextSibling($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 $1 = $0;
 $2 = HEAPU16[$2 + 10 >> 1] | (HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8 | (HEAPU8[$1 + 6 | 0] << 16 | HEAPU8[$1 + 7 | 0] << 24)) & -65536;
 $1 = HEAPU8[$1 + 8 | 0] | HEAPU8[$1 + 9 | 0] << 8 | (HEAPU8[$1 + 10 | 0] << 16 | HEAPU8[$1 + 11 | 0] << 24);
 HEAP8[$0 + 12 | 0] = HEAPU8[$0 + 12 | 0];
 HEAP8[$0 + 4 | 0] = $2;
 HEAP8[$0 + 5 | 0] = $2 >>> 8;
 HEAP8[$0 + 6 | 0] = $2 >>> 16;
 HEAP8[$0 + 7 | 0] = $2 >>> 24;
 HEAP8[$0 + 8 | 0] = $1;
 HEAP8[$0 + 9 | 0] = $1 >>> 8;
 HEAP8[$0 + 10 | 0] = $1 >>> 16;
 HEAP8[$0 + 11 | 0] = $1 >>> 24;
}
function scalbn($0, $1) {
 var $2 = 0;
 label$1 : {
  if (($1 | 0) >= 1024) {
   $0 = $0 * 8.98846567431158e+307;
   $2 = $1 + -1023 | 0;
   if (($2 | 0) < 1024) {
    $1 = $2;
    break label$1;
   }
   $0 = $0 * 8.98846567431158e+307;
   $1 = (($1 | 0) < 3069 ? $1 : 3069) + -2046 | 0;
   break label$1;
  }
  if (($1 | 0) > -1023) {
   break label$1;
  }
  $0 = $0 * 2.2250738585072014e-308;
  $2 = $1 + 1022 | 0;
  if (($2 | 0) > -1023) {
   $1 = $2;
   break label$1;
  }
  $0 = $0 * 2.2250738585072014e-308;
  $1 = (($1 | 0) > -3066 ? $1 : -3066) + 2044 | 0;
 }
 $1 = $1 + 1023 << 20;
 wasm2js_scratch_store_i32(0, 0);
 wasm2js_scratch_store_i32(1, $1 | 0);
 return $0 * +wasm2js_scratch_load_f64();
}
function jswrap_graphics_fillEllipse($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0;
 $5 = global$0 - 96 | 0;
 global$0 = $5;
 HEAP32[$5 + 88 >> 2] = $0;
 HEAP32[$5 + 84 >> 2] = $1;
 HEAP32[$5 + 80 >> 2] = $2;
 HEAP32[$5 + 76 >> 2] = $3;
 HEAP32[$5 + 72 >> 2] = $4;
 label$1 : {
  if (!(graphicsGetFromVar($5, HEAP32[$5 + 88 >> 2]) & 1)) {
   HEAP32[$5 + 92 >> 2] = 0;
   break label$1;
  }
  graphicsFillEllipse($5, HEAP32[$5 + 84 >> 2], HEAP32[$5 + 80 >> 2], HEAP32[$5 + 76 >> 2], HEAP32[$5 + 72 >> 2]);
  graphicsSetVar($5);
  HEAP32[$5 + 92 >> 2] = jsvLockAgain(HEAP32[$5 + 88 >> 2]);
 }
 global$0 = $5 + 96 | 0;
 return HEAP32[$5 + 92 >> 2];
}
function jswrap_graphics_drawEllipse($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0;
 $5 = global$0 - 96 | 0;
 global$0 = $5;
 HEAP32[$5 + 88 >> 2] = $0;
 HEAP32[$5 + 84 >> 2] = $1;
 HEAP32[$5 + 80 >> 2] = $2;
 HEAP32[$5 + 76 >> 2] = $3;
 HEAP32[$5 + 72 >> 2] = $4;
 label$1 : {
  if (!(graphicsGetFromVar($5, HEAP32[$5 + 88 >> 2]) & 1)) {
   HEAP32[$5 + 92 >> 2] = 0;
   break label$1;
  }
  graphicsDrawEllipse($5, HEAP32[$5 + 84 >> 2], HEAP32[$5 + 80 >> 2], HEAP32[$5 + 76 >> 2], HEAP32[$5 + 72 >> 2]);
  graphicsSetVar($5);
  HEAP32[$5 + 92 >> 2] = jsvLockAgain(HEAP32[$5 + 88 >> 2]);
 }
 global$0 = $5 + 96 | 0;
 return HEAP32[$5 + 92 >> 2];
}
function jstSystemTimeChanged($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 12 >> 2] = $1;
 HEAP8[$2 + 7 | 0] = HEAPU8[324178];
 while (1) {
  if (HEAPU8[$2 + 7 | 0] != HEAPU8[324177]) {
   $0 = Math_imul(HEAPU8[$2 + 7 | 0], 25) + 324192 | 0;
   $1 = $0;
   $0 = HEAP32[$2 + 8 >> 2] + (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) | 0;
   HEAP8[$1 | 0] = $0;
   HEAP8[$1 + 1 | 0] = $0 >>> 8;
   HEAP8[$1 + 2 | 0] = $0 >>> 16;
   HEAP8[$1 + 3 | 0] = $0 >>> 24;
   HEAP8[$2 + 7 | 0] = HEAPU8[$2 + 7 | 0] + 1 & 15;
   continue;
  }
  break;
 }
 $1 = HEAP32[$2 + 8 >> 2] + HEAP32[81047] | 0;
 HEAP32[81047] = $1;
}
function getMonth($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = 0;
 label$1 : {
  while (1) {
   if (HEAP32[$1 + 4 >> 2] < 12) {
    if (!(HEAP8[HEAP32[$1 + 8 >> 2]] != HEAP8[HEAP32[35428] + (HEAP32[$1 + 4 >> 2] << 2) | 0] | HEAP8[HEAP32[$1 + 8 >> 2] + 1 | 0] != HEAP8[HEAP32[35428] + ((HEAP32[$1 + 4 >> 2] << 2) + 1 | 0) | 0] | HEAP8[HEAP32[$1 + 8 >> 2] + 2 | 0] != HEAP8[HEAP32[35428] + ((HEAP32[$1 + 4 >> 2] << 2) + 2 | 0) | 0])) {
     HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
     break label$1;
    }
    HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$1 + 12 >> 2] = -1;
 }
 return HEAP32[$1 + 12 >> 2];
}
function jshPushEvent($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[$1 + 11 | 0] = HEAPU8[322306] + 1;
 label$1 : {
  if (HEAPU8[322307] == HEAPU8[$1 + 11 | 0]) {
   HEAP8[322179] = HEAPU8[322179] | 1;
   break label$1;
  }
  $0 = Math_imul(HEAPU8[322306], 5) + 322896 | 0;
  $2 = HEAP32[$1 + 12 >> 2];
  $3 = HEAPU8[$2 | 0] | HEAPU8[$2 + 1 | 0] << 8 | (HEAPU8[$2 + 2 | 0] << 16 | HEAPU8[$2 + 3 | 0] << 24);
  HEAP8[$0 | 0] = $3;
  HEAP8[$0 + 1 | 0] = $3 >>> 8;
  HEAP8[$0 + 2 | 0] = $3 >>> 16;
  HEAP8[$0 + 3 | 0] = $3 >>> 24;
  HEAP8[$0 + 4 | 0] = HEAPU8[$2 + 4 | 0];
  HEAP8[322306] = HEAPU8[$1 + 11 | 0];
 }
 global$0 = $1 + 16 | 0;
}
function fmt_u($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 label$1 : {
  if (($1 | 0) == 1 & $0 >>> 0 < 0 | $1 >>> 0 < 1) {
   $3 = $0;
   break label$1;
  }
  while (1) {
   $2 = $2 + -1 | 0;
   $3 = __wasm_i64_udiv($0, $1, 10, 0);
   $4 = i64toi32_i32$HIGH_BITS;
   $5 = $4;
   $4 = __wasm_i64_mul($3, $4, 10, 0);
   HEAP8[$2 | 0] = $0 - $4 | 48;
   $4 = ($1 | 0) == 9 & $0 >>> 0 > 4294967295 | $1 >>> 0 > 9;
   $0 = $3;
   $1 = $5;
   if ($4) {
    continue;
   }
   break;
  }
 }
 if ($3) {
  while (1) {
   $2 = $2 + -1 | 0;
   $0 = ($3 >>> 0) / 10 | 0;
   HEAP8[$2 | 0] = $3 - Math_imul($0, 10) | 48;
   $1 = $3 >>> 0 > 9;
   $3 = $0;
   if ($1) {
    continue;
   }
   break;
  }
 }
 return $2;
}
function jswGetBuiltInLibrary($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!strcmp(HEAP32[$1 + 8 >> 2], 94082)) {
   HEAP32[$1 + 12 >> 2] = 42;
   break label$1;
  }
  if (!strcmp(HEAP32[$1 + 8 >> 2], 94088)) {
   HEAP32[$1 + 12 >> 2] = 50;
   break label$1;
  }
  if (!strcmp(HEAP32[$1 + 8 >> 2], 94096)) {
   HEAP32[$1 + 12 >> 2] = 52;
   break label$1;
  }
  if (!strcmp(HEAP32[$1 + 8 >> 2], 94107)) {
   HEAP32[$1 + 12 >> 2] = 54;
   break label$1;
  }
  if (!strcmp(HEAP32[$1 + 8 >> 2], 94114)) {
   HEAP32[$1 + 12 >> 2] = 55;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jswrap_graphics_drawLine($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0;
 $5 = global$0 - 96 | 0;
 global$0 = $5;
 HEAP32[$5 + 88 >> 2] = $0;
 HEAP32[$5 + 84 >> 2] = $1;
 HEAP32[$5 + 80 >> 2] = $2;
 HEAP32[$5 + 76 >> 2] = $3;
 HEAP32[$5 + 72 >> 2] = $4;
 label$1 : {
  if (!(graphicsGetFromVar($5, HEAP32[$5 + 88 >> 2]) & 1)) {
   HEAP32[$5 + 92 >> 2] = 0;
   break label$1;
  }
  graphicsDrawLine($5, HEAP32[$5 + 84 >> 2], HEAP32[$5 + 80 >> 2], HEAP32[$5 + 76 >> 2], HEAP32[$5 + 72 >> 2]);
  graphicsSetVar($5);
  HEAP32[$5 + 92 >> 2] = jsvLockAgain(HEAP32[$5 + 88 >> 2]);
 }
 global$0 = $5 + 96 | 0;
 return HEAP32[$5 + 92 >> 2];
}
function jsvNewFromLongInteger($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1 : {
  label$2 : {
   $0 = HEAP32[$2 + 4 >> 2];
   if (($0 | 0) < -1 ? 1 : ($0 | 0) <= -1 ? HEAPU32[$2 >> 2] >= 2147483648 ? 0 : 1 : 0) {
    break label$2;
   }
   $0 = HEAP32[$2 + 4 >> 2];
   if (($0 | 0) > 0 ? 1 : ($0 | 0) >= 0 ? HEAPU32[$2 >> 2] <= 2147483647 ? 0 : 1 : 0) {
    break label$2;
   }
   HEAP32[$2 + 12 >> 2] = jsvNewFromInteger(HEAP32[$2 >> 2]);
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jsvNewFromFloat(+HEAPU32[$2 >> 2] + 4294967296 * +HEAP32[$2 + 4 >> 2]);
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function unsigned_20char_20const__20std____2__min_unsigned_20char_2c_20std____2____less_unsigned_20char_2c_20unsigned_20char__20__28unsigned_20char_20const__2c_20unsigned_20char_20const__2c_20std____2____less_unsigned_20char_2c_20unsigned_20char__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 4 >> 2] = $0;
 HEAP32[$2 >> 2] = $1;
 label$1 : {
  if (std____2____less_unsigned_20char_2c_20unsigned_20char___operator_28_29_28unsigned_20char_20const__2c_20unsigned_20char_20const__29_20const($2 + 8 | 0, HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]) & 1) {
   $0 = HEAP32[$2 >> 2];
   break label$1;
  }
  $0 = HEAP32[$2 + 4 >> 2];
 }
 global$0 = $2 + 16 | 0;
 return $0;
}
function unsigned_20char_20const__20std____2__max_unsigned_20char_2c_20std____2____less_unsigned_20char_2c_20unsigned_20char__20__28unsigned_20char_20const__2c_20unsigned_20char_20const__2c_20std____2____less_unsigned_20char_2c_20unsigned_20char__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 4 >> 2] = $0;
 HEAP32[$2 >> 2] = $1;
 label$1 : {
  if (std____2____less_unsigned_20char_2c_20unsigned_20char___operator_28_29_28unsigned_20char_20const__2c_20unsigned_20char_20const__29_20const($2 + 8 | 0, HEAP32[$2 + 4 >> 2], HEAP32[$2 >> 2]) & 1) {
   $0 = HEAP32[$2 >> 2];
   break label$1;
  }
  $0 = HEAP32[$2 + 4 >> 2];
 }
 global$0 = $2 + 16 | 0;
 return $0;
}
function std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___release_28_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = HEAP32[std____2____compressed_pair_TfLiteConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29_20const($0) >> 2];
 HEAP32[std____2____compressed_pair_TfLiteConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29_20const($0) >> 2] = 0;
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function st_yield_tag_bit($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1 : {
  if (can_take_byte(HEAP32[$2 + 4 >> 2])) {
   if (!HEAPU16[HEAP32[$2 + 8 >> 2] + 4 >> 1]) {
    add_tag_bit(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2], 1);
    HEAP32[$2 + 12 >> 2] = 4;
    break label$1;
   }
   add_tag_bit(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2], 0);
   HEAP16[HEAP32[$2 + 8 >> 2] + 8 >> 1] = HEAPU16[HEAP32[$2 + 8 >> 2] + 6 >> 1] - 1;
   HEAP8[HEAP32[$2 + 8 >> 2] + 10 | 0] = 8;
   HEAP32[$2 + 12 >> 2] = 5;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = 3;
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function jswrap_graphics_getColorX($0, $1) {
 var $2 = 0;
 $2 = global$0 - 96 | 0;
 global$0 = $2;
 HEAP32[$2 + 88 >> 2] = $0;
 HEAP8[$2 + 87 | 0] = $1;
 label$1 : {
  if (!(graphicsGetFromVar($2 + 8 | 0, HEAP32[$2 + 88 >> 2]) & 1)) {
   HEAP32[$2 + 92 >> 2] = 0;
   break label$1;
  }
  $0 = $2;
  if (HEAP8[$2 + 87 | 0] & 1) {
   $1 = HEAPU8[$2 + 25 | 0] | HEAPU8[$2 + 26 | 0] << 8 | (HEAPU8[$2 + 27 | 0] << 16 | HEAPU8[$2 + 28 | 0] << 24);
  } else {
   $1 = HEAPU8[$2 + 29 | 0] | HEAPU8[$2 + 30 | 0] << 8 | (HEAPU8[$2 + 31 | 0] << 16 | HEAPU8[$2 + 32 | 0] << 24);
  }
  HEAP32[$0 + 92 >> 2] = $1 & (1 << HEAPU8[$2 + 24 | 0]) - 1;
 }
 global$0 = $2 + 96 | 0;
 return HEAP32[$2 + 92 >> 2];
}
function jspeStatementReturn() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 12 >> 2] = 0;
 jslGetNextToken();
 if (!(HEAP16[HEAP32[35539] + 2 >> 1] == 59 | HEAP16[HEAP32[35539] + 2 >> 1] == 125)) {
  HEAP32[$0 + 12 >> 2] = jsvSkipNameAndUnLock(jspeExpression());
 }
 if ((HEAP32[80549] & 63) == 1) {
  HEAP32[$0 + 8 >> 2] = jspeiFindInScopes(79874);
  label$3 : {
   if (HEAP32[$0 + 8 >> 2]) {
    jsvReplaceWith(HEAP32[$0 + 8 >> 2], HEAP32[$0 + 12 >> 2]);
    jsvUnLock(HEAP32[$0 + 8 >> 2]);
    HEAP32[80549] = HEAP32[80549] | 8;
    break label$3;
   }
   jsExceptionHere(2, 80737, 0);
  }
 }
 jsvUnLock(HEAP32[$0 + 12 >> 2]);
 global$0 = $0 + 16 | 0;
 return 0;
}
function jsvStringIteratorAppendString($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 + -64 | 0;
 global$0 = $4;
 HEAP32[$4 + 60 >> 2] = $0;
 HEAP32[$4 + 56 >> 2] = $1;
 HEAP32[$4 + 52 >> 2] = $2;
 HEAP32[$4 + 48 >> 2] = $3;
 jsvStringIteratorNew($4 + 8 | 0, HEAP32[$4 + 56 >> 2], HEAP32[$4 + 52 >> 2]);
 while (1) {
  if (jsvStringIteratorHasChar($4 + 8 | 0) & 1) {
   $0 = HEAP32[$4 + 48 >> 2] > 0;
  } else {
   $0 = 0;
  }
  if ($0) {
   jsvStringIteratorAppend(HEAP32[$4 + 60 >> 2], jsvStringIteratorGetCharAndNext($4 + 8 | 0) << 24 >> 24);
   HEAP32[$4 + 48 >> 2] = HEAP32[$4 + 48 >> 2] + -1;
   continue;
  }
  break;
 }
 jsvStringIteratorFree($4 + 8 | 0);
 global$0 = $4 - -64 | 0;
}
function graphicsFillVectorChar($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = global$0 - 48 | 0;
 global$0 = $6;
 HEAP32[$6 + 40 >> 2] = $0;
 HEAP32[$6 + 36 >> 2] = $1;
 HEAP32[$6 + 32 >> 2] = $2;
 HEAP32[$6 + 28 >> 2] = $3;
 HEAP32[$6 + 24 >> 2] = $4;
 HEAP8[$6 + 23 | 0] = $5;
 HEAP32[$6 + 12 >> 2] = vfGetCharPtr(HEAP8[$6 + 23 | 0], $6 + 16 | 0);
 label$1 : {
  if (!HEAP32[$6 + 12 >> 2]) {
   HEAP32[$6 + 44 >> 2] = HEAP32[$6 + 28 >> 2] / 2;
   break label$1;
  }
  HEAP32[$6 + 44 >> 2] = vfDrawCharPtr(HEAP32[$6 + 40 >> 2], HEAP32[$6 + 36 >> 2], HEAP32[$6 + 32 >> 2], HEAP32[$6 + 28 >> 2], HEAP32[$6 + 24 >> 2], HEAP32[$6 + 12 >> 2], HEAP32[$6 + 16 >> 2]);
 }
 global$0 = $6 + 48 | 0;
}
function tflite__EnumNameBuiltinOperator_28tflite__BuiltinOperator_29($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP32[$1 + 20 >> 2] = 0;
 HEAP32[$1 + 16 >> 2] = 126;
 label$1 : {
  if (bool_20flatbuffers__IsOutRange_tflite__BuiltinOperator__28tflite__BuiltinOperator_20const__2c_20tflite__BuiltinOperator_20const__2c_20tflite__BuiltinOperator_20const__29($1 + 24 | 0, $1 + 20 | 0, $1 + 16 | 0) & 1) {
   HEAP32[$1 + 28 >> 2] = 129667;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 24 >> 2];
  HEAP32[$1 + 28 >> 2] = HEAP32[(HEAP32[$1 + 12 >> 2] << 2) + 129680 >> 2];
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function jswrap_graphics_moveTo($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 96 | 0;
 global$0 = $3;
 HEAP32[$3 + 88 >> 2] = $0;
 HEAP32[$3 + 84 >> 2] = $1;
 HEAP32[$3 + 80 >> 2] = $2;
 label$1 : {
  if (!(graphicsGetFromVar($3 + 8 | 0, HEAP32[$3 + 88 >> 2]) & 1)) {
   HEAP32[$3 + 92 >> 2] = 0;
   break label$1;
  }
  $0 = HEAP32[$3 + 84 >> 2];
  HEAP8[$3 + 35 | 0] = $0;
  HEAP8[$3 + 36 | 0] = $0 >>> 8;
  $0 = HEAP32[$3 + 80 >> 2];
  HEAP8[$3 + 37 | 0] = $0;
  HEAP8[$3 + 38 | 0] = $0 >>> 8;
  graphicsSetVar($3 + 8 | 0);
  HEAP32[$3 + 92 >> 2] = jsvLockAgain(HEAP32[$3 + 88 >> 2]);
 }
 global$0 = $3 + 96 | 0;
 return HEAP32[$3 + 92 >> 2];
}
function vfGetPolyPtr($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 HEAP8[$2 + 27 | 0] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1 : {
  if (HEAPU8[$2 + 27 | 0] >= 201) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = HEAPU8[HEAPU8[$2 + 27 | 0] + 105728 | 0];
  HEAP32[$2 + 16 >> 2] = 105936;
  HEAP8[$2 + 15 | 0] = 0;
  while (1) {
   if (HEAPU8[$2 + 15 | 0] < HEAPU8[$2 + 27 | 0]) {
    HEAP32[$2 + 16 >> 2] = HEAPU8[HEAPU8[$2 + 15 | 0] + 105728 | 0] + HEAP32[$2 + 16 >> 2];
    HEAP8[$2 + 15 | 0] = HEAPU8[$2 + 15 | 0] + 1;
    continue;
   }
   break;
  }
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 16 >> 2];
 }
 return HEAP32[$2 + 28 >> 2];
}
function tflite__NumElements_28TfLiteIntArray_20const__29($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 HEAP32[$1 + 28 >> 2] = $0;
 HEAP32[$1 + 16 >> 2] = 1;
 HEAP32[$1 + 20 >> 2] = 0;
 HEAP32[$1 + 12 >> 2] = 0;
 while (1) {
  if (HEAP32[$1 + 12 >> 2] < HEAP32[HEAP32[$1 + 28 >> 2] >> 2]) {
   $0 = HEAP32[(HEAP32[$1 + 28 >> 2] + 4 | 0) + (HEAP32[$1 + 12 >> 2] << 2) >> 2];
   HEAP32[$1 + 16 >> 2] = __wasm_i64_mul(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 20 >> 2], $0, $0 >> 31);
   HEAP32[$1 + 20 >> 2] = i64toi32_i32$HIGH_BITS;
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 i64toi32_i32$HIGH_BITS = HEAP32[$1 + 20 >> 2];
 return HEAP32[$1 + 16 >> 2];
}
function jsvGetConstString($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (jsvIsUndefined(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 78366;
   break label$1;
  }
  if (jsvIsNull(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 78376;
   break label$1;
  }
  label$4 : {
   if (!(jsvIsBoolean(HEAP32[$1 + 8 >> 2]) & 1)) {
    break label$4;
   }
   if (jsvIsNameIntBool(HEAP32[$1 + 8 >> 2]) & 1) {
    break label$4;
   }
   HEAP32[$1 + 12 >> 2] = jsvGetBool(HEAP32[$1 + 8 >> 2]) & 1 ? 78381 : 78386;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function st_backref_count_lsb($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP8[$1 + 7 | 0] = 6;
 $0 = $1;
 $3 = HEAP32[$1 + 8 >> 2];
 if (HEAPU8[$1 + 7 | 0] < 8) {
  $2 = HEAPU8[$1 + 7 | 0];
 } else {
  $2 = 8;
 }
 HEAP16[$0 + 4 >> 1] = get_bits($3, $2);
 label$3 : {
  if (HEAPU16[$1 + 4 >> 1] == 65535) {
   HEAP32[$1 + 12 >> 2] = 5;
   break label$3;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP16[$0 + 4 >> 1] = HEAPU16[$1 + 4 >> 1] | HEAPU16[$0 + 4 >> 1];
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP16[$0 + 4 >> 1] = HEAPU16[$0 + 4 >> 1] + 1;
  HEAP32[$1 + 12 >> 2] = 6;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jsvObjectSetChild($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 label$1 : {
  if (!(jsvHasChildren(HEAP32[$3 + 24 >> 2]) & 1)) {
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = jsvFindChildFromString(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], 1);
  if (!HEAP32[$3 + 12 >> 2]) {
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  jsvSetValueOfName(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 16 >> 2]);
  jsvUnLock(HEAP32[$3 + 12 >> 2]);
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 16 >> 2];
 }
 global$0 = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}
function tflite___28anonymous_20namespace_29__CalculateActivationRangeQuantizedImpl_28TfLiteFusedActivation_2c_20int_2c_20int_2c_20TfLiteTensor__2c_20int__2c_20int__29__$_0__operator_28_29_28float_29_20const($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAPF32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 $3 = HEAP32[$0 + 4 >> 2];
 $1 = float_20tflite__TfLiteRound_float__28float_29(Math_fround(HEAPF32[$2 + 8 >> 2] / HEAPF32[$0 >> 2]));
 label$1 : {
  if (Math_fround(Math_abs($1)) < Math_fround(2147483648)) {
   $0 = ~~$1;
   break label$1;
  }
  $0 = -2147483648;
 }
 global$0 = $2 + 16 | 0;
 return $0 + $3 | 0;
}
function st_flush_bit_buffer($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1 : {
  if (HEAPU8[HEAP32[$2 + 8 >> 2] + 14 | 0] == 128) {
   HEAP32[$2 + 12 >> 2] = 9;
   break label$1;
  }
  if (can_take_byte(HEAP32[$2 + 4 >> 2])) {
   $1 = HEAPU8[HEAP32[$2 + 8 >> 2] + 13 | 0];
   $4 = HEAP32[HEAP32[$2 + 4 >> 2] >> 2];
   $3 = HEAP32[HEAP32[$2 + 4 >> 2] + 8 >> 2];
   $0 = HEAP32[$3 >> 2];
   HEAP32[$3 >> 2] = $0 + 1;
   HEAP8[$0 + $4 | 0] = $1;
   HEAP32[$2 + 12 >> 2] = 9;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = 8;
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function unsigned_20char_20flatbuffers__Table__GetField_unsigned_20char__28unsigned_20short_2c_20unsigned_20char_29_20const($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 HEAP8[$2 + 9 | 0] = 0;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP16[$2 + 6 >> 1] = flatbuffers__Table__GetOptionalFieldOffset_28unsigned_20short_29_20const($0, HEAPU16[$2 + 10 >> 1]);
 label$1 : {
  if (HEAPU16[$2 + 6 >> 1]) {
   $0 = unsigned_20char_20flatbuffers__ReadScalar_unsigned_20char__28void_20const__29($0 + HEAPU16[$2 + 6 >> 1] | 0);
   break label$1;
  }
  $0 = HEAPU8[$2 + 9 | 0];
 }
 global$0 = $2 + 16 | 0;
 return $0 & 255;
}
function jsvMathsOpSkipNames($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 HEAP32[$3 + 16 >> 2] = jsvSkipName(HEAP32[$3 + 28 >> 2]);
 HEAP32[$3 + 12 >> 2] = jsvSkipName(HEAP32[$3 + 24 >> 2]);
 HEAP32[$3 + 8 >> 2] = jsvGetValueOf(HEAP32[$3 + 16 >> 2]);
 HEAP32[$3 + 4 >> 2] = jsvGetValueOf(HEAP32[$3 + 12 >> 2]);
 jsvUnLock2(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 12 >> 2]);
 HEAP32[$3 >> 2] = jsvMathsOp(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], HEAP32[$3 + 20 >> 2]);
 jsvUnLock2(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 global$0 = $3 + 32 | 0;
 return HEAP32[$3 >> 2];
}
function isIDString($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!(isAlpha(HEAP8[HEAP32[$1 + 8 >> 2]]) & 1)) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  while (1) {
   if (HEAPU8[HEAP32[$1 + 8 >> 2]]) {
    label$5 : {
     if (isAlpha(HEAP8[HEAP32[$1 + 8 >> 2]]) & 1) {
      break label$5;
     }
     if (isNumeric(HEAP8[HEAP32[$1 + 8 >> 2]]) & 1) {
      break label$5;
     }
     HEAP8[$1 + 15 | 0] = 0;
     break label$1;
    }
    HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP8[$1 + 15 | 0] = 1;
 }
 global$0 = $1 + 16 | 0;
 return HEAP8[$1 + 15 | 0] & 1;
}
function jspSetException($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvFindChildFromString(HEAP32[80546], 79595, 1);
 if (HEAP32[$1 + 8 >> 2]) {
  jsvSetValueOfName(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2]);
  jsvUnLock(HEAP32[$1 + 8 >> 2]);
 }
 HEAP32[80549] = HEAP32[80549] | 32;
 if (HEAP32[35539]) {
  HEAP32[$1 + 4 >> 2] = jsvObjectGetChild(HEAP32[80546], 79602, 27);
  if (HEAP32[$1 + 4 >> 2]) {
   jsvAppendPrintf(HEAP32[$1 + 4 >> 2], 79609, 0);
   jspAppendStackTrace(HEAP32[$1 + 4 >> 2]);
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
   HEAP32[80549] = HEAP32[80549] | 128;
  }
 }
 global$0 = $1 + 16 | 0;
}
function signed_20char_20flatbuffers__Table__GetField_signed_20char__28unsigned_20short_2c_20signed_20char_29_20const($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 HEAP8[$2 + 9 | 0] = 0;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP16[$2 + 6 >> 1] = flatbuffers__Table__GetOptionalFieldOffset_28unsigned_20short_29_20const($0, HEAPU16[$2 + 10 >> 1]);
 label$1 : {
  if (HEAPU16[$2 + 6 >> 1]) {
   $0 = signed_20char_20flatbuffers__ReadScalar_signed_20char__28void_20const__29($0 + HEAPU16[$2 + 6 >> 1] | 0);
   break label$1;
  }
  $0 = HEAPU8[$2 + 9 | 0];
 }
 global$0 = $2 + 16 | 0;
 return $0 << 24 >> 24;
}
function jsvNewArray($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = jsvNewWithFlags(3);
 label$1 : {
  if (!HEAP32[$2 + 16 >> 2]) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = 0;
  while (1) {
   if (HEAP32[$2 + 12 >> 2] < HEAP32[$2 + 20 >> 2]) {
    jsvArrayPush(HEAP32[$2 + 16 >> 2], HEAP32[HEAP32[$2 + 24 >> 2] + (HEAP32[$2 + 12 >> 2] << 2) >> 2]);
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 16 >> 2];
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function jswrap_onewire_write($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 HEAP8[$3 + 6 | 0] = onewire_getpin(HEAP32[$3 + 12 >> 2]);
 label$1 : {
  if (!(jshIsPinValid(HEAPU8[$3 + 6 | 0]) & 1)) {
   break label$1;
  }
  jsvIterateCallback(HEAP32[$3 + 8 >> 2], 563, $3 + 6 | 0);
  if (HEAP8[$3 + 7 | 0] & 1) {
   jshPinSetValue(HEAPU8[$3 + 6 | 0], 1);
   jshPinSetState(HEAPU8[$3 + 6 | 0], 1);
   break label$1;
  }
  jshPinSetState(HEAPU8[$3 + 6 | 0], 4);
  jshPinSetValue(HEAPU8[$3 + 6 | 0], 1);
 }
 global$0 = $3 + 16 | 0;
}
function flatbuffers__Vector_int__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_int__20const___28unsigned_20short_29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP16[$2 + 8 >> 1] = flatbuffers__Table__GetOptionalFieldOffset_28unsigned_20short_29_20const($0, HEAPU16[$2 + 10 >> 1]);
 HEAP32[$2 + 4 >> 2] = $0 + HEAPU16[$2 + 8 >> 1];
 label$1 : {
  if (HEAPU16[$2 + 8 >> 1]) {
   $0 = HEAP32[$2 + 4 >> 2] + flatbuffers__Vector_int___size_28_29_20const(HEAP32[$2 + 4 >> 2]) | 0;
   break label$1;
  }
  $0 = 0;
 }
 global$0 = $2 + 16 | 0;
 return $0;
}
function signed_20char_20const__20std____2__min_signed_20char_2c_20std____2____less_signed_20char_2c_20signed_20char__20__28signed_20char_20const__2c_20signed_20char_20const__2c_20std____2____less_signed_20char_2c_20signed_20char__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 4 >> 2] = $0;
 HEAP32[$2 >> 2] = $1;
 label$1 : {
  if (std____2____less_signed_20char_2c_20signed_20char___operator_28_29_28signed_20char_20const__2c_20signed_20char_20const__29_20const($2 + 8 | 0, HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]) & 1) {
   $0 = HEAP32[$2 >> 2];
   break label$1;
  }
  $0 = HEAP32[$2 + 4 >> 2];
 }
 global$0 = $2 + 16 | 0;
 return $0;
}
function signed_20char_20const__20std____2__max_signed_20char_2c_20std____2____less_signed_20char_2c_20signed_20char__20__28signed_20char_20const__2c_20signed_20char_20const__2c_20std____2____less_signed_20char_2c_20signed_20char__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 4 >> 2] = $0;
 HEAP32[$2 >> 2] = $1;
 label$1 : {
  if (std____2____less_signed_20char_2c_20signed_20char___operator_28_29_28signed_20char_20const__2c_20signed_20char_20const__29_20const($2 + 8 | 0, HEAP32[$2 + 4 >> 2], HEAP32[$2 >> 2]) & 1) {
   $0 = HEAP32[$2 >> 2];
   break label$1;
  }
  $0 = HEAP32[$2 + 4 >> 2];
 }
 global$0 = $2 + 16 | 0;
 return $0;
}
function wrapAround($0, $1) {
 $0 = +$0;
 $1 = +$1;
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = global$0 - 32 | 0;
 HEAPF64[$2 + 16 >> 3] = $0;
 HEAPF64[$2 + 8 >> 3] = $1;
 label$1 : {
  if (HEAPF64[$2 + 8 >> 3] < 0) {
   HEAPF64[$2 + 24 >> 3] = 0;
   break label$1;
  }
  HEAPF64[$2 + 16 >> 3] = HEAPF64[$2 + 16 >> 3] / HEAPF64[$2 + 8 >> 3];
  $4 = $2;
  $1 = HEAPF64[$2 + 16 >> 3];
  $0 = HEAPF64[$2 + 16 >> 3];
  label$3 : {
   if (Math_abs($0) < 2147483648) {
    $3 = ~~$0;
    break label$3;
   }
   $3 = -2147483648;
  }
  HEAPF64[$4 + 16 >> 3] = $1 - +($3 | 0);
  HEAPF64[$2 + 24 >> 3] = HEAPF64[$2 + 16 >> 3] * HEAPF64[$2 + 8 >> 3];
 }
 return +HEAPF64[$2 + 24 >> 3];
}
function i2c_get_address($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 HEAP8[HEAP32[$2 + 4 >> 2]] = 1;
 label$1 : {
  if (jsvIsObject(HEAP32[$2 + 8 >> 2]) & 1) {
   HEAP32[$2 >> 2] = jsvObjectGetChild(HEAP32[$2 + 8 >> 2], 125922, 0);
   if (HEAP32[$2 >> 2]) {
    $0 = jsvGetBoolAndUnLock(HEAP32[$2 >> 2]);
    HEAP8[HEAP32[$2 + 4 >> 2]] = $0 & 1;
   }
   HEAP32[$2 + 12 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$2 + 8 >> 2], 125927, 0));
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jsvGetInteger(HEAP32[$2 + 8 >> 2]);
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function jspeParseFunctionCallBrackets() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 label$1 : {
  if (!(jslMatch(40) & 1)) {
   break label$1;
  }
  while (1) {
   if (HEAP32[80549] & 80 ? 0 : HEAP16[HEAP32[35539] + 2 >> 1] != 41) {
    jsvUnLock(__jspeAssignmentExpression(jspeConditionalExpression()));
    if (HEAP16[HEAP32[35539] + 2 >> 1] == 162) {
     jsvUnLock(jspeArrowFunction(0, 0));
    }
    if (HEAP16[HEAP32[35539] + 2 >> 1] != 41) {
     if (!(jslMatch(44) & 1)) {
      break label$1;
     }
    }
    continue;
   }
   break;
  }
  if (!(HEAP32[80549] & 80)) {
   jslMatch(41);
  }
 }
 HEAP8[$0 + 15 | 0] = 0;
 global$0 = $0 + 16 | 0;
}
function gemmlowp__FixedPoint_int_2c_200__20gemmlowp__AddSaturatingIf16Bit_int_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 $3 = $2 + 8 | 0;
 HEAP32[$2 + 16 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 24 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29(int_20gemmlowp__AddSaturatingIf16Bit_int__28int_2c_20int_29(HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($2 + 16 | 0) >> 2], HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($3) >> 2]));
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 24 >> 2];
}
function jswrap_date_setMonth($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $3 = global$0 + -64 | 0;
 global$0 = $3;
 HEAP32[$3 + 60 >> 2] = $0;
 HEAP32[$3 + 56 >> 2] = $1;
 HEAP32[$3 + 52 >> 2] = $2;
 getTimeFromDateVar($3 + 24 | 0, HEAP32[$3 + 60 >> 2], 0);
 getCalendarDate($3, HEAP32[$3 + 24 >> 2]);
 HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 56 >> 2];
 if (jsvIsNumeric(HEAP32[$3 + 52 >> 2]) & 1) {
  HEAP32[$3 + 4 >> 2] = jsvGetInteger(HEAP32[$3 + 52 >> 2]);
 }
 $0 = $3 + 24 | 0;
 HEAP32[$3 + 24 >> 2] = fromCalenderDate($3);
 $4 = jswrap_date_setTime(HEAP32[$3 + 60 >> 2], fromTimeInDay($0));
 global$0 = $3 - -64 | 0;
 return +$4;
}
function _jswrap_error_constructor($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 HEAP32[$2 >> 2] = jspNewObject(0, HEAP32[$2 + 4 >> 2]);
 label$1 : {
  if (!HEAP32[$2 >> 2]) {
   HEAP32[$2 + 12 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$2 + 8 >> 2]) {
   HEAP32[$2 + 8 >> 2] = jsvAsString(HEAP32[$2 + 8 >> 2]);
   jsvObjectSetChildAndUnLock(HEAP32[$2 >> 2], 119919, HEAP32[$2 + 8 >> 2]);
  }
  jsvObjectSetChildAndUnLock(HEAP32[$2 >> 2], 119927, jsvNewFromString(HEAP32[$2 + 4 >> 2]));
  HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function jsiChangeToHistory($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 15 | 0] = $0;
 HEAP32[$1 + 8 >> 2] = jsiGetHistoryLine(HEAP8[$1 + 15 | 0] & 1);
 label$1 : {
  if (HEAP32[$1 + 8 >> 2]) {
   jsiReplaceInputLine(HEAP32[$1 + 8 >> 2]);
   jsvUnLock(HEAP32[$1 + 8 >> 2]);
   HEAP8[322241] = 1;
   break label$1;
  }
  if (!(HEAP8[$1 + 15 | 0] & 1)) {
   if (jsiShowInputLine() & 1) {
    jsiMoveCursorChar(HEAP32[80557], HEAP32[80559], 0);
    jsiConsolePrintString(81039);
   }
   jsiInputLineCursorMoved();
   jsvUnLock(HEAP32[80557]);
   HEAP32[80557] = jsvNewWithFlags(27);
   HEAP32[80559] = 0;
  }
 }
 global$0 = $1 + 16 | 0;
}
function graphicsSetVar($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = jsvFindChildFromString(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 108415, 1);
 HEAP32[$1 + 4 >> 2] = jsvSkipName(HEAP32[$1 + 8 >> 2]);
 if (!HEAP32[$1 + 4 >> 2]) {
  HEAP32[$1 + 4 >> 2] = jsvNewStringOfLength(44, 0);
  jsvSetValueOfName(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 4 >> 2]);
 }
 jsvUnLock(HEAP32[$1 + 8 >> 2]);
 jsvSetString(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 12 >> 2] + 4 | 0, 44);
 jsvUnLock(HEAP32[$1 + 4 >> 2]);
 global$0 = $1 + 16 | 0;
}
function jsvNewNativeFunction($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP16[$2 + 6 >> 1] = $1;
 HEAP32[$2 >> 2] = jsvNewWithFlags(71);
 label$1 : {
  if (!HEAP32[$2 >> 2]) {
   HEAP32[$2 + 12 >> 2] = 0;
   break label$1;
  }
  $0 = HEAP32[$2 >> 2];
  $1 = HEAP32[$2 + 8 >> 2];
  HEAP8[$0 | 0] = $1;
  HEAP8[$0 + 1 | 0] = $1 >>> 8;
  HEAP8[$0 + 2 | 0] = $1 >>> 16;
  HEAP8[$0 + 3 | 0] = $1 >>> 24;
  $0 = HEAP32[$2 >> 2];
  $1 = HEAPU16[$2 + 6 >> 1];
  HEAP8[$0 + 4 | 0] = $1;
  HEAP8[$0 + 5 | 0] = $1 >>> 8;
  HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function int_sqrt32($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 HEAP32[$1 + 28 >> 2] = $0;
 HEAP16[$1 + 26 >> 1] = 0;
 HEAP16[$1 + 24 >> 1] = 32768;
 HEAP32[$1 + 20 >> 2] = 0;
 while (1) {
  if (HEAP32[$1 + 20 >> 2] < 16) {
   HEAP16[$1 + 18 >> 1] = HEAPU16[$1 + 26 >> 1] | HEAPU16[$1 + 24 >> 1];
   HEAP32[$1 + 12 >> 2] = Math_imul(HEAPU16[$1 + 18 >> 1], HEAPU16[$1 + 18 >> 1]);
   if (HEAPU32[$1 + 28 >> 2] >= HEAPU32[$1 + 12 >> 2]) {
    HEAP16[$1 + 26 >> 1] = HEAPU16[$1 + 18 >> 1];
   }
   HEAP16[$1 + 24 >> 1] = HEAPU16[$1 + 24 >> 1] >> 1;
   HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 20 >> 2] + 1;
   continue;
  }
  break;
 }
 return HEAPU16[$1 + 26 >> 1];
}
function jshPopIOEvent($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (HEAPU8[322306] == HEAPU8[322307]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  $2 = Math_imul(HEAPU8[322307], 5) + 322896 | 0;
  $3 = HEAPU8[$2 | 0] | HEAPU8[$2 + 1 | 0] << 8 | (HEAPU8[$2 + 2 | 0] << 16 | HEAPU8[$2 + 3 | 0] << 24);
  HEAP8[$0 | 0] = $3;
  HEAP8[$0 + 1 | 0] = $3 >>> 8;
  HEAP8[$0 + 2 | 0] = $3 >>> 16;
  HEAP8[$0 + 3 | 0] = $3 >>> 24;
  HEAP8[$0 + 4 | 0] = HEAPU8[$2 + 4 | 0];
  HEAP8[322307] = HEAPU8[322307] + 1;
  HEAP8[$1 + 15 | 0] = 1;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}
function espruino_snprintf_va($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 global$0 = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP32[$4 >> 2] = HEAP32[$4 + 28 >> 2];
 HEAP32[$4 + 4 >> 2] = 0;
 HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 24 >> 2];
 vcbprintf(8, $4, HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2]);
 label$1 : {
  if (HEAPU32[$4 + 4 >> 2] < HEAPU32[$4 + 8 >> 2]) {
   HEAP8[HEAP32[$4 >> 2] + HEAP32[$4 + 4 >> 2] | 0] = 0;
   break label$1;
  }
  HEAP8[HEAP32[$4 >> 2] + (HEAP32[$4 + 8 >> 2] - 1 | 0) | 0] = 0;
 }
 global$0 = $4 + 32 | 0;
 return HEAP32[$4 + 4 >> 2];
}
function tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 global$0 = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 label$1 : {
  if ((tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2]) | 0) != (tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2]) | 0)) {
   break label$1;
  }
 }
 $0 = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2]);
 global$0 = $4 + 16 | 0;
 return $0;
}
function gemmlowp__FixedPoint_int_2c_200__20gemmlowp__RoundingHalfSum_int_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 $3 = $2 + 8 | 0;
 HEAP32[$2 + 16 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 24 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29(int_20gemmlowp__RoundingHalfSum_int__28int_2c_20int_29(HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($2 + 16 | 0) >> 2], HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($3) >> 2]));
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 24 >> 2];
}
function jsiExecuteEventCallbackName($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 global$0 = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP8[$4 + 15 | 0] = 0;
 if (jsvHasChildren(HEAP32[$4 + 28 >> 2]) & 1) {
  HEAP32[$4 + 8 >> 2] = jsvObjectGetChild(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2], 0);
  if (HEAP32[$4 + 8 >> 2]) {
   jsiExecuteEventCallback(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2]);
   HEAP8[$4 + 15 | 0] = 1;
  }
  jsvUnLock(HEAP32[$4 + 8 >> 2]);
 }
 global$0 = $4 + 32 | 0;
 return HEAP8[$4 + 15 | 0] & 1;
}
function tflite__SimpleMemoryAllocator__SimpleMemoryAllocator_28tflite__ErrorReporter__2c_20unsigned_20char__2c_20unsigned_20long_29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 global$0 = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 $0 = HEAP32[$4 + 12 >> 2];
 tflite__SimpleMemoryAllocator__SimpleMemoryAllocator_28tflite__ErrorReporter__2c_20unsigned_20char__2c_20unsigned_20char__29($0, HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 + 4 >> 2] + HEAP32[$4 >> 2] | 0);
 global$0 = $4 + 16 | 0;
 return $0 | 0;
}
function jsvArrayBufferIteratorGetFloatValue($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 20 >> 2] = $0;
 label$1 : {
  if (!HEAPU16[HEAP32[$1 + 20 >> 2] + 36 >> 1]) {
   HEAPF64[$1 + 24 >> 3] = 0;
   break label$1;
  }
  jsvArrayBufferIteratorGetValueData(HEAP32[$1 + 20 >> 2], $1 + 12 | 0);
  if (HEAPU16[HEAP32[$1 + 20 >> 2] + 36 >> 1] & 32) {
   HEAPF64[$1 + 24 >> 3] = jsvArrayBufferIteratorDataToFloat(HEAP32[$1 + 20 >> 2], $1 + 12 | 0);
   break label$1;
  }
  HEAPF64[$1 + 24 >> 3] = jsvArrayBufferIteratorDataToInt(HEAP32[$1 + 20 >> 2], $1 + 12 | 0) | 0;
 }
 global$0 = $1 + 32 | 0;
 return HEAPF64[$1 + 24 >> 3];
}
function jslGetTokenValueAsVar() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 label$1 : {
  if (HEAP32[HEAP32[35539] + 76 >> 2]) {
   HEAP32[$0 + 12 >> 2] = jsvLockAgain(HEAP32[HEAP32[35539] + 76 >> 2]);
   break label$1;
  }
  if (!(HEAP16[HEAP32[35539] + 2 >> 1] < 163 | HEAP16[HEAP32[35539] + 2 >> 1] > 198)) {
   HEAP32[$0 + 12 >> 2] = jsvNewFromString(jslReservedWordAsString(HEAP16[HEAP32[35539] + 2 >> 1]));
   break label$1;
  }
  HEAP8[HEAPU8[HEAP32[35539] + 80 | 0] + (HEAP32[35539] + 12 | 0) | 0] = 0;
  HEAP32[$0 + 12 >> 2] = jsvNewFromString(HEAP32[35539] + 12 | 0);
 }
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}
function jsvObjectSetChildVar($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 label$1 : {
  if (!(jsvHasChildren(HEAP32[$3 + 24 >> 2]) & 1)) {
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = jsvFindChildFromVar(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], 1);
  if (!HEAP32[$3 + 12 >> 2]) {
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  jsvSetValueOfName(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 16 >> 2]);
  jsvUnLock(HEAP32[$3 + 12 >> 2]);
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 16 >> 2];
 }
 global$0 = $3 + 32 | 0;
}
function tflite__MicroAllocator__Create_28tflite__SimpleMemoryAllocator__2c_20tflite__ErrorReporter__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 label$1 : {
  if (!HEAP32[$2 + 12 >> 2]) {
   break label$1;
  }
 }
 label$2 : {
  if (!HEAP32[$2 + 8 >> 2]) {
   break label$2;
  }
 }
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 + 4 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 12 >> 2]]($0, 24, 4);
 $0 = HEAP32[$2 + 4 >> 2];
 FUNCTION_TABLE[612]($0, HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]) | 0;
 HEAP32[$2 >> 2] = $0;
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 >> 2];
}
function graphicsFillRect($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0;
 $6 = global$0 - 32 | 0;
 global$0 = $6;
 $7 = $6 + 16 | 0;
 $8 = $6 + 12 | 0;
 HEAP32[$6 + 28 >> 2] = $0;
 HEAP32[$6 + 24 >> 2] = $1;
 HEAP32[$6 + 20 >> 2] = $2;
 HEAP32[$6 + 16 >> 2] = $3;
 HEAP32[$6 + 12 >> 2] = $4;
 HEAP32[$6 + 8 >> 2] = $5;
 graphicsToDeviceCoordinates(HEAP32[$6 + 28 >> 2], $6 + 24 | 0, $6 + 20 | 0);
 graphicsToDeviceCoordinates(HEAP32[$6 + 28 >> 2], $7, $8);
 graphicsFillRectDevice(HEAP32[$6 + 28 >> 2], HEAP32[$6 + 24 >> 2], HEAP32[$6 + 20 >> 2], HEAP32[$6 + 16 >> 2], HEAP32[$6 + 12 >> 2], HEAP32[$6 + 8 >> 2]);
 global$0 = $6 + 32 | 0;
}
function jsvMoreFreeVariablesThan() {
 var $0 = 0, $1 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 8 >> 2] = 600;
 label$1 : {
  if (!HEAP32[$0 + 8 >> 2]) {
   HEAP8[$0 + 15 | 0] = 0;
   break label$1;
  }
  HEAP16[$0 + 6 >> 1] = HEAPU16[71084];
  while (1) {
   if (HEAPU16[$0 + 6 >> 1]) {
    $1 = HEAP32[$0 + 8 >> 2];
    HEAP32[$0 + 8 >> 2] = $1 + -1;
    if (!$1) {
     HEAP8[$0 + 15 | 0] = 1;
     break label$1;
    }
    HEAP16[$0 + 6 >> 1] = jsvGetNextSibling(jsvGetAddressOf(HEAPU16[$0 + 6 >> 1]));
    continue;
   }
   break;
  }
  HEAP8[$0 + 15 | 0] = 0;
 }
 global$0 = $0 + 16 | 0;
 return HEAP8[$0 + 15 | 0] & 1;
}
function jsserialCheckForCharacter($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAPU8[HEAP32[$1 + 12 >> 2] + 88 | 0] >= HEAPU8[HEAP32[$1 + 12 >> 2] + 89 | 0]) {
  HEAP32[$1 + 8 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 84 >> 2] >>> 1 & 255;
  if (HEAPU8[HEAP32[$1 + 12 >> 2] + 64 | 0] < 64) {
   $3 = HEAP32[$1 + 8 >> 2];
   $0 = HEAP32[$1 + 12 >> 2];
   $2 = HEAPU8[$0 + 64 | 0];
   HEAP8[$0 + 64 | 0] = $2 + 1;
   HEAP8[$0 + $2 | 0] = $3;
   jshHasEvents();
  }
  HEAP8[HEAP32[$1 + 12 >> 2] + 88 | 0] = 0;
  HEAP32[HEAP32[$1 + 12 >> 2] + 84 >> 2] = 0;
 }
 global$0 = $1 + 16 | 0;
}
function bool_20std____2__operator___TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20const__2c_20std__nullptr_t_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = 0;
 $0 = std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator_20bool_28_29_20const(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return $0 & 1;
}
function unsigned_20int_20flatbuffers__Table__GetField_unsigned_20int__28unsigned_20short_2c_20unsigned_20int_29_20const($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP16[$3 + 10 >> 1] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 HEAP16[$3 + 2 >> 1] = flatbuffers__Table__GetOptionalFieldOffset_28unsigned_20short_29_20const($0, HEAPU16[$3 + 10 >> 1]);
 label$1 : {
  if (HEAPU16[$3 + 2 >> 1]) {
   $0 = flatbuffers__Vector_int___size_28_29_20const($0 + HEAPU16[$3 + 2 >> 1] | 0);
   break label$1;
  }
  $0 = HEAP32[$3 + 4 >> 2];
 }
 global$0 = $3 + 16 | 0;
 return $0;
}
function gemmlowp__FixedPoint_int_2c_205__20gemmlowp__operator__int_2c_205__28gemmlowp__FixedPoint_int_2c_205__2c_20gemmlowp__FixedPoint_int_2c_205__29_1($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 $3 = $2 + 8 | 0;
 HEAP32[$2 + 16 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 24 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29(int_20gemmlowp__BitAnd_int__28int_2c_20int_29(HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($2 + 16 | 0) >> 2], HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($3) >> 2]));
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 24 >> 2];
}
function gemmlowp__FixedPoint_int_2c_2012__20gemmlowp__operator__int_2c_2012__28gemmlowp__FixedPoint_int_2c_2012__2c_20gemmlowp__FixedPoint_int_2c_2012__29($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 $3 = $2 + 8 | 0;
 HEAP32[$2 + 16 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 24 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29(int_20gemmlowp__Add_int__28int_2c_20int_29(HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($2 + 16 | 0) >> 2], HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($3) >> 2]));
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 24 >> 2];
}
function float_20flatbuffers__Table__GetField_float__28unsigned_20short_2c_20float_29_20const($0) {
 var $1 = 0, $2 = Math_fround(0);
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP16[$1 + 10 >> 1] = 4;
 HEAPF32[$1 + 4 >> 2] = 0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP16[$1 + 2 >> 1] = flatbuffers__Table__GetOptionalFieldOffset_28unsigned_20short_29_20const($0, HEAPU16[$1 + 10 >> 1]);
 label$1 : {
  if (HEAPU16[$1 + 2 >> 1]) {
   $2 = float_20flatbuffers__ReadScalar_float__28void_20const__29($0 + HEAPU16[$1 + 2 >> 1] | 0);
   break label$1;
  }
  $2 = HEAPF32[$1 + 4 >> 2];
 }
 global$0 = $1 + 16 | 0;
 return $2;
}
function jswrap_graphics_setFont12x20($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 if (HEAP32[$2 + 24 >> 2] < 1) {
  HEAP32[$2 + 24 >> 2] = 1;
 }
 HEAP32[$2 + 20 >> 2] = jsvNewNativeString(113840, 4723);
 HEAP32[$2 + 16 >> 2] = jsvNewNativeString(118576, 224);
 HEAP32[$2 + 12 >> 2] = jswrap_graphics_setFontCustom(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 20 >> 2], 32, HEAP32[$2 + 16 >> 2], (HEAP32[$2 + 24 >> 2] << 8) + 20 | 0);
 jsvUnLock2(HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2]);
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function jswrap_graphics_setFont6x15($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 if (HEAP32[$2 + 24 >> 2] < 1) {
  HEAP32[$2 + 24 >> 2] = 1;
 }
 HEAP32[$2 + 20 >> 2] = jsvNewNativeString(111600, 2001);
 HEAP32[$2 + 16 >> 2] = jsvNewNativeString(113616, 223);
 HEAP32[$2 + 12 >> 2] = jswrap_graphics_setFontCustom(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 20 >> 2], 32, HEAP32[$2 + 16 >> 2], (HEAP32[$2 + 24 >> 2] << 8) + 15 | 0);
 jsvUnLock2(HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2]);
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function st_yield_br_length($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1 : {
  if (can_take_byte(HEAP32[$2 + 4 >> 2])) {
   if ((push_outgoing_bits(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]) & 255) > 0) {
    HEAP32[$2 + 12 >> 2] = 6;
    break label$1;
   }
   $0 = HEAP32[$2 + 8 >> 2];
   HEAP16[$0 + 2 >> 1] = HEAPU16[HEAP32[$2 + 8 >> 2] + 4 >> 1] + HEAPU16[$0 + 2 >> 1];
   HEAP16[HEAP32[$2 + 8 >> 2] + 4 >> 1] = 0;
   HEAP32[$2 + 12 >> 2] = 2;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = 6;
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function jswrap_array_shift($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 HEAP32[$1 + 24 >> 2] = jsvNewFromInteger(1);
 HEAP32[$1 + 20 >> 2] = jsvNewWithFlags(3);
 HEAP32[$1 + 16 >> 2] = jswrap_array_splice(HEAP32[$1 + 28 >> 2], 0, HEAP32[$1 + 24 >> 2], HEAP32[$1 + 20 >> 2]);
 jsvUnLock2(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 24 >> 2]);
 HEAP32[$1 + 12 >> 2] = 0;
 if (jsvIsArray(HEAP32[$1 + 16 >> 2]) & 1) {
  HEAP32[$1 + 12 >> 2] = jsvSkipNameAndUnLock(jsvArrayPop(HEAP32[$1 + 16 >> 2]));
 }
 jsvUnLock(HEAP32[$1 + 16 >> 2]);
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function heatshrink_decoder_reset($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = 256;
 HEAP32[$1 + 4 >> 2] = 32;
 memset(HEAP32[$1 + 12 >> 2] + 13 | 0, 0, HEAP32[$1 + 8 >> 2] + HEAP32[$1 + 4 >> 2] | 0);
 HEAP8[HEAP32[$1 + 12 >> 2] + 10 | 0] = 0;
 HEAP16[HEAP32[$1 + 12 >> 2] >> 1] = 0;
 HEAP16[HEAP32[$1 + 12 >> 2] + 2 >> 1] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 12 | 0] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 11 | 0] = 0;
 HEAP16[HEAP32[$1 + 12 >> 2] + 4 >> 1] = 0;
 HEAP16[HEAP32[$1 + 12 >> 2] + 6 >> 1] = 0;
 HEAP16[HEAP32[$1 + 12 >> 2] + 8 >> 1] = 0;
 global$0 = $1 + 16 | 0;
}
function jswrap_btoa_encode($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] & 63;
 label$1 : {
  if (HEAP32[$1 + 8 >> 2] < 26) {
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2] + 65;
   break label$1;
  }
  if (HEAP32[$1 + 8 >> 2] < 52) {
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2] + 71;
   break label$1;
  }
  if (HEAP32[$1 + 8 >> 2] < 62) {
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2] + -4;
   break label$1;
  }
  if (HEAP32[$1 + 8 >> 2] == 62) {
   HEAP32[$1 + 12 >> 2] = 43;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 47;
 }
 return HEAP32[$1 + 12 >> 2];
}
function jsiHandlePageUpDown($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP8[$1 + 31 | 0] = $0;
 jsvGetLineAndCol(HEAP32[80557], HEAP32[80559], $1 + 20 | 0, $1 + 24 | 0);
 label$1 : {
  if (!(HEAP8[$1 + 31 | 0] & 1)) {
   HEAP32[80559] = 0;
   break label$1;
  }
  HEAP32[80559] = jsvGetStringLength(HEAP32[80557]);
 }
 HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 24 >> 2];
 HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 20 >> 2];
 jsvGetLineAndCol(HEAP32[80557], HEAP32[80559], $1 + 12 | 0, $1 + 16 | 0);
 jsiMoveCursor(HEAP32[$1 + 24 >> 2], HEAP32[$1 + 20 >> 2], HEAP32[$1 + 16 >> 2], HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 32 | 0;
}
function jspeSkipBlock() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 12 >> 2] = 1;
 while (1) {
  label$2 : {
   if (!(HEAP16[HEAP32[35539] + 2 >> 1] ? HEAP32[$0 + 12 >> 2] != 0 : 0)) {
    break label$2;
   }
   label$5 : {
    if (HEAP16[HEAP32[35539] + 2 >> 1] == 123) {
     HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
     break label$5;
    }
    if (HEAP16[HEAP32[35539] + 2 >> 1] == 125) {
     HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + -1;
     if (!HEAP32[$0 + 12 >> 2]) {
      break label$2;
     }
    }
   }
   jslGetNextToken();
   continue;
  }
  break;
 }
 global$0 = $0 + 16 | 0;
}
function jshPushIOCharEvent($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
 label$1 : {
  if (jshPushIOCharEventHandler(HEAPU8[$2 + 15 | 0], HEAP8[$2 + 14 | 0]) & 1) {
   break label$1;
  }
  if (jshPushIOCharEventAppend(HEAPU8[$2 + 15 | 0], HEAP8[$2 + 14 | 0]) & 1) {
   break label$1;
  }
  HEAP8[$2 + 8 | 0] = HEAPU8[$2 + 15 | 0];
  HEAP8[$2 + 8 | 0] = HEAPU8[$2 + 8 | 0] & 159;
  HEAP8[$2 + 9 | 0] = HEAPU8[$2 + 14 | 0];
  jshPushEvent($2 + 8 | 0);
  jshPushIOCharEventFlowControl(HEAPU8[$2 + 15 | 0]);
 }
 global$0 = $2 + 16 | 0;
}
function jsvArrayPush($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = jsvGetArrayLength(HEAP32[$2 + 24 >> 2]);
 HEAP32[$2 + 12 >> 2] = jsvMakeIntoVariableName(jsvNewFromInteger(HEAP32[$2 + 16 >> 2]), HEAP32[$2 + 20 >> 2]);
 label$1 : {
  if (!HEAP32[$2 + 12 >> 2]) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  jsvAddName(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 12 >> 2]);
  jsvUnLock(HEAP32[$2 + 12 >> 2]);
  HEAP32[$2 + 28 >> 2] = jsvGetArrayLength(HEAP32[$2 + 24 >> 2]);
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function jslIsToken($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = 1;
 HEAP32[$1 >> 2] = HEAP32[$1 + 4 >> 2];
 label$1 : {
  while (1) {
   if (HEAP32[$1 >> 2] < HEAPU8[HEAP32[35539] + 80 | 0]) {
    if (HEAP8[HEAP32[$1 >> 2] + (HEAP32[35539] + 12 | 0) | 0] != HEAP8[HEAP32[$1 + 8 >> 2] + HEAP32[$1 >> 2] | 0]) {
     HEAP8[$1 + 15 | 0] = 0;
     break label$1;
    } else {
     HEAP32[$1 >> 2] = HEAP32[$1 >> 2] + 1;
     continue;
    }
   }
   break;
  }
  HEAP8[$1 + 15 | 0] = !HEAP8[HEAP32[$1 + 8 >> 2] + HEAPU8[HEAP32[35539] + 80 | 0] | 0];
 }
 return HEAP8[$1 + 15 | 0] & 1;
}
function jswrap_arguments() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 8 >> 2] = 0;
 if (HEAP32[80547]) {
  HEAP32[$0 + 8 >> 2] = jsvGetLastArrayItem(HEAP32[80547]);
 }
 label$2 : {
  if (!(jsvIsFunction(HEAP32[$0 + 8 >> 2]) & 1)) {
   jsExceptionHere(1, 121203, 0);
   HEAP32[$0 + 12 >> 2] = 0;
   break label$2;
  }
  HEAP32[$0 + 4 >> 2] = jsvGetFunctionArgumentLength(HEAP32[$0 + 8 >> 2]);
  jsvObjectSetChild(HEAP32[$0 + 8 >> 2], 121255, HEAP32[$0 + 4 >> 2]);
  jsvUnLock(HEAP32[$0 + 8 >> 2]);
  HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 4 >> 2];
 }
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}
function heatshrink_encoder_reset($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = 512;
 memset(HEAP32[$1 + 12 >> 2] + 15 | 0, 0, HEAP32[$1 + 8 >> 2]);
 HEAP16[HEAP32[$1 + 12 >> 2] >> 1] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 12 | 0] = 0;
 HEAP16[HEAP32[$1 + 12 >> 2] + 2 >> 1] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 11 | 0] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 14 | 0] = 128;
 HEAP8[HEAP32[$1 + 12 >> 2] + 13 | 0] = 0;
 HEAP16[HEAP32[$1 + 12 >> 2] + 4 >> 1] = 0;
 HEAP16[HEAP32[$1 + 12 >> 2] + 8 >> 1] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 10 | 0] = 0;
 global$0 = $1 + 16 | 0;
}
function espruino_snprintf_cb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
 while (1) {
  if (HEAPU8[HEAP32[$2 + 12 >> 2]]) {
   if (HEAPU32[HEAP32[$2 + 4 >> 2] + 4 >> 2] < HEAPU32[HEAP32[$2 + 4 >> 2] + 8 >> 2]) {
    HEAP8[HEAP32[HEAP32[$2 + 4 >> 2] >> 2] + HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] | 0] = HEAPU8[HEAP32[$2 + 12 >> 2]];
   }
   $0 = HEAP32[$2 + 4 >> 2];
   HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + 1;
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
}
function gemmlowp__FixedPoint_int_2c_205__20gemmlowp__operator__int_2c_205__28gemmlowp__FixedPoint_int_2c_205__2c_20gemmlowp__FixedPoint_int_2c_205__29($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 $3 = $2 + 8 | 0;
 HEAP32[$2 + 16 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 24 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29(_jswrap_arraybufferview_sort_int(HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($2 + 16 | 0) >> 2], HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($3) >> 2]));
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 24 >> 2];
}
function jsvIteratorFree($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[HEAP32[$1 + 12 >> 2] >> 2] + -1 | 0;
 label$1 : {
  if ($0 >>> 0 > 3) {
   break label$1;
  }
  label$2 : {
   switch ($0 - 1 | 0) {
   case 2:
    jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2]);
   case 0:
    jsvObjectIteratorFree(HEAP32[$1 + 12 >> 2] + 4 | 0);
    break label$1;
   default:
    jsvStringIteratorFree(HEAP32[$1 + 12 >> 2] + 4 | 0);
    break label$1;
   case 1:
    break label$2;
   }
  }
  jsvArrayBufferIteratorFree(HEAP32[$1 + 12 >> 2] + 4 | 0);
 }
 global$0 = $1 + 16 | 0;
}
function std____2____compressed_pair_elem_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_2c_201_2c_20false_____compressed_pair_elem_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_2c_20void__28tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[HEAP32[$2 + 12 >> 2] >> 2] = HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(HEAP32[$2 + 8 >> 2]) >> 2];
 global$0 = $2 + 16 | 0;
}
function fputc($0) {
 var $1 = 0;
 if (HEAP32[$0 + 76 >> 2] < 0) {
  label$2 : {
   if (HEAP8[$0 + 75 | 0] == 10) {
    break label$2;
   }
   $1 = HEAP32[$0 + 20 >> 2];
   if ($1 >>> 0 >= HEAPU32[$0 + 16 >> 2]) {
    break label$2;
   }
   HEAP32[$0 + 20 >> 2] = $1 + 1;
   HEAP8[$1 | 0] = 10;
   return;
  }
  __overflow($0);
  return;
 }
 label$3 : {
  label$4 : {
   if (HEAP8[$0 + 75 | 0] == 10) {
    break label$4;
   }
   $1 = HEAP32[$0 + 20 >> 2];
   if ($1 >>> 0 >= HEAPU32[$0 + 16 >> 2]) {
    break label$4;
   }
   HEAP32[$0 + 20 >> 2] = $1 + 1;
   HEAP8[$1 | 0] = 10;
   break label$3;
  }
  __overflow($0);
 }
}
function lcdMemLCD_setCallbacks($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP8[$0 + 52 | 0] = 551;
 HEAP8[$0 + 53 | 0] = 2;
 HEAP8[$0 + 54 | 0] = 0;
 HEAP8[$0 + 55 | 0] = 0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP8[$0 + 56 | 0] = 550;
 HEAP8[$0 + 57 | 0] = 2;
 HEAP8[$0 + 58 | 0] = 0;
 HEAP8[$0 + 59 | 0] = 0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP8[$0 + 60 | 0] = 549;
 HEAP8[$0 + 61 | 0] = 2;
 HEAP8[$0 + 62 | 0] = 0;
 HEAP8[$0 + 63 | 0] = 0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP8[$0 + 68 | 0] = 548;
 HEAP8[$0 + 69 | 0] = 2;
 HEAP8[$0 + 70 | 0] = 0;
 HEAP8[$0 + 71 | 0] = 0;
}
function frexp($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 wasm2js_scratch_store_f64(+$0);
 $2 = wasm2js_scratch_load_i32(1) | 0;
 $3 = wasm2js_scratch_load_i32(0) | 0;
 $4 = $2;
 $2 = $2 >>> 20 & 2047;
 if (($2 | 0) != 2047) {
  if (!$2) {
   $2 = $1;
   if ($0 == 0) {
    $1 = 0;
   } else {
    $0 = frexp($0 * 0x10000000000000000, $1);
    $1 = HEAP32[$1 >> 2] + -64 | 0;
   }
   HEAP32[$2 >> 2] = $1;
   return $0;
  }
  HEAP32[$1 >> 2] = $2 + -1022;
  $1 = $4 & -2146435073 | 1071644672;
  wasm2js_scratch_store_i32(0, $3 | 0);
  wasm2js_scratch_store_i32(1, $1 | 0);
  $0 = +wasm2js_scratch_load_f64();
 }
 return $0;
}
function jsvSetArrayItem($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 HEAP32[$3 >> 2] = jsvGetArrayIndex(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
 label$1 : {
  if (HEAP32[$3 >> 2]) {
   jsvSetValueOfName(HEAP32[$3 >> 2], HEAP32[$3 + 4 >> 2]);
   break label$1;
  }
  HEAP32[$3 >> 2] = jsvMakeIntoVariableName(jsvNewFromInteger(HEAP32[$3 + 8 >> 2]), HEAP32[$3 + 4 >> 2]);
  if (HEAP32[$3 >> 2]) {
   jsvAddName(HEAP32[$3 + 12 >> 2], HEAP32[$3 >> 2]);
  }
 }
 jsvUnLock(HEAP32[$3 >> 2]);
 global$0 = $3 + 16 | 0;
}
function jsvReplaceWithOrAddToRoot($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 label$1 : {
  if (jsvGetRefs(HEAP32[$2 + 12 >> 2]) & 255) {
   break label$1;
  }
  if (!(jsvIsName(HEAP32[$2 + 12 >> 2]) & 1)) {
   break label$1;
  }
  label$2 : {
   if (jsvIsArrayBufferName(HEAP32[$2 + 12 >> 2]) & 1) {
    break label$2;
   }
   if (jsvIsNewChild(HEAP32[$2 + 12 >> 2]) & 1) {
    break label$2;
   }
   jsvAddName(HEAP32[80545], HEAP32[$2 + 12 >> 2]);
  }
 }
 jsvReplaceWith(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
}
function tflite__internal__ContextHelper__RequestScratchBufferInArena_28TfLiteContext__2c_20unsigned_20long_2c_20int__29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 HEAP32[$3 >> 2] = HEAP32[HEAP32[$3 + 12 >> 2] + 12 >> 2];
 $0 = tflite__MicroAllocator__RequestScratchBufferInArena_28int_2c_20unsigned_20long_2c_20int__29(HEAP32[HEAP32[$3 >> 2] >> 2], HEAP32[HEAP32[$3 >> 2] + 16 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function jsvExecuteSetter($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 label$1 : {
  if (!(jsvIsGetterOrSetter(HEAP32[$3 + 8 >> 2]) & 1)) {
   break label$1;
  }
  HEAP32[$3 >> 2] = jsvObjectGetChild(HEAP32[$3 + 8 >> 2], 78608, 0);
  if (!(jsvIsFunction(HEAP32[$3 >> 2]) & 1)) {
   jsvUnLock(HEAP32[$3 >> 2]);
   break label$1;
  }
  if (!HEAP32[$3 >> 2]) {
   break label$1;
  }
  jsvUnLock2(jspExecuteFunction(HEAP32[$3 >> 2], HEAP32[$3 + 12 >> 2], 1, $3 + 4 | 0), HEAP32[$3 >> 2]);
 }
 global$0 = $3 + 16 | 0;
}
function jslReservedWordAsString($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = 0;
 HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 12 >> 2] - 138;
 while (1) {
  if (HEAP32[$1 + 4 >> 2] > 0 ? HEAPU32[$1 + 8 >> 2] < 300 : 0) {
   while (1) {
    if (HEAP8[HEAP32[$1 + 8 >> 2] + 77456 | 0] ? HEAPU32[$1 + 8 >> 2] < 300 : 0) {
     HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
   HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + -1;
   continue;
  }
  break;
 }
 return HEAP32[$1 + 8 >> 2] + 77456 | 0;
}
function jsfGetAddressOfNextPage($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 label$1 : {
  if (!(jshFlashGetPage(HEAP32[$1 + 24 >> 2], $1 + 20 | 0, $1 + 16 | 0) & 1)) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsfGetBankEndAddress(HEAP32[$1 + 24 >> 2]);
  HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 20 >> 2] + HEAP32[$1 + 16 >> 2];
  if (HEAPU32[$1 + 24 >> 2] >= HEAPU32[$1 + 12 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 24 >> 2];
 }
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}
function i2c_initstruct($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP8[HEAP32[$2 + 12 >> 2] + 1 | 0] = HEAPU8[HEAP32[$2 + 8 >> 2] + 5 | 0];
 HEAP8[HEAP32[$2 + 12 >> 2]] = HEAPU8[HEAP32[$2 + 8 >> 2] + 4 | 0];
 HEAP8[HEAP32[$2 + 12 >> 2] + 2 | 0] = HEAP8[HEAP32[$2 + 8 >> 2] + 6 | 0] & 1;
 $0 = HEAP32[$2 + 8 >> 2];
 HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2] = 25e4 / (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24));
 HEAP32[HEAP32[$2 + 12 >> 2] + 8 >> 2] = HEAP8[HEAP32[$2 + 8 >> 2] + 7 | 0] & 1 ? 1e5 : 0;
}
function mbedtls_sha1_processR($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[HEAP32[$2 + 12 >> 2] + ((HEAP32[$2 + 8 >> 2] & 15) << 2) >> 2] ^ (HEAP32[HEAP32[$2 + 12 >> 2] + ((HEAP32[$2 + 8 >> 2] - 14 & 15) << 2) >> 2] ^ (HEAP32[HEAP32[$2 + 12 >> 2] + ((HEAP32[$2 + 8 >> 2] - 3 & 15) << 2) >> 2] ^ HEAP32[HEAP32[$2 + 12 >> 2] + ((HEAP32[$2 + 8 >> 2] - 8 & 15) << 2) >> 2]));
 $0 = HEAP32[$2 + 4 >> 2] << 1 | HEAP32[$2 + 4 >> 2] >>> 31;
 HEAP32[HEAP32[$2 + 12 >> 2] + ((HEAP32[$2 + 8 >> 2] & 15) << 2) >> 2] = $0;
 return $0;
}
function jshUSARTInitInfo($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP8[$0 | 0] = 9600;
 HEAP8[$0 + 1 | 0] = 37;
 HEAP8[$0 + 2 | 0] = 0;
 HEAP8[$0 + 3 | 0] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 4 | 0] = 255;
 HEAP8[HEAP32[$1 + 12 >> 2] + 5 | 0] = 255;
 HEAP8[HEAP32[$1 + 12 >> 2] + 6 | 0] = 255;
 HEAP8[HEAP32[$1 + 12 >> 2] + 7 | 0] = 255;
 HEAP8[HEAP32[$1 + 12 >> 2] + 8 | 0] = 8;
 HEAP8[HEAP32[$1 + 12 >> 2] + 9 | 0] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 10 | 0] = 1;
 HEAP8[HEAP32[$1 + 12 >> 2] + 11 | 0] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 12 | 0] = 0;
}
function tflite__SimpleMemoryAllocator__SimpleMemoryAllocator_28tflite__ErrorReporter__2c_20unsigned_20char__2c_20unsigned_20char__29($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 $0 = HEAP32[$4 + 12 >> 2];
 HEAP32[$0 >> 2] = 128792;
 HEAP32[$0 + 4 >> 2] = HEAP32[$4 + 8 >> 2];
 HEAP32[$0 + 8 >> 2] = HEAP32[$4 + 4 >> 2];
 HEAP32[$0 + 12 >> 2] = HEAP32[$4 >> 2];
 HEAP32[$0 + 16 >> 2] = HEAP32[$4 + 4 >> 2];
 HEAP32[$0 + 20 >> 2] = HEAP32[$4 >> 2];
 HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 8 >> 2];
}
function jswrap_banglejs_dbg() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 8 >> 2] = jsvNewWithFlags(5);
 label$1 : {
  if (!HEAP32[$0 + 8 >> 2]) {
   HEAP32[$0 + 12 >> 2] = 0;
   break label$1;
  }
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 8 >> 2], 110994, jsvNewFromInteger(HEAPU8[336770]));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 8 >> 2], 111008, jsvNewFromInteger(HEAPU8[336936]));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 8 >> 2], 111024, jsvNewFromInteger(HEAPU8[336937]));
  HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 8 >> 2];
 }
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}
function jshFlashErasePage($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 if (jshFlashGetPage(HEAP32[$1 + 28 >> 2], $1 + 24 | 0, $1 + 20 | 0) & 1) {
  HEAP32[$1 + 16 >> 2] = 0;
  while (1) {
   if (HEAPU32[$1 + 16 >> 2] < HEAPU32[$1 + 20 >> 2]) {
    HEAP8[$1 + 14 | 0] = 105;
    HEAP8[$1 + 15 | 0] = 0;
    HEAP32[$1 >> 2] = (HEAP32[$1 + 24 >> 2] + HEAP32[$1 + 16 >> 2] | 0) + -134217728;
    emscripten_asm_const_iii(109769, $1 + 14 | 0, $1 | 0) | 0;
    HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 16 >> 2] + 1;
    continue;
   }
   break;
  }
 }
 global$0 = $1 + 32 | 0;
}
function int_20gemmlowp__SelectUsingMask_int__28int_2c_20int_2c_20int_29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $1 = int_20gemmlowp__BitAnd_int__28int_2c_20int_29(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
 $2 = int_20gemmlowp__BitAnd_int__28int_2c_20int_29(int_20gemmlowp__BitNot_int__28int_29(HEAP32[$3 + 12 >> 2]), HEAP32[$3 + 4 >> 2]);
 $0 = global$0 - 16 | 0;
 HEAP32[$0 + 12 >> 2] = $1;
 HEAP32[$0 + 8 >> 2] = $2;
 global$0 = $3 + 16 | 0;
 return HEAP32[$0 + 12 >> 2] ^ HEAP32[$0 + 8 >> 2];
}
function jswrap_banglejs_setLCDBrightness($0) {
 $0 = +$0;
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAPF64[$1 + 8 >> 3] = $0;
 $3 = $1;
 $0 = HEAPF64[$1 + 8 >> 3] * 256 + .5;
 label$1 : {
  if (Math_abs($0) < 2147483648) {
   $2 = ~~$0;
   break label$1;
  }
  $2 = -2147483648;
 }
 HEAP32[$3 + 4 >> 2] = $2;
 if (HEAP32[$1 + 4 >> 2] < 0) {
  HEAP32[$1 + 4 >> 2] = 0;
 }
 if (HEAP32[$1 + 4 >> 2] > 255) {
  HEAP32[$1 + 4 >> 2] = 255;
 }
 HEAP8[336668] = HEAP32[$1 + 4 >> 2];
 if (HEAP32[84152] & 32768) {
  jswrap_banglejs_setLCDPowerBacklight(1);
 }
 global$0 = $1 + 16 | 0;
}
function tflite___28anonymous_20namespace_29__CheckParsePointerParams_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 label$1 : {
  if (!HEAP32[$4 + 12 >> 2]) {
   break label$1;
  }
 }
 label$2 : {
  if (!HEAP32[$4 + 8 >> 2]) {
   break label$2;
  }
 }
 label$3 : {
  if (!HEAP32[$4 + 4 >> 2]) {
   break label$3;
  }
 }
 label$4 : {
  if (!HEAP32[$4 >> 2]) {
   break label$4;
  }
 }
}
function jshSPIInitInfo($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP8[$0 | 0] = 1e5;
 HEAP8[$0 + 1 | 0] = 390;
 HEAP8[$0 + 2 | 0] = 1;
 HEAP8[$0 + 3 | 0] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 4 | 0] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 5 | 0] = 255;
 HEAP8[HEAP32[$1 + 12 >> 2] + 6 | 0] = 255;
 HEAP8[HEAP32[$1 + 12 >> 2] + 7 | 0] = 255;
 HEAP8[HEAP32[$1 + 12 >> 2] + 8 | 0] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 9 | 0] = 1;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP8[$0 + 10 | 0] = 8;
 HEAP8[$0 + 11 | 0] = 0;
 HEAP8[$0 + 12 | 0] = 0;
 HEAP8[$0 + 13 | 0] = 0;
}
function st_yield_br_index($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1 : {
  if (can_take_byte(HEAP32[$2 + 4 >> 2])) {
   if ((push_outgoing_bits(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]) & 255) > 0) {
    HEAP32[$2 + 12 >> 2] = 5;
    break label$1;
   }
   HEAP16[HEAP32[$2 + 8 >> 2] + 8 >> 1] = HEAPU16[HEAP32[$2 + 8 >> 2] + 4 >> 1] - 1;
   HEAP8[HEAP32[$2 + 8 >> 2] + 10 | 0] = 6;
   HEAP32[$2 + 12 >> 2] = 6;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = 5;
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function jsvAsName($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  if (!(jsvGetRefs(HEAP32[$1 + 8 >> 2]) & 255)) {
   if (!(jsvIsName(HEAP32[$1 + 8 >> 2]) & 1)) {
    HEAP32[$1 + 8 >> 2] = jsvMakeIntoVariableName(HEAP32[$1 + 8 >> 2], 0);
   }
   HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[$1 + 8 >> 2]);
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvMakeIntoVariableName(jsvCopy(HEAP32[$1 + 8 >> 2], 0), 0);
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function tflite__micro__GetMutableEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 label$1 : {
  if (!HEAP32[$3 + 12 >> 2]) {
   break label$1;
  }
 }
 label$2 : {
  if (!HEAP32[$3 + 8 >> 2]) {
   break label$2;
  }
 }
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$3 + 12 >> 2] + 84 >> 2]](HEAP32[$3 + 12 >> 2], HEAP32[(HEAP32[HEAP32[$3 + 8 >> 2] >> 2] + 4 | 0) + (HEAP32[$3 + 4 >> 2] << 2) >> 2]) | 0;
 global$0 = $3 + 16 | 0;
 return $0;
}
function jspeFactorTypeOf() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 jslGetNextToken();
 HEAP32[$0 + 12 >> 2] = jspeUnaryExpression();
 HEAP32[$0 + 8 >> 2] = 0;
 if ((HEAP32[80549] & 63) == 1) {
  label$2 : {
   if (!(jsvIsVariableDefined(HEAP32[$0 + 12 >> 2]) & 1)) {
    HEAP32[$0 + 8 >> 2] = jsvNewFromString(80211);
    break label$2;
   }
   HEAP32[$0 + 12 >> 2] = jsvSkipNameAndUnLock(HEAP32[$0 + 12 >> 2]);
   HEAP32[$0 + 8 >> 2] = jsvNewFromString(jsvGetTypeOf(HEAP32[$0 + 12 >> 2]));
  }
 }
 jsvUnLock(HEAP32[$0 + 12 >> 2]);
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 8 >> 2];
}
function jsvAddressToVar($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1 : {
  if (HEAPU32[$2 + 4 >> 2] <= 0) {
   HEAP32[$2 + 12 >> 2] = jsvNewWithFlags(27);
   break label$1;
  }
  HEAP32[$2 >> 2] = jshFlashGetMemMapAddress(HEAP32[$2 + 8 >> 2]);
  if (!HEAP32[$2 >> 2]) {
   HEAP32[$2 + 12 >> 2] = jsvNewFlashString(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jsvNewNativeString(HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]);
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function jswrap_array_indexOf($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 HEAP32[$3 + 12 >> 2] = jsvGetIndexOfFull(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], 0, 1, HEAP32[$3 + 16 >> 2]);
 label$1 : {
  if (!HEAP32[$3 + 12 >> 2]) {
   HEAP32[$3 + 28 >> 2] = jsvNewFromInteger(-1);
   break label$1;
  }
  HEAP32[$3 + 28 >> 2] = jsvNewFromInteger(jsvGetIntegerAndUnLock(HEAP32[$3 + 12 >> 2]));
 }
 global$0 = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}
function jsvStringIteratorGoto($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 label$1 : {
  if (HEAPU32[$3 + 4 >> 2] >= HEAPU32[HEAP32[$3 + 12 >> 2] + 8 >> 2]) {
   HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = HEAP32[$3 + 4 >> 2] - HEAP32[HEAP32[$3 + 12 >> 2] + 8 >> 2];
   jsvStringIteratorCatchUp(HEAP32[$3 + 12 >> 2]);
   break label$1;
  }
  jsvStringIteratorFree(HEAP32[$3 + 12 >> 2]);
  jsvStringIteratorNew(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 }
 global$0 = $3 + 16 | 0;
}
function memcpy_circular($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP32[$4 + 12 >> 2] = 32;
 while (1) {
  $0 = HEAP32[$4 + 12 >> 2];
  HEAP32[$4 + 12 >> 2] = $0 + -1;
  if ($0) {
   $0 = HEAP32[$4 + 16 >> 2];
   HEAP32[$4 + 16 >> 2] = $0 + 1;
   HEAP8[HEAP32[$4 + 28 >> 2] + HEAP32[HEAP32[$4 + 24 >> 2] >> 2] | 0] = HEAPU8[$0 | 0];
   HEAP32[HEAP32[$4 + 24 >> 2] >> 2] = (HEAP32[HEAP32[$4 + 24 >> 2] >> 2] + 1 >>> 0) % HEAPU32[$4 + 20 >> 2];
   continue;
  }
  break;
 }
}
function std____2__vector_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29__2c_20std____2__allocator_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29__20__20___vector_28_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 std____2____vector_base_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29__2c_20std____2__allocator_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29__20__20_____vector_base_28_29(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
}
function jswrap_waveform_stop($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[$1 + 11 | 0] = jsvGetBoolAndUnLock(jsvObjectGetChild(HEAP32[$1 + 12 >> 2], 126056, 0)) & 1;
 label$1 : {
  if (!(HEAP8[$1 + 11 | 0] & 1)) {
   jsExceptionHere(1, 126278, 0);
   break label$1;
  }
  HEAP32[$1 + 4 >> 2] = jswrap_waveform_getBuffer(HEAP32[$1 + 12 >> 2], 0, 0);
  if (!(jstStopBufferTimerTask(HEAP32[$1 + 4 >> 2]) & 1)) {
   jsExceptionHere(1, 126113, 0);
  }
  jsvUnLock(HEAP32[$1 + 4 >> 2]);
  jswrap_waveform_idle();
 }
 global$0 = $1 + 16 | 0;
}
function jsiAtEndOfInputLine() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 8 >> 2] = HEAP32[80559];
 HEAP32[$0 + 4 >> 2] = jsvGetStringLength(HEAP32[80557]);
 label$1 : {
  while (1) {
   if (HEAPU32[$0 + 8 >> 2] < HEAPU32[$0 + 4 >> 2]) {
    if (isWhitespace(jsvGetCharInString(HEAP32[80557], HEAP32[$0 + 8 >> 2]) << 24 >> 24) & 1) {
     HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 8 >> 2] + 1;
     continue;
    } else {
     HEAP8[$0 + 15 | 0] = 0;
     break label$1;
    }
   }
   break;
  }
  HEAP8[$0 + 15 | 0] = 1;
 }
 global$0 = $0 + 16 | 0;
 return HEAP8[$0 + 15 | 0] & 1;
}
function jsvArrayBufferIteratorIntToData($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 if (HEAP32[$4 + 4 >> 2] & 64) {
  if (HEAP32[$4 >> 2] < 0) {
   HEAP32[$4 >> 2] = 0;
  }
  if (HEAP32[$4 >> 2] > 255) {
   HEAP32[$4 >> 2] = 255;
  }
 }
 label$4 : {
  if (HEAP32[$4 + 8 >> 2] == 8) {
   $0 = HEAP32[$4 + 12 >> 2];
   $1 = HEAP32[$4 >> 2];
   HEAP32[$0 >> 2] = $1;
   HEAP32[$0 + 4 >> 2] = $1 >> 31;
   break label$4;
  }
  HEAP32[HEAP32[$4 + 12 >> 2] >> 2] = HEAP32[$4 >> 2];
 }
}
function tflite__micro__GetEvalOutput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = 0;
 label$1 : {
  if (!HEAP32[$2 + 12 >> 2]) {
   break label$1;
  }
 }
 label$2 : {
  if (!HEAP32[$2 + 8 >> 2]) {
   break label$2;
  }
 }
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$2 + 12 >> 2] + 84 >> 2]](HEAP32[$2 + 12 >> 2], HEAP32[(HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] + 4 | 0) + (HEAP32[$2 + 4 >> 2] << 2) >> 2]) | 0;
 global$0 = $2 + 16 | 0;
 return $0;
}
function jswrap_espruino_toUint8Array($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 80 | 0;
 global$0 = $1;
 HEAP32[$1 + 72 >> 2] = $0;
 HEAP32[$1 + 68 >> 2] = jsvNewTypedArray(1, jsvIterateCallbackCount(HEAP32[$1 + 72 >> 2]));
 label$1 : {
  if (!HEAP32[$1 + 68 >> 2]) {
   HEAP32[$1 + 76 >> 2] = 0;
   break label$1;
  }
  $0 = $1 + 8 | 0;
  jsvArrayBufferIteratorNew($0, HEAP32[$1 + 68 >> 2], 0);
  jsvIterateCallback(HEAP32[$1 + 72 >> 2], 560, $0);
  jsvArrayBufferIteratorFree($0);
  HEAP32[$1 + 76 >> 2] = HEAP32[$1 + 68 >> 2];
 }
 global$0 = $1 + 80 | 0;
 return HEAP32[$1 + 76 >> 2];
}
function jsvHasChildren($0) {
 var $1 = 0, $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 $0 = jsvIsFunction(HEAP32[$2 + 12 >> 2]) & 1;
 $1 = 1;
 label$1 : {
  if ($0) {
   break label$1;
  }
  $0 = jsvIsObject(HEAP32[$2 + 12 >> 2]) & 1;
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = jsvIsArray(HEAP32[$2 + 12 >> 2]) & 1;
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = jsvIsRoot(HEAP32[$2 + 12 >> 2]) & 1;
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $1 = jsvIsGetterOrSetter(HEAP32[$2 + 12 >> 2]);
 }
 $0 = $1;
 global$0 = $2 + 16 | 0;
 return $0 & 1;
}
function tflite__SimpleMemoryAllocator__SimpleMemoryAllocator_28tflite__SimpleMemoryAllocator_20const__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$0 >> 2] = 128792;
 $1 = HEAP32[$2 + 8 >> 2];
 $2 = HEAP32[$1 + 8 >> 2];
 HEAP32[$0 + 4 >> 2] = HEAP32[$1 + 4 >> 2];
 HEAP32[$0 + 8 >> 2] = $2;
 $2 = HEAP32[$1 + 24 >> 2];
 HEAP32[$0 + 20 >> 2] = HEAP32[$1 + 20 >> 2];
 HEAP32[$0 + 24 >> 2] = $2;
 $2 = HEAP32[$1 + 16 >> 2];
 HEAP32[$0 + 12 >> 2] = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 + 16 >> 2] = $2;
}
function jsvIsIterable($0) {
 var $1 = 0, $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 $0 = jsvIsArray(HEAP32[$2 + 12 >> 2]) & 1;
 $1 = 1;
 label$1 : {
  if ($0) {
   break label$1;
  }
  $0 = jsvIsObject(HEAP32[$2 + 12 >> 2]) & 1;
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = jsvIsFunction(HEAP32[$2 + 12 >> 2]) & 1;
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $0 = jsvIsString(HEAP32[$2 + 12 >> 2]) & 1;
  $1 = 1;
  if ($0) {
   break label$1;
  }
  $1 = jsvIsArrayBuffer(HEAP32[$2 + 12 >> 2]);
 }
 $0 = $1;
 global$0 = $2 + 16 | 0;
 return $0 & 1;
}
function jswrap_stream_available($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!(jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1)) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 4 >> 2] = jsvObjectGetChild(HEAP32[$1 + 8 >> 2], 125935, 0);
  HEAP32[$1 >> 2] = 0;
  if (jsvIsString(HEAP32[$1 + 4 >> 2]) & 1) {
   HEAP32[$1 >> 2] = jsvGetStringLength(HEAP32[$1 + 4 >> 2]);
  }
  jsvUnLock(HEAP32[$1 + 4 >> 2]);
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jshFlashGetPage($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = global$0 - 16 | 0;
 HEAP32[$3 + 8 >> 2] = $0;
 HEAP32[$3 + 4 >> 2] = $1;
 HEAP32[$3 >> 2] = $2;
 label$1 : {
  if (HEAPU32[$3 + 8 >> 2] < 134217728) {
   HEAP8[$3 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$3 + 4 >> 2];
  $4 = Math_floor(+(HEAP32[$3 + 8 >> 2] >>> 12 >>> 0)) * 4096;
  label$3 : {
   if ($4 < 4294967296 & $4 >= 0) {
    $1 = ~~$4 >>> 0;
    break label$3;
   }
   $1 = 0;
  }
  HEAP32[$0 >> 2] = $1;
  HEAP32[HEAP32[$3 >> 2] >> 2] = 4096;
  HEAP8[$3 + 15 | 0] = 1;
 }
 return HEAP8[$3 + 15 | 0] & 1;
}
function jsonNewLine($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 global$0 = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 cbprintf(HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2], 122730, 0);
 HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 28 >> 2] >>> 12;
 while (1) {
  label$2 : {
   $0 = HEAP32[$4 + 12 >> 2];
   HEAP32[$4 + 12 >> 2] = $0 + -1;
   if (!$0) {
    break label$2;
   }
   cbprintf(HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2], HEAP32[$4 + 24 >> 2], 0);
   continue;
  }
  break;
 }
 global$0 = $4 + 32 | 0;
}
function jspeExpression() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 label$1 : {
  while (1) {
   if (((HEAP32[80549] & 80) != 0 ^ -1) & 1) {
    HEAP32[$0 + 8 >> 2] = __jspeAssignmentExpression(jspeConditionalExpression());
    if (HEAP16[HEAP32[35539] + 2 >> 1] != 44) {
     HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 8 >> 2];
     break label$1;
    }
    jsvCheckReferenceError(HEAP32[$0 + 8 >> 2]);
    jsvUnLock(HEAP32[$0 + 8 >> 2]);
    jslGetNextToken();
    continue;
   }
   break;
  }
  HEAP32[$0 + 12 >> 2] = 0;
 }
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}
function jsvVarPrintf($0, $1) {
 var $2 = 0;
 $2 = global$0 + -64 | 0;
 global$0 = $2;
 HEAP32[$2 + 56 >> 2] = $0;
 HEAP32[$2 + 52 >> 2] = jsvNewWithFlags(27);
 label$1 : {
  if (!HEAP32[$2 + 52 >> 2]) {
   HEAP32[$2 + 60 >> 2] = 0;
   break label$1;
  }
  $0 = $2 + 16 | 0;
  jsvStringIteratorNew($0, HEAP32[$2 + 52 >> 2], 0);
  jsvStringIteratorGotoEnd($0);
  HEAP32[$2 + 12 >> 2] = $1;
  vcbprintf(2, $0, HEAP32[$2 + 56 >> 2], HEAP32[$2 + 12 >> 2]);
  jsvStringIteratorFree($0);
  HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 52 >> 2];
 }
 global$0 = $2 - -64 | 0;
 return HEAP32[$2 + 60 >> 2];
}
function TfLiteStatus_20tflite__internal__FlatBufferVectorToTfLiteTypeArray_int_2c_20TfLiteIntArray__28tflite__SimpleMemoryAllocator__2c_20tflite__ErrorReporter__2c_20flatbuffers__Vector_int__20const__2c_20TfLiteIntArray___29($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 label$1 : {
  if (!HEAP32[$4 + 8 >> 2]) {
   break label$1;
  }
 }
 label$2 : {
  if (!HEAP32[$4 + 4 >> 2]) {
   break label$2;
  }
 }
 HEAP32[HEAP32[$4 >> 2] >> 2] = HEAP32[$4 + 4 >> 2];
 return 0;
}
function jslSeekToP($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[HEAP32[35539] + 100 >> 2]) {
  jsvLockAgain(HEAP32[HEAP32[35539] + 100 >> 2]);
 }
 jsvStringIteratorFree(HEAP32[35539] + 88 | 0);
 jsvStringIteratorClone(HEAP32[35539] + 88 | 0, HEAP32[$1 + 12 >> 2]);
 jsvUnLock(HEAP32[HEAP32[35539] + 100 >> 2]);
 HEAP8[HEAP32[35539]] = HEAPU8[HEAP32[$1 + 12 >> 2] + 36 | 0];
 HEAP32[HEAP32[35539] + 4 >> 2] = 0;
 HEAP32[HEAP32[35539] + 8 >> 2] = 0;
 HEAP16[HEAP32[35539] + 2 >> 1] = 0;
 jslGetNextToken();
 global$0 = $1 + 16 | 0;
}
function double_20const__20std____2__min_double_2c_20std____2____less_double_2c_20double__20__28double_20const__2c_20double_20const__2c_20std____2____less_double_2c_20double__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 4 >> 2] = $0;
 HEAP32[$2 >> 2] = $1;
 label$1 : {
  if (std____2____less_double_2c_20double___operator_28_29_28double_20const__2c_20double_20const__29_20const($2 + 8 | 0, HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]) & 1) {
   $0 = HEAP32[$2 >> 2];
   break label$1;
  }
  $0 = HEAP32[$2 + 4 >> 2];
 }
 global$0 = $2 + 16 | 0;
 return $0;
}
function jswrap_graphics_scroll($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 96 | 0;
 global$0 = $3;
 HEAP32[$3 + 88 >> 2] = $0;
 HEAP32[$3 + 84 >> 2] = $1;
 HEAP32[$3 + 80 >> 2] = $2;
 label$1 : {
  if (!(graphicsGetFromVar($3 + 8 | 0, HEAP32[$3 + 88 >> 2]) & 1)) {
   HEAP32[$3 + 92 >> 2] = 0;
   break label$1;
  }
  $0 = $3 + 8 | 0;
  graphicsScroll($0, HEAP32[$3 + 84 >> 2], HEAP32[$3 + 80 >> 2]);
  graphicsSetVar($0);
  HEAP32[$3 + 92 >> 2] = jsvLockAgain(HEAP32[$3 + 88 >> 2]);
 }
 global$0 = $3 + 96 | 0;
 return HEAP32[$3 + 92 >> 2];
}
function jswrap_graphics_clear($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 96 | 0;
 global$0 = $2;
 HEAP32[$2 + 88 >> 2] = $0;
 HEAP8[$2 + 87 | 0] = $1;
 if (HEAP8[$2 + 87 | 0] & 1) {
  jsvUnLock(jswrap_graphics_reset(HEAP32[$2 + 88 >> 2]));
 }
 label$2 : {
  if (!(graphicsGetFromVar($2 + 8 | 0, HEAP32[$2 + 88 >> 2]) & 1)) {
   HEAP32[$2 + 92 >> 2] = 0;
   break label$2;
  }
  $0 = $2 + 8 | 0;
  graphicsClear($0);
  graphicsSetVar($0);
  HEAP32[$2 + 92 >> 2] = jsvLockAgain(HEAP32[$2 + 88 >> 2]);
 }
 global$0 = $2 + 96 | 0;
 return HEAP32[$2 + 92 >> 2];
}
function _jswrap_io_peek($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1 : {
  if (HEAP32[$2 + 4 >> 2] == 1) {
   HEAP32[$2 + 12 >> 2] = HEAPU8[HEAP32[$2 + 8 >> 2]];
   break label$1;
  }
  if (HEAP32[$2 + 4 >> 2] == 2) {
   HEAP32[$2 + 12 >> 2] = HEAPU8[HEAP32[$2 + 8 >> 2]] | HEAPU8[HEAP32[$2 + 8 >> 2] + 1 | 0] << 8;
   break label$1;
  }
  if (HEAP32[$2 + 4 >> 2] == 4) {
   HEAP32[$2 + 12 >> 2] = HEAP32[HEAP32[$2 + 8 >> 2] >> 2];
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = 0;
 }
 return HEAP32[$2 + 12 >> 2];
}
function __fflush_unlocked($0) {
 var $1 = 0, $2 = 0;
 label$1 : {
  if (HEAPU32[$0 + 20 >> 2] <= HEAPU32[$0 + 28 >> 2]) {
   break label$1;
  }
  FUNCTION_TABLE[HEAP32[$0 + 36 >> 2]]($0, 0, 0) | 0;
  if (HEAP32[$0 + 20 >> 2]) {
   break label$1;
  }
  return -1;
 }
 $1 = HEAP32[$0 + 4 >> 2];
 $2 = HEAP32[$0 + 8 >> 2];
 if ($1 >>> 0 < $2 >>> 0) {
  $1 = $1 - $2 | 0;
  FUNCTION_TABLE[HEAP32[$0 + 40 >> 2]]($0, $1, $1 >> 31, 1) | 0;
 }
 HEAP32[$0 + 28 >> 2] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 0;
 return 0;
}
function tflite__RuntimeShape__FlatSize_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = 1;
 HEAP32[$1 + 4 >> 2] = tflite__RuntimeShape__DimsData_28_29($0);
 HEAP32[$1 >> 2] = 0;
 while (1) {
  if (HEAP32[$1 >> 2] < HEAP32[$0 >> 2]) {
   HEAP32[$1 + 8 >> 2] = Math_imul(HEAP32[HEAP32[$1 + 4 >> 2] + (HEAP32[$1 >> 2] << 2) >> 2], HEAP32[$1 + 8 >> 2]);
   HEAP32[$1 >> 2] = HEAP32[$1 >> 2] + 1;
   continue;
  }
  break;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function jsvSetString($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 + -64 | 0;
 global$0 = $3;
 HEAP32[$3 + 60 >> 2] = $0;
 HEAP32[$3 + 56 >> 2] = $1;
 HEAP32[$3 + 52 >> 2] = $2;
 jsvStringIteratorNew($3 + 16 | 0, HEAP32[$3 + 60 >> 2], 0);
 HEAP32[$3 + 12 >> 2] = 0;
 while (1) {
  if (HEAPU32[$3 + 12 >> 2] < HEAPU32[$3 + 52 >> 2]) {
   jsvStringIteratorSetCharAndNext($3 + 16 | 0, HEAP8[HEAP32[$3 + 56 >> 2] + HEAP32[$3 + 12 >> 2] | 0]);
   HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 jsvStringIteratorFree($3 + 16 | 0);
 global$0 = $3 - -64 | 0;
}
function jspGetConstructor($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = jspGetPrototype(HEAP32[$1 + 8 >> 2]);
 label$1 : {
  if (HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 >> 2] = jsvObjectGetChild(HEAP32[$1 + 4 >> 2], 80199, 0);
   if (jsvIsFunction(HEAP32[$1 >> 2]) & 1) {
    jsvUnLock(HEAP32[$1 + 4 >> 2]);
    HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
    break label$1;
   }
   jsvUnLock2(HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2]);
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jsvSetArrayLength($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP8[$2 + 7 | 0] = 0;
 label$1 : {
  if (!(HEAP8[$2 + 7 | 0] & 1)) {
   break label$1;
  }
  $0 = HEAP32[$2 + 12 >> 2];
  if (HEAP32[$2 + 8 >> 2] >= (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24))) {
   break label$1;
  }
 }
 $0 = HEAP32[$2 + 12 >> 2];
 $1 = HEAP32[$2 + 8 >> 2];
 HEAP8[$0 | 0] = $1;
 HEAP8[$0 + 1 | 0] = $1 >>> 8;
 HEAP8[$0 + 2 | 0] = $1 >>> 16;
 HEAP8[$0 + 3 | 0] = $1 >>> 24;
}
function jswrap_storage_erase($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 + -64 | 0;
 global$0 = $1;
 HEAP32[$1 + 60 >> 2] = $0;
 jsfNameFromVar($1 + 32 | 0, HEAP32[$1 + 60 >> 2]);
 HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 56 >> 2];
 $0 = HEAP32[$1 + 52 >> 2];
 HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 48 >> 2];
 HEAP32[$1 + 20 >> 2] = $0;
 $0 = HEAP32[$1 + 44 >> 2];
 HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 40 >> 2];
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 36 >> 2];
 HEAP32[$1 >> 2] = HEAP32[$1 + 32 >> 2];
 HEAP32[$1 + 4 >> 2] = $0;
 jsfEraseFile($1);
 global$0 = $1 - -64 | 0;
}
function unsigned_20char_20const__20std____2__min_unsigned_20char__28unsigned_20char_20const__2c_20unsigned_20char_20const__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = unsigned_20char_20const__20std____2__min_unsigned_20char_2c_20std____2____less_unsigned_20char_2c_20unsigned_20char__20__28unsigned_20char_20const__2c_20unsigned_20char_20const__2c_20std____2____less_unsigned_20char_2c_20unsigned_20char__29(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0;
}
function unsigned_20char_20const__20std____2__max_unsigned_20char__28unsigned_20char_20const__2c_20unsigned_20char_20const__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = unsigned_20char_20const__20std____2__max_unsigned_20char_2c_20std____2____less_unsigned_20char_2c_20unsigned_20char__20__28unsigned_20char_20const__2c_20unsigned_20char_20const__2c_20std____2____less_unsigned_20char_2c_20unsigned_20char__29(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0;
}
function float_20const__20std____2__min_float_2c_20std____2____less_float_2c_20float__20__28float_20const__2c_20float_20const__2c_20std____2____less_float_2c_20float__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 4 >> 2] = $0;
 HEAP32[$2 >> 2] = $1;
 label$1 : {
  if (std____2____less_float_2c_20float___operator_28_29_28float_20const__2c_20float_20const__29_20const($2 + 8 | 0, HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]) & 1) {
   $0 = HEAP32[$2 >> 2];
   break label$1;
  }
  $0 = HEAP32[$2 + 4 >> 2];
 }
 global$0 = $2 + 16 | 0;
 return $0;
}
function float_20const__20std____2__max_float_2c_20std____2____less_float_2c_20float__20__28float_20const__2c_20float_20const__2c_20std____2____less_float_2c_20float__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 4 >> 2] = $0;
 HEAP32[$2 >> 2] = $1;
 label$1 : {
  if (std____2____less_float_2c_20float___operator_28_29_28float_20const__2c_20float_20const__29_20const($2 + 8 | 0, HEAP32[$2 + 4 >> 2], HEAP32[$2 >> 2]) & 1) {
   $0 = HEAP32[$2 >> 2];
   break label$1;
  }
  $0 = HEAP32[$2 + 4 >> 2];
 }
 global$0 = $2 + 16 | 0;
 return $0;
}
function tflite__SimpleMemoryAllocator__GetAvailableMemory_28unsigned_20long_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = 16;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 4 >> 2] = tflite__AlignPointerUp_28unsigned_20char__2c_20unsigned_20long_29(HEAP32[$0 + 16 >> 2], HEAP32[$1 + 8 >> 2]);
 HEAP32[$1 >> 2] = tflite__AlignPointerDown_28unsigned_20char__2c_20unsigned_20long_29(HEAP32[$0 + 20 >> 2], HEAP32[$1 + 8 >> 2]);
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 >> 2] - HEAP32[$1 + 4 >> 2] | 0;
}
function jsvStringIteratorGetPtrAndNext($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 HEAP32[HEAP32[$3 + 8 >> 2] >> 2] = HEAP32[HEAP32[$3 + 12 >> 2] + 16 >> 2] + HEAP32[HEAP32[$3 + 12 >> 2] >> 2];
 HEAP32[HEAP32[$3 + 4 >> 2] >> 2] = HEAP32[HEAP32[$3 + 12 >> 2] + 4 >> 2] - HEAP32[HEAP32[$3 + 12 >> 2] >> 2];
 HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = HEAP32[HEAP32[$3 + 12 >> 2] + 4 >> 2] - 1;
 jsvStringIteratorNextInline(HEAP32[$3 + 12 >> 2]);
 global$0 = $3 + 16 | 0;
}
function jswrap_isFinite($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 HEAPF64[$1 + 16 >> 3] = jsvGetFloat(HEAP32[$1 + 28 >> 2]);
 $0 = __DOUBLE_BITS(HEAPF64[$1 + 16 >> 3]);
 $2 = i64toi32_i32$HIGH_BITS & 2147483647;
 $2 = ($2 | 0) == 2146435072 & $0 >>> 0 > 0 | $2 >>> 0 > 2146435072;
 $0 = 0;
 label$1 : {
  if ($2) {
   break label$1;
  }
  $0 = 0;
  if (HEAPF64[$1 + 16 >> 3] == infinity) {
   break label$1;
  }
  $0 = HEAPF64[$1 + 16 >> 3] != -infinity;
 }
 global$0 = $1 + 32 | 0;
 return $0 | 0;
}
function tf_invoke($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 24 >> 2];
 HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 20 >> 2];
 HEAP32[$1 + 12 >> 2] = tflite__MicroInterpreter__Invoke_28_29(HEAP32[$1 + 20 >> 2] + 400 | 0);
 label$1 : {
  if (HEAP32[$1 + 12 >> 2]) {
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$1 + 16 >> 2], 137689, 0);
   HEAP8[$1 + 31 | 0] = 0;
   break label$1;
  }
  HEAP8[$1 + 31 | 0] = 1;
 }
 global$0 = $1 + 32 | 0;
 return HEAP8[$1 + 31 | 0] & 1;
}
function chtod($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP8[$1 + 11 | 0] = $0;
 label$1 : {
  if (!(HEAP8[$1 + 11 | 0] < 48 | HEAP8[$1 + 11 | 0] > 57)) {
   HEAP32[$1 + 12 >> 2] = HEAP8[$1 + 11 | 0] - 48;
   break label$1;
  }
  if (!(HEAP8[$1 + 11 | 0] < 97 | HEAP8[$1 + 11 | 0] > 122)) {
   HEAP32[$1 + 12 >> 2] = HEAP8[$1 + 11 | 0] + -87;
   break label$1;
  }
  if (!(HEAP8[$1 + 11 | 0] < 65 | HEAP8[$1 + 11 | 0] > 90)) {
   HEAP32[$1 + 12 >> 2] = HEAP8[$1 + 11 | 0] + -55;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = -1;
 }
 return HEAP32[$1 + 12 >> 2];
}
function lcdSetPixel_ArrayBuffer_flat8($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 $0 = HEAP32[$4 + 12 >> 2];
 $1 = HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24);
 $0 = HEAP32[$4 + 12 >> 2];
 HEAP8[$1 + (HEAP32[$4 + 8 >> 2] + Math_imul(HEAP32[$4 + 4 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) | 0) | 0] = HEAP32[$4 >> 2];
}
function jswrap_date_setSeconds($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP32[$3 + 36 >> 2] = $2;
 getTimeFromDateVar($3 + 8 | 0, HEAP32[$3 + 44 >> 2], 0);
 HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 40 >> 2];
 if (jsvIsNumeric(HEAP32[$3 + 36 >> 2]) & 1) {
  HEAP32[$3 + 12 >> 2] = jsvGetInteger(HEAP32[$3 + 36 >> 2]);
 }
 $4 = jswrap_date_setTime(HEAP32[$3 + 44 >> 2], fromTimeInDay($3 + 8 | 0));
 global$0 = $3 + 48 | 0;
 return +$4;
}
function jswrap_graphics_drawCString($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = 8;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 HEAP32[$3 + 12 >> 2] = jsvNewFromString(HEAP32[$3 + 16 >> 2]);
 $0 = HEAP32[$3 + 28 >> 2];
 jsvUnLock2(jswrap_graphics_drawString(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), HEAP32[$3 + 12 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], 0), HEAP32[$3 + 12 >> 2]);
 global$0 = $3 + 32 | 0;
}
function jsiMoveCursorChar($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 if (HEAP32[$3 + 24 >> 2] != HEAP32[$3 + 20 >> 2]) {
  $0 = $3 + 4 | 0;
  $1 = $3 + 8 | 0;
  jsvGetLineAndCol(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2], $3 + 12 | 0, $3 + 16 | 0);
  jsvGetLineAndCol(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 20 >> 2], $0, $1);
  jsiMoveCursor(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 }
 global$0 = $3 + 32 | 0;
}
function jslInit($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsvLockAgain(HEAP32[$1 + 12 >> 2]);
 HEAP32[HEAP32[35539] + 84 >> 2] = $0;
 HEAP16[HEAP32[35539] + 2 >> 1] = 0;
 HEAP32[HEAP32[35539] + 4 >> 2] = 0;
 HEAP32[HEAP32[35539] + 8 >> 2] = 0;
 HEAP8[HEAP32[35539] + 80 | 0] = 0;
 HEAP32[HEAP32[35539] + 76 >> 2] = 0;
 jsvStringIteratorNew(HEAP32[35539] + 88 | 0, HEAP32[HEAP32[35539] + 84 >> 2], 0);
 jsvUnLock(HEAP32[HEAP32[35539] + 100 >> 2]);
 jslGetNextCh();
 jslGetNextToken();
 global$0 = $1 + 16 | 0;
}
function jsiFreeMoreMemory() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 jsvObjectRemoveChild(HEAP32[80546], 81555);
 HEAP32[$0 + 8 >> 2] = jsvObjectGetChild(HEAP32[80546], 81563, 0);
 label$1 : {
  if (!HEAP32[$0 + 8 >> 2]) {
   HEAP8[$0 + 15 | 0] = 0;
   break label$1;
  }
  HEAP32[$0 + 4 >> 2] = jsvArrayPopFirst(HEAP32[$0 + 8 >> 2]);
  HEAP8[$0 + 3 | 0] = HEAP32[$0 + 4 >> 2] != 0;
  jsvUnLock2(HEAP32[$0 + 4 >> 2], HEAP32[$0 + 8 >> 2]);
  HEAP8[$0 + 15 | 0] = HEAP8[$0 + 3 | 0] & 1;
 }
 global$0 = $0 + 16 | 0;
 return HEAP8[$0 + 15 | 0] & 1;
}
function _jswrap_banglejs_setVibration() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 12 >> 2] = 0;
 if (HEAP32[84152] & 64) {
  HEAP32[$0 + 12 >> 2] = HEAPU16[168371];
 }
 label$2 : {
  if (!(HEAPU8[336740] | HEAP32[$0 + 12 >> 2])) {
   jshPinOutput(19, 0);
   break label$2;
  }
  label$4 : {
   if (!HEAP32[$0 + 12 >> 2]) {
    jshPinAnalogOutput(19, .4 + +HEAPU8[336740] * .6 / 255, 1e3, 0);
    break label$4;
   }
   jshPinAnalogOutput(19, .2 + +HEAPU8[336740] * .6 / 255, +HEAP32[$0 + 12 >> 2], 0);
  }
 }
 global$0 = $0 + 16 | 0;
}
function jsvNewFromBool($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 11 | 0] = $0;
 HEAP32[$1 + 4 >> 2] = jsvNewWithFlags(11);
 label$1 : {
  if (!HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 4 >> 2];
  $2 = HEAP8[$1 + 11 | 0] & 1 ? 1 : 0;
  HEAP8[$0 | 0] = $2;
  HEAP8[$0 + 1 | 0] = $2 >>> 8;
  HEAP8[$0 + 2 | 0] = $2 >>> 16;
  HEAP8[$0 + 3 | 0] = $2 >>> 24;
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jswrap_graphics_getWidthOrHeight($0, $1) {
 var $2 = 0;
 $2 = global$0 - 96 | 0;
 global$0 = $2;
 HEAP32[$2 + 88 >> 2] = $0;
 HEAP8[$2 + 87 | 0] = $1;
 label$1 : {
  if (!(graphicsGetFromVar($2 + 8 | 0, HEAP32[$2 + 88 >> 2]) & 1)) {
   HEAP32[$2 + 92 >> 2] = 0;
   break label$1;
  }
  $0 = $2;
  label$3 : {
   if (HEAP8[$2 + 87 | 0] & 1) {
    $1 = graphicsGetHeight($2 + 8 | 0) & 65535;
    break label$3;
   }
   $1 = graphicsGetWidth($2 + 8 | 0) & 65535;
  }
  HEAP32[$0 + 92 >> 2] = $1;
 }
 global$0 = $2 + 96 | 0;
 return HEAP32[$2 + 92 >> 2];
}
function i2c_rd($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 HEAP32[$2 >> 2] = 0;
 HEAP32[$2 + 4 >> 2] = 0;
 while (1) {
  if (HEAP32[$2 + 4 >> 2] < 8) {
   HEAP32[$2 >> 2] = HEAP32[$2 >> 2] << 1 | (i2c_rd_bit(HEAP32[$2 + 12 >> 2]) & 1 ? 1 : 0);
   HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + 1;
   continue;
  }
  break;
 }
 i2c_wr_bit(HEAP32[$2 + 12 >> 2], HEAP8[$2 + 11 | 0] & 1);
 i2c_pin_wr1(HEAPU8[HEAP32[$2 + 12 >> 2] + 1 | 0]);
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 >> 2];
}
function isValidBPP($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = 1;
 label$1 : {
  if (HEAP32[$1 + 12 >> 2] == 1) {
   break label$1;
  }
  $0 = 1;
  if (HEAP32[$1 + 12 >> 2] == 2) {
   break label$1;
  }
  $0 = 1;
  if (HEAP32[$1 + 12 >> 2] == 4) {
   break label$1;
  }
  $0 = 1;
  if (HEAP32[$1 + 12 >> 2] == 8) {
   break label$1;
  }
  $0 = 1;
  if (HEAP32[$1 + 12 >> 2] == 16) {
   break label$1;
  }
  $0 = 1;
  if (HEAP32[$1 + 12 >> 2] == 24) {
   break label$1;
  }
  $0 = HEAP32[$1 + 12 >> 2] == 32;
 }
 return $0;
}
function tflite__MicroMutableOpResolver_9u___AddDepthwiseConv2D_28_29($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 48 | 0;
 global$0 = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 $0 = HEAP32[$1 + 44 >> 2];
 $2 = $1 + 8 | 0;
 tflite__ops__micro__Register_DEPTHWISE_CONV_2D_28_29($2);
 tflite__MicroMutableOpResolver_9u___AddBuiltin_28tflite__BuiltinOperator_2c_20TfLiteRegistration_20const__2c_20TfLiteStatus_20_28__29_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29_29($0, 4, $2, 663);
 global$0 = $1 + 48 | 0;
}
function jsvFindOrCreateRoot() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP16[$0 + 10 >> 1] = 1;
 label$1 : {
  while (1) {
   if (HEAPU16[$0 + 10 >> 1] <= HEAPU32[35415]) {
    if (jsvIsRoot(jsvGetAddressOf(HEAPU16[$0 + 10 >> 1])) & 1) {
     HEAP32[$0 + 12 >> 2] = jsvLock(HEAPU16[$0 + 10 >> 1]);
     break label$1;
    } else {
     HEAP16[$0 + 10 >> 1] = HEAPU16[$0 + 10 >> 1] + 1;
     continue;
    }
   }
   break;
  }
  HEAP32[$0 + 12 >> 2] = jsvRef(jsvNewWithFlags(1));
 }
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}
function tflite__internal__ContextHelper__ContextHelper_28tflite__ErrorReporter__2c_20tflite__MicroAllocator__2c_20tflite__Model_20const__29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 $0 = HEAP32[$4 + 12 >> 2];
 HEAP32[$0 >> 2] = HEAP32[$4 + 4 >> 2];
 HEAP32[$0 + 4 >> 2] = HEAP32[$4 + 8 >> 2];
 HEAP32[$0 + 8 >> 2] = HEAP32[$4 >> 2];
 HEAP32[$0 + 16 >> 2] = -1;
 return $0 | 0;
}
function tflite__MicroMutableOpResolver_9u___AddFullyConnected_28_29($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 48 | 0;
 global$0 = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 $0 = HEAP32[$1 + 44 >> 2];
 $2 = $1 + 8 | 0;
 tflite__ops__micro__Register_FULLY_CONNECTED_28_29($2);
 tflite__MicroMutableOpResolver_9u___AddBuiltin_28tflite__BuiltinOperator_2c_20TfLiteRegistration_20const__2c_20TfLiteStatus_20_28__29_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29_29($0, 9, $2, 666);
 global$0 = $1 + 48 | 0;
}
function tflite__MicroMutableOpResolver_9u___AddAveragePool2D_28_29($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 48 | 0;
 global$0 = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 $0 = HEAP32[$1 + 44 >> 2];
 $2 = $1 + 8 | 0;
 tflite__ops__micro__Register_AVERAGE_POOL_2D_28_29($2);
 tflite__MicroMutableOpResolver_9u___AddBuiltin_28tflite__BuiltinOperator_2c_20TfLiteRegistration_20const__2c_20TfLiteStatus_20_28__29_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29_29($0, 1, $2, 665);
 global$0 = $1 + 48 | 0;
}
function jsvSetCharInString($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP8[$3 + 39 | 0] = $2;
 HEAP8[$3 + 38 | 0] = 1;
 if (jsvIsString(HEAP32[$3 + 44 >> 2]) & 1) {
  jsvStringIteratorNew($3, HEAP32[$3 + 44 >> 2], HEAP32[$3 + 40 >> 2]);
  if (HEAP8[$3 + 38 | 0] & 1) {
   HEAP8[$3 + 39 | 0] = jsvStringIteratorGetChar($3) << 24 >> 24 | HEAP8[$3 + 39 | 0];
  }
  jsvStringIteratorSetChar($3, HEAP8[$3 + 39 | 0]);
  jsvStringIteratorFree($3);
 }
 global$0 = $3 + 48 | 0;
}
function jsvNewTypedArray($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP16[$2 + 26 >> 1] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = jsvNewFromInteger(HEAP32[$2 + 20 >> 2]);
 label$1 : {
  if (!HEAP32[$2 + 16 >> 2]) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jswrap_typedarray_constructor(HEAPU16[$2 + 26 >> 1], HEAP32[$2 + 16 >> 2], 0, 0);
  jsvUnLock(HEAP32[$2 + 16 >> 2]);
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function jsvNewFromInteger($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = jsvNewWithFlags(9);
 label$1 : {
  if (!HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 4 >> 2];
  $2 = HEAP32[$1 + 8 >> 2];
  HEAP8[$0 | 0] = $2;
  HEAP8[$0 + 1 | 0] = $2 >>> 8;
  HEAP8[$0 + 2 | 0] = $2 >>> 16;
  HEAP8[$0 + 3 | 0] = $2 >>> 24;
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function __overflow($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 15 | 0] = 10;
 $2 = HEAP32[$0 + 16 >> 2];
 label$1 : {
  if (!$2) {
   if (__towrite($0)) {
    break label$1;
   }
   $2 = HEAP32[$0 + 16 >> 2];
  }
  $3 = HEAP32[$0 + 20 >> 2];
  if (!(HEAP8[$0 + 75 | 0] == 10 | $3 >>> 0 >= $2 >>> 0)) {
   HEAP32[$0 + 20 >> 2] = $3 + 1;
   HEAP8[$3 | 0] = 10;
   break label$1;
  }
  if ((FUNCTION_TABLE[HEAP32[$0 + 36 >> 2]]($0, $1 + 15 | 0, 1) | 0) != 1) {
   break label$1;
  }
 }
 global$0 = $1 + 16 | 0;
}
function jsvAppendStringBuf($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 48 | 0;
 global$0 = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP32[$3 + 36 >> 2] = $2;
 jsvStringIteratorNew($3, HEAP32[$3 + 44 >> 2], 0);
 jsvStringIteratorGotoEnd($3);
 while (1) {
  if (HEAP32[$3 + 36 >> 2]) {
   $0 = HEAP32[$3 + 40 >> 2];
   HEAP32[$3 + 40 >> 2] = $0 + 1;
   jsvStringIteratorAppend($3, HEAP8[$0 | 0]);
   HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 36 >> 2] + -1;
   continue;
  }
  break;
 }
 jsvStringIteratorFree($3);
 global$0 = $3 + 48 | 0;
}
function signed_20char_20const__20std____2__min_signed_20char__28signed_20char_20const__2c_20signed_20char_20const__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = signed_20char_20const__20std____2__min_signed_20char_2c_20std____2____less_signed_20char_2c_20signed_20char__20__28signed_20char_20const__2c_20signed_20char_20const__2c_20std____2____less_signed_20char_2c_20signed_20char__29(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0;
}
function signed_20char_20const__20std____2__max_signed_20char__28signed_20char_20const__2c_20signed_20char_20const__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = signed_20char_20const__20std____2__max_signed_20char_2c_20std____2____less_signed_20char_2c_20signed_20char__20__28signed_20char_20const__2c_20signed_20char_20const__2c_20std____2____less_signed_20char_2c_20signed_20char__29(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0;
}
function int_20const__20std____2__min_int_2c_20std____2____less_int_2c_20int__20__28int_20const__2c_20int_20const__2c_20std____2____less_int_2c_20int__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 4 >> 2] = $0;
 HEAP32[$2 >> 2] = $1;
 label$1 : {
  if (std____2____less_int_2c_20int___operator_28_29_28int_20const__2c_20int_20const__29_20const($2 + 8 | 0, HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]) & 1) {
   $0 = HEAP32[$2 >> 2];
   break label$1;
  }
  $0 = HEAP32[$2 + 4 >> 2];
 }
 global$0 = $2 + 16 | 0;
 return $0;
}
function int_20const__20std____2__max_int_2c_20std____2____less_int_2c_20int__20__28int_20const__2c_20int_20const__2c_20std____2____less_int_2c_20int__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 4 >> 2] = $0;
 HEAP32[$2 >> 2] = $1;
 label$1 : {
  if (std____2____less_int_2c_20int___operator_28_29_28int_20const__2c_20int_20const__29_20const($2 + 8 | 0, HEAP32[$2 + 4 >> 2], HEAP32[$2 >> 2]) & 1) {
   $0 = HEAP32[$2 >> 2];
   break label$1;
  }
  $0 = HEAP32[$2 + 4 >> 2];
 }
 global$0 = $2 + 16 | 0;
 return $0;
}
function jsiIsInHistory($0) {
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP32[$1 + 20 >> 2] = jsiGetHistory();
 label$1 : {
  if (!HEAP32[$1 + 20 >> 2]) {
   HEAP8[$1 + 31 | 0] = 0;
   break label$1;
  }
  HEAP32[$1 + 16 >> 2] = jsvGetIndexOf(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 24 >> 2], 1);
  HEAP8[$1 + 15 | 0] = HEAP32[$1 + 16 >> 2] != 0;
  jsvUnLock2(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 20 >> 2]);
  HEAP8[$1 + 31 | 0] = HEAP8[$1 + 15 | 0] & 1;
 }
 global$0 = $1 + 32 | 0;
 return HEAP8[$1 + 31 | 0] & 1;
}
function jswrap_object_keys_or_property_names($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP8[$2 + 7 | 0] = $1;
 HEAP8[$2 + 6 | 0] = 0;
 HEAP32[$2 >> 2] = jsvNewWithFlags(3);
 label$1 : {
  if (!HEAP32[$2 >> 2]) {
   HEAP32[$2 + 12 >> 2] = 0;
   break label$1;
  }
  jswrap_object_keys_or_property_names_cb(HEAP32[$2 + 8 >> 2], HEAP8[$2 + 7 | 0] & 1, HEAP8[$2 + 6 | 0] & 1, 562, HEAP32[$2 >> 2]);
  HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function jsvAddNamedChild($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 HEAP32[$3 + 12 >> 2] = jsvMakeIntoVariableName(jsvNewFromString(HEAP32[$3 + 16 >> 2]), HEAP32[$3 + 20 >> 2]);
 label$1 : {
  if (!HEAP32[$3 + 12 >> 2]) {
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  jsvAddName(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 12 >> 2]);
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2];
 }
 global$0 = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}
function tflite__MicroMutableOpResolver_9u___AddMaxPool2D_28_29($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 48 | 0;
 global$0 = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 $0 = HEAP32[$1 + 44 >> 2];
 $2 = $1 + 8 | 0;
 tflite__ops__micro__Register_MAX_POOL_2D_28_29($2);
 tflite__MicroMutableOpResolver_9u___AddBuiltin_28tflite__BuiltinOperator_2c_20TfLiteRegistration_20const__2c_20TfLiteStatus_20_28__29_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29_29($0, 17, $2, 665);
 global$0 = $1 + 48 | 0;
}
function jswrap_pin_writeAtTime($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = +$2;
 var $3 = 0, $4 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 $4 = $3 + 15 | 0;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP8[$3 + 27 | 0] = $1;
 HEAPF64[$3 + 16 >> 3] = $2;
 HEAP8[$3 + 15 | 0] = jshGetPinFromVar(HEAP32[$3 + 28 >> 2]);
 HEAP32[$3 >> 2] = jshGetTimeFromMilliseconds(HEAPF64[$3 + 16 >> 3] * 1e3);
 HEAP32[$3 + 4 >> 2] = i64toi32_i32$HIGH_BITS;
 jstPinOutputAtTime(HEAP32[$3 >> 2], HEAP32[$3 + 4 >> 2], $4, HEAP8[$3 + 27 | 0] & 1);
 global$0 = $3 + 32 | 0;
}
function jswrap_pin_toggle($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP8[$1 + 7 | 0] = jshGetPinFromVar(HEAP32[$1 + 8 >> 2]);
 label$1 : {
  if (!(jshIsPinValid(HEAPU8[$1 + 7 | 0]) & 1)) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  HEAP8[$1 + 6 | 0] = ((jshPinGetState(HEAPU8[$1 + 7 | 0]) & 16) != 0 ^ -1) & 1;
  jshPinOutput(HEAPU8[$1 + 7 | 0], HEAP8[$1 + 6 | 0] & 1);
  HEAP8[$1 + 15 | 0] = HEAP8[$1 + 6 | 0] & 1;
 }
 global$0 = $1 + 16 | 0;
 return HEAP8[$1 + 15 | 0] & 1;
}
function jsiSetTimeout() {
 var $0 = 0;
 $0 = global$0 - 32 | 0;
 global$0 = $0;
 HEAP32[$0 + 24 >> 2] = 554;
 HEAPF64[$0 + 16 >> 3] = 500;
 HEAP32[$0 + 12 >> 2] = jsvNewNativeFunction(HEAP32[$0 + 24 >> 2], 0);
 label$1 : {
  if (!HEAP32[$0 + 12 >> 2]) {
   HEAP32[$0 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$0 + 8 >> 2] = jswrap_interface_setTimeout(HEAP32[$0 + 12 >> 2], HEAPF64[$0 + 16 >> 3], 0);
  jsvUnLock(HEAP32[$0 + 12 >> 2]);
  HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 8 >> 2];
 }
 global$0 = $0 + 32 | 0;
 return HEAP32[$0 + 28 >> 2];
}
function _jswrap_banglejs_getHealthStatusObject($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvNewWithFlags(5);
 if (HEAP32[$1 + 8 >> 2]) {
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 8 >> 2], 111578, jsvNewFromInteger(HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2] / HEAPU16[HEAP32[$1 + 12 >> 2] + 8 >> 1] | 0));
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 8 >> 2], 111587, jsvNewFromInteger(HEAPU16[HEAP32[$1 + 12 >> 2] + 10 >> 1]));
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function tflite__MicroMutableOpResolver_9u___AddDequantize_28_29($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 48 | 0;
 global$0 = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 $0 = HEAP32[$1 + 44 >> 2];
 $2 = $1 + 8 | 0;
 tflite__ops__micro__Register_DEQUANTIZE_28_29($2);
 tflite__MicroMutableOpResolver_9u___AddBuiltin_28tflite__BuiltinOperator_2c_20TfLiteRegistration_20const__2c_20TfLiteStatus_20_28__29_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29_29($0, 6, $2, 669);
 global$0 = $1 + 48 | 0;
}
function lcdInit_JS($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 jsvObjectSetChild(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 108450, HEAP32[$3 + 8 >> 2]);
 $0 = HEAP32[$3 + 12 >> 2];
 jsvObjectSetChild(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 108460, HEAP32[$3 + 4 >> 2]);
 global$0 = $3 + 16 | 0;
}
function jspeAddNamedFunctionParameter($0, $1) {
 var $2 = 0;
 $2 = global$0 - 96 | 0;
 global$0 = $2;
 HEAP32[$2 + 92 >> 2] = $0;
 HEAP32[$2 + 88 >> 2] = $1;
 if (!HEAP32[$2 + 92 >> 2]) {
  HEAP32[$2 + 92 >> 2] = jsvNewWithFlags(7);
 }
 HEAP8[$2 + 16 | 0] = 255;
 $0 = $2 + 16 | 0;
 jsvGetString(HEAP32[$2 + 88 >> 2], $0 + 1 | 0, 64);
 HEAP32[$2 + 12 >> 2] = jsvAddNamedChild(HEAP32[$2 + 92 >> 2], 0, $0);
 jsvMakeFunctionParameter(HEAP32[$2 + 12 >> 2]);
 jsvUnLock(HEAP32[$2 + 12 >> 2]);
 global$0 = $2 + 96 | 0;
 return HEAP32[$2 + 92 >> 2];
}
function tflite__MicroMutableOpResolver_9u___AddQuantize_28_29($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 48 | 0;
 global$0 = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 $0 = HEAP32[$1 + 44 >> 2];
 $2 = $1 + 8 | 0;
 tflite__ops__micro__Register_QUANTIZE_28_29($2);
 tflite__MicroMutableOpResolver_9u___AddBuiltin_28tflite__BuiltinOperator_2c_20TfLiteRegistration_20const__2c_20TfLiteStatus_20_28__29_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29_29($0, 114, $2, 668);
 global$0 = $1 + 48 | 0;
}
function jswrap_object_addEventListener($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 global$0 = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP16[$4 + 18 >> 1] = $3;
 HEAP32[$4 + 12 >> 2] = jsvNewFromString(HEAP32[$4 + 24 >> 2]);
 HEAP32[$4 + 8 >> 2] = jsvNewNativeFunction(HEAP32[$4 + 20 >> 2], HEAPU16[$4 + 18 >> 1]);
 jswrap_object_on(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2]);
 jsvUnLock2(HEAP32[$4 + 8 >> 2], HEAP32[$4 + 12 >> 2]);
 global$0 = $4 + 32 | 0;
}
function tflite__internal__ContextHelper__GetTensor_28TfLiteContext_20const__2c_20int_29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2];
 $0 = HEAP32[HEAP32[$2 + 4 >> 2] >> 2];
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 4 >> 2]]($0, HEAP32[HEAP32[$2 + 4 >> 2] + 8 >> 2], HEAP32[HEAP32[$2 + 4 >> 2] + 12 >> 2], HEAP32[$2 + 8 >> 2]) | 0;
 global$0 = $2 + 16 | 0;
 return $0 | 0;
}
function strncmp($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $3 = 23;
 $2 = 133056;
 $1 = HEAPU8[$0 | 0];
 label$1 : {
  if (!$1) {
   break label$1;
  }
  while (1) {
   label$3 : {
    $4 = HEAPU8[$2 | 0];
    if (($4 | 0) != ($1 | 0)) {
     break label$3;
    }
    $3 = $3 + -1 | 0;
    if (!$3 | !$4) {
     break label$3;
    }
    $2 = $2 + 1 | 0;
    $1 = HEAPU8[$0 + 1 | 0];
    $0 = $0 + 1 | 0;
    if ($1) {
     continue;
    }
    break label$1;
   }
   break;
  }
  $5 = $1;
 }
 return ($5 & 255) - HEAPU8[$2 | 0] | 0;
}
function jsvUnLock($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1 : {
  if (!HEAP32[$1 + 12 >> 2]) {
   break label$1;
  }
  $0 = HEAP32[$1 + 12 >> 2];
  $2 = (HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) - 512 | 0;
  HEAP8[$0 + 13 | 0] = $2;
  HEAP8[$0 + 14 | 0] = $2 >>> 8;
  $0 = HEAP32[$1 + 12 >> 2];
  if ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 7680) {
   break label$1;
  }
  jsvUnLockFreeIfNeeded(HEAP32[$1 + 12 >> 2]);
 }
 global$0 = $1 + 16 | 0;
}
function tflite__MicroMutableOpResolver_9u___AddSoftmax_28_29($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 48 | 0;
 global$0 = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 $0 = HEAP32[$1 + 44 >> 2];
 $2 = $1 + 8 | 0;
 tflite__ops__micro__Register_SOFTMAX_28_29($2);
 tflite__MicroMutableOpResolver_9u___AddBuiltin_28tflite__BuiltinOperator_2c_20TfLiteRegistration_20const__2c_20TfLiteStatus_20_28__29_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29_29($0, 25, $2, 667);
 global$0 = $1 + 48 | 0;
}
function tflite__MicroMutableOpResolver_9u___AddReshape_28_29($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 48 | 0;
 global$0 = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 $0 = HEAP32[$1 + 44 >> 2];
 $2 = $1 + 8 | 0;
 tflite__ops__micro__Register_RESHAPE_28_29($2);
 tflite__MicroMutableOpResolver_9u___AddBuiltin_28tflite__BuiltinOperator_2c_20TfLiteRegistration_20const__2c_20TfLiteStatus_20_28__29_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29_29($0, 22, $2, 670);
 global$0 = $1 + 48 | 0;
}
function jswrap_graphics_fillCircle($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 global$0 = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 $0 = jswrap_graphics_fillEllipse(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2] - HEAP32[$4 >> 2] | 0, HEAP32[$4 + 4 >> 2] - HEAP32[$4 >> 2] | 0, HEAP32[$4 + 8 >> 2] + HEAP32[$4 >> 2] | 0, HEAP32[$4 + 4 >> 2] + HEAP32[$4 >> 2] | 0);
 global$0 = $4 + 16 | 0;
 return $0 | 0;
}
function jswrap_graphics_drawCircle($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 global$0 = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 $0 = jswrap_graphics_drawEllipse(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2] - HEAP32[$4 >> 2] | 0, HEAP32[$4 + 4 >> 2] - HEAP32[$4 >> 2] | 0, HEAP32[$4 + 8 >> 2] + HEAP32[$4 >> 2] | 0, HEAP32[$4 + 4 >> 2] + HEAP32[$4 >> 2] | 0);
 global$0 = $4 + 16 | 0;
 return $0 | 0;
}
function tflite__MicroMutableOpResolver_9u___AddConv2D_28_29($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 48 | 0;
 global$0 = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 $0 = HEAP32[$1 + 44 >> 2];
 $2 = $1 + 8 | 0;
 tflite__ops__micro__Register_CONV_2D_28_29($2);
 tflite__MicroMutableOpResolver_9u___AddBuiltin_28tflite__BuiltinOperator_2c_20TfLiteRegistration_20const__2c_20TfLiteStatus_20_28__29_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29_29($0, 3, $2, 664);
 global$0 = $1 + 48 | 0;
}
function getDay($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = 0;
 label$1 : {
  while (1) {
   if (HEAP32[$1 + 4 >> 2] < 7) {
    if (strcmp(HEAP32[$1 + 8 >> 2], HEAP32[35429] + (HEAP32[$1 + 4 >> 2] << 2) | 0)) {
     HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + 1;
     continue;
    } else {
     HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
     break label$1;
    }
   }
   break;
  }
  HEAP32[$1 + 12 >> 2] = -1;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jsvGetCharInString($0, $1) {
 var $2 = 0;
 $2 = global$0 + -64 | 0;
 global$0 = $2;
 HEAP32[$2 + 56 >> 2] = $0;
 HEAP32[$2 + 52 >> 2] = $1;
 label$1 : {
  if (!(jsvIsString(HEAP32[$2 + 56 >> 2]) & 1)) {
   HEAP8[$2 + 63 | 0] = 0;
   break label$1;
  }
  $0 = $2 + 16 | 0;
  jsvStringIteratorNew($0, HEAP32[$2 + 56 >> 2], HEAP32[$2 + 52 >> 2]);
  HEAP8[$2 + 15 | 0] = jsvStringIteratorGetChar($0);
  jsvStringIteratorFree($0);
  HEAP8[$2 + 63 | 0] = HEAPU8[$2 + 15 | 0];
 }
 global$0 = $2 - -64 | 0;
 return HEAP8[$2 + 63 | 0];
}
function jsiExecuteEventCallbackOn($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 global$0 = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP32[$4 + 12 >> 2] = jsvObjectGetChild(HEAP32[80545], HEAP32[$4 + 28 >> 2], 0);
 HEAP8[$4 + 11 | 0] = jsiExecuteEventCallbackName(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2]) & 1;
 jsvUnLock(HEAP32[$4 + 12 >> 2]);
 global$0 = $4 + 32 | 0;
 return HEAP8[$4 + 11 | 0] & 1;
}
function jslMatchError($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 96 | 0;
 global$0 = $1;
 $2 = $1 + 16 | 0;
 HEAP32[$1 + 92 >> 2] = $0;
 $0 = $1 + 48 | 0;
 jslGetTokenString($0);
 jslTokenAsString(HEAP32[$1 + 92 >> 2], $2, 30);
 HEAP32[$1 + 12 >> 2] = HEAP32[HEAP32[35539] + 8 >> 2];
 HEAP32[HEAP32[35539] + 8 >> 2] = HEAP32[HEAP32[35539] + 4 >> 2];
 HEAP32[$1 + 4 >> 2] = $2;
 HEAP32[$1 >> 2] = $0;
 jsExceptionHere(2, 77977, $1);
 HEAP32[HEAP32[35539] + 8 >> 2] = HEAP32[$1 + 12 >> 2];
 jslGetNextToken();
 global$0 = $1 + 96 | 0;
}
function jsiHandleEnd() {
 var $0 = 0, $1 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 12 >> 2] = jsvGetStringLength(HEAP32[80557]);
 while (1) {
  if (HEAPU32[80559] < HEAPU32[$0 + 12 >> 2]) {
   $1 = (jsvGetCharInString(HEAP32[80557], HEAP32[80559]) & 255) != 10;
  } else {
   $1 = 0;
  }
  if ($1) {
   if (jsiShowInputLine() & 1) {
    jsiConsolePrintChar(jsvGetCharInString(HEAP32[80557], HEAP32[80559]) << 24 >> 24);
   }
   HEAP32[80559] = HEAP32[80559] + 1;
   continue;
  }
  break;
 }
 global$0 = $0 + 16 | 0;
}
function jspGetPrototype($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!(jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1)) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 4 >> 2] = jsvObjectGetChild(HEAP32[$1 + 8 >> 2], 79526, 0);
  if (jsvIsObject(HEAP32[$1 + 4 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
   break label$1;
  }
  jsvUnLock(HEAP32[$1 + 4 >> 2]);
  HEAP32[$1 + 12 >> 2] = 0;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function graphicsBlendGfxColor($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 $1 = HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24);
 $0 = HEAP32[$2 + 12 >> 2];
 $0 = graphicsBlendColor(HEAP32[$2 + 12 >> 2], $1, HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24), HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0;
}
function jspIsConstructor($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = jsvObjectGetChild(HEAP32[80545], HEAP32[$2 + 20 >> 2], 0);
 label$1 : {
  if (!HEAP32[$2 + 16 >> 2]) {
   HEAP8[$2 + 31 | 0] = 0;
   break label$1;
  }
  HEAP8[$2 + 15 | 0] = HEAP32[$2 + 16 >> 2] == HEAP32[$2 + 24 >> 2];
  jsvUnLock(HEAP32[$2 + 16 >> 2]);
  HEAP8[$2 + 31 | 0] = HEAP8[$2 + 15 | 0] & 1;
 }
 global$0 = $2 + 32 | 0;
 return HEAP8[$2 + 31 | 0] & 1;
}
function jswrap_graphics_getBPP($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 80 | 0;
 global$0 = $1;
 HEAP32[$1 + 72 >> 2] = $0;
 label$1 : {
  if (!(graphicsGetFromVar($1, HEAP32[$1 + 72 >> 2]) & 1)) {
   HEAP32[$1 + 76 >> 2] = 0;
   break label$1;
  }
  if ((HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8 | (HEAPU8[$1 + 6 | 0] << 16 | HEAPU8[$1 + 7 | 0] << 24)) == 6) {
   HEAP32[$1 + 76 >> 2] = 3;
   break label$1;
  }
  HEAP32[$1 + 76 >> 2] = HEAPU8[$1 + 16 | 0];
 }
 global$0 = $1 + 80 | 0;
 return HEAP32[$1 + 76 >> 2];
}
function jsiShouldExecuteWatch($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 HEAP32[$2 + 4 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$2 + 12 >> 2], 81848, 0));
 global$0 = $2 + 16 | 0;
 $0 = 1;
 label$1 : {
  if (!HEAP32[$2 + 4 >> 2]) {
   break label$1;
  }
  if (HEAP8[$2 + 11 | 0] & 1) {
   $0 = 1;
   if (HEAP32[$2 + 4 >> 2] > 0) {
    break label$1;
   }
  }
  $0 = HEAP8[$2 + 11 | 0] & 1 ? 0 : HEAP32[$2 + 4 >> 2] < 0;
 }
 return $0 & 1;
}
function graphicsClear($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 $2 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) - 1 | 0;
 $0 = HEAP32[$1 + 12 >> 2];
 $3 = (HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8) - 1 | 0;
 $0 = HEAP32[$1 + 12 >> 2];
 graphicsFillRectDevice(HEAP32[$1 + 12 >> 2], 0, 0, $2, $3, HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24));
 global$0 = $1 + 16 | 0;
}
function jsvCheckReferenceError($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1 : {
  if (!(jsvIsBasicName(HEAP32[$1 + 12 >> 2]) & 1)) {
   break label$1;
  }
  if (jsvGetRefs(HEAP32[$1 + 12 >> 2]) & 255) {
   break label$1;
  }
  if (jsvIsNewChild(HEAP32[$1 + 12 >> 2]) & 1) {
   break label$1;
  }
  if (jsvGetFirstChild(HEAP32[$1 + 12 >> 2]) & 65535) {
   break label$1;
  }
  HEAP32[$1 >> 2] = HEAP32[$1 + 12 >> 2];
  jsExceptionHere(5, 78726, $1);
 }
 global$0 = $1 + 16 | 0;
}
function jslGetTokenValueAsString() {
 var $0 = 0;
 HEAP8[HEAPU8[HEAP32[35539] + 80 | 0] + (HEAP32[35539] + 12 | 0) | 0] = 0;
 if (!(HEAPU8[HEAP32[35539] + 80 | 0] | HEAP16[HEAP32[35539] + 2 >> 1] < 163 | HEAP16[HEAP32[35539] + 2 >> 1] > 198)) {
  jslTokenAsString(HEAP16[HEAP32[35539] + 2 >> 1], HEAP32[35539] + 12 | 0, 64);
  strcpy(HEAP32[35539] + 12 | 0, jslReservedWordAsString(HEAP16[HEAP32[35539] + 2 >> 1]));
  $0 = strlen(HEAP32[35539] + 12 | 0);
  HEAP8[HEAP32[35539] + 80 | 0] = $0;
 }
 return HEAP32[35539] + 12 | 0;
}
function jsfListFiles($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 HEAP32[$3 + 12 >> 2] = jsvNewWithFlags(3);
 label$1 : {
  if (!HEAP32[$3 + 12 >> 2]) {
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  jsfBankListFiles(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 16 >> 2], 0);
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2];
 }
 global$0 = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}
function tflite__RuntimeShape__Dims_28int_29_20const($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 label$1 : {
  if (HEAP32[$2 + 8 >> 2] < 0) {
   break label$1;
  }
 }
 label$2 : {
  if (HEAP32[$2 + 8 >> 2] >= HEAP32[$0 >> 2]) {
   break label$2;
  }
 }
 if (HEAP32[$0 >> 2] > 5) {
  $0 = HEAP32[HEAP32[$0 + 4 >> 2] + (HEAP32[$2 + 8 >> 2] << 2) >> 2];
 } else {
  $0 = HEAP32[($0 + 4 | 0) + (HEAP32[$2 + 8 >> 2] << 2) >> 2];
 }
 return $0;
}
function jshPinSetValue($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
 if (HEAPU8[Math_imul(HEAPU8[$2 + 15 | 0], 3) + 109872 | 0] & 16) {
  HEAP8[$2 + 14 | 0] = (HEAPU8[$2 + 14 | 0] ^ -1) & 1;
 }
 HEAP8[$2 + 11 | 0] = 105;
 HEAP8[$2 + 12 | 0] = 105;
 HEAP8[$2 + 13 | 0] = 0;
 $0 = HEAPU8[$2 + 15 | 0];
 HEAP32[$2 + 4 >> 2] = HEAP8[$2 + 14 | 0] & 1;
 HEAP32[$2 >> 2] = $0;
 emscripten_asm_const_iii(109692, $2 + 11 | 0, $2 | 0) | 0;
 global$0 = $2 + 16 | 0;
}
function tflite__ops__micro__activations__SoftmaxInit_28TfLiteContext__2c_20char_20const__2c_20unsigned_20long_29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 label$1 : {
  if (!HEAP32[HEAP32[$3 + 12 >> 2] + 56 >> 2]) {
   break label$1;
  }
 }
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$3 + 12 >> 2] + 56 >> 2]](HEAP32[$3 + 12 >> 2], 56) | 0;
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function tflite___28anonymous_20namespace_29__OpNameFromRegistration_28TfLiteRegistration_20const__29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (HEAP32[HEAP32[$1 + 8 >> 2] + 20 >> 2] == 32) {
   HEAP32[$1 + 12 >> 2] = HEAP32[HEAP32[$1 + 8 >> 2] + 24 >> 2];
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = tflite__EnumNameBuiltinOperator_28tflite__BuiltinOperator_29(HEAP32[HEAP32[$1 + 8 >> 2] + 20 >> 2]);
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function tflite__MicroAllocator__MicroAllocator_28tflite__SimpleMemoryAllocator__2c_20tflite__ErrorReporter__29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 HEAP32[$0 >> 2] = 131608;
 HEAP32[$0 + 4 >> 2] = HEAP32[$3 + 8 >> 2];
 HEAP32[$0 + 8 >> 2] = HEAP32[$3 + 4 >> 2];
 HEAP8[$0 + 12 | 0] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 return $0 | 0;
}
function jswrap_date_setDate($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = global$0 + -64 | 0;
 global$0 = $2;
 $3 = $2 + 8 | 0;
 HEAP32[$2 + 60 >> 2] = $0;
 HEAP32[$2 + 56 >> 2] = $1;
 $0 = $2 + 32 | 0;
 getTimeFromDateVar($0, HEAP32[$2 + 60 >> 2], 0);
 getCalendarDate($3, HEAP32[$2 + 32 >> 2]);
 HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 56 >> 2];
 HEAP32[$2 + 32 >> 2] = fromCalenderDate($3);
 $4 = jswrap_date_setTime(HEAP32[$2 + 60 >> 2], fromTimeInDay($0));
 global$0 = $2 - -64 | 0;
 return +$4;
}
function gemmlowp__FixedPoint_int_2c_2012__20gemmlowp__Rescale_12_2c_20int_2c_200__28gemmlowp__FixedPoint_int_2c_200__29($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 $2 = $1 + 8 | 0;
 HEAP32[$1 >> 2] = $0;
 $0 = int_20gemmlowp__SaturatingRoundingMultiplyByPOT__12_2c_20int__28int_29(HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($1) >> 2]);
 HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($2) >> 2] = $0;
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function _jswrap_io_poke($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 label$1 : {
  if (HEAP32[$3 + 4 >> 2] == 1) {
   HEAP8[HEAP32[$3 + 12 >> 2]] = HEAP32[$3 + 8 >> 2];
   break label$1;
  }
  label$3 : {
   if (HEAP32[$3 + 4 >> 2] == 2) {
    HEAP16[HEAP32[$3 + 12 >> 2] >> 1] = HEAP32[$3 + 8 >> 2];
    break label$3;
   }
   if (HEAP32[$3 + 4 >> 2] == 4) {
    HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = HEAP32[$3 + 8 >> 2];
   }
  }
 }
}
function tflite__MicroAllocator__AllocatePersistentTfLiteTensorInternal_28tflite__Model_20const__2c_20TfLiteEvalTensor__2c_20int_29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 global$0 = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 $0 = HEAP32[HEAP32[$4 + 12 >> 2] + 4 >> 2];
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 12 >> 2]]($0, 40, 4) | 0;
 global$0 = $4 + 16 | 0;
 return $0 | 0;
}
function tflite__ops__micro__depthwise_conv__Init_28TfLiteContext__2c_20char_20const__2c_20unsigned_20long_29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 label$1 : {
  if (!HEAP32[HEAP32[$3 + 12 >> 2] + 56 >> 2]) {
   break label$1;
  }
 }
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$3 + 12 >> 2] + 56 >> 2]](HEAP32[$3 + 12 >> 2], 52) | 0;
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function jsvIsNameInt($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  if (((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) != 15) {
   $0 = HEAP32[$1 + 12 >> 2];
   if (((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) >= 17) {
    $0 = HEAP32[$1 + 12 >> 2];
    $0 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) <= 21;
   } else {
    $0 = 0;
   }
  } else {
   $0 = 1;
  }
 } else {
  $0 = 0;
 }
 return $0 & 1;
}
function tflite__internal__ContextHelper__ReportOpError_28TfLiteContext__2c_20char_20const__2c_20____29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = HEAP32[HEAP32[$3 + 12 >> 2] + 12 >> 2];
 HEAP32[$3 >> 2] = $2;
 $0 = HEAP32[HEAP32[$3 + 4 >> 2] + 4 >> 2];
 FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 8 >> 2]]($0, HEAP32[$3 + 8 >> 2], HEAP32[$3 >> 2]) | 0;
 global$0 = $3 + 16 | 0;
}
function jsvGetChildren($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = 0;
 HEAP16[$1 + 6 >> 1] = jsvGetFirstChild(HEAP32[$1 + 12 >> 2]);
 while (1) {
  if (HEAPU16[$1 + 6 >> 1]) {
   HEAP32[$1 >> 2] = jsvLock(HEAPU16[$1 + 6 >> 1]);
   HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
   HEAP16[$1 + 6 >> 1] = jsvGetNextSibling(HEAP32[$1 >> 2]);
   jsvUnLock(HEAP32[$1 >> 2]);
   continue;
  }
  break;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function jspeArrowFunction($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jslGetNextToken();
 HEAP32[$2 + 12 >> 2] = jspeAddNamedFunctionParameter(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 HEAP8[$2 + 7 | 0] = HEAP16[HEAP32[35539] + 2 >> 1] != 123;
 jspeFunctionDefinitionInternal(HEAP32[$2 + 12 >> 2], HEAP8[$2 + 7 | 0] & 1);
 jsvObjectSetChild(HEAP32[$2 + 12 >> 2], 79827, HEAP32[80548]);
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function jshPushIOCharEventHandler($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP8[$2 + 14 | 0] = $0;
 HEAP8[$2 + 13 | 0] = $1;
 label$1 : {
  if (!(HEAP8[$2 + 13 | 0] != 3 | HEAPU8[$2 + 14 | 0] != HEAPU8[141672])) {
   if (!(jsiPasswordProtected() & 1)) {
    HEAP32[80549] = HEAP32[80549] | 2048;
   }
   HEAP8[$2 + 15 | 0] = 1;
   break label$1;
  }
  HEAP8[$2 + 15 | 0] = jswOnCharEvent(HEAPU8[$2 + 14 | 0], HEAP8[$2 + 13 | 0]) & 1;
 }
 global$0 = $2 + 16 | 0;
 return HEAP8[$2 + 15 | 0] & 1;
}
function jsfVarFromName($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP8[$1 + 28 | 0] = 0;
 $2 = HEAP32[$0 + 4 >> 2];
 HEAP32[$1 >> 2] = HEAP32[$0 >> 2];
 HEAP32[$1 + 4 >> 2] = $2;
 HEAP32[$1 + 24 >> 2] = HEAP32[$0 + 24 >> 2];
 $2 = HEAP32[$0 + 20 >> 2];
 HEAP32[$1 + 16 >> 2] = HEAP32[$0 + 16 >> 2];
 HEAP32[$1 + 20 >> 2] = $2;
 $2 = HEAP32[$0 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = HEAP32[$0 + 8 >> 2];
 HEAP32[$1 + 12 >> 2] = $2;
 $0 = jsvNewFromString($1);
 global$0 = $1 + 32 | 0;
 return $0;
}
function gemmlowp__FixedPoint_int_2c_202__20gemmlowp__Rescale_2_2c_20int_2c_204__28gemmlowp__FixedPoint_int_2c_204__29($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 $2 = $1 + 8 | 0;
 HEAP32[$1 >> 2] = $0;
 $0 = int_20gemmlowp__SaturatingRoundingMultiplyByPOT_2_2c_20int__28int_29(HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($1) >> 2]);
 HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($2) >> 2] = $0;
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function gemmlowp__FixedPoint_int_2c_200__20gemmlowp__Rescale_0_2c_20int_2c_205__28gemmlowp__FixedPoint_int_2c_205__29($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 $2 = $1 + 8 | 0;
 HEAP32[$1 >> 2] = $0;
 $0 = int_20gemmlowp__SaturatingRoundingMultiplyByPOT_5_2c_20int__28int_29(HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($1) >> 2]);
 HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($2) >> 2] = $0;
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function gemmlowp__FixedPoint_int_2c_200__20gemmlowp__Rescale_0_2c_20int_2c_201__28gemmlowp__FixedPoint_int_2c_201__29($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 $2 = $1 + 8 | 0;
 HEAP32[$1 >> 2] = $0;
 $0 = int_20gemmlowp__SaturatingRoundingMultiplyByPOT_1_2c_20int__28int_29(HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($1) >> 2]);
 HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($2) >> 2] = $0;
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function jsvAddFunctionParameter($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 if (!HEAP32[$3 + 8 >> 2]) {
  HEAP32[$3 + 8 >> 2] = jsvNewWithFlags(27);
 }
 if (HEAP32[$3 + 8 >> 2]) {
  jsvMakeFunctionParameter(HEAP32[$3 + 8 >> 2]);
  jsvSetValueOfName(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
  jsvAddName(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
  jsvUnLock(HEAP32[$3 + 8 >> 2]);
 }
 global$0 = $3 + 16 | 0;
}
function jswrap_graphics_getPixel($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 96 | 0;
 global$0 = $3;
 HEAP32[$3 + 88 >> 2] = $0;
 HEAP32[$3 + 84 >> 2] = $1;
 HEAP32[$3 + 80 >> 2] = $2;
 label$1 : {
  if (!(graphicsGetFromVar($3 + 8 | 0, HEAP32[$3 + 88 >> 2]) & 1)) {
   HEAP32[$3 + 92 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 92 >> 2] = graphicsGetPixel($3 + 8 | 0, HEAP32[$3 + 84 >> 2], HEAP32[$3 + 80 >> 2]);
 }
 global$0 = $3 + 96 | 0;
 return HEAP32[$3 + 92 >> 2];
}
function __stdio_seek($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 global$0 = $4;
 label$1 : {
  if (!__wasi_syscall_ret(legalimport$__wasi_fd_seek(HEAP32[$0 + 60 >> 2], $1 | 0, $2 | 0, $3 & 255, $4 + 8 | 0) | 0)) {
   $1 = HEAP32[$4 + 12 >> 2];
   $0 = HEAP32[$4 + 8 >> 2];
   break label$1;
  }
  HEAP32[$4 + 8 >> 2] = -1;
  HEAP32[$4 + 12 >> 2] = -1;
  $1 = -1;
  $0 = -1;
 }
 global$0 = $4 + 16 | 0;
 i64toi32_i32$HIGH_BITS = $1;
 return $0 | 0;
}
function jsvObjectIteratorRemoveAndGotoNext($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 if (HEAP32[HEAP32[$2 + 12 >> 2] >> 2]) {
  HEAP16[$2 + 6 >> 1] = jsvGetNextSibling(HEAP32[HEAP32[$2 + 12 >> 2] >> 2]);
  jsvRemoveChild(HEAP32[$2 + 8 >> 2], HEAP32[HEAP32[$2 + 12 >> 2] >> 2]);
  jsvUnLock(HEAP32[HEAP32[$2 + 12 >> 2] >> 2]);
  $0 = jsvLockSafe(HEAPU16[$2 + 6 >> 1]);
  HEAP32[HEAP32[$2 + 12 >> 2] >> 2] = $0;
 }
 global$0 = $2 + 16 | 0;
}
function float_20tflite__ActivationFunctionWithMinMax_float__28float_2c_20float_2c_20float_29($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 $4 = $3 + 4 | 0;
 HEAPF32[$3 + 12 >> 2] = $0;
 HEAPF32[$3 + 8 >> 2] = $1;
 HEAPF32[$3 + 4 >> 2] = $2;
 $0 = HEAPF32[float_20const__20std____2__min_float__28float_20const__2c_20float_20const__29(float_20const__20std____2__max_float__28float_20const__2c_20float_20const__29($3 + 12 | 0, $3 + 8 | 0), $4) >> 2];
 global$0 = $3 + 16 | 0;
 return $0;
}
function _ZN17compiler_builtins3int3mul3Mul3mul17h070e9a1c69faec5bE($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $4 = $2 >>> 16;
 $5 = $0 >>> 16;
 $9 = Math_imul($4, $5);
 $6 = $2 & 65535;
 $7 = $0 & 65535;
 $8 = Math_imul($6, $7);
 $5 = ($8 >>> 16) + Math_imul($5, $6) | 0;
 $4 = ($5 & 65535) + Math_imul($4, $7) | 0;
 $0 = (((Math_imul($1, $2) + $9 | 0) + Math_imul($0, $3) | 0) + ($5 >>> 16) | 0) + ($4 >>> 16) | 0;
 $1 = $8 & 65535 | $4 << 16;
 i64toi32_i32$HIGH_BITS = $0;
 return $1;
}
function lcdGetPixel_ArrayBuffer_flat8($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 $1 = HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24);
 $0 = HEAP32[$3 + 12 >> 2];
 return HEAPU8[$1 + (HEAP32[$3 + 8 >> 2] + Math_imul(HEAP32[$3 + 4 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) | 0) | 0];
}
function flatbuffers__IndirectHelper_long_20long___Read_28unsigned_20char_20const__2c_20unsigned_20int_29($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $1 = HEAP32[$2 + 12 >> 2] + (HEAP32[$2 + 8 >> 2] << 3) | 0;
 $3 = HEAP32[$1 + 4 >> 2];
 $0 = global$0 - 16 | 0;
 HEAP32[$0 + 8 >> 2] = HEAP32[$1 >> 2];
 HEAP32[$0 + 12 >> 2] = $3;
 global$0 = $2 + 16 | 0;
 i64toi32_i32$HIGH_BITS = HEAP32[$0 + 12 >> 2];
 return HEAP32[$0 + 8 >> 2];
}
function tflite__ops__micro__pooling__Init_28TfLiteContext__2c_20char_20const__2c_20unsigned_20long_29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 label$1 : {
  if (!HEAP32[HEAP32[$3 + 12 >> 2] + 56 >> 2]) {
   break label$1;
  }
 }
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$3 + 12 >> 2] + 56 >> 2]](HEAP32[$3 + 12 >> 2], 32) | 0;
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function jsvArrayBufferIteratorHasElement($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!HEAPU16[HEAP32[$1 + 8 >> 2] + 36 >> 1]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  if (HEAP8[HEAP32[$1 + 8 >> 2] + 52 | 0] & 1) {
   HEAP8[$1 + 15 | 0] = 1;
   break label$1;
  }
  HEAP8[$1 + 15 | 0] = HEAP32[HEAP32[$1 + 8 >> 2] + 44 >> 2] + (HEAPU16[HEAP32[$1 + 8 >> 2] + 36 >> 1] & 15) >>> 0 <= HEAPU32[HEAP32[$1 + 8 >> 2] + 40 >> 2];
 }
 return HEAP8[$1 + 15 | 0] & 1;
}
function jsvSetNamedChild($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = 125679;
 HEAP32[$2 + 12 >> 2] = jsvFindChildFromString(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 16 >> 2], 1);
 label$1 : {
  if (HEAP32[$2 + 12 >> 2]) {
   HEAP32[$2 + 28 >> 2] = jsvSetValueOfName(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 20 >> 2]);
   break label$1;
  }
  HEAP32[$2 + 28 >> 2] = 0;
 }
 global$0 = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}
function jshGetPinFromVar($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!(!(jsvIsString(HEAP32[$1 + 8 >> 2]) & 1) | HEAP8[HEAP32[$1 + 8 >> 2] + 5 | 0])) {
   HEAP8[$1 + 15 | 0] = jshGetPinFromString(HEAP32[$1 + 8 >> 2]);
   break label$1;
  }
  if (jsvIsInt(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP8[$1 + 15 | 0] = jsvGetInteger(HEAP32[$1 + 8 >> 2]);
   break label$1;
  }
  HEAP8[$1 + 15 | 0] = 255;
 }
 global$0 = $1 + 16 | 0;
 return HEAPU8[$1 + 15 | 0];
}
function jsfFindFileFromAddr($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1 : {
  if (!(HEAPU32[$2 + 8 >> 2] < 134217728 | HEAPU32[$2 + 8 >> 2] > 142606336)) {
   HEAP32[$2 >> 2] = jsfBankFindFileFromAddr(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
   if (HEAP32[$2 >> 2]) {
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
    break label$1;
   }
  }
  HEAP32[$2 + 12 >> 2] = 0;
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function _jswrap_promise_is_promise($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jspGetConstructor(HEAP32[$1 + 12 >> 2]);
 $2 = $1;
 if (HEAP32[$1 + 8 >> 2]) {
  $0 = HEAP32[$1 + 8 >> 2];
  $0 = (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 29;
 } else {
  $0 = 0;
 }
 HEAP8[$2 + 7 | 0] = $0;
 jsvUnLock(HEAP32[$1 + 8 >> 2]);
 global$0 = $1 + 16 | 0;
 return HEAP8[$1 + 7 | 0] & 1;
}
function jsvArrayBufferIteratorDataToFloat($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 20 >> 2] = HEAPU16[HEAP32[$2 + 28 >> 2] + 36 >> 1] & 15;
 HEAPF64[$2 + 8 >> 3] = 0;
 label$1 : {
  if (HEAP32[$2 + 20 >> 2] == 4) {
   HEAPF64[$2 + 8 >> 3] = HEAPF32[HEAP32[$2 + 24 >> 2] >> 2];
   break label$1;
  }
  if (HEAP32[$2 + 20 >> 2] == 8) {
   HEAPF64[$2 + 8 >> 3] = HEAPF64[HEAP32[$2 + 24 >> 2] >> 3];
  }
 }
 return HEAPF64[$2 + 8 >> 3];
}
function jsiHandleIOEventForConsole($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = ((HEAPU8[HEAP32[$1 + 12 >> 2]] & 96) >> 5) + 1;
 jsiSetBusy(1, 1);
 HEAP32[$1 + 8 >> 2] = 0;
 while (1) {
  if (HEAP32[$1 + 8 >> 2] < HEAP32[$1 + 4 >> 2]) {
   jsiHandleChar(HEAP8[HEAP32[$1 + 8 >> 2] + (HEAP32[$1 + 12 >> 2] + 1 | 0) | 0]);
   HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
   continue;
  }
  break;
 }
 jsiSetBusy(1, 0);
 global$0 = $1 + 16 | 0;
}
function tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator__Allocate_28unsigned_20long_2c_20unsigned_20long_29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[HEAP32[$3 + 12 >> 2] + 4 >> 2];
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 12 >> 2]]($0, HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]) | 0;
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function jsvIsInternalObjectKey($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $2 = jsvIsString(HEAP32[$1 + 12 >> 2]) & 1;
 $0 = 0;
 if ($2) {
  $0 = 1;
  label$2 : {
   if (HEAP8[HEAP32[$1 + 12 >> 2]] == -1) {
    break label$2;
   }
   $2 = jsvIsStringEqual(HEAP32[$1 + 12 >> 2], 79158) & 1;
   $0 = 1;
   if ($2) {
    break label$2;
   }
   $0 = jsvIsStringEqual(HEAP32[$1 + 12 >> 2], 79168);
  }
 }
 global$0 = $1 + 16 | 0;
 return $0 & 1;
}
function graphicsGetSetPixelFn($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 $0 = HEAP32[$1 + 8 >> 2];
 label$1 : {
  if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 112) {
   HEAP32[$1 + 12 >> 2] = 533;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP32[$1 + 12 >> 2] = HEAPU8[$0 + 52 | 0] | HEAPU8[$0 + 53 | 0] << 8 | (HEAPU8[$0 + 54 | 0] << 16 | HEAPU8[$0 + 55 | 0] << 24);
 }
 return HEAP32[$1 + 12 >> 2];
}
function tflite___28anonymous_20namespace_29__AllocationInfoBuilder__Init_28unsigned_20long_2c_20unsigned_20long_29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 HEAP32[$0 + 8 >> 2] = HEAP32[$3 + 8 >> 2];
 HEAP32[$0 + 12 >> 2] = HEAP32[$3 + 4 >> 2];
 $0 = tflite___28anonymous_20namespace_29__AllocationInfoBuilder__Allocate_28_29($0);
 global$0 = $3 + 16 | 0;
 return $0;
}
function jswrap_espruino_setBootCode($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 label$1 : {
  if (jsvIsString(HEAP32[$2 + 12 >> 2]) & 1) {
   HEAP32[$2 + 12 >> 2] = jsvLockAgain(HEAP32[$2 + 12 >> 2]);
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jsvNewWithFlags(27);
 }
 jsfSaveBootCodeToFlash(HEAP32[$2 + 12 >> 2], HEAP8[$2 + 11 | 0] & 1);
 jsvUnLock(HEAP32[$2 + 12 >> 2]);
 global$0 = $2 + 16 | 0;
}
function jsiExecuteObjectCallbacks($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 20 >> 2] = 0;
 HEAP32[$2 + 16 >> 2] = 0;
 HEAP32[$2 + 12 >> 2] = jsvObjectGetChild(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2], 0);
 if (HEAP32[$2 + 12 >> 2]) {
  jsiExecuteEventCallback(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 20 >> 2]);
  jsvUnLock(HEAP32[$2 + 12 >> 2]);
 }
 global$0 = $2 + 32 | 0;
}
function fflush($0) {
 $0 = $0 | 0;
 var $1 = 0;
 if ($0) {
  if (HEAP32[$0 + 76 >> 2] <= -1) {
   return __fflush_unlocked($0) | 0;
  }
  return __fflush_unlocked($0) | 0;
 }
 if (HEAP32[84239]) {
  $1 = fflush(HEAP32[84239]);
 }
 __lock(336944);
 $0 = HEAP32[84238];
 if ($0) {
  while (1) {
   if (HEAPU32[$0 + 20 >> 2] > HEAPU32[$0 + 28 >> 2]) {
    $1 = __fflush_unlocked($0) | $1;
   }
   $0 = HEAP32[$0 + 56 >> 2];
   if ($0) {
    continue;
   }
   break;
  }
 }
 __unlock(336944);
 return $1 | 0;
}
function jswrap_array_findIndex($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 HEAP32[$2 >> 2] = _jswrap_array_iterate_with_callback(118847, HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2], 0, 3, 1, 1);
 label$1 : {
  if (HEAP32[$2 >> 2]) {
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jsvNewFromInteger(-1);
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function jsiQueueObjectCallbacks($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 global$0 = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP32[$4 + 12 >> 2] = jsvObjectGetChild(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2], 0);
 if (HEAP32[$4 + 12 >> 2]) {
  jsiQueueEvents(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 12 >> 2], HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2]);
  jsvUnLock(HEAP32[$4 + 12 >> 2]);
 }
 global$0 = $4 + 32 | 0;
}
function gemmlowp__FixedPoint_int_2c_200__20gemmlowp__SaturatingRoundingMultiplyByPOT__2_2c_20int_2c_200__28gemmlowp__FixedPoint_int_2c_200__29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29(int_20gemmlowp__SaturatingRoundingMultiplyByPOT__2_2c_20int__28int_29(HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($1) >> 2]));
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function gemmlowp__FixedPoint_int_2c_200__20gemmlowp__SaturatingRoundingMultiplyByPOT__1_2c_20int_2c_200__28gemmlowp__FixedPoint_int_2c_200__29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29(int_20gemmlowp__SaturatingRoundingMultiplyByPOT__1_2c_20int__28int_29(HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($1) >> 2]));
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function tflite__OpResolver__GetDelegates_28int_29_20const($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 std____2__vector_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29__2c_20std____2__allocator_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29__20__20___vector_28_29($0);
 global$0 = $3 + 16 | 0;
}
function jspGetStackTrace() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 8 >> 2] = jsvFindChildFromString(HEAP32[80546], 79602, 0);
 label$1 : {
  if (HEAP32[$0 + 8 >> 2]) {
   HEAP32[$0 + 4 >> 2] = jsvSkipName(HEAP32[$0 + 8 >> 2]);
   jsvRemoveChild(HEAP32[80546], HEAP32[$0 + 8 >> 2]);
   jsvUnLock(HEAP32[$0 + 8 >> 2]);
   HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 4 >> 2];
   break label$1;
  }
  HEAP32[$0 + 12 >> 2] = 0;
 }
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}
function tflite__QuantizeMultiplierGreaterThanOne_28double_2c_20int__2c_20int__29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAPF64[$3 + 8 >> 3] = $0;
 HEAP32[$3 + 4 >> 2] = $1;
 HEAP32[$3 >> 2] = $2;
 if (!(HEAPF64[$3 + 8 >> 3] > 1)) {
  abort();
  abort();
 }
 tflite__QuantizeMultiplier_28double_2c_20int__2c_20int__29(HEAPF64[$3 + 8 >> 3], HEAP32[$3 + 4 >> 2], HEAP32[$3 >> 2]);
 if (HEAP32[HEAP32[$3 >> 2] >> 2] < 0) {
  abort();
  abort();
 }
 global$0 = $3 + 16 | 0;
}
function push_literal_byte($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP16[$2 + 6 >> 1] = HEAPU16[HEAP32[$2 + 12 >> 2] + 2 >> 1] - 1;
 HEAP16[$2 + 4 >> 1] = (get_input_offset(HEAP32[$2 + 12 >> 2]) & 65535) + HEAPU16[$2 + 6 >> 1];
 HEAP8[$2 + 3 | 0] = HEAPU8[HEAPU16[$2 + 4 >> 1] + (HEAP32[$2 + 12 >> 2] + 15 | 0) | 0];
 push_bits(HEAP32[$2 + 12 >> 2], 8, HEAPU8[$2 + 3 | 0], HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
}
function tflite__ElementCount_28TfLiteIntArray_20const__29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = 1;
 HEAP32[$1 + 4 >> 2] = 0;
 while (1) {
  if (HEAP32[$1 + 4 >> 2] < HEAP32[HEAP32[$1 + 12 >> 2] >> 2]) {
   HEAP32[$1 + 8 >> 2] = Math_imul(HEAP32[(HEAP32[$1 + 12 >> 2] + 4 | 0) + (HEAP32[$1 + 4 >> 2] << 2) >> 2], HEAP32[$1 + 8 >> 2]);
   HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + 1;
   continue;
  }
  break;
 }
 return HEAP32[$1 + 8 >> 2];
}
function terminalGetGFX($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = jswrap_graphics_getInstance();
 label$1 : {
  if (!HEAP32[$1 + 4 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  if (graphicsGetFromVar(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 4 >> 2]) & 1) {
   HEAP8[$1 + 15 | 0] = 1;
   break label$1;
  }
  jsvUnLock(HEAP32[$1 + 4 >> 2]);
  HEAP8[$1 + 15 | 0] = 0;
 }
 global$0 = $1 + 16 | 0;
 return HEAP8[$1 + 15 | 0] & 1;
}
function std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator_20bool_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[std____2____compressed_pair_TfLiteConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29_20const(HEAP32[$1 + 12 >> 2]) >> 2];
 global$0 = $1 + 16 | 0;
 return ($0 | 0) != 0;
}
function jshGetEventFlagsForPin($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP8[$1 + 14 | 0] = $0;
 HEAP32[$1 + 8 >> 2] = 0;
 label$1 : {
  while (1) {
   if (HEAP32[$1 + 8 >> 2] < 16) {
    if (HEAPU8[HEAP32[$1 + 8 >> 2] + 336592 | 0] == HEAPU8[$1 + 14 | 0]) {
     HEAP8[$1 + 15 | 0] = HEAP32[$1 + 8 >> 2] + 1;
     break label$1;
    } else {
     HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
     continue;
    }
   }
   break;
  }
  HEAP8[$1 + 15 | 0] = 0;
 }
 return HEAPU8[$1 + 15 | 0];
}
function jspFindPrototypeFor($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = jsvObjectGetChild(HEAP32[80545], HEAP32[$1 + 8 >> 2], 0);
 label$1 : {
  if (!HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 >> 2] = jsvObjectGetChild(HEAP32[$1 + 4 >> 2], 79516, 0);
  jsvUnLock(HEAP32[$1 + 4 >> 2]);
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jswrap_promise_then($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 _jswrap_promise_add(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], 1);
 if (HEAP32[$3 + 4 >> 2]) {
  _jswrap_promise_add(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 4 >> 2], 0);
 }
 $0 = jswrap_promise_get_chained_promise(HEAP32[$3 + 12 >> 2]);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function jsiReplaceInputLine($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (jsiShowInputLine() & 1) {
  jsiMoveCursorChar(HEAP32[80557], HEAP32[80559], 0);
  jsiConsolePrintString(81039);
  jsiConsolePrintStringVarWithNewLineChar(HEAP32[$1 + 12 >> 2], 0, 58);
 }
 jsiInputLineCursorMoved();
 jsvUnLock(HEAP32[80557]);
 HEAP32[80557] = jsvLockAgain(HEAP32[$1 + 12 >> 2]);
 HEAP32[80559] = jsvGetStringLength(HEAP32[80557]);
 global$0 = $1 + 16 | 0;
}
function jsvIsIntegerish($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsvIsInt(HEAP32[$1 + 12 >> 2]) & 1;
 $2 = 1;
 label$1 : {
  if ($0) {
   break label$1;
  }
  $0 = jsvIsPin(HEAP32[$1 + 12 >> 2]) & 1;
  $2 = 1;
  if ($0) {
   break label$1;
  }
  $0 = jsvIsBoolean(HEAP32[$1 + 12 >> 2]) & 1;
  $2 = 1;
  if ($0) {
   break label$1;
  }
  $2 = jsvIsNull(HEAP32[$1 + 12 >> 2]);
 }
 $0 = $2;
 global$0 = $1 + 16 | 0;
 return $0 & 1;
}
function _jswrap_promise_queueresolve($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = jsvNewNativeFunction(587, 32776);
 if (HEAP32[$2 + 4 >> 2]) {
  $0 = $2 + 8 | 0;
  jsvObjectSetChild(HEAP32[$2 + 4 >> 2], 125115, HEAP32[$2 + 12 >> 2]);
  jsiQueueEvents(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2], $0, 1);
  jsvUnLock(HEAP32[$2 + 4 >> 2]);
 }
 global$0 = $2 + 16 | 0;
}
function jsvArrayBufferIteratorSetValueAndRewind($0, $1) {
 var $2 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP32[$2 + 44 >> 2] = $0;
 HEAP32[$2 + 40 >> 2] = $1;
 jsvStringIteratorClone($2, HEAP32[$2 + 44 >> 2]);
 jsvArrayBufferIteratorSetValue(HEAP32[$2 + 44 >> 2], HEAP32[$2 + 40 >> 2]);
 jsvStringIteratorFree(HEAP32[$2 + 44 >> 2]);
 jsvStringIteratorClone(HEAP32[$2 + 44 >> 2], $2);
 jsvStringIteratorFree($2);
 HEAP8[HEAP32[$2 + 44 >> 2] + 52 | 0] = 0;
 global$0 = $2 + 48 | 0;
}
function _jswrap_promise_queuereject($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = jsvNewNativeFunction(586, 32776);
 if (HEAP32[$2 + 4 >> 2]) {
  $0 = $2 + 8 | 0;
  jsvObjectSetChild(HEAP32[$2 + 4 >> 2], 125115, HEAP32[$2 + 12 >> 2]);
  jsiQueueEvents(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2], $0, 1);
  jsvUnLock(HEAP32[$2 + 4 >> 2]);
 }
 global$0 = $2 + 16 | 0;
}
function std____2____compressed_pair_elem_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29___2c_200_2c_20false_____compressed_pair_elem_std__nullptr_t_2c_20void__28std__nullptr_t___29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(HEAP32[$2 + 8 >> 2]);
 HEAP32[$0 >> 2] = 0;
 global$0 = $2 + 16 | 0;
}
function jsvIsNewChild($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = !(jsvIsName(HEAP32[$1 + 12 >> 2]) & 1);
 $2 = 0;
 label$1 : {
  if ($0) {
   break label$1;
  }
  $0 = !(jsvGetNextSibling(HEAP32[$1 + 12 >> 2]) & 65535);
  $2 = 0;
  if ($0) {
   break label$1;
  }
  $2 = (jsvGetNextSibling(HEAP32[$1 + 12 >> 2]) & 65535) == (jsvGetPrevSibling(HEAP32[$1 + 12 >> 2]) & 65535);
 }
 $0 = $2;
 global$0 = $1 + 16 | 0;
 return $0 & 1;
}
function jsiAppendToInputLine($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (!HEAP32[80566]) {
  jsvStringIteratorNew(322252, HEAP32[80557], 0);
  jsvStringIteratorGotoEnd(322252);
 }
 while (1) {
  if (HEAPU8[HEAP32[$1 + 12 >> 2]]) {
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$1 + 12 >> 2] = $0 + 1;
   jsvStringIteratorAppend(322252, HEAP8[$0 | 0]);
   HEAP32[35419] = HEAP32[35419] + 1;
   continue;
  }
  break;
 }
 global$0 = $1 + 16 | 0;
}
function jswrap_espruino_memoryArea($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1 : {
  if (HEAP32[$2 + 4 >> 2] < 0) {
   HEAP32[$2 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 >> 2] = jshFlashGetMemMapAddress(HEAP32[$2 + 8 >> 2]);
  HEAP32[$2 + 12 >> 2] = jsvNewNativeString(HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]);
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function jsvGetFirstChildSigned($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 $0 = HEAP32[$1 + 8 >> 2];
 label$1 : {
  if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8) > 32767) {
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP16[$1 + 14 >> 1] = ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8) << 16 >> 16) + -65536;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP16[$1 + 14 >> 1] = HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8;
 }
 return HEAP16[$1 + 14 >> 1];
}
function jspExecuteJSFunction($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = 0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 HEAP32[$3 + 12 >> 2] = jspEvaluate(HEAP32[$3 + 28 >> 2]);
 HEAP32[$3 + 8 >> 2] = jspExecuteFunction(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 16 >> 2]);
 jsvUnLock(HEAP32[$3 + 12 >> 2]);
 global$0 = $3 + 32 | 0;
 return HEAP32[$3 + 8 >> 2];
}
function jshSleep($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 12 >> 2] = $1;
 HEAPF64[$2 >> 3] = jshGetMillisecondsFromTime(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 12 >> 2]);
 if (HEAPF64[$2 >> 3] > 2147483647) {
  HEAPF64[$2 >> 3] = 2147483647;
 }
 $3 = HEAPF64[$2 >> 3];
 label$2 : {
  if (Math_abs($3) < 2147483648) {
   $0 = ~~$3;
   break label$2;
  }
  $0 = -2147483648;
 }
 HEAP32[35420] = $0;
 global$0 = $2 + 16 | 0;
}
function hexToByte($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP8[$2 + 11 | 0] = $0;
 HEAP8[$2 + 10 | 0] = $1;
 HEAP32[$2 + 4 >> 2] = chtod(HEAP8[$2 + 11 | 0]);
 HEAP32[$2 >> 2] = chtod(HEAP8[$2 + 10 | 0]);
 label$1 : {
  if (!(HEAP32[$2 >> 2] >= 0 ? HEAP32[$2 + 4 >> 2] >= 0 : 0)) {
   HEAP32[$2 + 12 >> 2] = -1;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2] | HEAP32[$2 + 4 >> 2] << 4;
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function jswrap_tfmicrointerpreter_getTFMI($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 $2 = $1 + 4 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvObjectGetChild(HEAP32[$1 + 12 >> 2], 128484, 0);
 HEAP32[$1 >> 2] = jsvGetDataPointer(HEAP32[$1 + 8 >> 2], $2);
 jsvUnLock(HEAP32[$1 + 8 >> 2]);
 if (!HEAP32[$1 >> 2]) {
  jsExceptionHere(1, 128487, 0);
 }
 HEAP32[$1 >> 2] = HEAP32[$1 >> 2] + 15 & -16;
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 >> 2];
}
function mbedtls_sha512($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 240 | 0;
 global$0 = $4;
 HEAP32[$4 + 236 >> 2] = $0;
 HEAP32[$4 + 232 >> 2] = $1;
 HEAP32[$4 + 228 >> 2] = $2;
 HEAP32[$4 + 224 >> 2] = $3;
 $0 = $4 + 8 | 0;
 mbedtls_sha512_init($0);
 mbedtls_sha512_starts($0, HEAP32[$4 + 224 >> 2]);
 mbedtls_sha512_update($0, HEAP32[$4 + 236 >> 2], HEAP32[$4 + 232 >> 2]);
 mbedtls_sha512_finish($0, HEAP32[$4 + 228 >> 2]);
 mbedtls_sha512_free($0);
 global$0 = $4 + 240 | 0;
}
function jsvIterateCallbackToBytesCb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
 if (HEAPU32[HEAP32[$2 + 4 >> 2] + 4 >> 2] < HEAPU32[HEAP32[$2 + 4 >> 2] + 8 >> 2]) {
  HEAP8[HEAP32[HEAP32[$2 + 4 >> 2] >> 2] + HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] | 0] = HEAP32[$2 + 12 >> 2];
 }
 $0 = HEAP32[$2 + 4 >> 2];
 HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + 1;
}
function st_tag_bit($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = get_bits(HEAP32[$1 + 8 >> 2], 1) & 65535;
 label$1 : {
  if (HEAP32[$1 + 4 >> 2] == 65535) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 1;
   break label$1;
  }
  HEAP16[HEAP32[$1 + 8 >> 2] + 6 >> 1] = 0;
  HEAP32[$1 + 12 >> 2] = 3;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jswrap_regexp_test($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = jswrap_regexp_exec(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 $0 = $2;
 if (HEAP32[$2 + 4 >> 2]) {
  $1 = jsvIsNull(HEAP32[$2 + 4 >> 2]) ^ -1;
 } else {
  $1 = 0;
 }
 HEAP8[$0 + 3 | 0] = $1 & 1;
 jsvUnLock(HEAP32[$2 + 4 >> 2]);
 global$0 = $2 + 16 | 0;
 return HEAP8[$2 + 3 | 0] & 1;
}
function jshGetTimeFromMilliseconds($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 HEAPF64[$1 + 8 >> 3] = $0;
 $0 = HEAPF64[$1 + 8 >> 3] * 1e3;
 label$1 : {
  if (Math_abs($0) < 0x8000000000000000) {
   $2 = Math_abs($0) >= 1 ? $0 > 0 ? ~~Math_min(Math_floor($0 / 4294967296), 4294967295) >>> 0 : ~~Math_ceil(($0 - +(~~$0 >>> 0 >>> 0)) / 4294967296) >>> 0 : 0;
   $1 = ~~$0 >>> 0;
   break label$1;
  }
  $2 = -2147483648;
  $1 = 0;
 }
 i64toi32_i32$HIGH_BITS = $2;
 return $1;
}
function std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[std____2____compressed_pair_TfLiteConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29_20const(HEAP32[$1 + 12 >> 2]) >> 2];
 global$0 = $1 + 16 | 0;
 return $0;
}
function jswrap_eval($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 4 >> 2] = jsvAsString(HEAP32[$1 + 8 >> 2]);
  HEAP32[$1 >> 2] = jspEvaluateVar(HEAP32[$1 + 4 >> 2], HEAP32[80548], 0);
  jsvUnLock(HEAP32[$1 + 4 >> 2]);
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function st_backref_index_msb($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP8[$1 + 7 | 0] = 8;
 HEAP16[$1 + 4 >> 1] = get_bits(HEAP32[$1 + 8 >> 2], HEAPU8[$1 + 7 | 0] - 8 & 255);
 label$1 : {
  if (HEAPU16[$1 + 4 >> 1] == 65535) {
   HEAP32[$1 + 12 >> 2] = 2;
   break label$1;
  }
  HEAP16[HEAP32[$1 + 8 >> 2] + 6 >> 1] = HEAPU16[$1 + 4 >> 1] << 8;
  HEAP32[$1 + 12 >> 2] = 3;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function st_backref_count_msb($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP8[$1 + 7 | 0] = 6;
 HEAP16[$1 + 4 >> 1] = get_bits(HEAP32[$1 + 8 >> 2], HEAPU8[$1 + 7 | 0] - 8 & 255);
 label$1 : {
  if (HEAPU16[$1 + 4 >> 1] == 65535) {
   HEAP32[$1 + 12 >> 2] = 4;
   break label$1;
  }
  HEAP16[HEAP32[$1 + 8 >> 2] + 4 >> 1] = HEAPU16[$1 + 4 >> 1] << 8;
  HEAP32[$1 + 12 >> 2] = 5;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jshPinInput($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 15 | 0] = $0;
 HEAP8[$1 + 14 | 0] = 0;
 label$1 : {
  if (jshIsPinValid(HEAPU8[$1 + 15 | 0]) & 1) {
   if (!(jshGetPinStateIsManual(HEAPU8[$1 + 15 | 0]) & 1)) {
    jshPinSetState(HEAPU8[$1 + 15 | 0], 4);
   }
   HEAP8[$1 + 14 | 0] = jshPinGetValue(HEAPU8[$1 + 15 | 0]) & 1;
   break label$1;
  }
  jsExceptionHere(1, 80907, 0);
 }
 global$0 = $1 + 16 | 0;
 return HEAP8[$1 + 14 | 0] & 1;
}
function tflite___28anonymous_20namespace_29__AllocationInfoBuilder__AllocationInfoBuilder_28tflite__ErrorReporter__2c_20tflite__SimpleMemoryAllocator__29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 HEAP32[$0 >> 2] = HEAP32[$3 + 8 >> 2];
 HEAP32[$0 + 4 >> 2] = HEAP32[$3 + 4 >> 2];
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
}
function jsvGetLinesInString($0) {
 var $1 = 0;
 $1 = global$0 - 48 | 0;
 global$0 = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 HEAP32[$1 + 40 >> 2] = 1;
 jsvStringIteratorNew($1, HEAP32[$1 + 44 >> 2], 0);
 while (1) {
  if (jsvStringIteratorHasChar($1) & 1) {
   if ((jsvStringIteratorGetCharAndNext($1) & 255) == 10) {
    HEAP32[$1 + 40 >> 2] = HEAP32[$1 + 40 >> 2] + 1;
   }
   continue;
  }
  break;
 }
 jsvStringIteratorFree($1);
 global$0 = $1 + 48 | 0;
 return HEAP32[$1 + 40 >> 2];
}
function jspGetPrototypeOwner($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  label$2 : {
   if (!(jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1)) {
    if (!(jsvIsArray(HEAP32[$1 + 8 >> 2]) & 1)) {
     break label$2;
    }
   }
   HEAP32[$1 + 12 >> 2] = jsvSkipNameAndUnLock(jsvObjectGetChild(HEAP32[$1 + 8 >> 2], 80199, 0));
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function isWhitespace($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 $0 = 1;
 label$1 : {
  if (HEAP8[$1 + 15 | 0] == 9) {
   break label$1;
  }
  $0 = 1;
  if (HEAP8[$1 + 15 | 0] == 11) {
   break label$1;
  }
  $0 = 1;
  if (HEAP8[$1 + 15 | 0] == 12) {
   break label$1;
  }
  $0 = 1;
  if (HEAP8[$1 + 15 | 0] == 32) {
   break label$1;
  }
  $0 = 1;
  if (HEAP8[$1 + 15 | 0] == 10) {
   break label$1;
  }
  $0 = HEAP8[$1 + 15 | 0] == 13;
 }
 return $0;
}
function flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph__20___Get_28unsigned_20int_29_20const($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = flatbuffers__IndirectHelper_flatbuffers__Offset_tflite__Tensor__20___Read_28unsigned_20char_20const__2c_20unsigned_20int_29(flatbuffers__Vector_int___Data_28_29_20const(HEAP32[$2 + 12 >> 2]), HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0;
}
function i2c_wr($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = 0;
 while (1) {
  if (HEAP32[$2 + 4 >> 2] < 8) {
   i2c_wr_bit(HEAP32[$2 + 12 >> 2], (HEAP32[$2 + 8 >> 2] & 128) != 0);
   HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] << 1;
   HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + 1;
   continue;
  }
  break;
 }
 i2c_rd_bit(HEAP32[$2 + 12 >> 2]);
 global$0 = $2 + 16 | 0;
 return 1;
}
function jswIdle() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP8[$0 + 15 | 0] = 0;
 if (jswrap_banglejs_idle() & 1) {
  HEAP8[$0 + 15 | 0] = 1;
 }
 if (jswrap_pipe_idle() & 1) {
  HEAP8[$0 + 15 | 0] = 1;
 }
 if (jsserialEventCallbackIdle() & 1) {
  HEAP8[$0 + 15 | 0] = 1;
 }
 if (jswrap_waveform_idle() & 1) {
  HEAP8[$0 + 15 | 0] = 1;
 }
 if (jswrap_terminal_idle() & 1) {
  HEAP8[$0 + 15 | 0] = 1;
 }
 global$0 = $0 + 16 | 0;
 return HEAP8[$0 + 15 | 0] & 1;
}
function gemmlowp__FixedPoint_int_2c_20_28_1_29_20__20_282_29__20gemmlowp__ExactMulByPot__1_2c_20int_2c_202__28gemmlowp__FixedPoint_int_2c_202__29($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 $2 = $1 + 8 | 0;
 HEAP32[$1 >> 2] = $0;
 $0 = HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($1) >> 2];
 HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($2) >> 2] = $0;
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function pad($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0;
 $5 = global$0 - 256 | 0;
 global$0 = $5;
 if (!($4 & 73728 | ($2 | 0) <= ($3 | 0))) {
  $4 = $2 - $3 | 0;
  $6 = $4 >>> 0 < 256;
  memset($5, $1, $6 ? $4 : 256);
  $1 = $0;
  $7 = $5;
  if (!$6) {
   $2 = $2 - $3 | 0;
   while (1) {
    out($0, $5, 256);
    $4 = $4 + -256 | 0;
    if ($4 >>> 0 > 255) {
     continue;
    }
    break;
   }
   $4 = $2 & 255;
  }
  out($1, $7, $4);
 }
 global$0 = $5 + 256 | 0;
}
function jswrap_onewire_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 11 | 0] = $0;
 HEAP32[$1 + 4 >> 2] = jspNewObject(0, 124310);
 label$1 : {
  if (!HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 4 >> 2], 124318, jsvNewFromPin(HEAPU8[$1 + 11 | 0]));
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function _ZN17compiler_builtins3int4sdiv3Div3div17he78fc483e41d7ec7E($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = $1 >> 31;
 $0 = $0 ^ $3;
 $5 = $0 - $3 | 0;
 $4 = $1 >> 31;
 $3 = ($4 ^ $1) - (($0 >>> 0 < $3 >>> 0) + $4 | 0) | 0;
 $0 = $2;
 $2 = __wasm_i64_udiv($5, $3, $0, 0 - ($0 >>> 0 < 0) | 0);
 $0 = $1 >> 31;
 $2 = $2 ^ $0;
 $3 = $2 - $0 | 0;
 $1 = $1 >> 31;
 i64toi32_i32$HIGH_BITS = ($1 ^ i64toi32_i32$HIGH_BITS) - (($2 >>> 0 < $0 >>> 0) + $1 | 0) | 0;
 return $3;
}
function tflite__ops__micro__conv__RuntimePaddingType_28TfLitePadding_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 $0 = HEAP32[$1 + 8 >> 2];
 label$1 : {
  if ($0 >>> 0 <= 2) {
   label$3 : {
    switch ($0 - 1 | 0) {
    case 0:
     HEAP8[$1 + 15 | 0] = 1;
     break label$1;
    case 1:
     HEAP8[$1 + 15 | 0] = 2;
     break label$1;
    default:
     break label$3;
    }
   }
  }
  HEAP8[$1 + 15 | 0] = 0;
 }
 return HEAPU8[$1 + 15 | 0];
}
function tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator__MicroBuiltinDataAllocator_28tflite__SimpleMemoryAllocator__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $1 = global$0 - 16 | 0;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[HEAP32[$1 + 12 >> 2] >> 2] = 132972;
 HEAP32[$0 >> 2] = 132948;
 HEAP32[$0 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
 global$0 = $2 + 16 | 0;
}
function jswrap_serial_setConsole($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 HEAP8[$2 + 10 | 0] = jsiGetDeviceFromClass(HEAP32[$2 + 12 >> 2]);
 label$1 : {
  if (!(HEAPU8[$2 + 10 | 0] < 17 | HEAPU8[$2 + 10 | 0] > 22)) {
   jsiSetConsoleDevice(HEAPU8[$2 + 10 | 0], HEAP8[$2 + 11 | 0] & 1);
   break label$1;
  }
  jsExceptionHere(1, 125413, 0);
 }
 global$0 = $2 + 16 | 0;
}
function jswrap_promise_all_reject($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = jsvObjectGetChild(HEAP32[$2 + 12 >> 2], 125167, 0);
 if (HEAP32[$2 + 4 >> 2]) {
  jsvUnLock(HEAP32[$2 + 4 >> 2]);
  jsvObjectRemoveChild(HEAP32[$2 + 12 >> 2], 125167);
  _jswrap_promise_queuereject(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 }
 global$0 = $2 + 16 | 0;
}
function jswrap_json_parse($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = global$0 - 144 | 0;
 global$0 = $1;
 $2 = $1 + 16 | 0;
 HEAP32[$1 + 140 >> 2] = $0;
 HEAP32[$1 + 12 >> 2] = jsvAsString(HEAP32[$1 + 140 >> 2]);
 HEAP32[$1 + 8 >> 2] = jslSetLex($2);
 jslInit(HEAP32[$1 + 12 >> 2]);
 jsvUnLock(HEAP32[$1 + 12 >> 2]);
 HEAP32[$1 + 4 >> 2] = jswrap_json_parse_internal();
 jslKill();
 jslSetLex(HEAP32[$1 + 8 >> 2]);
 global$0 = $1 + 144 | 0;
 return HEAP32[$1 + 4 >> 2];
}
function flatbuffers__Vector_int__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_int__20const___28unsigned_20short_29_20const($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = flatbuffers__Vector_int__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_int__20const___28unsigned_20short_29(HEAP32[$2 + 12 >> 2], HEAPU16[$2 + 10 >> 1]);
 global$0 = $2 + 16 | 0;
 return $0;
}
function jshPinGetValue($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 15 | 0] = $0;
 HEAP8[$1 + 12 | 0] = 105;
 HEAP8[$1 + 13 | 0] = 0;
 HEAP32[$1 >> 2] = HEAPU8[$1 + 15 | 0];
 HEAP8[$1 + 14 | 0] = (emscripten_asm_const_iii(109717, $1 + 12 | 0, $1 | 0) | 0) != 0;
 if (HEAPU8[Math_imul(HEAPU8[$1 + 15 | 0], 3) + 109872 | 0] & 16) {
  HEAP8[$1 + 14 | 0] = (HEAPU8[$1 + 14 | 0] ^ -1) & 1;
 }
 global$0 = $1 + 16 | 0;
 return HEAP8[$1 + 14 | 0] & 1;
}
function tflite__RuntimeShape__ReplaceWith_28int_2c_20int_20const__29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 tflite__RuntimeShape__Resize_28int_29($0, HEAP32[$3 + 8 >> 2]);
 HEAP32[$3 >> 2] = tflite__RuntimeShape__DimsData_28_29($0);
 memcpy(HEAP32[$3 >> 2], HEAP32[$3 + 4 >> 2], HEAP32[$3 + 8 >> 2] << 2);
 global$0 = $3 + 16 | 0;
}
function jsvAppendString($0, $1) {
 var $2 = 0;
 $2 = global$0 - 48 | 0;
 global$0 = $2;
 HEAP32[$2 + 44 >> 2] = $0;
 HEAP32[$2 + 40 >> 2] = $1;
 jsvStringIteratorNew($2, HEAP32[$2 + 44 >> 2], 0);
 jsvStringIteratorGotoEnd($2);
 while (1) {
  if (HEAPU8[HEAP32[$2 + 40 >> 2]]) {
   $0 = HEAP32[$2 + 40 >> 2];
   HEAP32[$2 + 40 >> 2] = $0 + 1;
   jsvStringIteratorAppend($2, HEAP8[$0 | 0]);
   continue;
  }
  break;
 }
 jsvStringIteratorFree($2);
 global$0 = $2 + 48 | 0;
}
function jsfGetJSONWhitespace($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 + -64 | 0;
 global$0 = $4;
 HEAP32[$4 + 60 >> 2] = $0;
 HEAP32[$4 + 56 >> 2] = $1;
 HEAP32[$4 + 52 >> 2] = $2;
 HEAP32[$4 + 48 >> 2] = $3;
 $0 = $4 + 8 | 0;
 jsvStringIteratorNew($0, HEAP32[$4 + 56 >> 2], 0);
 jsvStringIteratorGotoEnd($0);
 jsfGetJSONWithCallback(HEAP32[$4 + 60 >> 2], 0, HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2], 2, $0);
 jsvStringIteratorFree($0);
 global$0 = $4 - -64 | 0;
}
function jswrap_graphics_stringWidth($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 96 | 0;
 global$0 = $2;
 HEAP32[$2 + 88 >> 2] = $0;
 HEAP32[$2 + 84 >> 2] = $1;
 label$1 : {
  if (!(graphicsGetFromVar($2 + 8 | 0, HEAP32[$2 + 88 >> 2]) & 1)) {
   HEAP32[$2 + 92 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 92 >> 2] = _jswrap_graphics_stringWidth($2 + 8 | 0, HEAP32[$2 + 84 >> 2], -1);
 }
 global$0 = $2 + 96 | 0;
 return HEAP32[$2 + 92 >> 2];
}
function jswrap_number_toFixed($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 80 | 0;
 global$0 = $2;
 HEAP32[$2 + 76 >> 2] = $0;
 HEAP32[$2 + 72 >> 2] = $1;
 if (HEAP32[$2 + 72 >> 2] < 0) {
  HEAP32[$2 + 72 >> 2] = 0;
 }
 if (HEAP32[$2 + 72 >> 2] > 20) {
  HEAP32[$2 + 72 >> 2] = 20;
 }
 ftoa_bounded_extra(jsvGetFloat(HEAP32[$2 + 76 >> 2]), $2, 70, 10, HEAP32[$2 + 72 >> 2]);
 $0 = jsvNewFromString($2);
 global$0 = $2 + 80 | 0;
 return $0 | 0;
}
function heatshrink_decode($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = 593;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = 0;
 HEAP32[$1 >> 2] = HEAP32[$1 + 4 >> 2];
 $2 = HEAP32[$1 + 12 >> 2];
 $3 = HEAP32[$1 + 8 >> 2];
 $4 = HEAP32[$1 + 4 >> 2] ? 527 : 0;
 if (HEAP32[$1 + 4 >> 2]) {
  $0 = $1;
 } else {
  $0 = 0;
 }
 $0 = heatshrink_decode_cb($2, $3, $4, $0);
 global$0 = $1 + 16 | 0;
 return $0;
}
function mbedtls_sha256($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 128 | 0;
 global$0 = $4;
 HEAP32[$4 + 124 >> 2] = $0;
 HEAP32[$4 + 120 >> 2] = $1;
 HEAP32[$4 + 116 >> 2] = $2;
 HEAP32[$4 + 112 >> 2] = $3;
 mbedtls_sha256_init($4);
 mbedtls_sha256_starts($4, HEAP32[$4 + 112 >> 2]);
 mbedtls_sha256_update($4, HEAP32[$4 + 124 >> 2], HEAP32[$4 + 120 >> 2]);
 mbedtls_sha256_finish($4, HEAP32[$4 + 116 >> 2]);
 mbedtls_sha256_free($4);
 global$0 = $4 + 128 | 0;
}
function jswrap_interface_setSleepIndicator($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[$1 + 11 | 0] = HEAPU8[141674];
 HEAP8[141674] = jshGetPinFromVar(HEAP32[$1 + 12 >> 2]);
 if (HEAPU8[141674] != HEAPU8[$1 + 11 | 0]) {
  if (HEAPU8[$1 + 11 | 0] != 255) {
   jshPinOutput(HEAPU8[$1 + 11 | 0], 0);
  }
  if (HEAPU8[141674] != 255) {
   jshPinOutput(HEAPU8[141674], 1);
  }
 }
 global$0 = $1 + 16 | 0;
}
function int_20tflite__reference_ops__depthwise_conv__DepthwiseConvRound__28tflite__DepthwiseConvOutputRounding_291__28int_2c_20int_2c_20int_29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = tflite__MultiplyByQuantizedMultiplier_28int_2c_20int_2c_20int_29(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 global$0 = $3 + 16 | 0;
 return $0;
}
function bool_20flatbuffers__IsOutRange_tflite__BuiltinOperator__28tflite__BuiltinOperator_20const__2c_20tflite__BuiltinOperator_20const__2c_20tflite__BuiltinOperator_20const__29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 return HEAP32[HEAP32[$3 + 12 >> 2] >> 2] >= HEAP32[HEAP32[$3 + 8 >> 2] >> 2] ? HEAP32[HEAP32[$3 + 4 >> 2] >> 2] < HEAP32[HEAP32[$3 + 12 >> 2] >> 2] : 1;
}
function jswrap_interface_setBusyIndicator($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[$1 + 11 | 0] = HEAPU8[141673];
 HEAP8[141673] = jshGetPinFromVar(HEAP32[$1 + 12 >> 2]);
 if (HEAPU8[141673] != HEAPU8[$1 + 11 | 0]) {
  if (HEAPU8[$1 + 11 | 0] != 255) {
   jshPinOutput(HEAPU8[$1 + 11 | 0], 0);
  }
  if (HEAPU8[141673] != 255) {
   jshPinOutput(HEAPU8[141673], 1);
  }
 }
 global$0 = $1 + 16 | 0;
}
function jswrap_graphics_getFontHeight($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 96 | 0;
 global$0 = $1;
 HEAP32[$1 + 88 >> 2] = $0;
 label$1 : {
  if (!(graphicsGetFromVar($1 + 16 | 0, HEAP32[$1 + 88 >> 2]) & 1)) {
   HEAP32[$1 + 92 >> 2] = 0;
   break label$1;
  }
  $0 = $1 + 16 | 0;
  _jswrap_graphics_getFontInfo($0, $1);
  HEAP32[$1 + 92 >> 2] = _jswrap_graphics_getFontHeightInternal($0, $1);
 }
 global$0 = $1 + 96 | 0;
 return HEAP32[$1 + 92 >> 2];
}
function jsvResetVariable($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 HEAP32[$2 + 4 >> 2] = 0;
 while (1) {
  if (HEAPU32[$2 + 4 >> 2] < 15) {
   HEAP8[HEAP32[$2 + 12 >> 2] + HEAP32[$2 + 4 >> 2] | 0] = 0;
   HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + 1;
   continue;
  }
  break;
 }
 $0 = HEAP32[$2 + 12 >> 2];
 $1 = HEAPU16[$2 + 10 >> 1] | 512;
 HEAP8[$0 + 13 | 0] = $1;
 HEAP8[$0 + 14 | 0] = $1 >>> 8;
}
function graphicsSetPixel($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 global$0 = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 graphicsToDeviceCoordinates(HEAP32[$4 + 12 >> 2], $4 + 8 | 0, $4 + 4 | 0);
 graphicsSetPixelDevice(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2]);
 global$0 = $4 + 16 | 0;
}
function graphicsGetHeight($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 label$1 : {
  if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 16) {
   $0 = HEAP32[$1 + 12 >> 2];
   $0 = HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8;
   break label$1;
  }
  $0 = HEAP32[$1 + 12 >> 2];
  $0 = HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8;
 }
 return $0;
}
function double_20const__20std____2__min_double__28double_20const__2c_20double_20const__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = double_20const__20std____2__min_double_2c_20std____2____less_double_2c_20double__20__28double_20const__2c_20double_20const__2c_20std____2____less_double_2c_20double__29(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0;
}
function tflite__EspruinoErrorReporter__Report_28char_20const__2c_20void__29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 288 | 0;
 global$0 = $3;
 HEAP32[$3 + 284 >> 2] = $0;
 HEAP32[$3 + 280 >> 2] = $1;
 HEAP32[$3 + 276 >> 2] = $2;
 $0 = $3 + 16 | 0;
 espruino_snprintf_va($0, 256, HEAP32[$3 + 280 >> 2], HEAP32[$3 + 276 >> 2]);
 HEAP32[$3 >> 2] = $0;
 jsExceptionHere(1, 137744, $3);
 global$0 = $3 + 288 | 0;
 return 0;
}
function jswrap_waveform_startInput($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = +$2;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 global$0 = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP8[$4 + 27 | 0] = $1;
 HEAPF64[$4 + 16 >> 3] = $2;
 HEAP32[$4 + 12 >> 2] = $3;
 if (!(jshPinAnalog(HEAPU8[$4 + 27 | 0]) < 0)) {
  jswrap_waveform_start(HEAP32[$4 + 28 >> 2], HEAPU8[$4 + 27 | 0], HEAPF64[$4 + 16 >> 3], HEAP32[$4 + 12 >> 2], 0);
 }
 global$0 = $4 + 32 | 0;
}
function graphicsGetWidth($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 label$1 : {
  if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 16) {
   $0 = HEAP32[$1 + 12 >> 2];
   $0 = HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8;
   break label$1;
  }
  $0 = HEAP32[$1 + 12 >> 2];
  $0 = HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8;
 }
 return $0;
}
function flatbuffers__IndirectHelper_flatbuffers__Offset_tflite__Tensor__20___Read_28unsigned_20char_20const__2c_20unsigned_20int_29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + (HEAP32[$2 + 8 >> 2] << 2);
 $0 = HEAP32[$2 + 12 >> 2] + flatbuffers__Vector_int___size_28_29_20const(HEAP32[$2 + 12 >> 2]) | 0;
 global$0 = $2 + 16 | 0;
 return $0;
}
function jswrap_banglejs_getLogo() {
 var $0 = 0, $1 = 0;
 $0 = global$0 - 496 | 0;
 global$0 = $0;
 $1 = $0 + 16 | 0;
 memcpy($1, 111088, 467);
 HEAP32[$0 + 12 >> 2] = jsvNewNativeString($1, 467);
 HEAP32[$0 + 8 >> 2] = jswrap_heatshrink_decompress(HEAP32[$0 + 12 >> 2]);
 HEAP32[$0 + 4 >> 2] = jsvGetArrayBufferBackingString(HEAP32[$0 + 8 >> 2], 0);
 jsvUnLock2(HEAP32[$0 + 12 >> 2], HEAP32[$0 + 8 >> 2]);
 global$0 = $0 + 496 | 0;
 return HEAP32[$0 + 4 >> 2];
}
function tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = tflite___28anonymous_20namespace_29__GetMutableInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 global$0 = $3 + 16 | 0;
 return $0;
}
function jswrap_graphics_reset($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 80 | 0;
 global$0 = $1;
 HEAP32[$1 + 72 >> 2] = $0;
 label$1 : {
  if (!(graphicsGetFromVar($1, HEAP32[$1 + 72 >> 2]) & 1)) {
   HEAP32[$1 + 76 >> 2] = 0;
   break label$1;
  }
  graphicsStructResetState($1);
  graphicsSetVar($1);
  HEAP32[$1 + 76 >> 2] = jswrap_graphics_setFontSizeX(HEAP32[$1 + 72 >> 2], 8193, 0);
 }
 global$0 = $1 + 80 | 0;
 return HEAP32[$1 + 76 >> 2];
}
function mbedtls_sha1_starts($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[HEAP32[$1 + 12 >> 2] >> 2] = 0;
 HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] = 0;
 HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] = 1732584193;
 HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2] = -271733879;
 HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = -1732584194;
 HEAP32[HEAP32[$1 + 12 >> 2] + 20 >> 2] = 271733878;
 HEAP32[HEAP32[$1 + 12 >> 2] + 24 >> 2] = -1009589776;
}
function jshPinOutput($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
 label$1 : {
  if (jshIsPinValid(HEAPU8[$2 + 15 | 0]) & 1) {
   jshPinSetValue(HEAPU8[$2 + 15 | 0], HEAP8[$2 + 14 | 0] & 1);
   if (!(jshGetPinStateIsManual(HEAPU8[$2 + 15 | 0]) & 1)) {
    jshPinSetState(HEAPU8[$2 + 15 | 0], 1);
   }
   break label$1;
  }
  jsExceptionHere(1, 80907, 0);
 }
 global$0 = $2 + 16 | 0;
}
function tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = tflite__micro__GetMutableEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 global$0 = $3 + 16 | 0;
 return $0;
}
function jsvStringIteratorGetCharOrMinusOne($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!(HEAPU32[HEAP32[$1 + 8 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 8 >> 2] + 4 >> 2] ? HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2] : 0)) {
   HEAP32[$1 + 12 >> 2] = -1;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = HEAPU8[HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2] + HEAP32[HEAP32[$1 + 8 >> 2] >> 2] | 0];
 }
 return HEAP32[$1 + 12 >> 2];
}
function jslFunctionCharAsString($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = 32;
 label$1 : {
  if (HEAPU8[$2 + 15 | 0] >= 128) {
   jslTokenAsString(HEAPU8[$2 + 15 | 0], HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
   break label$1;
  }
  HEAP8[HEAP32[$2 + 8 >> 2]] = HEAPU8[$2 + 15 | 0];
  HEAP8[HEAP32[$2 + 8 >> 2] + 1 | 0] = 0;
 }
 global$0 = $2 + 16 | 0;
}
function float_20const__20std____2__min_float__28float_20const__2c_20float_20const__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = float_20const__20std____2__min_float_2c_20std____2____less_float_2c_20float__20__28float_20const__2c_20float_20const__2c_20std____2____less_float_2c_20float__29(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0;
}
function float_20const__20std____2__max_float__28float_20const__2c_20float_20const__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = float_20const__20std____2__max_float_2c_20std____2____less_float_2c_20float__20__28float_20const__2c_20float_20const__2c_20std____2____less_float_2c_20float__29(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0;
}
function lcdInit_ArrayBuffer($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jswrap_arraybuffer_constructor(graphicsGetMemoryRequired(HEAP32[$1 + 12 >> 2]));
 $0 = HEAP32[$1 + 12 >> 2];
 jsvUnLock2(jsvAddNamedChild(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), HEAP32[$1 + 8 >> 2], 108443), HEAP32[$1 + 8 >> 2]);
 global$0 = $1 + 16 | 0;
}
function jsvUnLockFreeIfNeeded($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1 : {
  if (jsvGetRefs(HEAP32[$1 + 12 >> 2]) & 255) {
   break label$1;
  }
  if (!(jsvHasRef(HEAP32[$1 + 12 >> 2]) & 1)) {
   break label$1;
  }
  $0 = HEAP32[$1 + 12 >> 2];
  if (!((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63)) {
   break label$1;
  }
  jsvFreePtr(HEAP32[$1 + 12 >> 2]);
 }
 global$0 = $1 + 16 | 0;
}
function jsvNewFromPin($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvNewFromInteger(HEAP32[$1 + 12 >> 2]);
 if (HEAP32[$1 + 8 >> 2]) {
  $0 = HEAP32[$1 + 8 >> 2];
  $2 = HEAP32[$1 + 8 >> 2];
  $2 = (HEAPU8[$2 + 13 | 0] | HEAPU8[$2 + 14 | 0] << 8) & -64 | 12;
  HEAP8[$0 + 13 | 0] = $2;
  HEAP8[$0 + 14 | 0] = $2 >>> 8;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function heatshrink_encoder_finish($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP32[$1 + 12 >> 2] = -1;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$0 + 11 | 0] = HEAPU8[$0 + 11 | 0] | 1;
  if (!HEAPU8[HEAP32[$1 + 8 >> 2] + 12 | 0]) {
   HEAP8[HEAP32[$1 + 8 >> 2] + 12 | 0] = 1;
  }
  HEAP32[$1 + 12 >> 2] = HEAPU8[HEAP32[$1 + 8 >> 2] + 12 | 0] == 9 ? 0 : 1;
 }
}
function jsspiHardwareFunc($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 global$0 = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP8[$4 + 15 | 0] = HEAPU8[HEAP32[$4 + 16 >> 2]];
 jshSPISendMany(HEAPU8[$4 + 15 | 0], HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2]);
 global$0 = $4 + 32 | 0;
}
function tflite__internal__ContextHelper__AllocatePersistentBuffer_28TfLiteContext__2c_20unsigned_20long_29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = tflite__MicroAllocator__AllocatePersistentBuffer_28unsigned_20long_29(HEAP32[HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2] >> 2], HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0 | 0;
}
function std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter____unique_ptr_28_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___reset_28TfLiteConvParams__29(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
}
function lcdMemLCD_convert16to3($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 HEAP32[$3 + 12 >> 2] = HEAPU16[(((HEAP32[$3 + 4 >> 2] & 1) << 2) + 108470 | 0) + ((HEAP32[$3 + 8 >> 2] & 1) << 1) >> 1] + (HEAP32[$3 + 12 >> 2] & 59164);
 return (HEAP32[$3 + 12 >> 2] & 65536 ? 4 : 0) | (HEAP32[$3 + 12 >> 2] & 2048 ? 2 : 0) | (HEAP32[$3 + 12 >> 2] & 32 ? 1 : 0);
}
function jsvArrayBufferIteratorFloatToData($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAPF64[$4 + 8 >> 3] = $3;
 label$1 : {
  if (HEAP32[$4 + 24 >> 2] == 4) {
   HEAPF32[HEAP32[$4 + 28 >> 2] >> 2] = HEAPF64[$4 + 8 >> 3];
   break label$1;
  }
  if (HEAP32[$4 + 24 >> 2] == 8) {
   HEAPF64[HEAP32[$4 + 28 >> 2] >> 3] = HEAPF64[$4 + 8 >> 3];
  }
 }
}
function jswrap_espruino_getAddressOf($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP8[$2 + 7 | 0] = $1;
 label$1 : {
  if (HEAP8[$2 + 7 | 0] & 1) {
   HEAP32[$2 >> 2] = 0;
   HEAP32[$2 + 12 >> 2] = jsvGetDataPointer(HEAP32[$2 + 8 >> 2], $2);
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 8 >> 2];
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function tflite__MicroMutableOpResolver_9u___MicroMutableOpResolver_28tflite__ErrorReporter__29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = 0;
 $0 = HEAP32[$1 + 12 >> 2];
 tflite__MicroOpResolver__MicroOpResolver_28_29($0);
 HEAP32[$0 >> 2] = 137756;
 HEAP32[$0 + 292 >> 2] = 0;
 HEAP32[$0 + 368 >> 2] = 0;
 HEAP32[$0 + 372 >> 2] = HEAP32[$1 + 8 >> 2];
 global$0 = $1 + 16 | 0;
}
function jsvArrayAddUnique($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = jsvGetIndexOf(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 0);
 label$1 : {
  if (!HEAP32[$2 + 4 >> 2]) {
   jsvArrayPush(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
   break label$1;
  }
  jsvUnLock(HEAP32[$2 + 4 >> 2]);
 }
 global$0 = $2 + 16 | 0;
}
function jsfEraseFileInternal($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] - 32;
 HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + ((HEAP32[$2 + 8 >> 2] + 4 | 0) - HEAP32[$2 + 8 >> 2] | 0);
 HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] = 0;
 jshFlashWrite(HEAP32[$2 + 8 >> 2] + 4 | 0, HEAP32[$2 + 12 >> 2], 4);
 global$0 = $2 + 16 | 0;
}
function jswrap_espruino_clip($0, $1, $2) {
 $0 = +$0;
 $1 = +$1;
 $2 = +$2;
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 HEAPF64[$3 + 24 >> 3] = $0;
 HEAPF64[$3 + 16 >> 3] = $1;
 HEAPF64[$3 + 8 >> 3] = $2;
 if (HEAPF64[$3 + 24 >> 3] < HEAPF64[$3 + 16 >> 3]) {
  HEAPF64[$3 + 24 >> 3] = HEAPF64[$3 + 16 >> 3];
 }
 if (HEAPF64[$3 + 24 >> 3] > HEAPF64[$3 + 8 >> 3]) {
  HEAPF64[$3 + 24 >> 3] = HEAPF64[$3 + 8 >> 3];
 }
 return +HEAPF64[$3 + 24 >> 3];
}
function tflite__ErrorReporter__ReportError_28void__2c_20char_20const__2c_20____29($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 global$0 = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 $0 = HEAP32[$4 + 28 >> 2];
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP32[$4 + 12 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 8 >> 2]]($0, HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2]);
 global$0 = $4 + 32 | 0;
}
function jsiConsoleReturnInputLine() {
 if (HEAP8[322232] & 1) {
  HEAP8[322232] = 0;
  if (jsiEcho() & 1) {
   if (HEAPU16[161112] & 8) {
    jsiConsolePrintString(81059);
   }
   if (jsiPasswordProtected() & 1) {
    jsiConsolePrintString(81065);
   }
   jsiConsolePrintChar(62);
   jsiConsolePrintStringVarWithNewLineChar(HEAP32[80557], 0, 58);
   jsiMoveCursorChar(HEAP32[80557], jsvGetStringLength(HEAP32[80557]), HEAP32[80559]);
  }
 }
}
function jsvIsVariableDefined($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = !(jsvIsName(HEAP32[$1 + 12 >> 2]) & 1);
 $2 = 1;
 label$1 : {
  if ($0) {
   break label$1;
  }
  $0 = jsvIsNameWithValue(HEAP32[$1 + 12 >> 2]) & 1;
  $2 = 1;
  if ($0) {
   break label$1;
  }
  $2 = (jsvGetFirstChild(HEAP32[$1 + 12 >> 2]) & 65535) != 0;
 }
 $0 = $2;
 global$0 = $1 + 16 | 0;
 return $0 & 1;
}
function jsiSetBusy($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 label$1 : {
  if (HEAP8[$2 + 11 | 0] & 1) {
   HEAP32[80561] = HEAP32[$2 + 12 >> 2] | HEAP32[80561];
   break label$1;
  }
  HEAP32[80561] = HEAP32[80561] & (HEAP32[$2 + 12 >> 2] ^ -1);
 }
 if (HEAPU8[141673] != 255) {
  jshPinOutput(HEAPU8[141673], HEAP32[80561] != 0);
 }
 global$0 = $2 + 16 | 0;
}
function heatshrink_var_input_cb($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 4 >> 2] = -1;
 if (jsvIteratorHasElement(HEAP32[$1 + 8 >> 2]) & 1) {
  HEAP32[$1 + 4 >> 2] = jsvIteratorGetIntegerValue(HEAP32[$1 + 8 >> 2]) & 255;
 }
 jsvIteratorNext(HEAP32[$1 + 8 >> 2]);
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 4 >> 2];
}
function tflite__MultiplyByQuantizedMultiplierGreaterThanOne_28int_2c_20int_2c_20int_29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = int_20gemmlowp__SaturatingRoundingDoublingHighMul_int__28int_2c_20int_29(Math_imul(HEAP32[$3 + 12 >> 2], 1 << HEAP32[$3 + 4 >> 2]), HEAP32[$3 + 8 >> 2]);
 global$0 = $3 + 16 | 0;
 return $0;
}
function jswrap_promise_reject($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = jspromise_create();
 label$1 : {
  if (!HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  jspromise_reject(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 8 >> 2]);
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function tflite__MicroOpResolver__FindOp_28tflite__BuiltinOperator_2c_20int_29_20const($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 20 >> 2]]($0, HEAP32[$3 + 8 >> 2]) | 0;
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function jswrap_e_dumpStr() {
 var $0 = 0;
 $0 = global$0 - 48 | 0;
 global$0 = $0;
 HEAP32[$0 + 40 >> 2] = jsvNewWithFlags(27);
 label$1 : {
  if (!HEAP32[$0 + 40 >> 2]) {
   HEAP32[$0 + 44 >> 2] = 0;
   break label$1;
  }
  jsvStringIteratorNew($0, HEAP32[$0 + 40 >> 2], 0);
  jsiDumpState(2, $0);
  jsvStringIteratorFree($0);
  HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 40 >> 2];
 }
 global$0 = $0 + 48 | 0;
 return HEAP32[$0 + 44 >> 2];
}
function jsvStringIteratorPrintfCallback($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 while (1) {
  if (HEAPU8[HEAP32[$2 + 12 >> 2]]) {
   $0 = HEAP32[$2 + 8 >> 2];
   $1 = HEAP32[$2 + 12 >> 2];
   HEAP32[$2 + 12 >> 2] = $1 + 1;
   jsvStringIteratorAppend($0, HEAP8[$1 | 0]);
   continue;
  }
  break;
 }
 global$0 = $2 + 16 | 0;
}
function jsiGetClassNameFromDevice($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 11 | 0] = $0;
 HEAP32[$1 + 4 >> 2] = jshGetDeviceString(HEAPU8[$1 + 11 | 0]);
 label$1 : {
  if (!HEAPU8[HEAP32[$1 + 4 >> 2]]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvFindChildFromString(HEAP32[80545], HEAP32[$1 + 4 >> 2], 0);
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jsiConsoleRemoveInputLine() {
 if (!(HEAP8[322232] & 1)) {
  HEAP8[322232] = 1;
  if (!(!(jsiEcho() & 1) | !HEAP32[80557])) {
   jsiMoveCursorChar(HEAP32[80557], HEAP32[80559], 0);
   jsiConsolePrintChar(13);
   jsiConsolePrintString(81039);
   if (HEAPU16[161112] & 8) {
    jsiConsolePrintChar(8);
    jsiConsolePrintChar(8);
    jsiConsolePrintChar(8);
    jsiConsolePrintChar(8);
    jsiConsolePrintChar(8);
   }
  }
 }
}
function jspeBlockOrStatement() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 label$1 : {
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 123) {
   jspeBlock();
   HEAP32[$0 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$0 + 8 >> 2] = jspeStatement();
  if (HEAP16[HEAP32[35539] + 2 >> 1] == 59) {
   jslGetNextToken();
  }
  HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 8 >> 2];
 }
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}
function jsiHandleIOEventForSerial($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = 0;
 HEAP32[$2 >> 2] = jsiExtractIOEventData(HEAP32[$2 + 8 >> 2], $2 + 4 | 0);
 if (HEAP32[$2 >> 2]) {
  jswrap_stream_pushData(HEAP32[$2 + 12 >> 2], HEAP32[$2 >> 2]);
  jsvUnLock(HEAP32[$2 >> 2]);
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 4 >> 2];
}
function gen_jswrap_Graphics_setBgColor($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 global$0 = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 $0 = jswrap_graphics_setColorX(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2], 0);
 global$0 = $4 + 16 | 0;
 return $0 | 0;
}
function jsvMakeFunctionParameter($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (!(jsvIsName(HEAP32[$1 + 12 >> 2]) & 1)) {
  jsvMakeIntoVariableName(HEAP32[$1 + 12 >> 2], 0);
 }
 $0 = HEAP32[$1 + 12 >> 2];
 $2 = HEAP32[$1 + 12 >> 2];
 $2 = HEAPU8[$2 + 13 | 0] | HEAPU8[$2 + 14 | 0] << 8 | 64;
 HEAP8[$0 + 13 | 0] = $2;
 HEAP8[$0 + 14 | 0] = $2 >>> 8;
 global$0 = $1 + 16 | 0;
}
function int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = int_20const__20std____2__min_int_2c_20std____2____less_int_2c_20int__20__28int_20const__2c_20int_20const__2c_20std____2____less_int_2c_20int__29(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0;
}
function int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = int_20const__20std____2__max_int_2c_20std____2____less_int_2c_20int__20__28int_20const__2c_20int_20const__2c_20std____2____less_int_2c_20int__29(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0;
}
function gen_jswrap_Graphics_setColor($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 global$0 = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 $0 = jswrap_graphics_setColorX(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2], 1);
 global$0 = $4 + 16 | 0;
 return $0 | 0;
}
function jsvIsNameWithValue($0) {
 var $1 = 0, $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 $1 = 0;
 label$1 : {
  if (!HEAP32[$2 + 12 >> 2]) {
   break label$1;
  }
  $0 = HEAP32[$2 + 12 >> 2];
  $1 = 0;
  if (((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) < 15) {
   break label$1;
  }
  $0 = HEAP32[$2 + 12 >> 2];
  $1 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) <= 21;
 }
 return $1;
}
function flatbuffers__Vector_float___Get_28unsigned_20int_29_20const($0) {
 var $1 = 0, $2 = Math_fround(0);
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = 0;
 $2 = flatbuffers__IndirectHelper_float___Read_28unsigned_20char_20const__2c_20unsigned_20int_29(flatbuffers__Vector_int___Data_28_29_20const(HEAP32[$1 + 12 >> 2]), HEAP32[$1 + 8 >> 2]);
 global$0 = $1 + 16 | 0;
 return $2;
}
function jswrap_array_unshift($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = jsvNewFromInteger(0);
 jsvUnLock2(jswrap_array_splice(HEAP32[$2 + 12 >> 2], 0, HEAP32[$2 + 4 >> 2], HEAP32[$2 + 8 >> 2]), HEAP32[$2 + 4 >> 2]);
 $0 = jsvGetLength(HEAP32[$2 + 12 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0 | 0;
}
function jsvIsFunctionParameter($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $2 = 0;
 label$1 : {
  if (!HEAP32[$1 + 12 >> 2]) {
   break label$1;
  }
  $0 = HEAP32[$1 + 12 >> 2];
  $2 = 0;
  if (!((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 64)) {
   break label$1;
  }
  $2 = jsvIsString(HEAP32[$1 + 12 >> 2]);
 }
 $0 = $2;
 global$0 = $1 + 16 | 0;
 return $0 & 1;
}
function jsvIsBasicString($0) {
 var $1 = 0, $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 $1 = 0;
 label$1 : {
  if (!HEAP32[$2 + 12 >> 2]) {
   break label$1;
  }
  $0 = HEAP32[$2 + 12 >> 2];
  $1 = 0;
  if (((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) < 27) {
   break label$1;
  }
  $0 = HEAP32[$2 + 12 >> 2];
  $1 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) <= 37;
 }
 return $1;
}
function jsvArrayBufferGetFromName($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvGetInteger(HEAP32[$1 + 12 >> 2]);
 HEAP32[$1 + 4 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$1 + 12 >> 2]) & 65535);
 HEAP32[$1 >> 2] = jsvArrayBufferGet(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 8 >> 2]);
 jsvUnLock(HEAP32[$1 + 4 >> 2]);
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 >> 2];
}
function jswrap_pin_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP8[$1 + 7 | 0] = jshGetPinFromVar(HEAP32[$1 + 8 >> 2]);
 label$1 : {
  if (!(jshIsPinValid(HEAPU8[$1 + 7 | 0]) & 1)) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvNewFromPin(HEAPU8[$1 + 7 | 0]);
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function tflite__MicroOpResolver__FindOp_28char_20const__2c_20int_29_20const($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 24 >> 2]]($0, HEAP32[$3 + 8 >> 2]) | 0;
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function jsvIsStringExt($0) {
 var $1 = 0, $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 $1 = 0;
 label$1 : {
  if (!HEAP32[$2 + 12 >> 2]) {
   break label$1;
  }
  $0 = HEAP32[$2 + 12 >> 2];
  $1 = 0;
  if (((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) < 41) {
   break label$1;
  }
  $0 = HEAP32[$2 + 12 >> 2];
  $1 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) <= 52;
 }
 return $1;
}
function jsvIsBasicName($0) {
 var $1 = 0, $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 $1 = 0;
 label$1 : {
  if (!HEAP32[$2 + 12 >> 2]) {
   break label$1;
  }
  $0 = HEAP32[$2 + 12 >> 2];
  $1 = 0;
  if (((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) < 22) {
   break label$1;
  }
  $0 = HEAP32[$2 + 12 >> 2];
  $1 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) <= 26;
 }
 return $1;
}
function jsvGetInternalFunctionCheckerFor($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (jsvIsFunction(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 3;
   break label$1;
  }
  if (jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 4;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function flatbuffers__Vector_long_20long___Get_28unsigned_20int_29_20const($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = flatbuffers__IndirectHelper_long_20long___Read_28unsigned_20char_20const__2c_20unsigned_20int_29(flatbuffers__Vector_int___Data_28_29_20const(HEAP32[$2 + 12 >> 2]), HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0;
}
function jswrap_onewire_reset($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP8[$1 + 7 | 0] = onewire_getpin(HEAP32[$1 + 8 >> 2]);
 label$1 : {
  if (!(jshIsPinValid(HEAPU8[$1 + 7 | 0]) & 1)) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  HEAP8[$1 + 15 | 0] = OneWireReset(HEAPU8[$1 + 7 | 0]) & 1;
 }
 global$0 = $1 + 16 | 0;
 return HEAP8[$1 + 15 | 0] & 1;
}
function jswrap_object_valueOf($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP32[$1 >> 2] = HEAP32[$1 + 8 >> 2];
   jsExceptionHere(3, 123204, $1);
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[$1 + 8 >> 2]);
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jsvIsString($0) {
 var $1 = 0, $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 $1 = 0;
 label$1 : {
  if (!HEAP32[$2 + 12 >> 2]) {
   break label$1;
  }
  $0 = HEAP32[$2 + 12 >> 2];
  $1 = 0;
  if (((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) < 17) {
   break label$1;
  }
  $0 = HEAP32[$2 + 12 >> 2];
  $1 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) <= 40;
 }
 return $1;
}
function jsvIsNumeric($0) {
 var $1 = 0, $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 $1 = 0;
 label$1 : {
  if (!HEAP32[$2 + 12 >> 2]) {
   break label$1;
  }
  $0 = HEAP32[$2 + 12 >> 2];
  $1 = 0;
  if (((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) < 9) {
   break label$1;
  }
  $0 = HEAP32[$2 + 12 >> 2];
  $1 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) <= 16;
 }
 return $1;
}
function jsvRemoveAllChildren($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 while (1) {
  if (jsvGetFirstChild(HEAP32[$1 + 12 >> 2]) & 65535) {
   HEAP32[$1 + 8 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$1 + 12 >> 2]) & 65535);
   jsvRemoveChild(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 8 >> 2]);
   jsvUnLock(HEAP32[$1 + 8 >> 2]);
   continue;
  }
  break;
 }
 global$0 = $1 + 16 | 0;
}
function jsvIsName($0) {
 var $1 = 0, $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 $1 = 0;
 label$1 : {
  if (!HEAP32[$2 + 12 >> 2]) {
   break label$1;
  }
  $0 = HEAP32[$2 + 12 >> 2];
  $1 = 0;
  if (((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) < 13) {
   break label$1;
  }
  $0 = HEAP32[$2 + 12 >> 2];
  $1 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) <= 26;
 }
 return $1;
}
function jsvAppendPrintf($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = global$0 + -64 | 0;
 global$0 = $3;
 $4 = $3 + 12 | 0;
 HEAP32[$3 + 60 >> 2] = $0;
 HEAP32[$3 + 56 >> 2] = $1;
 $0 = $3 + 16 | 0;
 jsvStringIteratorNew($0, HEAP32[$3 + 60 >> 2], 0);
 jsvStringIteratorGotoEnd($0);
 HEAP32[$4 >> 2] = $2;
 vcbprintf(2, $0, HEAP32[$3 + 56 >> 2], HEAP32[$3 + 12 >> 2]);
 jsvStringIteratorFree($0);
 global$0 = $3 - -64 | 0;
}
function jsiConsolePrintString($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 while (1) {
  if (HEAPU8[HEAP32[$1 + 12 >> 2]]) {
   if (HEAP8[HEAP32[$1 + 12 >> 2]] == 10) {
    jsiConsolePrintChar(13);
   }
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$1 + 12 >> 2] = $0 + 1;
   jsiConsolePrintChar(HEAP8[$0 | 0]);
   continue;
  }
  break;
 }
 global$0 = $1 + 16 | 0;
}
function jshPushIOEvent($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP8[$3 + 31 | 0] = $0;
 HEAP32[$3 + 16 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 HEAP8[$3 + 8 | 0] = HEAPU8[$3 + 31 | 0];
 $0 = HEAP32[$3 + 16 >> 2];
 HEAP8[$3 + 9 | 0] = $0;
 HEAP8[$3 + 10 | 0] = $0 >>> 8;
 HEAP8[$3 + 11 | 0] = $0 >>> 16;
 HEAP8[$3 + 12 | 0] = $0 >>> 24;
 jshPushEvent($3 + 8 | 0);
 global$0 = $3 + 32 | 0;
}
function jsonNeedsNewLine($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsvIsUndefined(HEAP32[$1 + 12 >> 2]) & 1;
 $2 = 1;
 label$1 : {
  if ($0) {
   break label$1;
  }
  $0 = jsvIsNull(HEAP32[$1 + 12 >> 2]) & 1;
  $2 = 1;
  if ($0) {
   break label$1;
  }
  $2 = jsvIsNumeric(HEAP32[$1 + 12 >> 2]);
 }
 $0 = $2;
 global$0 = $1 + 16 | 0;
 return ($0 ^ -1) & 1;
}
function tflite__Operator__builtin_options_as_DepthwiseConv2DOptions_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 label$1 : {
  if ((tflite__Operator__builtin_options_type_28_29_20const($0) | 0) == 2) {
   $0 = tflite__Tensor__quantization_28_29_20const($0);
   break label$1;
  }
  $0 = 0;
 }
 global$0 = $1 + 16 | 0;
 return $0;
}
function mbedtls_sha1($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 112 | 0;
 global$0 = $3;
 HEAP32[$3 + 108 >> 2] = $0;
 HEAP32[$3 + 104 >> 2] = $1;
 HEAP32[$3 + 100 >> 2] = $2;
 $0 = $3 + 8 | 0;
 mbedtls_sha1_init($0);
 mbedtls_sha1_starts($0);
 mbedtls_sha1_update($0, HEAP32[$3 + 108 >> 2], HEAP32[$3 + 104 >> 2]);
 mbedtls_sha1_finish($0, HEAP32[$3 + 100 >> 2]);
 mbedtls_sha1_free($0);
 global$0 = $3 + 112 | 0;
}
function jsvGetMaxCharactersInVar($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (jsvIsStringExt(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 11;
   break label$1;
  }
  if (jsvIsName(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 4;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 10;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function fromTimeInDay($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return +(HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] + Math_imul(HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] + Math_imul((HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2] + Math_imul(HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2], 60) | 0) - HEAP32[HEAP32[$1 + 12 >> 2] + 20 >> 2] | 0, 60) | 0, 1e3) | 0) + +HEAP32[HEAP32[$1 + 12 >> 2] >> 2] * 864e5;
}
function tflite__Operator__builtin_options_as_FullyConnectedOptions_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 label$1 : {
  if ((tflite__Operator__builtin_options_type_28_29_20const($0) | 0) == 8) {
   $0 = tflite__Tensor__quantization_28_29_20const($0);
   break label$1;
  }
  $0 = 0;
 }
 global$0 = $1 + 16 | 0;
 return $0;
}
function jswrap_tfmicrointerpreter_invoke($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jswrap_tfmicrointerpreter_getTFMI(HEAP32[$1 + 12 >> 2]);
 label$1 : {
  if (!HEAP32[$1 + 8 >> 2]) {
   break label$1;
  }
  if (tf_invoke(HEAP32[$1 + 8 >> 2]) & 1) {
   break label$1;
  }
  jsExceptionHere(3, 128748, 0);
 }
 global$0 = $1 + 16 | 0;
}
function jsnCallFunction($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 32 | 0;
 global$0 = $5;
 HEAP32[$5 + 28 >> 2] = $0;
 HEAP16[$5 + 26 >> 1] = $1;
 HEAP32[$5 + 20 >> 2] = $2;
 HEAP32[$5 + 16 >> 2] = $3;
 HEAP32[$5 + 12 >> 2] = $4;
 $0 = jswCallFunctionHack(HEAP32[$5 + 28 >> 2], HEAPU16[$5 + 26 >> 1], HEAP32[$5 + 20 >> 2], HEAP32[$5 + 16 >> 2], HEAP32[$5 + 12 >> 2]);
 global$0 = $5 + 32 | 0;
 return $0;
}
function jshGetPinString($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 HEAP8[HEAP32[$2 + 12 >> 2]] = 0;
 label$1 : {
  if (HEAPU8[$2 + 11 | 0] < 48) {
   HEAP8[HEAP32[$2 + 12 >> 2]] = 68;
   itostr(HEAPU8[$2 + 11 | 0], HEAP32[$2 + 12 >> 2] + 1 | 0, 10);
   break label$1;
  }
  strcpy(HEAP32[$2 + 12 >> 2], 80897);
 }
 global$0 = $2 + 16 | 0;
}
function flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph__20___operator_5b_5d_28unsigned_20int_29_20const($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph__20___Get_28unsigned_20int_29_20const(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0;
}
function tflite__internal__ContextHelper__GetScratchBuffer_28TfLiteContext__2c_20int_29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = tflite__MicroAllocator__GetScratchBuffer_28int_29_20const(HEAP32[HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2] >> 2], HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0 | 0;
}
function jswrap_promise_get_chained_promise($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvObjectGetChild(HEAP32[$1 + 12 >> 2], 125109, 0);
 if (!HEAP32[$1 + 8 >> 2]) {
  HEAP32[$1 + 8 >> 2] = jspNewObject(0, 125172);
  jsvObjectSetChild(HEAP32[$1 + 12 >> 2], 125109, HEAP32[$1 + 8 >> 2]);
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function OneWireReset($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 15 | 0] = $0;
 jshPinSetState(HEAPU8[$1 + 15 | 0], 3);
 jshPinSetValue(HEAPU8[$1 + 15 | 0], 0);
 do_indexing(500);
 jshPinSetValue(HEAPU8[$1 + 15 | 0], 1);
 do_indexing(80);
 HEAP8[$1 + 14 | 0] = (jshPinGetValue(HEAPU8[$1 + 15 | 0]) ^ -1) & 1;
 do_indexing(420);
 global$0 = $1 + 16 | 0;
 return HEAP8[$1 + 14 | 0] & 1;
}
function jswrap_waveform_startOutput($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = +$2;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 global$0 = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP8[$4 + 27 | 0] = $1;
 HEAPF64[$4 + 16 >> 3] = $2;
 HEAP32[$4 + 12 >> 2] = $3;
 jswrap_waveform_start(HEAP32[$4 + 28 >> 2], HEAPU8[$4 + 27 | 0], HEAPF64[$4 + 16 >> 3], HEAP32[$4 + 12 >> 2], 1);
 global$0 = $4 + 32 | 0;
}
function jswrap_string_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!jsvGetArrayLength(HEAP32[$1 + 8 >> 2])) {
   HEAP32[$1 + 12 >> 2] = jsvNewWithFlags(27);
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvAsStringAndUnLock(jsvGetArrayItem(HEAP32[$1 + 8 >> 2], 0));
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function gen_jswrap_DataView_setFloat64($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 global$0 = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP8[$4 + 3 | 0] = $3;
 jswrap_dataview_set(HEAP32[$4 + 12 >> 2], 40, HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP8[$4 + 3 | 0] & 1);
 global$0 = $4 + 16 | 0;
}
function gen_jswrap_DataView_setFloat32($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 global$0 = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP8[$4 + 3 | 0] = $3;
 jswrap_dataview_set(HEAP32[$4 + 12 >> 2], 36, HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP8[$4 + 3 | 0] & 1);
 global$0 = $4 + 16 | 0;
}
function lcdSetPixel_ArrayBuffer_flat($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 global$0 = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 lcdSetPixels_ArrayBuffer_flat(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], 1, HEAP32[$4 >> 2]);
 global$0 = $4 + 16 | 0;
}
function jsvObjectGetChildI($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1 : {
  if (!HEAP32[$2 + 8 >> 2]) {
   HEAP32[$2 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jsvSkipNameAndUnLock(jsvFindChildFromStringI(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]));
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function gen_jswrap_DataView_setUint32($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 global$0 = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP8[$4 + 3 | 0] = $3;
 jswrap_dataview_set(HEAP32[$4 + 12 >> 2], 4, HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP8[$4 + 3 | 0] & 1);
 global$0 = $4 + 16 | 0;
}
function gen_jswrap_DataView_setUint16($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 global$0 = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP8[$4 + 3 | 0] = $3;
 jswrap_dataview_set(HEAP32[$4 + 12 >> 2], 2, HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP8[$4 + 3 | 0] & 1);
 global$0 = $4 + 16 | 0;
}
function gen_jswrap_DataView_setInt32($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 global$0 = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP8[$4 + 3 | 0] = $3;
 jswrap_dataview_set(HEAP32[$4 + 12 >> 2], 20, HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP8[$4 + 3 | 0] & 1);
 global$0 = $4 + 16 | 0;
}
function gen_jswrap_DataView_setInt16($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 global$0 = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP8[$4 + 3 | 0] = $3;
 jswrap_dataview_set(HEAP32[$4 + 12 >> 2], 18, HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP8[$4 + 3 | 0] & 1);
 global$0 = $4 + 16 | 0;
}
function tflite__Operator__builtin_options_as_ReshapeOptions_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 label$1 : {
  if ((tflite__Operator__builtin_options_type_28_29_20const($0) | 0) == 17) {
   $0 = tflite__Tensor__quantization_28_29_20const($0);
   break label$1;
  }
  $0 = 0;
 }
 global$0 = $1 + 16 | 0;
 return $0;
}
function gen_jswrap_DataView_setUint8($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 global$0 = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP8[$4 + 3 | 0] = $3;
 jswrap_dataview_set(HEAP32[$4 + 12 >> 2], 1, HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP8[$4 + 3 | 0] & 1);
 global$0 = $4 + 16 | 0;
}
function gen_jswrap_DataView_setInt8($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 global$0 = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP8[$4 + 3 | 0] = $3;
 jswrap_dataview_set(HEAP32[$4 + 12 >> 2], 17, HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP8[$4 + 3 | 0] & 1);
 global$0 = $4 + 16 | 0;
}
function tflite__Operator__builtin_options_as_SoftmaxOptions_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 label$1 : {
  if ((tflite__Operator__builtin_options_type_28_29_20const($0) | 0) == 9) {
   $0 = tflite__Tensor__quantization_28_29_20const($0);
   break label$1;
  }
  $0 = 0;
 }
 global$0 = $1 + 16 | 0;
 return $0;
}
function jsvStringIteratorSetCharAndNext($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 if (jsvStringIteratorHasChar(HEAP32[$2 + 12 >> 2]) & 1) {
  HEAP8[HEAP32[HEAP32[$2 + 12 >> 2] + 16 >> 2] + HEAP32[HEAP32[$2 + 12 >> 2] >> 2] | 0] = HEAPU8[$2 + 11 | 0];
 }
 jsvStringIteratorNextInline(HEAP32[$2 + 12 >> 2]);
 global$0 = $2 + 16 | 0;
}
function tflite__Operator__builtin_options_as_Pool2DOptions_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 label$1 : {
  if ((tflite__Operator__builtin_options_type_28_29_20const($0) | 0) == 5) {
   $0 = tflite__Tensor__quantization_28_29_20const($0);
   break label$1;
  }
  $0 = 0;
 }
 global$0 = $1 + 16 | 0;
 return $0;
}
function tflite__Operator__builtin_options_as_Conv2DOptions_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 label$1 : {
  if ((tflite__Operator__builtin_options_type_28_29_20const($0) | 0) == 1) {
   $0 = tflite__Tensor__quantization_28_29_20const($0);
   break label$1;
  }
  $0 = 0;
 }
 global$0 = $1 + 16 | 0;
 return $0;
}
function jsvGetLastArrayItem($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP16[$1 + 6 >> 1] = jsvGetLastChild(HEAP32[$1 + 8 >> 2]);
 label$1 : {
  if (!HEAPU16[$1 + 6 >> 1]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvSkipNameAndUnLock(jsvLock(HEAPU16[$1 + 6 >> 1]));
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function flatbuffers__Vector_int___Get_28unsigned_20int_29_20const($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = flatbuffers__IndirectHelper_int___Read_28unsigned_20char_20const__2c_20unsigned_20int_29(flatbuffers__Vector_int___Data_28_29_20const(HEAP32[$2 + 12 >> 2]), HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0;
}
function jsiIsAboutToEditInputLine() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 if (HEAP8[322241] & 1) {
  HEAP8[322241] = 0;
  if (jsiIsInHistory(HEAP32[80557]) & 1) {
   HEAP32[$0 + 12 >> 2] = jsvCopy(HEAP32[80557], 0);
   if (HEAP32[$0 + 12 >> 2]) {
    jsiInputLineCursorMoved();
    jsvUnLock(HEAP32[80557]);
    HEAP32[80557] = HEAP32[$0 + 12 >> 2];
   }
  }
 }
 global$0 = $0 + 16 | 0;
}
function _jsiInitNamedArray($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvObjectGetChild(HEAP32[80546], HEAP32[$1 + 12 >> 2], 3);
 HEAP16[$1 + 6 >> 1] = 0;
 if (HEAP32[$1 + 8 >> 2]) {
  HEAP16[$1 + 6 >> 1] = jsvGetRef(jsvRef(HEAP32[$1 + 8 >> 2]));
 }
 jsvUnLock(HEAP32[$1 + 8 >> 2]);
 global$0 = $1 + 16 | 0;
 return HEAPU16[$1 + 6 >> 1];
}
function jshSetPinShouldStayWatched($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 HEAP8[$1 + 15 | 0] = 17;
 HEAP8[$1 + 14 | 0] = $0;
 $0 = (HEAPU8[$1 + 15 | 0] >> 5 << 2) + 322208 | 0;
 if (HEAP8[$1 + 14 | 0] & 1) {
  $2 = 1 << (HEAPU8[$1 + 15 | 0] & 31);
 } else {
  $2 = 0;
 }
 HEAP32[$0 >> 2] = $2 | HEAP32[(HEAPU8[$1 + 15 | 0] >> 5 << 2) + 322208 >> 2] & (1 << (HEAPU8[$1 + 15 | 0] & 31) ^ -1);
}
function isHexadecimal($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 label$1 : {
  if (HEAP8[$1 + 15 | 0] >= 48) {
   $0 = 1;
   if (HEAP8[$1 + 15 | 0] <= 57) {
    break label$1;
   }
  }
  if (HEAP8[$1 + 15 | 0] >= 97) {
   $0 = 1;
   if (HEAP8[$1 + 15 | 0] <= 102) {
    break label$1;
   }
  }
  $0 = HEAP8[$1 + 15 | 0] >= 65 ? HEAP8[$1 + 15 | 0] <= 70 : 0;
 }
 return $0 & 1;
}
function gemmlowp__FixedPoint_int_2c_2012___FromScalarRaw_28int_29($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 $2 = $1 + 8 | 0;
 HEAP32[$1 + 4 >> 2] = $0;
 $0 = tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(HEAP32[$1 + 4 >> 2]);
 HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($2) >> 2] = $0;
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function tflite__RuntimeShape__RuntimeShape_28int_2c_20int_20const__29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 HEAP32[$0 >> 2] = 0;
 tflite__RuntimeShape__ReplaceWith_28int_2c_20int_20const__29($0, HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 global$0 = $3 + 16 | 0;
}
function st_yield_literal($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1 : {
  if (can_take_byte(HEAP32[$2 + 4 >> 2])) {
   push_literal_byte(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
   HEAP32[$2 + 12 >> 2] = 2;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = 4;
 }
 global$0 = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function lcdSetPixel_ArrayBuffer($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 global$0 = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 lcdSetPixels_ArrayBuffer(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], 1, HEAP32[$4 >> 2]);
 global$0 = $4 + 16 | 0;
}
function jswrap_espruino_setTimeZone($0) {
 $0 = +$0;
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAPF64[$1 + 8 >> 3] = $0;
 $3 = HEAP32[80546];
 $0 = HEAPF64[$1 + 8 >> 3] * 60;
 label$1 : {
  if (Math_abs($0) < 2147483648) {
   $2 = ~~$0;
   break label$1;
  }
  $2 = -2147483648;
 }
 jsvObjectSetChildAndUnLock($3, 120710, jsvNewFromInteger($2));
 global$0 = $1 + 16 | 0;
}
function jsvObjectIteratorNext($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[HEAP32[$1 + 12 >> 2] >> 2]) {
  HEAP16[$1 + 10 >> 1] = jsvGetNextSibling(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
  $0 = jsvLockSafe(HEAPU16[$1 + 10 >> 1]);
  HEAP32[HEAP32[$1 + 12 >> 2] >> 2] = $0;
 }
 global$0 = $1 + 16 | 0;
}
function flatbuffers__IndirectHelper_float___Read_28unsigned_20char_20const__2c_20unsigned_20int_29($0, $1) {
 var $2 = 0, $3 = Math_fround(0);
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $3 = float_20flatbuffers__EndianScalar_float__28float_29(HEAPF32[HEAP32[$2 + 12 >> 2] + (HEAP32[$2 + 8 >> 2] << 2) >> 2]);
 global$0 = $2 + 16 | 0;
 return $3;
}
function jspParse() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 12 >> 2] = 0;
 while (1) {
  if (HEAP32[80549] & 80 ? 0 : HEAP16[HEAP32[35539] + 2 >> 1]) {
   jsvUnLock(HEAP32[$0 + 12 >> 2]);
   HEAP32[$0 + 12 >> 2] = jspeBlockOrStatement();
   jsvCheckReferenceError(HEAP32[$0 + 12 >> 2]);
   continue;
  }
  break;
 }
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}
function tflite___28anonymous_20namespace_29__ConvertPadding_28tflite__Padding_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 $0 = HEAP32[$1 + 8 >> 2];
 label$1 : {
  if ($0 >>> 0 <= 1) {
   if ($0 - 1) {
    HEAP32[$1 + 12 >> 2] = 1;
    break label$1;
   }
   HEAP32[$1 + 12 >> 2] = 2;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 return HEAP32[$1 + 12 >> 2];
}
function jsvNewFromStringVar($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 HEAP32[$3 >> 2] = jsvNewWithFlags(27);
 if (HEAP32[$3 >> 2]) {
  jsvAppendStringVar(HEAP32[$3 >> 2], HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 }
 global$0 = $3 + 16 | 0;
 return HEAP32[$3 >> 2];
}
function jspeiGetTopScope() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 label$1 : {
  if (HEAP32[80547]) {
   HEAP32[$0 + 8 >> 2] = jsvGetLastArrayItem(HEAP32[80547]);
   if (HEAP32[$0 + 8 >> 2]) {
    HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 8 >> 2];
    break label$1;
   }
  }
  HEAP32[$0 + 12 >> 2] = jsvLockAgain(HEAP32[80545]);
 }
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}
function strcmp($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = HEAPU8[$0 | 0];
 $3 = HEAPU8[$1 | 0];
 label$1 : {
  if (!$2 | ($3 | 0) != ($2 | 0)) {
   break label$1;
  }
  while (1) {
   $3 = HEAPU8[$1 + 1 | 0];
   $2 = HEAPU8[$0 + 1 | 0];
   if (!$2) {
    break label$1;
   }
   $1 = $1 + 1 | 0;
   $0 = $0 + 1 | 0;
   if (($2 | 0) == ($3 | 0)) {
    continue;
   }
   break;
  }
 }
 return $2 - $3 | 0;
}
function jspeiAddScope($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 if (!HEAP32[80547]) {
  HEAP32[80547] = jsvNewWithFlags(3);
 }
 label$2 : {
  if (!HEAP32[80547]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$2;
  }
  jsvArrayPush(HEAP32[80547], HEAP32[$1 + 8 >> 2]);
  HEAP8[$1 + 15 | 0] = 1;
 }
 global$0 = $1 + 16 | 0;
 return HEAP8[$1 + 15 | 0] & 1;
}
function jshSetPinStateIsManual($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
 $0 = (HEAPU8[$2 + 15 | 0] >> 5 << 2) + 322200 | 0;
 if (HEAP8[$2 + 14 | 0] & 1) {
  $1 = 1 << (HEAPU8[$2 + 15 | 0] & 31);
 } else {
  $1 = 0;
 }
 HEAP32[$0 >> 2] = $1 | HEAP32[(HEAPU8[$2 + 15 | 0] >> 5 << 2) + 322200 >> 2] & (1 << (HEAPU8[$2 + 15 | 0] & 31) ^ -1);
}
function jswrap_object_removeAllListeners_cstr($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = jsvNewFromString(HEAP32[$2 + 8 >> 2]);
 if (HEAP32[$2 + 4 >> 2]) {
  jswrap_object_removeAllListeners(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2]);
  jsvUnLock(HEAP32[$2 + 4 >> 2]);
 }
 global$0 = $2 + 16 | 0;
}
function jsiObjectHasCallbacks($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = jsvObjectGetChild(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 0);
 HEAP8[$2 + 3 | 0] = (jsvIsUndefined(HEAP32[$2 + 4 >> 2]) ^ -1) & 1;
 jsvUnLock(HEAP32[$2 + 4 >> 2]);
 global$0 = $2 + 16 | 0;
 return HEAP8[$2 + 3 | 0] & 1;
}
function jswrap_date_setMilliseconds($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 getTimeFromDateVar($2, HEAP32[$2 + 28 >> 2], 0);
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 24 >> 2];
 $3 = jswrap_date_setTime(HEAP32[$2 + 28 >> 2], fromTimeInDay($2));
 global$0 = $2 + 32 | 0;
 return +$3;
}
function jspAppendStackTrace($0) {
 var $1 = 0;
 $1 = global$0 - 48 | 0;
 global$0 = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 $0 = $1 + 8 | 0;
 jsvStringIteratorNew($0, HEAP32[$1 + 44 >> 2], 0);
 jsvStringIteratorGotoEnd($0);
 jslPrintPosition($0, HEAP32[HEAP32[35539] + 8 >> 2]);
 jslPrintTokenLineMarker(2, $0, HEAP32[HEAP32[35539] + 8 >> 2], 0);
 jsvStringIteratorFree($0);
 global$0 = $1 + 48 | 0;
}
function gen_jswrap_Uint8ClampedArray_Uint8ClampedArray($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_typedarray_constructor(65, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function jsvObjectRemoveChild($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = jsvFindChildFromString(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 0);
 if (HEAP32[$2 + 4 >> 2]) {
  jsvRemoveChild(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2]);
  jsvUnLock(HEAP32[$2 + 4 >> 2]);
 }
 global$0 = $2 + 16 | 0;
}
function jspeiRemoveScope() {
 label$1 : {
  label$2 : {
   if (HEAP32[80547]) {
    if (jsvGetArrayLength(HEAP32[80547])) {
     break label$2;
    }
   }
   jsExceptionHere(4, 79492, 0);
   jspSetError();
   break label$1;
  }
  jsvUnLock(jsvArrayPop(HEAP32[80547]));
  if (jsvGetFirstChild(HEAP32[80547]) & 65535) {
   break label$1;
  }
  jsvUnLock(HEAP32[80547]);
  HEAP32[80547] = 0;
 }
}
function jshSetFlowControlAllReady() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 if (HEAP8[324176] & 1) {
  HEAP32[$0 + 12 >> 2] = 0;
  while (1) {
   if (HEAP32[$0 + 12 >> 2] < 2) {
    jshSetFlowControlXON(HEAP32[$0 + 12 >> 2] + 21 & 255, 1);
    HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP8[324176] = 0;
 }
 global$0 = $0 + 16 | 0;
}
function jswrap_serial_inject($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP8[$2 + 7 | 0] = jsiGetDeviceFromClass(HEAP32[$2 + 12 >> 2]);
 if (!(HEAPU8[$2 + 7 | 0] < 17 | HEAPU8[$2 + 7 | 0] > 22)) {
  jsvIterateCallback(HEAP32[$2 + 8 >> 2], 590, $2 + 7 | 0);
 }
 global$0 = $2 + 16 | 0;
}
function jshI2CInitInfo($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 4 | 0] = 255;
 HEAP8[HEAP32[$1 + 12 >> 2] + 5 | 0] = 255;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP8[$0 | 0] = 1e5;
 HEAP8[$0 + 1 | 0] = 390;
 HEAP8[$0 + 2 | 0] = 1;
 HEAP8[$0 + 3 | 0] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 6 | 0] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 7 | 0] = 1;
}
function jsvGetPathTo($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = 4;
 HEAP32[$3 + 16 >> 2] = $2;
 HEAP32[$3 + 12 >> 2] = 0;
 $0 = jsvGetPathTo_int(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 16 >> 2], $3 + 12 | 0);
 global$0 = $3 + 32 | 0;
 return $0;
}
function jsvArrayBufferSet($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 80 | 0;
 global$0 = $3;
 HEAP32[$3 + 76 >> 2] = $0;
 HEAP32[$3 + 72 >> 2] = $1;
 HEAP32[$3 + 68 >> 2] = $2;
 $0 = $3 + 8 | 0;
 jsvArrayBufferIteratorNew($0, HEAP32[$3 + 76 >> 2], HEAP32[$3 + 72 >> 2]);
 jsvArrayBufferIteratorSetValue($0, HEAP32[$3 + 68 >> 2]);
 jsvArrayBufferIteratorFree($0);
 global$0 = $3 + 80 | 0;
}
function jsvArrayBufferGet($0, $1) {
 var $2 = 0;
 $2 = global$0 - 80 | 0;
 global$0 = $2;
 HEAP32[$2 + 76 >> 2] = $0;
 HEAP32[$2 + 72 >> 2] = $1;
 $0 = $2 + 16 | 0;
 jsvArrayBufferIteratorNew($0, HEAP32[$2 + 76 >> 2], HEAP32[$2 + 72 >> 2]);
 HEAP32[$2 + 12 >> 2] = jsvArrayBufferIteratorGetValue($0);
 jsvArrayBufferIteratorFree($0);
 global$0 = $2 + 80 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function jslCharPosNew($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 jsvStringIteratorNew(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 $0 = jsvStringIteratorGetCharAndNext(HEAP32[$3 + 12 >> 2]);
 HEAP8[HEAP32[$3 + 12 >> 2] + 36 | 0] = $0;
 global$0 = $3 + 16 | 0;
}
function jshGetEventDataPin($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP8[$1 + 14 | 0] = $0;
 HEAP32[$1 + 8 >> 2] = HEAPU8[$1 + 14 | 0] - 1;
 label$1 : {
  if ((HEAP32[(HEAP32[$1 + 8 >> 2] << 2) + 322320 >> 2] & -256) == -256) {
   HEAP8[$1 + 15 | 0] = HEAP32[(HEAP32[$1 + 8 >> 2] << 2) + 322320 >> 2];
   break label$1;
  }
  HEAP8[$1 + 15 | 0] = 255;
 }
 return HEAPU8[$1 + 15 | 0];
}
function jswrap_espruino_toArrayBuffer($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!(jsvIsString(HEAP32[$1 + 8 >> 2]) & 1)) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvNewArrayBufferFromString(HEAP32[$1 + 8 >> 2], 0);
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jsvIsBoolean($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  if (((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) != 11) {
   $0 = HEAP32[$1 + 12 >> 2];
   $0 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) == 16;
  } else {
   $0 = 1;
  }
 } else {
  $0 = 0;
 }
 return $0 & 1;
}
function lcdMemLCD_extcominBacklight($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 15 | 0] = $0;
 if ((HEAP8[336582] & 1) != (HEAP8[$1 + 15 | 0] & 1)) {
  HEAP8[336582] = HEAP8[$1 + 15 | 0] & 1;
  label$2 : {
   if (HEAP8[$1 + 15 | 0] & 1) {
    jshPinAnalogOutput(6, 3e-4, 120, 0);
    break label$2;
   }
   jshPinOutput(6, 0);
  }
 }
 global$0 = $1 + 16 | 0;
}
function jsvIterateCallbackToBytes($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 24 >> 2];
 HEAP32[$3 + 12 >> 2] = 0;
 HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 20 >> 2];
 jsvIterateCallback(HEAP32[$3 + 28 >> 2], 6, $3 + 8 | 0);
 global$0 = $3 + 32 | 0;
}
function jsvIsFunction($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  if (((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) != 7) {
   $0 = HEAP32[$1 + 12 >> 2];
   $0 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) == 8;
  } else {
   $0 = 1;
  }
 } else {
  $0 = 0;
 }
 return $0 & 1;
}
function jspeCheckBreakContinue() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 label$1 : {
  label$2 : {
   if (HEAP32[80549] & 4) {
    HEAP32[80549] = HEAP32[80549] & -64 | 1;
    break label$2;
   }
   if (HEAP32[80549] & 2) {
    HEAP32[80549] = HEAP32[80549] & -64 | 1;
    HEAP8[$0 + 15 | 0] = 1;
    break label$1;
   }
  }
  HEAP8[$0 + 15 | 0] = 0;
 }
 return HEAP8[$0 + 15 | 0] & 1;
}
function jsSendTouchEvent($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 global$0 = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 touchHandlerInternal(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2]);
 global$0 = $4 + 16 | 0;
}
function tflite__AlignPointerUp_28unsigned_20char__2c_20unsigned_20long_29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 >> 2] = Math_imul(HEAP32[$2 + 8 >> 2], (HEAP32[$2 + 4 >> 2] + (HEAP32[$2 + 8 >> 2] - 1 | 0) >>> 0) / HEAPU32[$2 + 8 >> 2] | 0);
 return HEAP32[$2 >> 2];
}
function jswrap_interface_setInterval($0, $1, $2) {
 $0 = $0 | 0;
 $1 = +$1;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAPF64[$3 + 16 >> 3] = $1;
 HEAP32[$3 + 12 >> 2] = $2;
 $0 = _jswrap_interface_setTimeoutOrInterval(HEAP32[$3 + 28 >> 2], HEAPF64[$3 + 16 >> 3], HEAP32[$3 + 12 >> 2], 0);
 global$0 = $3 + 32 | 0;
 return $0 | 0;
}
function jsiGetDeviceFromClass($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!(HEAP8[HEAP32[$1 + 8 >> 2]] != 68 | HEAP8[HEAP32[$1 + 8 >> 2] + 1 | 0] != 69 | HEAP8[HEAP32[$1 + 8 >> 2] + 2 | 0] != 86)) {
   HEAP8[$1 + 15 | 0] = HEAPU8[HEAP32[$1 + 8 >> 2] + 3 | 0];
   break label$1;
  }
  HEAP8[$1 + 15 | 0] = 0;
 }
 return HEAPU8[$1 + 15 | 0];
}
function __sin($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = $0 * $0;
 $5 = $3 * ($3 * $3) * ($3 * 1.58969099521155e-10 + -2.5050760253406863e-8) + ($3 * ($3 * 27557313707070068e-22 + -.0001984126982985795) + .00833333333332249);
 $4 = $3 * $0;
 if (!$2) {
  return $4 * ($3 * $5 + -.16666666666666632) + $0;
 }
 return $0 - ($3 * ($1 * .5 - $4 * $5) - $1 + $4 * .16666666666666632);
}
function jswrap_interface_setTimeout($0, $1, $2) {
 $0 = $0 | 0;
 $1 = +$1;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAPF64[$3 + 16 >> 3] = $1;
 HEAP32[$3 + 12 >> 2] = $2;
 $0 = _jswrap_interface_setTimeoutOrInterval(HEAP32[$3 + 28 >> 2], HEAPF64[$3 + 16 >> 3], HEAP32[$3 + 12 >> 2], 1);
 global$0 = $3 + 32 | 0;
 return $0 | 0;
}
function jswrap_array_filter($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = _jswrap_array_iterate_with_callback(118835, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 1, 1, 1);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function jsvIsObject($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  if (((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) != 5) {
   $0 = HEAP32[$1 + 12 >> 2];
   $0 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) == 1;
  } else {
   $0 = 1;
  }
 } else {
  $0 = 0;
 }
 return $0 & 1;
}
function tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 $0 = HEAP32[$3 + 12 >> 2];
 HEAP32[$3 + 4 >> 2] = $2;
 HEAP32[$3 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 8 >> 2]]($0, HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 global$0 = $3 + 16 | 0;
}
function jswrap_espruino_getConsole() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP8[$0 + 11 | 0] = HEAPU8[141672];
 label$1 : {
  if (!HEAPU8[$0 + 11 | 0]) {
   HEAP32[$0 + 12 >> 2] = jsvNewWithFlags(2);
   break label$1;
  }
  HEAP32[$0 + 12 >> 2] = jsvNewFromString(jshGetDeviceString(HEAPU8[$0 + 11 | 0]));
 }
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}
function jswrap_array_every($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = _jswrap_array_iterate_with_callback(118862, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 0, 1, 1);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function flatbuffers__IndirectHelper_int___Read_28unsigned_20char_20const__2c_20unsigned_20int_29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(HEAP32[HEAP32[$2 + 12 >> 2] + (HEAP32[$2 + 8 >> 2] << 2) >> 2]);
 global$0 = $2 + 16 | 0;
 return $0;
}
function tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator___MicroBuiltinDataAllocator_28_29_1($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator___MicroBuiltinDataAllocator_28_29($0);
 do_indexing($0);
 global$0 = $1 + 16 | 0;
}
function jswrap_array_some($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = _jswrap_array_iterate_with_callback(118857, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 0, 1, 0);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function jsvTraceLockInfo($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsvGetRef(HEAP32[$1 + 12 >> 2]) & 65535;
 $2 = jsvGetRefs(HEAP32[$1 + 12 >> 2]) & 255;
 HEAP32[$1 + 8 >> 2] = jsvGetLocks(HEAP32[$1 + 12 >> 2]) & 255;
 HEAP32[$1 + 4 >> 2] = $2;
 HEAP32[$1 >> 2] = $0;
 jsiConsolePrintf(78825, $1);
 global$0 = $1 + 16 | 0;
}
function gen_jswrap_Float64Array_Float64Array($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_typedarray_constructor(40, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function gen_jswrap_Float32Array_Float32Array($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_typedarray_constructor(36, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function jswrap_array_map($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = _jswrap_array_iterate_with_callback(118823, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 1, 0, 0);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function graphicsGetPixel($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 graphicsToDeviceCoordinates(HEAP32[$3 + 12 >> 2], $3 + 8 | 0, $3 + 4 | 0);
 $0 = graphicsGetPixelDevice(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 global$0 = $3 + 16 | 0;
 return $0;
}
function __towrite($0) {
 var $1 = 0;
 $1 = HEAPU8[$0 + 74 | 0];
 HEAP8[$0 + 74 | 0] = $1 + -1 | $1;
 $1 = HEAP32[$0 >> 2];
 if ($1 & 8) {
  HEAP32[$0 >> 2] = $1 | 32;
  return -1;
 }
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 0;
 $1 = HEAP32[$0 + 44 >> 2];
 HEAP32[$0 + 28 >> 2] = $1;
 HEAP32[$0 + 20 >> 2] = $1;
 HEAP32[$0 + 16 >> 2] = $1 + HEAP32[$0 + 48 >> 2];
 return 0;
}
function jsvLock($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP16[$1 + 14 >> 1] = $0;
 HEAP32[$1 + 8 >> 2] = jsvGetAddressOf(HEAPU16[$1 + 14 >> 1]);
 $0 = HEAP32[$1 + 8 >> 2];
 $2 = (HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) + 512 | 0;
 HEAP8[$0 + 13 | 0] = $2;
 HEAP8[$0 + 14 | 0] = $2 >>> 8;
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function gen_jswrap_Uint32Array_Uint32Array($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_typedarray_constructor(4, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function gen_jswrap_Uint24Array_Uint24Array($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_typedarray_constructor(3, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function gen_jswrap_Uint16Array_Uint16Array($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_typedarray_constructor(2, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function jswrap_flash_erasePage($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1 : {
  if (!(jsvIsInt(HEAP32[$1 + 12 >> 2]) & 1)) {
   HEAP32[$1 >> 2] = HEAP32[$1 + 12 >> 2];
   jsExceptionHere(1, 121107, $1);
   break label$1;
  }
  jshFlashErasePage(jsvGetInteger(HEAP32[$1 + 12 >> 2]));
 }
 global$0 = $1 + 16 | 0;
}
function jsvUnLockMany($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 while (1) {
  if (HEAP32[$2 + 12 >> 2]) {
   $0 = HEAP32[$2 + 8 >> 2];
   $1 = HEAP32[$2 + 12 >> 2] + -1 | 0;
   HEAP32[$2 + 12 >> 2] = $1;
   jsvUnLock(HEAP32[$0 + ($1 << 2) >> 2]);
   continue;
  }
  break;
 }
 global$0 = $2 + 16 | 0;
}
function gen_jswrap_Int32Array_Int32Array($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_typedarray_constructor(20, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function gen_jswrap_Int16Array_Int16Array($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_typedarray_constructor(18, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__operator_28_29_28void__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[HEAP32[$2 + 12 >> 2] >> 2];
 FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 4 >> 2]]($0, HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
}
function std____2____compressed_pair_TfLiteConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___second_28_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(HEAP32[$1 + 12 >> 2] + 4 | 0);
 global$0 = $1 + 16 | 0;
 return $0;
}
function jspNewBuiltin($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = jswFindBuiltInFunction(0, HEAP32[$1 + 8 >> 2]);
 label$1 : {
  if (!HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jspEvaluateExpressionVar($0) {
 var $1 = 0;
 $1 = global$0 - 144 | 0;
 global$0 = $1;
 HEAP32[$1 + 140 >> 2] = $0;
 HEAP32[$1 + 12 >> 2] = jslSetLex($1 + 16 | 0);
 jslInit(HEAP32[$1 + 140 >> 2]);
 HEAP32[$1 + 8 >> 2] = jspeExpression();
 jslKill();
 jslSetLex(HEAP32[$1 + 12 >> 2]);
 $0 = jsvSkipNameAndUnLock(HEAP32[$1 + 8 >> 2]);
 global$0 = $1 + 144 | 0;
 return $0;
}
function gen_jswrap_Uint8Array_Uint8Array($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_typedarray_constructor(1, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function tflite__Model__20flatbuffers__GetMutableRoot_tflite__Model__28void__29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[(global$0 - 16 | 0) + 12 >> 2] = 1;
 $0 = HEAP32[$1 + 12 >> 2] + tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]) | 0;
 global$0 = $1 + 16 | 0;
 return $0;
}
function std____2____compressed_pair_TfLiteConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return $0;
}
function gen_jswrap_Int8Array_Int8Array($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_typedarray_constructor(17, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function jsvIsInternalFunctionKey($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1 : {
  if (jsvIsString(HEAP32[$1 + 12 >> 2]) & 1) {
   $0 = 1;
   if (HEAP8[HEAP32[$1 + 12 >> 2]] == -1) {
    break label$1;
   }
  }
  $0 = jsvIsFunctionParameter(HEAP32[$1 + 12 >> 2]);
 }
 global$0 = $1 + 16 | 0;
 return $0 & 1;
}
function jsvGetArrayLength($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP32[$1 + 12 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
 }
 return HEAP32[$1 + 12 >> 2];
}
function jslMatch($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (HEAP16[HEAP32[35539] + 2 >> 1] != HEAP32[$1 + 8 >> 2]) {
   jslMatchError(HEAP32[$1 + 8 >> 2]);
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  jslGetNextToken();
  HEAP8[$1 + 15 | 0] = 1;
 }
 global$0 = $1 + 16 | 0;
 return HEAP8[$1 + 15 | 0] & 1;
}
function gen_jswrap_String_includes($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_string_indexOf(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 0);
 global$0 = $3 + 16 | 0;
 return ($0 | 0) >= 0 | 0;
}
function tflite__internal__ContextHelper__GetEvalTensor_28TfLiteContext_20const__2c_20int_29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2];
 return HEAP32[HEAP32[$2 + 4 >> 2] + 12 >> 2] + Math_imul(HEAP32[$2 + 8 >> 2], 12) | 0;
}
function jsvStringIteratorCatchUp($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 while (1) {
  if (HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] > 0 ? HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] >= HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2] : 0) {
   jsvStringIteratorLoadInline(HEAP32[$1 + 12 >> 2]);
   continue;
  }
  break;
 }
 global$0 = $1 + 16 | 0;
}
function jspeiFindNameOnTop($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[$1 + 11 | 0] = 1;
 HEAP32[$1 + 4 >> 2] = jspeiGetTopScope();
 HEAP32[$1 >> 2] = jsvFindChildFromVar(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 12 >> 2], HEAP8[$1 + 11 | 0] & 1);
 jsvUnLock(HEAP32[$1 + 4 >> 2]);
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 >> 2];
}
function jsvArrayPush2Int($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 jsvArrayPushAndUnLock(HEAP32[$3 + 12 >> 2], jsvNewFromInteger(HEAP32[$3 + 8 >> 2]));
 jsvArrayPushAndUnLock(HEAP32[$3 + 12 >> 2], jsvNewFromInteger(HEAP32[$3 + 4 >> 2]));
 global$0 = $3 + 16 | 0;
}
function jspeiFindOnTop($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[$1 + 11 | 0] = 1;
 HEAP32[$1 + 4 >> 2] = jspeiGetTopScope();
 HEAP32[$1 >> 2] = jsvFindChildFromString(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 12 >> 2], HEAP8[$1 + 11 | 0] & 1);
 jsvUnLock(HEAP32[$1 + 4 >> 2]);
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 >> 2];
}
function jslKill() {
 HEAP16[HEAP32[35539] + 2 >> 1] = 0;
 if (HEAP32[HEAP32[35539] + 100 >> 2]) {
  jsvLockAgain(HEAP32[HEAP32[35539] + 100 >> 2]);
 }
 jsvStringIteratorFree(HEAP32[35539] + 88 | 0);
 if (HEAP32[HEAP32[35539] + 76 >> 2]) {
  jsvUnLock(HEAP32[HEAP32[35539] + 76 >> 2]);
  HEAP32[HEAP32[35539] + 76 >> 2] = 0;
 }
 jsvUnLock(HEAP32[HEAP32[35539] + 84 >> 2]);
}
function jsiClearInputLine($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 15 | 0] = $0;
 if (!(jsvIsEmptyString(HEAP32[80557]) & 1)) {
  if (HEAP8[$1 + 15 | 0] & 1) {
   jsiConsoleRemoveInputLine();
  }
  jsiInputLineCursorMoved();
  jsvUnLock(HEAP32[80557]);
  HEAP32[80557] = jsvNewWithFlags(27);
  HEAP32[80559] = 0;
 }
 global$0 = $1 + 16 | 0;
}
function memcmp($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 label$1 : {
  if (!$2) {
   break label$1;
  }
  while (1) {
   $3 = HEAPU8[$0 | 0];
   $4 = HEAPU8[$1 | 0];
   if (($3 | 0) == ($4 | 0)) {
    $1 = $1 + 1 | 0;
    $0 = $0 + 1 | 0;
    $2 = $2 + -1 | 0;
    if ($2) {
     continue;
    }
    break label$1;
   }
   break;
  }
  $5 = $3 - $4 | 0;
 }
 return $5;
}
function mbedtls_zeroize($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 12 >> 2];
 while (1) {
  $0 = HEAP32[$2 + 8 >> 2];
  HEAP32[$2 + 8 >> 2] = $0 + -1;
  if ($0) {
   $0 = HEAP32[$2 + 4 >> 2];
   HEAP32[$2 + 4 >> 2] = $0 + 1;
   HEAP8[$0 | 0] = 0;
   continue;
  }
  break;
 }
}
function jswrap_spi_write_cb($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 FUNCTION_TABLE[HEAP32[HEAP32[$3 + 4 >> 2] >> 2]](HEAP32[$3 + 12 >> 2], 0, HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2] + 4 | 0);
 global$0 = $3 + 16 | 0;
}
function tflite__MicroAllocator__AllocatePersistentBuffer_28unsigned_20long_29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2];
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 12 >> 2]]($0, HEAP32[$2 + 8 >> 2], 16) | 0;
 global$0 = $2 + 16 | 0;
 return $0;
}
function jswrap_graphics_dump($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jswrap_graphics_asURL(HEAP32[$1 + 12 >> 2]);
 if (HEAP32[$1 + 8 >> 2]) {
  jsiConsolePrintStringVar(HEAP32[$1 + 8 >> 2]);
 }
 jsvUnLock(HEAP32[$1 + 8 >> 2]);
 jsiConsolePrintString(128075);
 global$0 = $1 + 16 | 0;
}
function jstRestartUtilTimer() {
 var $0 = 0;
 HEAP32[81047] = jshGetSystemTime();
 $0 = Math_imul(HEAPU8[324178], 25) + 324192 | 0;
 HEAP32[81046] = (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) - HEAP32[81047];
 if (HEAP32[81046] < 0) {
  HEAP32[81046] = 0;
 }
 $0 = HEAP32[81046];
 jshSetSystemTime($0, $0 >> 31);
}
function espruino_snprintf($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 global$0 = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP32[$4 + 12 >> 2] = espruino_snprintf_va(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2]);
 global$0 = $4 + 32 | 0;
}
function _jswrap_graphics_stringWidth($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 32 | 0;
 global$0 = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 _jswrap_graphics_stringMetrics(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], $3 + 16 | 0, $3 + 12 | 0);
 global$0 = $3 + 32 | 0;
 return HEAP32[$3 + 16 >> 2];
}
function tflite__RuntimeShape__Resize_28int_29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 if (HEAP32[$0 >> 2] > 5) {
  abort();
  abort();
 }
 HEAP32[$0 >> 2] = HEAP32[$2 + 8 >> 2];
 if (HEAP32[$2 + 8 >> 2] > 5) {
  abort();
  abort();
 }
 global$0 = $2 + 16 | 0;
}
function gen_jswrap_Graphics_drawPoly($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 $0 = jswrap_graphics_drawPoly_X(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function jswOnCharEvent($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP8[$2 + 14 | 0] = $0;
 HEAP8[$2 + 13 | 0] = $1;
 label$1 : {
  if (HEAPU8[$2 + 14 | 0] == 22) {
   HEAP8[$2 + 15 | 0] = jshIsDeviceInitialised(HEAP8[$2 + 13 | 0]) & 1;
   break label$1;
  }
  HEAP8[$2 + 15 | 0] = 0;
 }
 global$0 = $2 + 16 | 0;
 return HEAP8[$2 + 15 | 0] & 1;
}
function gen_jswrap_String_lastIndexOf($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_string_indexOf(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 1);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function gen_jswrap_DataView_getFloat64($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 $0 = jswrap_dataview_get(HEAP32[$3 + 12 >> 2], 40, HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function gen_jswrap_DataView_getFloat32($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 $0 = jswrap_dataview_get(HEAP32[$3 + 12 >> 2], 36, HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function tflite__ParseDequantize_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 return 0;
}
function tflite__FullyConnectedOptions__asymmetric_quantize_inputs_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20char_20flatbuffers__Table__GetField_unsigned_20char__28unsigned_20short_2c_20unsigned_20char_29_20const(HEAP32[$1 + 12 >> 2], 10);
 global$0 = $1 + 16 | 0;
 return ($0 & 255) != 0;
}
function jswrap_espruino_toJS($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = 704;
 HEAP32[$1 + 4 >> 2] = jsvNewWithFlags(27);
 if (HEAP32[$1 + 4 >> 2]) {
  jsfGetJSON(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 4 >> 2], HEAP32[$1 + 8 >> 2]);
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 4 >> 2];
}
function jshInit() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 12 >> 2] = 0;
 while (1) {
  if (HEAP32[$0 + 12 >> 2] < 16) {
   HEAP8[HEAP32[$0 + 12 >> 2] + 336592 | 0] = 255;
   HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP8[322308] = 8;
 jshResetDevices();
 HEAP8[141684] = 1;
 global$0 = $0 + 16 | 0;
}
function jswrap_storagefile_read($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 if (HEAP32[$2 + 8 >> 2] < 0) {
  HEAP32[$2 + 8 >> 2] = 0;
 }
 $0 = jswrap_storagefile_read_internal(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0 | 0;
}
function jswrap_array_forEach($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 _jswrap_array_iterate_with_callback(118827, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 0, 0, 0);
 global$0 = $3 + 16 | 0;
}
function gen_jswrap_DataView_getUint32($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 $0 = jswrap_dataview_get(HEAP32[$3 + 12 >> 2], 4, HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function gen_jswrap_DataView_getUint16($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 $0 = jswrap_dataview_get(HEAP32[$3 + 12 >> 2], 2, HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function gen_jswrap_DataView_getInt32($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 $0 = jswrap_dataview_get(HEAP32[$3 + 12 >> 2], 20, HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function gen_jswrap_DataView_getInt16($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 $0 = jswrap_dataview_get(HEAP32[$3 + 12 >> 2], 18, HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function isAlpha($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 label$1 : {
  if (HEAP8[$1 + 15 | 0] >= 97) {
   $0 = 1;
   if (HEAP8[$1 + 15 | 0] <= 122) {
    break label$1;
   }
  }
  if (HEAP8[$1 + 15 | 0] >= 65) {
   $0 = 1;
   if (HEAP8[$1 + 15 | 0] <= 90) {
    break label$1;
   }
  }
  $0 = HEAP8[$1 + 15 | 0] == 95;
 }
 return $0;
}
function gen_jswrap_DataView_getUint8($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 $0 = jswrap_dataview_get(HEAP32[$3 + 12 >> 2], 1, HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function gen_jswrap_DataView_getInt8($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 $0 = jswrap_dataview_get(HEAP32[$3 + 12 >> 2], 17, HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function TfLiteFullyConnectedParams__20tflite__BuiltinDataAllocator__AllocatePOD_TfLiteFullyConnectedParams__28_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] >> 2]]($0, 12, 4);
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function jsvHasSingleChild($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $2 = jsvIsArrayBuffer(HEAP32[$1 + 12 >> 2]) & 1;
 $0 = 1;
 if (!$2) {
  if (jsvIsName(HEAP32[$1 + 12 >> 2]) & 1) {
   $0 = jsvIsNameWithValue(HEAP32[$1 + 12 >> 2]) ^ -1;
  } else {
   $0 = 0;
  }
 }
 global$0 = $1 + 16 | 0;
 return $0 & 1;
}
function gen_jswrap_String_indexOf($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_string_indexOf(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 0);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function TfLiteDepthwiseConvParams__20tflite__BuiltinDataAllocator__AllocatePOD_TfLiteDepthwiseConvParams__28_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] >> 2]]($0, 28, 4);
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function jsvTrace($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = 0;
 HEAP32[$1 + 4 >> 2] = HEAP32[35541];
 HEAP32[35541] = 0;
 _jsvTrace(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2], 0);
 HEAP32[35541] = HEAP32[$1 + 4 >> 2];
 jsiConsolePrintf(79153, 0);
 global$0 = $1 + 16 | 0;
}
function jsvNegateAndUnLock($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvNewFromInteger(0);
 HEAP32[$1 + 4 >> 2] = jsvMathsOpSkipNames(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2], 45);
 jsvUnLock2(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 4 >> 2];
}
function jsvGetLongIntegerAndUnLock($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 >> 2] = jsvGetLongInteger(HEAP32[$1 + 12 >> 2]);
 HEAP32[$1 + 4 >> 2] = i64toi32_i32$HIGH_BITS;
 jsvUnLock(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
 return HEAP32[$1 >> 2];
}
function gen_jswrap_String_padStart($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_string_padX(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 1);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function __cos($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = $0 * $0;
 $3 = $2 * .5;
 $4 = 1 - $3;
 $5 = 1 - $4 - $3;
 $3 = $2 * $2;
 return $4 + ($5 + ($2 * ($2 * ($2 * ($2 * 2480158728947673e-20 + -.001388888888887411) + .0416666666666666) + $3 * $3 * ($2 * ($2 * -1.1359647557788195e-11 + 2.087572321298175e-9) + -2.7557314351390663e-7)) - $0 * $1));
}
function tflite__DepthwiseConv2DOptions__fused_activation_function_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = signed_20char_20flatbuffers__Table__GetField_signed_20char__28unsigned_20short_2c_20signed_20char_29_20const(HEAP32[$1 + 12 >> 2], 12);
 global$0 = $1 + 16 | 0;
 return $0 << 24 >> 24;
}
function jsvIsEmptyString($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!(jsvHasCharacterData(HEAP32[$1 + 8 >> 2]) & 1)) {
   HEAP8[$1 + 15 | 0] = 1;
   break label$1;
  }
  HEAP8[$1 + 15 | 0] = !jsvGetCharactersInVar(HEAP32[$1 + 8 >> 2]);
 }
 global$0 = $1 + 16 | 0;
 return HEAP8[$1 + 15 | 0] & 1;
}
function jshPushIOCharEventFlowControl($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 15 | 0] = $0;
 label$1 : {
  if (HEAPU8[$1 + 15 | 0] < 21 | HEAPU8[$1 + 15 | 0] > 22) {
   break label$1;
  }
  if ((jshGetEventsUsed() | 0) <= 191) {
   break label$1;
  }
  jshSetFlowControlXON(HEAPU8[$1 + 15 | 0], 0);
 }
 global$0 = $1 + 16 | 0;
}
function gen_jswrap_String_padEnd($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_string_padX(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 0);
 global$0 = $3 + 16 | 0;
 return $0 | 0;
}
function jsvStringIteratorNextInline($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
 if (HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] >= HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2]) {
  jsvStringIteratorLoadInline(HEAP32[$1 + 12 >> 2]);
 }
 global$0 = $1 + 16 | 0;
}
function jsvObjectIteratorGetValue($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jsvObjectIteratorGetKey($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function gemmlowp__FixedPoint_int_2c_200___ScalarRawType_20gemmlowp__RescaleConstantInitializer_gemmlowp__FixedPoint_int_2c_200__20__28int_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = int_20gemmlowp__RoundingDivideByPOT_int__28int_2c_20int_29(HEAP32[$1 + 12 >> 2], 0);
 global$0 = $1 + 16 | 0;
 return $0;
}
function _jswrap_espruino_toUint8Array_char($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jsvArrayBufferIteratorSetByteValue(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 12 >> 2] << 24 >> 24);
 jsvArrayBufferIteratorNext(HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
}
function AccelFilter_init() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 HEAP32[$0 + 12 >> 2] = 142128;
 HEAP32[$0 + 8 >> 2] = 0;
 while (1) {
  if (HEAP32[$0 + 8 >> 2] < 7) {
   HEAP8[HEAP32[$0 + 12 >> 2] + HEAP32[$0 + 8 >> 2] | 0] = 0;
   HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 8 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[HEAP32[$0 + 12 >> 2] + 8 >> 2] = 0;
}
function sbrk($0) {
 var $1 = 0;
 $1 = HEAP32[84388];
 $0 = $1 + $0 | 0;
 if (($0 | 0) <= -1) {
  HEAP32[84242] = 48;
  return -1;
 }
 label$2 : {
  if ($0 >>> 0 <= __wasm_memory_size() << 16 >>> 0) {
   break label$2;
  }
  if (emscripten_resize_heap($0 | 0)) {
   break label$2;
  }
  HEAP32[84242] = 48;
  return -1;
 }
 HEAP32[84388] = $0;
 return $1;
}
function graphicsGetMemoryRequired($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 $2 = HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8;
 $0 = HEAP32[$1 + 12 >> 2];
 return Math_imul(HEAPU8[HEAP32[$1 + 12 >> 2] + 16 | 0], Math_imul($2, HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8)) + 7 >>> 3;
}
function jsvStringIteratorGetChar($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  HEAP8[$1 + 15 | 0] = HEAPU8[HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2] + HEAP32[HEAP32[$1 + 8 >> 2] >> 2] | 0];
 }
 return HEAP8[$1 + 15 | 0];
}
function tflite__FullyConnectedOptions__keep_num_dims_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20char_20flatbuffers__Table__GetField_unsigned_20char__28unsigned_20short_2c_20unsigned_20char_29_20const(HEAP32[$1 + 12 >> 2], 8);
 global$0 = $1 + 16 | 0;
 return ($0 & 255) != 0;
}
function graphicsFallbackGetPixel($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 return HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24);
}
function tflite__Pool2DOptions__fused_activation_function_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = signed_20char_20flatbuffers__Table__GetField_signed_20char__28unsigned_20short_2c_20signed_20char_29_20const(HEAP32[$1 + 12 >> 2], 14);
 global$0 = $1 + 16 | 0;
 return $0 << 24 >> 24;
}
function tflite__Conv2DOptions__fused_activation_function_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = signed_20char_20flatbuffers__Table__GetField_signed_20char__28unsigned_20short_2c_20signed_20char_29_20const(HEAP32[$1 + 12 >> 2], 10);
 global$0 = $1 + 16 | 0;
 return $0 << 24 >> 24;
}
function jswrap_espruino_memoryMap($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 >> 2] = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
 $0 = jspExecuteJSFunction(120713, 2, $2);
 global$0 = $2 + 16 | 0;
 return $0 | 0;
}
function jsvUnLock4($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 global$0 = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 jsvUnLock(HEAP32[$4 + 12 >> 2]);
 jsvUnLock(HEAP32[$4 + 8 >> 2]);
 jsvUnLock(HEAP32[$4 + 4 >> 2]);
 jsvUnLock(HEAP32[$4 >> 2]);
 global$0 = $4 + 16 | 0;
}
function TfLiteReshapeParams__20tflite__BuiltinDataAllocator__AllocatePOD_TfLiteReshapeParams__28_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] >> 2]]($0, 36, 4);
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function tflite__AlignPointerDown_28unsigned_20char__2c_20unsigned_20long_29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 >> 2] = Math_imul(HEAP32[$2 + 8 >> 2], HEAPU32[$2 + 4 >> 2] / HEAPU32[$2 + 8 >> 2] | 0);
 return HEAP32[$2 >> 2];
}
function jswrap_promise_catch($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 _jswrap_promise_add(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 0);
 $0 = jswrap_promise_get_chained_promise(HEAP32[$2 + 12 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0 | 0;
}
function jsvStringIteratorSetChar($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 if (jsvStringIteratorHasChar(HEAP32[$2 + 12 >> 2]) & 1) {
  HEAP8[HEAP32[HEAP32[$2 + 12 >> 2] + 16 >> 2] + HEAP32[HEAP32[$2 + 12 >> 2] >> 2] | 0] = HEAPU8[$2 + 11 | 0];
 }
 global$0 = $2 + 16 | 0;
}
function TfLiteSoftmaxParams__20tflite__BuiltinDataAllocator__AllocatePOD_TfLiteSoftmaxParams__28_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] >> 2]]($0, 4, 4);
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function tflite__MicroMutableOpResolver_9u____MicroMutableOpResolver_28_29($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator___MicroBuiltinDataAllocator_28_29($0);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function std____2____less_unsigned_20char_2c_20unsigned_20char___operator_28_29_28unsigned_20char_20const__2c_20unsigned_20char_20const__29_20const($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 return HEAPU8[HEAP32[$3 + 8 >> 2]] < HEAPU8[HEAP32[$3 + 4 >> 2]];
}
function jswrap_date_setTime($0, $1) {
 $0 = $0 | 0;
 $1 = +$1;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAPF64[$2 >> 3] = $1;
 if (HEAP32[$2 + 12 >> 2]) {
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 12 >> 2], 119809, jsvNewFromFloat(HEAPF64[$2 >> 3]));
 }
 global$0 = $2 + 16 | 0;
 return +HEAPF64[$2 >> 3];
}
function int_20gemmlowp__AddSaturatingIf16Bit_int__28int_2c_20int_29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = gemmlowp__AddSaturatingIf16BitImpl_int_2c_20false___Run_28int_2c_20int_29(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0;
}
function gen_jswrap_E_showPrompt($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 >> 2] = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
 $0 = jspExecuteJSFunction(101923, 2, $2);
 global$0 = $2 + 16 | 0;
 return $0 | 0;
}
function tflite__QuantizationParameters__quantized_dimension_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20int_20flatbuffers__Table__GetField_unsigned_20int__28unsigned_20short_2c_20unsigned_20int_29_20const(HEAP32[$1 + 12 >> 2], 16, 0);
 global$0 = $1 + 16 | 0;
 return $0;
}
function strncat($0, $1, $2) {
 var $3 = 0;
 $0 = strlen($0) + $0 | 0;
 label$1 : {
  if (!$2) {
   break label$1;
  }
  while (1) {
   $3 = HEAPU8[$1 | 0];
   if (!$3) {
    break label$1;
   }
   HEAP8[$0 | 0] = $3;
   $0 = $0 + 1 | 0;
   $1 = $1 + 1 | 0;
   $2 = $2 + -1 | 0;
   if ($2) {
    continue;
   }
   break;
  }
 }
 HEAP8[$0 | 0] = 0;
}
function jsvFreePtrInternal($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP8[$0 + 13 | 0] = 0;
 HEAP8[$0 + 14 | 0] = 0;
 jsvSetNextSibling(HEAP32[$1 + 12 >> 2], HEAPU16[71084]);
 HEAP16[71084] = jsvGetRef(HEAP32[$1 + 12 >> 2]);
 HEAP8[142161] = 1;
 global$0 = $1 + 16 | 0;
}
function gen_jswrap_E_showAlert($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 >> 2] = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
 $0 = jspExecuteJSFunction(98752, 2, $2);
 global$0 = $2 + 16 | 0;
 return $0 | 0;
}
function tflite__Operator__custom_options_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_int__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_int__20const___28unsigned_20short_29_20const(HEAP32[$1 + 12 >> 2], 14);
 global$0 = $1 + 16 | 0;
 return $0;
}
function tflite__DepthwiseConv2DOptions__dilation_h_factor_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20int_20flatbuffers__Table__GetField_unsigned_20int__28unsigned_20short_2c_20unsigned_20int_29_20const(HEAP32[$1 + 12 >> 2], 16, 1);
 global$0 = $1 + 16 | 0;
 return $0;
}
function jsvGetFlatStringPointer($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!(jsvIsFlatString(HEAP32[$1 + 8 >> 2]) & 1)) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2] + 15;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function tflite__DepthwiseConv2DOptions__depth_multiplier_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20int_20flatbuffers__Table__GetField_unsigned_20int__28unsigned_20short_2c_20unsigned_20int_29_20const(HEAP32[$1 + 12 >> 2], 10, 0);
 global$0 = $1 + 16 | 0;
 return $0;
}
function jspeStatementThrow() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 12 >> 2] = 0;
 jslGetNextToken();
 HEAP32[$0 + 12 >> 2] = jsvSkipNameAndUnLock(jspeExpression());
 if ((HEAP32[80549] & 63) == 1) {
  jspSetException(HEAP32[$0 + 12 >> 2]);
 }
 jsvUnLock(HEAP32[$0 + 12 >> 2]);
 global$0 = $0 + 16 | 0;
 return 0;
}
function _jswrap_drawImageLayerNextX($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 + 180 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 164 >> 2] + HEAP32[$0 + 180 >> 2];
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 + 184 >> 2] = HEAP32[$0 + 184 >> 2] - HEAP32[HEAP32[$1 + 12 >> 2] + 168 >> 2];
}
function TfLitePoolParams__20tflite__BuiltinDataAllocator__AllocatePOD_TfLitePoolParams__28_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] >> 2]]($0, 40, 4);
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function TfLiteConvParams__20tflite__BuiltinDataAllocator__AllocatePOD_TfLiteConvParams__28_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] >> 2]]($0, 24, 4);
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function int_20gemmlowp__MaskIfZero_int_2c_205__28gemmlowp__FixedPoint_int_2c_205__29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 $0 = int_20gemmlowp__MaskIfZero_int__28int_29(HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($1 + 8 | 0) >> 2]);
 global$0 = $1 + 16 | 0;
 return $0;
}
function tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator___MicroBuiltinDataAllocator_28_29($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($0);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function tflite__AlignSizeUp_28unsigned_20long_2c_20unsigned_20long_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = 16;
 HEAP32[$1 + 4 >> 2] = Math_imul(HEAP32[$1 + 8 >> 2], (HEAP32[$1 + 12 >> 2] + (HEAP32[$1 + 8 >> 2] - 1 | 0) >>> 0) / HEAPU32[$1 + 8 >> 2] | 0);
 return HEAP32[$1 + 4 >> 2];
}
function jsvObjectIteratorClone($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[HEAP32[$2 + 12 >> 2] >> 2] = HEAP32[HEAP32[$2 + 8 >> 2] >> 2];
 if (HEAP32[HEAP32[$2 + 12 >> 2] >> 2]) {
  jsvLockAgain(HEAP32[HEAP32[$2 + 12 >> 2] >> 2]);
 }
 global$0 = $2 + 16 | 0;
}
function tflite__Tensor__quantization_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_int__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_int__20const___28unsigned_20short_29_20const(HEAP32[$1 + 12 >> 2], 12);
 global$0 = $1 + 16 | 0;
 return $0;
}
function tflite__EspruinoErrorReporter__EspruinoErrorReporter_28_29($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = global$0 - 16 | 0;
 $2 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 + 12 >> 2] = $2;
 HEAP32[HEAP32[$0 + 12 >> 2] >> 2] = 137732;
 HEAP32[$2 >> 2] = 137712;
 global$0 = $1 + 16 | 0;
}
function jsGfxGetPtr($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!(HEAP32[$1 + 8 >> 2] < 176 ? HEAP32[$1 + 8 >> 2] >= 0 : 0)) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = Math_imul(HEAP32[$1 + 8 >> 2], 68) + 324610;
 }
 return HEAP32[$1 + 12 >> 2];
}
function tflite__SubGraph__operators_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_int__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_int__20const___28unsigned_20short_29_20const(HEAP32[$1 + 12 >> 2], 10);
 global$0 = $1 + 16 | 0;
 return $0;
}
function tflite__Operator__builtin_options_type_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20char_20flatbuffers__Table__GetField_unsigned_20char__28unsigned_20short_2c_20unsigned_20char_29_20const(HEAP32[$1 + 12 >> 2], 10);
 global$0 = $1 + 16 | 0;
 return $0 & 255;
}
function jswrap_object_clone($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvCopy(HEAP32[$1 + 8 >> 2], 1);
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jsvMathsOpError($0, $1) {
 var $2 = 0;
 $2 = global$0 + -64 | 0;
 global$0 = $2;
 HEAP32[$2 + 60 >> 2] = $0;
 HEAP32[$2 + 56 >> 2] = $1;
 $0 = $2 + 16 | 0;
 jslTokenAsString(HEAP32[$2 + 60 >> 2], $0, 32);
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 56 >> 2];
 HEAP32[$2 >> 2] = $0;
 jsError(78744, $2);
 global$0 = $2 - -64 | 0;
 return 0;
}
function gen_jswrap_E_showMessage($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 >> 2] = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
 jsvUnLock(jspExecuteJSFunction(101320, 2, $2));
 global$0 = $2 + 16 | 0;
}
function std____2____less_signed_20char_2c_20signed_20char___operator_28_29_28signed_20char_20const__2c_20signed_20char_20const__29_20const($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 return HEAP8[HEAP32[$3 + 8 >> 2]] < HEAP8[HEAP32[$3 + 4 >> 2]];
}
function jsvIsStringEqualOrStartsWith($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 $0 = jsvIsStringEqualOrStartsWithOffset(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1, 0);
 global$0 = $3 + 16 | 0;
 return $0 & 1;
}
function gen_jswrap_Bangle_setUI($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 >> 2] = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
 jsvUnLock(jspExecuteJSFunction(96504, 2, $2));
 global$0 = $2 + 16 | 0;
}
function tflite__Tensor__is_variable_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20char_20flatbuffers__Table__GetField_unsigned_20char__28unsigned_20short_2c_20unsigned_20char_29_20const(HEAP32[$1 + 12 >> 2], 14);
 global$0 = $1 + 16 | 0;
 return ($0 & 255) != 0;
}
function tflite__SubGraph__inputs_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_int__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_int__20const___28unsigned_20short_29_20const(HEAP32[$1 + 12 >> 2], 6);
 global$0 = $1 + 16 | 0;
 return $0;
}
function tflite__Model__subgraphs_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_int__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_int__20const___28unsigned_20short_29_20const(HEAP32[$1 + 12 >> 2], 8);
 global$0 = $1 + 16 | 0;
 return $0;
}
function tflite__Model__metadata_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_int__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_int__20const___28unsigned_20short_29_20const(HEAP32[$1 + 12 >> 2], 16);
 global$0 = $1 + 16 | 0;
 return $0;
}
function tflite__Conv2DOptions__dilation_w_factor_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20int_20flatbuffers__Table__GetField_unsigned_20int__28unsigned_20short_2c_20unsigned_20int_29_20const(HEAP32[$1 + 12 >> 2], 12, 1);
 global$0 = $1 + 16 | 0;
 return $0;
}
function tflite__Conv2DOptions__dilation_h_factor_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20int_20flatbuffers__Table__GetField_unsigned_20int__28unsigned_20short_2c_20unsigned_20int_29_20const(HEAP32[$1 + 12 >> 2], 14, 1);
 global$0 = $1 + 16 | 0;
 return $0;
}
function push_byte($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 $1 = HEAPU8[$3 + 7 | 0];
 $2 = HEAP32[HEAP32[$3 + 8 >> 2] >> 2];
 $3 = HEAP32[HEAP32[$3 + 8 >> 2] + 8 >> 2];
 $0 = HEAP32[$3 >> 2];
 HEAP32[$3 >> 2] = $0 + 1;
 HEAP8[$0 + $2 | 0] = $1;
}
function tflite__OperatorCode__builtin_code_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = signed_20char_20flatbuffers__Table__GetField_signed_20char__28unsigned_20short_2c_20signed_20char_29_20const(HEAP32[$1 + 12 >> 2], 4);
 global$0 = $1 + 16 | 0;
 return $0 << 24 >> 24;
}
function jswrap_banglejs_getLCDMode() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 8 >> 2] = 0;
 label$1 : {
  if (!HEAP32[$0 + 8 >> 2]) {
   HEAP32[$0 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$0 + 12 >> 2] = jsvNewFromString(HEAP32[$0 + 8 >> 2]);
 }
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}
function jshIsTopEvent($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP8[$1 + 14 | 0] = $0;
 label$1 : {
  if (HEAPU8[322306] == HEAPU8[322307]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  HEAP8[$1 + 15 | 0] = HEAPU8[$1 + 14 | 0] == (HEAPU8[Math_imul(HEAPU8[322307], 5) + 322896 | 0] & 31);
 }
 return HEAP8[$1 + 15 | 0] & 1;
}
function jsError($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 $3 = $2 + 8 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 jsiConsoleRemoveInputLine();
 jsiConsolePrintString(79438);
 HEAP32[$3 >> 2] = $1;
 vcbprintf(7, 0, HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 jsiConsolePrintString(79446);
 global$0 = $2 + 16 | 0;
}
function jsfHashFiles($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = 0;
 HEAP32[$1 + 4 >> 2] = 64;
 HEAP32[$1 >> 2] = -1412571974;
 jsfBankListFiles(0, HEAP32[$1 + 12 >> 2], HEAP32[$1 + 8 >> 2], HEAP32[$1 + 4 >> 2], $1);
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 >> 2];
}
function tflite__Tensor__shape_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_int__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_int__20const___28unsigned_20short_29_20const(HEAP32[$1 + 12 >> 2], 4);
 global$0 = $1 + 16 | 0;
 return $0;
}
function terminalSetGFX($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 graphicsSetVar(HEAP32[$1 + 12 >> 2]);
 HEAP8[336939] = 1;
 $0 = HEAP32[$1 + 12 >> 2];
 jsvUnLock(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24));
 global$0 = $1 + 16 | 0;
}
function jstGetLastBufferTimerTask($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 $3 = $2 + 6 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP16[$2 + 6 >> 1] = jsvGetRef(HEAP32[$2 + 12 >> 2]);
 $0 = utilTimerGetLastTask(13, $3, HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0 & 1;
}
function tflite__Pool2DOptions__filter_height_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20int_20flatbuffers__Table__GetField_unsigned_20int__28unsigned_20short_2c_20unsigned_20int_29_20const(HEAP32[$1 + 12 >> 2], 12, 0);
 global$0 = $1 + 16 | 0;
 return $0;
}
function jsiTimerAdd($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvLock(HEAPU16[161110]);
 HEAP32[$1 + 4 >> 2] = jsvArrayAddToEnd(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2]) - 1;
 jsvUnLock(HEAP32[$1 + 8 >> 2]);
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 4 >> 2];
}
function jsiHandleHome() {
 var $0 = 0;
 while (1) {
  if (HEAPU32[80559] > 0) {
   $0 = (jsvGetCharInString(HEAP32[80557], HEAP32[80559] - 1 | 0) & 255) != 10;
  } else {
   $0 = 0;
  }
  if ($0) {
   if (jsiShowInputLine() & 1) {
    jsiConsolePrintChar(8);
   }
   HEAP32[80559] = HEAP32[80559] + -1;
   continue;
  }
  break;
 }
}
function jswrap_espruino_setPassword($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  HEAP32[$1 + 12 >> 2] = jsvAsString(HEAP32[$1 + 12 >> 2]);
 }
 jsvUnLock(jsvObjectSetChild(HEAP32[80546], 120706, HEAP32[$1 + 12 >> 2]));
 global$0 = $1 + 16 | 0;
}
function jsvIterateCallbackCountCb($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 HEAP32[$3 >> 2] = HEAP32[$3 + 4 >> 2];
 $0 = HEAP32[$3 >> 2];
 HEAP32[$0 >> 2] = HEAP32[$3 + 8 >> 2] + HEAP32[$0 >> 2];
}
function heatshrink_ptr_output_cb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
 $1 = HEAPU8[$2 + 15 | 0];
 $2 = HEAP32[$2 + 4 >> 2];
 $0 = HEAP32[$2 >> 2];
 HEAP32[$2 >> 2] = $0 + 1;
 HEAP8[$0 | 0] = $1;
}
function gemmlowp__AddSaturatingIf16BitImpl_int_2c_20false___Run_28int_2c_20int_29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = int_20gemmlowp__Add_int__28int_2c_20int_29(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0;
}
function _jswrap_serial_inject_cb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP8[$2 + 7 | 0] = HEAPU8[HEAP32[$2 + 8 >> 2]];
 jshPushIOCharEvent(HEAPU8[$2 + 7 | 0], HEAP32[$2 + 12 >> 2] << 24 >> 24);
 global$0 = $2 + 16 | 0;
}
function tflite__MicroOpResolver__MicroOpResolver_28_29($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = global$0 - 16 | 0;
 $2 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 + 12 >> 2] = $2;
 HEAP32[HEAP32[$0 + 12 >> 2] >> 2] = 137836;
 HEAP32[$2 >> 2] = 137796;
 global$0 = $1 + 16 | 0;
}
function jshFlashGetMemMapAddress($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!(HEAPU32[$1 + 8 >> 2] < 134217728 | HEAPU32[$1 + 8 >> 2] >= 142606336)) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2];
 }
 return HEAP32[$1 + 12 >> 2];
}
function gen_jswrap_ArrayBufferView_byteLength($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 $2 = HEAPU8[$0 + 2 | 0] | HEAPU8[$0 + 3 | 0] << 8;
 $0 = HEAP32[$1 + 12 >> 2];
 return Math_imul($2, (HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8) & 15) | 0;
}
function tflite__Operator__opcode_index_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20int_20flatbuffers__Table__GetField_unsigned_20int__28unsigned_20short_2c_20unsigned_20int_29_20const(HEAP32[$1 + 12 >> 2], 4, 0);
 global$0 = $1 + 16 | 0;
 return $0;
}
function tflite__OperatorCode__version_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20int_20flatbuffers__Table__GetField_unsigned_20int__28unsigned_20short_2c_20unsigned_20int_29_20const(HEAP32[$1 + 12 >> 2], 8, 1);
 global$0 = $1 + 16 | 0;
 return $0;
}
function std____2____less_double_2c_20double___operator_28_29_28double_20const__2c_20double_20const__29_20const($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 return HEAPF64[HEAP32[$3 + 8 >> 2] >> 3] < HEAPF64[HEAP32[$3 + 4 >> 2] >> 3];
}
function tflite__ops__micro__Register_RESHAPE_28_29($0) {
 HEAP32[$0 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 654;
 HEAP32[$0 + 12 >> 2] = 653;
}
function jshGetDeviceToTransmit() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 label$1 : {
  if (HEAPU8[322304] == HEAPU8[322305]) {
   HEAP8[$0 + 15 | 0] = 0;
   break label$1;
  }
  HEAP8[$0 + 15 | 0] = HEAPU8[(HEAPU8[322305] << 1) + 322384 | 0] & 31;
 }
 global$0 = $0 + 16 | 0;
 return HEAPU8[$0 + 15 | 0];
}
function heatshrink_var_output_cb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
 jsvStringIteratorSetCharAndNext(HEAP32[$2 + 4 >> 2], HEAP8[$2 + 15 | 0]);
 global$0 = $2 + 16 | 0;
}
function tflite__Tensor__type_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = signed_20char_20flatbuffers__Table__GetField_signed_20char__28unsigned_20short_2c_20signed_20char_29_20const(HEAP32[$1 + 12 >> 2], 6);
 global$0 = $1 + 16 | 0;
 return $0 << 24 >> 24;
}
function tflite__MicroMutableOpResolver_9u____MicroMutableOpResolver_28_29_1($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 tflite__MicroMutableOpResolver_9u____MicroMutableOpResolver_28_29($0);
 do_indexing($0);
 global$0 = $1 + 16 | 0;
}
function tflite__MicroInterpreter__outputs_size_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_int___Length_28_29_20const(tflite__Model__subgraphs_28_29_20const(HEAP32[HEAP32[$1 + 12 >> 2] + 116 >> 2]));
 global$0 = $1 + 16 | 0;
 return $0;
}
function tflite__MicroInterpreter__inputs_size_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_int___Length_28_29_20const(tflite__SubGraph__inputs_28_29_20const(HEAP32[HEAP32[$1 + 12 >> 2] + 116 >> 2]));
 global$0 = $1 + 16 | 0;
 return $0;
}
function std____2____less_float_2c_20float___operator_28_29_28float_20const__2c_20float_20const__29_20const($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 return HEAPF32[HEAP32[$3 + 8 >> 2] >> 2] < HEAPF32[HEAP32[$3 + 4 >> 2] >> 2];
}
function jswrap_array_find($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = _jswrap_array_iterate_with_callback(118842, HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 0, 2, 1, 1);
 global$0 = $2 + 16 | 0;
 return $0 | 0;
}
function tflite__Metadata__buffer_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20int_20flatbuffers__Table__GetField_unsigned_20int__28unsigned_20short_2c_20unsigned_20int_29_20const(HEAP32[$1 + 12 >> 2], 6, 0);
 global$0 = $1 + 16 | 0;
 return $0;
}
function jsvLockSafe($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP16[$1 + 10 >> 1] = $0;
 label$1 : {
  if (!HEAPU16[$1 + 10 >> 1]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvLock(HEAPU16[$1 + 10 >> 1]);
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jsvArrayBufferIteratorSetByteValue($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 if ((HEAPU16[HEAP32[$2 + 12 >> 2] + 36 >> 1] & 15) == 1) {
  jsvStringIteratorSetChar(HEAP32[$2 + 12 >> 2], HEAP8[$2 + 11 | 0]);
 }
 global$0 = $2 + 16 | 0;
}
function gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 4 >> 2] = $0;
 $0 = HEAP32[$1 + 4 >> 2];
 HEAP32[tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($1 + 8 | 0) >> 2] = $0;
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function jswrap_pin_write($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 HEAP8[$2 + 10 | 0] = jshGetPinFromVar(HEAP32[$2 + 12 >> 2]);
 jshPinOutput(HEAPU8[$2 + 10 | 0], HEAP8[$2 + 11 | 0] & 1);
 global$0 = $2 + 16 | 0;
}
function unsigned_20short_20flatbuffers__ReadScalar_unsigned_20short__28void_20const__29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = global$0 - 16 | 0;
 HEAP16[$0 + 14 >> 1] = HEAPU16[HEAP32[$1 + 12 >> 2] >> 1];
 global$0 = $1 + 16 | 0;
 return HEAPU16[$0 + 14 >> 1];
}
function tflite__Tensor__buffer_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20int_20flatbuffers__Table__GetField_unsigned_20int__28unsigned_20short_2c_20unsigned_20int_29_20const(HEAP32[$1 + 12 >> 2], 8, 0);
 global$0 = $1 + 16 | 0;
 return $0;
}
function jswGetBuiltInJSLibrary($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!strcmp(HEAP32[$1 + 8 >> 2], 94125)) {
   HEAP32[$1 + 12 >> 2] = 94132;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function int_20gemmlowp__SaturatingRoundingMultiplyByPOT__12_2c_20int__28int_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = gemmlowp__ImplSaturatingRoundingMultiplyByPOT__12_2c_20int_2c_20_1___eval_28int_29(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return $0;
}
function int_20gemmlowp__MaskIfGreaterThan_int__28int_2c_20int_29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = int_20gemmlowp__MaskIfNonZero_int__28int_29(HEAP32[$2 + 12 >> 2] > HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0;
}
function int_20gemmlowp__SaturatingRoundingMultiplyByPOT__2_2c_20int__28int_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = gemmlowp__ImplSaturatingRoundingMultiplyByPOT__2_2c_20int_2c_20_1___eval_28int_29(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return $0;
}
function int_20gemmlowp__SaturatingRoundingMultiplyByPOT__1_2c_20int__28int_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = gemmlowp__ImplSaturatingRoundingMultiplyByPOT__1_2c_20int_2c_20_1___eval_28int_29(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return $0;
}
function getint($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 if (isdigit(HEAP8[HEAP32[$0 >> 2]])) {
  while (1) {
   $1 = HEAP32[$0 >> 2];
   $3 = HEAP8[$1 | 0];
   HEAP32[$0 >> 2] = $1 + 1;
   $2 = (Math_imul($2, 10) + $3 | 0) + -48 | 0;
   if (isdigit(HEAP8[$1 + 1 | 0])) {
    continue;
   }
   break;
  }
 }
 return $2;
}
function tflite__Model_20const__20flatbuffers__GetRoot_tflite__Model__28void_20const__29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = tflite__Model__20flatbuffers__GetMutableRoot_tflite__Model__28void__29(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return $0;
}
function jswrap_onewire_skip($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[$1 + 11 | 0] = onewire_getpin(HEAP32[$1 + 12 >> 2]);
 if (jshIsPinValid(HEAPU8[$1 + 11 | 0]) & 1) {
  OneWireWrite(HEAPU8[$1 + 11 | 0], 8, 204, 0);
 }
 global$0 = $1 + 16 | 0;
}
function int_20gemmlowp__MaskIfLessThan_int__28int_2c_20int_29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = int_20gemmlowp__MaskIfNonZero_int__28int_29(HEAP32[$2 + 12 >> 2] < HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0;
}
function gen_jswrap_Graphics_setFontVector($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = jswrap_graphics_setFontSizeX(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 1);
 global$0 = $2 + 16 | 0;
 return $0 | 0;
}
function cbprintf($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 global$0 = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 vcbprintf(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2]);
 global$0 = $4 + 16 | 0;
}
function tflite__SoftmaxOptions__beta_28_29_20const($0) {
 var $1 = 0, $2 = Math_fround(0);
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $2 = float_20flatbuffers__Table__GetField_float__28unsigned_20short_2c_20float_29_20const(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return $2;
}
function jswrap_graphics_init() {
 HEAP8[324592] = 65535;
 HEAP8[324593] = 255;
 HEAP8[324594] = 0;
 HEAP8[324595] = 0;
 HEAP8[324596] = 65535;
 HEAP8[324597] = 255;
 HEAP8[324598] = 0;
 HEAP8[324599] = 0;
 HEAP8[324600] = 65535;
 HEAP8[324601] = 255;
 HEAP8[324602] = 0;
 HEAP8[324603] = 0;
 HEAP8[324604] = 1;
}
function int_20gemmlowp__SaturatingRoundingMultiplyByPOT_5_2c_20int__28int_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = gemmlowp__ImplSaturatingRoundingMultiplyByPOT_5_2c_20int_2c_201___eval_28int_29(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return $0;
}
function int_20gemmlowp__SaturatingRoundingMultiplyByPOT_2_2c_20int__28int_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = gemmlowp__ImplSaturatingRoundingMultiplyByPOT_2_2c_20int_2c_201___eval_28int_29(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return $0;
}
function int_20gemmlowp__SaturatingRoundingMultiplyByPOT_1_2c_20int__28int_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = gemmlowp__ImplSaturatingRoundingMultiplyByPOT_1_2c_20int_2c_201___eval_28int_29(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return $0;
}
function std____2____less_int_2c_20int___operator_28_29_28int_20const__2c_20int_20const__29_20const($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 return HEAP32[HEAP32[$3 + 8 >> 2] >> 2] < HEAP32[HEAP32[$3 + 4 >> 2] >> 2];
}
function jsfSetFlag($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
 label$1 : {
  if (HEAP8[$2 + 14 | 0] & 1) {
   HEAP8[142160] = HEAPU8[$2 + 15 | 0] | HEAPU8[142160];
   break label$1;
  }
  HEAP8[142160] = HEAPU8[142160] & (HEAPU8[$2 + 15 | 0] ^ -1);
 }
}
function jswrap_interface_trace($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1 : {
  if (jsvIsUndefined(HEAP32[$1 + 12 >> 2]) & 1) {
   jsvTrace(HEAP32[80545]);
   break label$1;
  }
  jsvTrace(HEAP32[$1 + 12 >> 2]);
 }
 global$0 = $1 + 16 | 0;
}
function jswrap_espruino_reverseByte($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 12 >> 2] & 255;
 return Math_imul(Math_imul(HEAP32[$1 + 8 >> 2], 2050) & 139536 | Math_imul(HEAP32[$1 + 8 >> 2], 32800) & 558144, 65793) >>> 16 & 255;
}
function gemmlowp__ImplSaturatingRoundingMultiplyByPOT__12_2c_20int_2c_20_1___eval_28int_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = int_20gemmlowp__RoundingDivideByPOT_int__28int_2c_20int_29(HEAP32[$1 + 12 >> 2], 12);
 global$0 = $1 + 16 | 0;
 return $0;
}
function jsWarn($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsiConsoleRemoveInputLine();
 jsiConsolePrintString(79448);
 HEAP32[$1 + 8 >> 2] = 0;
 vcbprintf(7, 0, HEAP32[$1 + 12 >> 2], HEAP32[$1 + 8 >> 2]);
 jsiConsolePrintString(79446);
 global$0 = $1 + 16 | 0;
}
function float_20flatbuffers__ReadScalar_float__28void_20const__29($0) {
 var $1 = 0, $2 = Math_fround(0);
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $2 = float_20flatbuffers__EndianScalar_float__28float_29(HEAPF32[HEAP32[$1 + 12 >> 2] >> 2]);
 global$0 = $1 + 16 | 0;
 return $2;
}
function gemmlowp__ImplSaturatingRoundingMultiplyByPOT__2_2c_20int_2c_20_1___eval_28int_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = int_20gemmlowp__RoundingDivideByPOT_int__28int_2c_20int_29(HEAP32[$1 + 12 >> 2], 2);
 global$0 = $1 + 16 | 0;
 return $0;
}
function gemmlowp__ImplSaturatingRoundingMultiplyByPOT__1_2c_20int_2c_20_1___eval_28int_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = int_20gemmlowp__RoundingDivideByPOT_int__28int_2c_20int_29(HEAP32[$1 + 12 >> 2], 1);
 global$0 = $1 + 16 | 0;
 return $0;
}
function unsigned_20char_20flatbuffers__ReadScalar_unsigned_20char__28void_20const__29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = global$0 - 16 | 0;
 HEAP8[$0 + 15 | 0] = HEAPU8[HEAP32[$1 + 12 >> 2]];
 global$0 = $1 + 16 | 0;
 return HEAPU8[$0 + 15 | 0];
}
function jsvObjectSetChildAndUnLock($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 jsvUnLock(jsvObjectSetChild(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]));
 global$0 = $3 + 16 | 0;
}
function jshGetEventsUsed() {
 var $0 = 0, $1 = 0, $2 = 0;
 $0 = global$0 - 16 | 0;
 $2 = $0;
 if (HEAPU8[322306] >= HEAPU8[322307]) {
  $1 = HEAPU8[322306] - HEAPU8[322307] | 0;
 } else {
  $1 = (HEAPU8[322306] + 256 | 0) - HEAPU8[322307] | 0;
 }
 HEAP32[$2 + 12 >> 2] = $1;
 return HEAP32[$0 + 12 >> 2];
}
function jsvRef($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if ((jsvGetRefs(HEAP32[$1 + 12 >> 2]) & 255) < 255) {
  jsvSetRefs(HEAP32[$1 + 12 >> 2], (jsvGetRefs(HEAP32[$1 + 12 >> 2]) & 255) + 1 & 255);
 }
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jsvGetIndexOf($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 $0 = jsvGetIndexOfFull(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1, 0, 0);
 global$0 = $3 + 16 | 0;
 return $0;
}
function jsserialHardwareFunc($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP8[$2 + 7 | 0] = HEAPU8[HEAP32[$2 + 8 >> 2]];
 jshTransmit(HEAPU8[$2 + 7 | 0], HEAPU8[$2 + 15 | 0]);
 global$0 = $2 + 16 | 0;
}
function jsSendPinWatchEvent($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[$1 + 11 | 0] = jshGetEventFlagsForPin(HEAP32[$1 + 12 >> 2] & 255);
 if (HEAPU8[$1 + 11 | 0]) {
  jshPushIOWatchEvent(HEAPU8[$1 + 11 | 0]);
 }
 global$0 = $1 + 16 | 0;
}
function int_20gemmlowp__MaskIfNonZero_int__28int_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1 : {
  if (HEAP32[$1 + 12 >> 2]) {
   $0 = int_20gemmlowp__BitNot_int__28int_29(0);
   break label$1;
  }
  $0 = 0;
 }
 global$0 = $1 + 16 | 0;
 return $0;
}
function gemmlowp__FixedPoint_int_2c_200__20gemmlowp__FixedPoint_int_2c_200___ConstantPOT__3__28_29() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 8 >> 2] = gemmlowp__FixedPoint_int_2c_2012___FromScalarRaw_28int_29(268435456);
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 8 >> 2];
}
function jswrap_banglejs_kill() {
 jsvUnLock(HEAP32[84190]);
 HEAP32[84190] = 0;
 jsvUnLock(HEAP32[84191]);
 HEAP32[84191] = 0;
 if (HEAPU16[168371]) {
  jswrap_banglejs_beep_callback();
 }
 if (HEAPU8[336740]) {
  jswrap_banglejs_buzz_callback();
 }
 jshPinWatch(17, 0);
 jshSetPinShouldStayWatched(0);
}
function jsvStringIteratorGetCharAndNext($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[$1 + 11 | 0] = jsvStringIteratorGetChar(HEAP32[$1 + 12 >> 2]);
 jsvStringIteratorNextInline(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return HEAP8[$1 + 11 | 0];
}
function gemmlowp__FixedPoint_int_2c_205__20gemmlowp__FixedPoint_int_2c_205___ConstantPOT__2__28_29() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 8 >> 2] = gemmlowp__FixedPoint_int_2c_2012___FromScalarRaw_28int_29(16777216);
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 8 >> 2];
}
function gen_jswrap_Graphics_fillPoly($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = jswrap_graphics_fillPoly_X(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0 | 0;
}
function jsvObjectIteratorSetValue($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 if (HEAP32[HEAP32[$2 + 12 >> 2] >> 2]) {
  jsvSetValueOfName(HEAP32[HEAP32[$2 + 12 >> 2] >> 2], HEAP32[$2 + 8 >> 2]);
 }
 global$0 = $2 + 16 | 0;
}
function _jswrap_espruino_toString_char($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jsvStringIteratorSetCharAndNext(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 12 >> 2] << 24 >> 24);
 global$0 = $2 + 16 | 0;
}
function signed_20char_20flatbuffers__ReadScalar_signed_20char__28void_20const__29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = global$0 - 16 | 0;
 HEAP8[$0 + 15 | 0] = HEAP8[HEAP32[$1 + 12 >> 2]];
 global$0 = $1 + 16 | 0;
 return HEAP8[$0 + 15 | 0];
}
function jslTokenAppendChar($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 if (HEAPU8[HEAP32[35539] + 80 | 0] < 63) {
  $2 = HEAPU8[$1 + 15 | 0];
  $0 = HEAP32[35539];
  $1 = HEAPU8[$0 + 80 | 0];
  HEAP8[$0 + 80 | 0] = $1 + 1;
  HEAP8[$1 + ($0 + 12 | 0) | 0] = $2;
 }
}
function jswrap_espruino_lockConsole() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 12 >> 2] = jsvObjectGetChild(HEAP32[80546], 120706, 0);
 if (HEAP32[$0 + 12 >> 2]) {
  HEAP16[161112] = HEAPU16[161112] | 1024;
 }
 jsvUnLock(HEAP32[$0 + 12 >> 2]);
 global$0 = $0 + 16 | 0;
}
function jsvSetInteger($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 $1 = HEAP32[$2 + 8 >> 2];
 HEAP8[$0 | 0] = $1;
 HEAP8[$0 + 1 | 0] = $1 >>> 8;
 HEAP8[$0 + 2 | 0] = $1 >>> 16;
 HEAP8[$0 + 3 | 0] = $1 >>> 24;
}
function jsvUnLock3($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 jsvUnLock(HEAP32[$3 + 12 >> 2]);
 jsvUnLock(HEAP32[$3 + 8 >> 2]);
 jsvUnLock(HEAP32[$3 + 4 >> 2]);
 global$0 = $3 + 16 | 0;
}
function jswrap_date_from_milliseconds($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAPF64[$1 + 8 >> 3] = $0;
 HEAP32[$1 + 4 >> 2] = jspNewObject(0, 119745);
 jswrap_date_setTime(HEAP32[$1 + 4 >> 2], HEAPF64[$1 + 8 >> 3]);
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 4 >> 2];
}
function jsvGetRef($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP16[$1 + 14 >> 1] = 0;
   break label$1;
  }
  HEAP16[$1 + 14 >> 1] = ((HEAP32[$1 + 8 >> 2] - 142172 | 0) / 15 | 0) + 1;
 }
 return HEAPU16[$1 + 14 >> 1];
}
function tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__SafeBuiltinDataAllocator_28tflite__BuiltinDataAllocator__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[HEAP32[$2 + 12 >> 2] >> 2] = HEAP32[$2 + 8 >> 2];
}
function jswrap_string_charCodeAt($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = jsvGetCharInString(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0 & 255;
}
function jswrap_math_sqrt($0) {
 $0 = +$0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAPF64[$1 + 8 >> 3] = $0;
 label$1 : {
  if (HEAPF64[$1 + 8 >> 3] >= 0) {
   $0 = exp(log(HEAPF64[$1 + 8 >> 3]) * .5);
   break label$1;
  }
  $0 = nan;
 }
 global$0 = $1 + 16 | 0;
 return +$0;
}
function jshIsEventForPin($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 $0 = HEAPU8[HEAP32[$2 + 12 >> 2]] & 31;
 $1 = jshGetEventFlagsForPin(HEAPU8[$2 + 11 | 0]);
 global$0 = $2 + 16 | 0;
 return ($0 | 0) == ($1 & 255);
}
function _jswrap_promise_resolve($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 _jswrap_promise_resolve_or_reject_chain(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 1);
 global$0 = $2 + 16 | 0;
}
function jswrap_modules_removeAllCached() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 12 >> 2] = jswrap_modules_getModuleList();
 if (HEAP32[$0 + 12 >> 2]) {
  jsvRemoveAllChildren(HEAP32[$0 + 12 >> 2]);
  jsvUnLock(HEAP32[$0 + 12 >> 2]);
 }
 global$0 = $0 + 16 | 0;
}
function _jswrap_promise_reject($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 _jswrap_promise_resolve_or_reject_chain(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 0);
 global$0 = $2 + 16 | 0;
}
function jsvLockAgainSafe($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1 : {
  if (HEAP32[$1 + 12 >> 2]) {
   $0 = jsvLockAgain(HEAP32[$1 + 12 >> 2]);
   break label$1;
  }
  $0 = 0;
 }
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function jsiGetPreferredConsoleDevice() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP8[$0 + 15 | 0] = 21;
 if (!(jshIsDeviceInitialised(HEAPU8[$0 + 15 | 0]) & 1)) {
  HEAP8[$0 + 15 | 0] = 20;
 }
 HEAP8[$0 + 15 | 0] = 21;
 global$0 = $0 + 16 | 0;
 return HEAPU8[$0 + 15 | 0];
}
function tflite__MicroAllocator__ResetTempAllocations_28_29($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
 FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 20 >> 2]]($0);
 global$0 = $1 + 16 | 0;
}
function jsvArrayPushAndUnLock($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = jsvArrayPush(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 jsvUnLock(HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
}
function getCalendarDateFromDateVar($0, $1) {
 var $2 = 0;
 $2 = global$0 - 32 | 0;
 global$0 = $2;
 HEAP32[$2 + 28 >> 2] = $1;
 HEAP8[$2 + 27 | 0] = 0;
 getTimeFromDateVar($2, HEAP32[$2 + 28 >> 2], HEAP8[$2 + 27 | 0] & 1);
 getCalendarDate($0, HEAP32[$2 >> 2]);
 global$0 = $2 + 32 | 0;
}
function jswrap_pin_mode($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jswrap_io_pinMode(jshGetPinFromVar(HEAP32[$2 + 12 >> 2]) & 255, HEAP32[$2 + 8 >> 2], 0);
 global$0 = $2 + 16 | 0;
}
function jspeiGetScopesAsVar() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 label$1 : {
  if (!HEAP32[80547]) {
   HEAP32[$0 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$0 + 12 >> 2] = jsvCopy(HEAP32[80547], 1);
 }
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}
function jsfGetJSON($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 jsfGetJSONWhitespace(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 0);
 global$0 = $3 + 16 | 0;
}
function itoch($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1 : {
  if (HEAP32[$1 + 8 >> 2] < 10) {
   HEAP8[$1 + 15 | 0] = HEAP32[$1 + 8 >> 2] + 48;
   break label$1;
  }
  HEAP8[$1 + 15 | 0] = HEAP32[$1 + 8 >> 2] + 87;
 }
 return HEAP8[$1 + 15 | 0];
}
function jsvLockAgain($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 $2 = (HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) + 512 | 0;
 HEAP8[$0 + 13 | 0] = $2;
 HEAP8[$0 + 14 | 0] = $2 >>> 8;
 return HEAP32[$1 + 12 >> 2];
}
function tflite__ops__micro__Register_DEPTHWISE_CONV_2D_28_29($0) {
 HEAP32[$0 >> 2] = 633;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 632;
 HEAP32[$0 + 12 >> 2] = 631;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
}
function gen_jswrap_peek32($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = jswrap_io_peek(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 4);
 global$0 = $2 + 16 | 0;
 return $0 | 0;
}
function gen_jswrap_peek16($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = jswrap_io_peek(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 2);
 global$0 = $2 + 16 | 0;
 return $0 | 0;
}
function jsvHasCharacterData($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $2 = jsvIsString(HEAP32[$1 + 12 >> 2]);
 $0 = 1;
 if (!($2 & 1)) {
  $0 = jsvIsStringExt(HEAP32[$1 + 12 >> 2]);
 }
 global$0 = $1 + 16 | 0;
 return $0 & 1;
}
function gen_jswrap_peek8($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = jswrap_io_peek(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 1);
 global$0 = $2 + 16 | 0;
 return $0 | 0;
}
function ftoa_bounded($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAPF64[$3 + 8 >> 3] = $0;
 HEAP32[$3 + 4 >> 2] = $1;
 HEAP32[$3 >> 2] = $2;
 ftoa_bounded_extra(HEAPF64[$3 + 8 >> 3], HEAP32[$3 + 4 >> 2], HEAP32[$3 >> 2], 10, -1);
 global$0 = $3 + 16 | 0;
}
function tflite__ops__micro__Register_FULLY_CONNECTED_28_29($0) {
 HEAP32[$0 >> 2] = 646;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 645;
 HEAP32[$0 + 12 >> 2] = 644;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
}
function tflite__ops__micro__Register_AVERAGE_POOL_2D_28_29($0) {
 HEAP32[$0 >> 2] = 639;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 638;
 HEAP32[$0 + 12 >> 2] = 637;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
}
function jsvRefRef($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP16[$1 + 14 >> 1] = $0;
 HEAP32[$1 + 8 >> 2] = jsvLock(HEAPU16[$1 + 14 >> 1]);
 jsvRef(HEAP32[$1 + 8 >> 2]);
 jsvUnLock(HEAP32[$1 + 8 >> 2]);
 global$0 = $1 + 16 | 0;
 return HEAPU16[$1 + 14 >> 1];
}
function jsvObjectIteratorNew($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = jsvLockSafe(jsvGetFirstChild(HEAP32[$2 + 8 >> 2]) & 65535);
 HEAP32[HEAP32[$2 + 12 >> 2] >> 2] = $0;
 global$0 = $2 + 16 | 0;
}
function flatbuffers__Vector_int___size_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 global$0 = $1 + 16 | 0;
 return $0;
}
function tflite__GetModel_28void_20const__29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = tflite__Model_20const__20flatbuffers__GetRoot_tflite__Model__28void_20const__29(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return $0;
}
function _jswrap_onewire_write_cb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 OneWireWrite(HEAPU8[HEAP32[$2 + 8 >> 2]], 8, HEAP32[$2 + 12 >> 2], 0);
 global$0 = $2 + 16 | 0;
}
function _jswrap_drawImageLayerStartX($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[HEAP32[$1 + 12 >> 2] + 180 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 172 >> 2];
 HEAP32[HEAP32[$1 + 12 >> 2] + 184 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 176 >> 2];
}
function tflite__ops__micro__Register_MAX_POOL_2D_28_29($0) {
 HEAP32[$0 >> 2] = 639;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 638;
 HEAP32[$0 + 12 >> 2] = 640;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
}
function tflite__NumElements_28TfLiteTensor_20const__29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = tflite__NumElements_28TfLiteIntArray_20const__29(HEAP32[HEAP32[$1 + 12 >> 2] + 20 >> 2]);
 global$0 = $1 + 16 | 0;
 return $0;
}
function jswrap_math_asin($0) {
 $0 = +$0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAPF64[$1 + 8 >> 3] = $0;
 $0 = jswrap_math_atan(HEAPF64[$1 + 8 >> 3] / jswrap_math_sqrt(1 - HEAPF64[$1 + 8 >> 3] * HEAPF64[$1 + 8 >> 3]));
 global$0 = $1 + 16 | 0;
 return +$0;
}
function jsvUnRef($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if ((jsvGetRefs(HEAP32[$1 + 12 >> 2]) & 255) < 255) {
  jsvSetRefs(HEAP32[$1 + 12 >> 2], (jsvGetRefs(HEAP32[$1 + 12 >> 2]) & 255) - 1 & 255);
 }
 global$0 = $1 + 16 | 0;
}
function float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1 : {
  if (!HEAP32[$1 + 12 >> 2]) {
   break label$1;
  }
 }
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2];
}
function tflite__ops__micro__Register_DEQUANTIZE_28_29($0) {
 HEAP32[$0 >> 2] = 652;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 651;
 HEAP32[$0 + 12 >> 2] = 650;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
}
function jstStopBufferTimerTask($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 $2 = $1 + 10 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP16[$1 + 10 >> 1] = jsvGetRef(HEAP32[$1 + 12 >> 2]);
 $0 = utilTimerRemoveTask($2);
 global$0 = $1 + 16 | 0;
 return $0 & 1;
}
function jspeiLoadScopesFromVar($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[80547]);
 HEAP32[80547] = 0;
 if (HEAP32[$1 + 12 >> 2]) {
  HEAP32[80547] = jsvCopy(HEAP32[$1 + 12 >> 2], 1);
 }
 global$0 = $1 + 16 | 0;
}
function jswrap_serial_println($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 _jswrap_serial_print(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 1, 1);
 global$0 = $2 + 16 | 0;
}
function tflite__ops__micro__Register_QUANTIZE_28_29($0) {
 HEAP32[$0 >> 2] = 649;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 648;
 HEAP32[$0 + 12 >> 2] = 647;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
}
function tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29_1($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 FUNCTION_TABLE[598]($0) | 0;
 do_indexing($0);
 global$0 = $1 + 16 | 0;
}
function jslCharPosFromLex($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvStringIteratorClone(HEAP32[$1 + 12 >> 2], HEAP32[35539] + 88 | 0);
 HEAP8[HEAP32[$1 + 12 >> 2] + 36 | 0] = HEAPU8[HEAP32[35539]];
 global$0 = $1 + 16 | 0;
}
function gen_jswrap_E_showScroller($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 12 >> 2];
 $0 = jspExecuteJSFunction(103311, 1, $1 + 8 | 0);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function tflite__ops__micro__Register_SOFTMAX_28_29($0) {
 HEAP32[$0 >> 2] = 643;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 642;
 HEAP32[$0 + 12 >> 2] = 641;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
}
function tflite__ops__micro__Register_CONV_2D_28_29($0) {
 HEAP32[$0 >> 2] = 636;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 635;
 HEAP32[$0 + 12 >> 2] = 634;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
}
function tflite__RuntimeShape__DimsData_28_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 label$1 : {
  if (HEAP32[$0 >> 2] > 5) {
   $0 = HEAP32[$0 + 4 >> 2];
   break label$1;
  }
  $0 = $0 + 4 | 0;
 }
 return $0;
}
function jswrap_serial_write($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 _jswrap_serial_print(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 0, 0);
 global$0 = $2 + 16 | 0;
}
function jswrap_serial_print($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 _jswrap_serial_print(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 1, 0);
 global$0 = $2 + 16 | 0;
}
function jshGetPinFromVarAndUnLock($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[$1 + 11 | 0] = jshGetPinFromVar(HEAP32[$1 + 12 >> 2]);
 jsvUnLock(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return HEAPU8[$1 + 11 | 0];
}
function itostr($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 itostr_extra(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], 1, HEAP32[$3 + 4 >> 2]);
 global$0 = $3 + 16 | 0;
}
function tflite__SizeOfDimension_28TfLiteTensor_20const__2c_20int_29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 return HEAP32[(HEAP32[HEAP32[$2 + 12 >> 2] + 20 >> 2] + 4 | 0) + (HEAP32[$2 + 8 >> 2] << 2) >> 2];
}
function jsvAsArrayIndexAndUnLock($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvAsArrayIndex(HEAP32[$1 + 12 >> 2]);
 jsvUnLock(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function getTimeFromDateVar($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $1;
 HEAP8[$3 + 11 | 0] = $2;
 getTimeFromMilliSeconds($0, jswrap_date_getTime(HEAP32[$3 + 12 >> 2]), HEAP8[$3 + 11 | 0] & 1);
 global$0 = $3 + 16 | 0;
}
function gen_jswrap_Math_tan($0) {
 $0 = +$0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAPF64[$1 + 8 >> 3] = $0;
 $0 = jswrap_math_sin(HEAPF64[$1 + 8 >> 3]) / jswrap_math_sin(HEAPF64[$1 + 8 >> 3] + 1.5707963267948966);
 global$0 = $1 + 16 | 0;
 return +$0;
}
function add_tag_bit($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 global$0 = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 push_bits(HEAP32[$3 + 12 >> 2], 1, HEAPU8[$3 + 7 | 0], HEAP32[$3 + 8 >> 2]);
 global$0 = $3 + 16 | 0;
}
function jsvIsBasic($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $2 = jsvIsNumeric(HEAP32[$1 + 12 >> 2]);
 $0 = 1;
 if (!($2 & 1)) {
  $0 = jsvIsString(HEAP32[$1 + 12 >> 2]);
 }
 global$0 = $1 + 16 | 0;
 return $0 & 1;
}
function flatbuffers__Table__GetVTable_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 $0 = $0 - flatbuffers__Vector_int___size_28_29_20const($0) | 0;
 global$0 = $1 + 16 | 0;
 return $0;
}
function tflite__GreedyMemoryPlanner___GreedyMemoryPlanner_28_29_1($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 FUNCTION_TABLE[657]($0) | 0;
 do_indexing($0);
 global$0 = $1 + 16 | 0;
}
function jswrap_pin_read($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[$1 + 11 | 0] = jshGetPinFromVar(HEAP32[$1 + 12 >> 2]);
 $0 = jshPinInput(HEAPU8[$1 + 11 | 0]);
 global$0 = $1 + 16 | 0;
 return $0 & 1;
}
function jswrap_banglejs_setLCDPowerBacklight($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 label$1 : {
  if (HEAP8[$1 + 15 | 0] & 1) {
   HEAP32[84152] = HEAP32[84152] | 65536;
   break label$1;
  }
  HEAP32[84152] = HEAP32[84152] & -65537;
 }
}
function jsvSkipOneNameAndUnLock($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvSkipOneName(HEAP32[$1 + 12 >> 2]);
 jsvUnLock(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function jsvGetArrayItem($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = jsvSkipNameAndUnLock(jsvGetArrayIndex(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]));
 global$0 = $2 + 16 | 0;
 return $0;
}
function tflite__MicroInterpreter__outputs_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = tflite__Model__subgraphs_28_29_20const(HEAP32[HEAP32[$1 + 12 >> 2] + 116 >> 2]);
 global$0 = $1 + 16 | 0;
 return $0;
}
function gen_jswrap_E_showMenu($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 12 >> 2];
 $0 = jspExecuteJSFunction(99036, 1, $1 + 8 | 0);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function _jsvGetIntegerAndUnLock($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvGetInteger(HEAP32[$1 + 12 >> 2]);
 jsvUnLock(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function _jsvGetBoolAndUnLock($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[$1 + 11 | 0] = jsvGetBool(HEAP32[$1 + 12 >> 2]) & 1;
 jsvUnLock(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return HEAP8[$1 + 11 | 0] & 1;
}
function tflite__MicroInterpreter__inputs_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = tflite__SubGraph__inputs_28_29_20const(HEAP32[HEAP32[$1 + 12 >> 2] + 116 >> 2]);
 global$0 = $1 + 16 | 0;
 return $0;
}
function jsvIsStringEqual($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = jsvIsStringEqualOrStartsWith(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 0);
 global$0 = $2 + 16 | 0;
 return $0 & 1;
}
function pop_arg_long_double($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = $1;
 $1 = HEAP32[$1 >> 2] + 15 & -16;
 HEAP32[$2 >> 2] = $1 + 16;
 HEAPF64[$0 >> 3] = __trunctfdf2(HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2], HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2]);
}
function jswrap_interface_echo($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 label$1 : {
  if (HEAP8[$1 + 15 | 0] & 1) {
   HEAP16[161112] = HEAPU16[161112] & -2;
   break label$1;
  }
  HEAP16[161112] = HEAPU16[161112] | 1;
 }
}
function jswrap_tfmicrointerpreter_getOutput($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_tfmicrointerpreter_tensorToArrayBuffer(HEAP32[$1 + 12 >> 2], 0);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function jswrap_espruino_getErrorFlags() {
 var $0 = 0, $1 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP8[$0 + 15 | 0] = HEAPU8[322179];
 HEAP8[322179] = 0;
 $1 = jswrap_espruino_getErrorFlagArray(HEAPU8[$0 + 15 | 0]);
 global$0 = $0 + 16 | 0;
 return $1 | 0;
}
function jswrap_tfmicrointerpreter_getInput($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_tfmicrointerpreter_tensorToArrayBuffer(HEAP32[$1 + 12 >> 2], 1);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function jsvIterateCallbackCount($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = 0;
 jsvIterateBufferCallback(HEAP32[$1 + 12 >> 2], 5, $1 + 8 | 0);
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function jsvIsNativeFunction($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  $0 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 127) == 71;
 } else {
  $0 = 0;
 }
 return $0;
}
function jsvIsArrayBufferName($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  $0 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) == 13;
 } else {
  $0 = 0;
 }
 return $0;
}
function flatbuffers__Vector_unsigned_20char___data_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_int___Data_28_29_20const(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return $0;
}
function jswrap_flash_getFree() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 12 >> 2] = jshFlashGetFree();
 if (!HEAP32[$0 + 12 >> 2]) {
  HEAP32[$0 + 12 >> 2] = jsvNewWithFlags(3);
 }
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}
function jsvSkipNameAndUnLock($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvSkipName(HEAP32[$1 + 12 >> 2]);
 jsvUnLock(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function jsvAsStringAndUnLock($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvAsString(HEAP32[$1 + 12 >> 2]);
 jsvUnLock(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function jsvAsNumberAndUnLock($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvAsNumber(HEAP32[$1 + 12 >> 2]);
 jsvUnLock(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function int_20gemmlowp__MaskIfZero_int__28int_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = int_20gemmlowp__MaskIfNonZero_int__28int_29((HEAP32[$1 + 12 >> 2] != 0 ^ -1) & 1);
 global$0 = $1 + 16 | 0;
 return $0;
}
function jswrap_pipe_kill() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 12 >> 2] = pipeGetArray(0);
 if (HEAP32[$0 + 12 >> 2]) {
  jsvRemoveAllChildren(HEAP32[$0 + 12 >> 2]);
  jsvUnLock(HEAP32[$0 + 12 >> 2]);
 }
 global$0 = $0 + 16 | 0;
}
function jswrap_interface_load($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP16[161112] = HEAPU16[161112] | 64;
 jsvObjectSetChild(HEAP32[80546], 121453, HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
}
function jsvIsGetterOrSetter($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  $0 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) == 6;
 } else {
  $0 = 0;
 }
 return $0;
}
function jsvIsFunctionReturn($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  $0 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) == 8;
 } else {
  $0 = 0;
 }
 return $0;
}
function jsvIsNativeString($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  $0 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) == 39;
 } else {
  $0 = 0;
 }
 return $0;
}
function jsvGetFlatStringBlocks($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 return ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) + 14 >>> 0) / 15 | 0;
}
function jsiLoop() {
 jshIdle();
 jsiIdle();
 jsiCheckErrors();
 if (HEAP32[80549] & 6144) {
  HEAP32[80549] = HEAP32[80549] & -6145;
  if (jsvIsEmptyString(HEAP32[80557]) & 1) {
   HEAP32[80574] = 0;
  }
  jsiClearInputLine(1);
 }
 jsiConsoleReturnInputLine();
}
function gen_jswrap_poke32($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jswrap_io_poke(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 4);
 global$0 = $2 + 16 | 0;
}
function gen_jswrap_poke16($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jswrap_io_poke(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 2);
 global$0 = $2 + 16 | 0;
}
function jsvIsNameIntBool($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  $0 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) == 16;
 } else {
  $0 = 0;
 }
 return $0;
}
function jsvIsFlashString($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  $0 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) == 40;
 } else {
  $0 = 0;
 }
 return $0;
}
function gen_jswrap_poke8($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jswrap_io_poke(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 1);
 global$0 = $2 + 16 | 0;
}
function tflite__MicroAllocator___MicroAllocator_28_29_1($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 FUNCTION_TABLE[611]($0) | 0;
 do_indexing($0);
 global$0 = $1 + 16 | 0;
}
function jswrap_interface_reset($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 15 | 0] = $0;
 HEAP16[161112] = HEAPU16[161112] | 128;
 if (HEAP8[$1 + 15 | 0] & 1) {
  jsfRemoveCodeFromFlash();
 }
 global$0 = $1 + 16 | 0;
}
function jsvIsFlatString($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  $0 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) == 38;
 } else {
  $0 = 0;
 }
 return $0;
}
function jsvIsArrayBuffer($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  $0 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) == 4;
 } else {
  $0 = 0;
 }
 return $0;
}
function fmt_x($0, $1, $2, $3) {
 if ($0 | $1) {
  while (1) {
   $2 = $2 + -1 | 0;
   HEAP8[$2 | 0] = HEAPU8[($0 & 15) + 138560 | 0] | $3;
   $0 = ($1 & 15) << 28 | $0 >>> 4;
   $1 = $1 >>> 4;
   if ($0 | $1) {
    continue;
   }
   break;
  }
 }
 return $2;
}
function jsvAppendStringVarComplete($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jsvAppendStringVar(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 0, 2147483647);
 global$0 = $2 + 16 | 0;
}
function gen_jswrap_Object_getOwnPropertyNames($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_object_keys_or_property_names(HEAP32[$1 + 12 >> 2], 1);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function gemmlowp__FixedPoint_int_2c_200___One_28_29() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 8 >> 2] = gemmlowp__FixedPoint_int_2c_2012___FromScalarRaw_28int_29(2147483647);
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 8 >> 2];
}
function _jsvGetFloatAndUnLock($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAPF64[$1 >> 3] = jsvGetFloat(HEAP32[$1 + 12 >> 2]);
 jsvUnLock(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return HEAPF64[$1 >> 3];
}
function jsvIsSimpleInt($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  $0 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) == 9;
 } else {
  $0 = 0;
 }
 return $0;
}
function jsfGetDriveBankAddress($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 HEAP8[$3 + 15 | 0] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 HEAP32[HEAP32[$3 + 8 >> 2] >> 2] = 134217728;
 HEAP32[HEAP32[$3 + 4 >> 2] >> 2] = 142606336;
}
function gemmlowp__FixedPoint_int_2c_202___One_28_29() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 8 >> 2] = gemmlowp__FixedPoint_int_2c_2012___FromScalarRaw_28int_29(536870912);
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 8 >> 2];
}
function jswrap_date_getTime($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $2 = jsvGetFloatAndUnLock(jsvObjectGetChild(HEAP32[$1 + 12 >> 2], 119809, 0));
 global$0 = $1 + 16 | 0;
 return +$2;
}
function jsiOneSecondAfterStartup() {
 label$1 : {
  if (HEAPU8[141672] == 19) {
   HEAP8[141672] = jsiGetPreferredConsoleDevice();
   jshTransmitMove(HEAPU8[141672]);
   jshUSARTUnSetup(HEAPU8[141672]);
   break label$1;
  }
  jshTransmitClearDevice();
 }
}
function jswrap_math_atan2($0, $1) {
 $0 = +$0;
 $1 = +$1;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAPF64[$2 + 8 >> 3] = $0;
 HEAPF64[$2 >> 3] = $1;
 $0 = atan2(HEAPF64[$2 + 8 >> 3], HEAPF64[$2 >> 3]);
 global$0 = $2 + 16 | 0;
 return +$0;
}
function jstGetLastPinTimerTask($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = utilTimerGetLastTask(12, $2 + 15 | 0, HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
 return $0 & 1;
}
function srand($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[35416] = HEAP32[$1 + 12 >> 2] & 65535 | HEAP32[$1 + 12 >> 2] << 16;
 HEAP32[35417] = HEAP32[$1 + 12 >> 2] & -65536 | HEAP32[$1 + 12 >> 2] >>> 16;
}
function jsvIsNative($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  $0 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 64) != 0;
 } else {
  $0 = 0;
 }
 return $0;
}
function jsvIsFloat($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  $0 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) == 10;
 } else {
  $0 = 0;
 }
 return $0;
}
function i2c_pin_wr1($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 15 | 0] = $0;
 jshPinSetValue(HEAPU8[$1 + 15 | 0], 1);
 jshPinSetState(HEAPU8[$1 + 15 | 0], 1);
 jshPinSetState(HEAPU8[$1 + 15 | 0], 5);
 global$0 = $1 + 16 | 0;
}
function float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[HEAP32[$1 + 12 >> 2] >> 2];
 } else {
  $0 = 0;
 }
 return $0;
}
function flatbuffers__Vector_int___Length_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_int___size_28_29_20const(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return $0;
}
function jswrap_pin_reset($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[$1 + 11 | 0] = jshGetPinFromVar(HEAP32[$1 + 12 >> 2]);
 jshPinOutput(HEAPU8[$1 + 11 | 0], 0);
 global$0 = $1 + 16 | 0;
}
function jswrap_date_getTimezoneOffset($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 getTimeFromDateVar($1, HEAP32[$1 + 28 >> 2], 0);
 global$0 = $1 + 32 | 0;
 return 0 - HEAP32[$1 + 20 >> 2] | 0;
}
function jsvUnRefRef($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP16[$1 + 14 >> 1] = $0;
 HEAP32[$1 + 8 >> 2] = jsvLock(HEAPU16[$1 + 14 >> 1]);
 jsvUnRef(HEAP32[$1 + 8 >> 2]);
 jsvUnLock(HEAP32[$1 + 8 >> 2]);
 global$0 = $1 + 16 | 0;
}
function jsvIsArray($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  $0 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) == 3;
 } else {
  $0 = 0;
 }
 return $0;
}
function charToUpperCase($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 if (HEAP8[$1 + 15 | 0] < 97 | HEAP8[$1 + 15 | 0] > 122) {
  $0 = HEAP8[$1 + 15 | 0];
 } else {
  $0 = HEAP8[$1 + 15 | 0] - 32 | 0;
 }
 return $0 << 24 >> 24;
}
function btn1Handler($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
 btnHandlerCommon(HEAP8[$2 + 15 | 0] & 1, HEAPU8[$2 + 14 | 0]);
 global$0 = $2 + 16 | 0;
}
function jswrap_date_getFullYear($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 getCalendarDateFromDateVar($1 + 8 | 0, HEAP32[$1 + 28 >> 2]);
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 20 >> 2];
}
function jsvIsRoot($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  $0 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) == 1;
 } else {
  $0 = 0;
 }
 return $0;
}
function jsvIsPin($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  $0 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) == 12;
 } else {
  $0 = 0;
 }
 return $0;
}
function jsvIsNull($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  $0 = ((HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) & 63) == 2;
 } else {
  $0 = 0;
 }
 return $0;
}
function gen_jswrap_Graphics_setFontBitmap($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_graphics_setFontSizeX(HEAP32[$1 + 12 >> 2], 8193, 0);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function charToLowerCase($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 if (HEAP8[$1 + 15 | 0] < 65 | HEAP8[$1 + 15 | 0] > 90) {
  $0 = HEAP8[$1 + 15 | 0];
 } else {
  $0 = HEAP8[$1 + 15 | 0] + 32 | 0;
 }
 return $0 << 24 >> 24;
}
function jswrap_pin_set($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[$1 + 11 | 0] = jshGetPinFromVar(HEAP32[$1 + 12 >> 2]);
 jshPinOutput(HEAPU8[$1 + 11 | 0], 1);
 global$0 = $1 + 16 | 0;
}
function gemmlowp__FixedPoint_int_2c_2012___Zero_28_29() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 8 >> 2] = gemmlowp__FixedPoint_int_2c_2012___FromScalarRaw_28int_29(0);
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 8 >> 2];
}
function graphicsFallbackSetPixel($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = global$0 - 16 | 0;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
}
function jswrap_date_getMonth($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 getCalendarDateFromDateVar($1 + 8 | 0, HEAP32[$1 + 28 >> 2]);
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 16 >> 2];
}
function jswrap_referenceerror_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = _jswrap_error_constructor(HEAP32[$1 + 12 >> 2], 119974);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function jswrap_date_getDate($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 getCalendarDateFromDateVar($1 + 8 | 0, HEAP32[$1 + 28 >> 2]);
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function gen_jswrap_ArrayBufferView_buffer($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsvLock(jsvGetFirstChild(HEAP32[$1 + 12 >> 2]) & 65535);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function jswrap_internalerror_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = _jswrap_error_constructor(HEAP32[$1 + 12 >> 2], 119960);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function jswrap_date_getDay($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 getCalendarDateFromDateVar($1 + 8 | 0, HEAP32[$1 + 28 >> 2]);
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 24 >> 2];
}
function jsvArrayBufferIteratorFree($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAPU16[HEAP32[$1 + 12 >> 2] + 36 >> 1]) {
  jsvStringIteratorFree(HEAP32[$1 + 12 >> 2]);
 }
 global$0 = $1 + 16 | 0;
}
function gen_jswrap_Graphics_getHeight($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_graphics_getWidthOrHeight(HEAP32[$1 + 12 >> 2], 1);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function jswrap_syntaxerror_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = _jswrap_error_constructor(HEAP32[$1 + 12 >> 2], 119938);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function jswrap_storagefile_readLine($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_storagefile_read_internal(HEAP32[$1 + 12 >> 2], -1);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function jsfPrintJSON($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jsfGetJSONWithCallback(HEAP32[$2 + 12 >> 2], 0, HEAP32[$2 + 8 >> 2], 0, 7, 0);
 global$0 = $2 + 16 | 0;
}
function gen_jswrap_Graphics_getWidth($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_graphics_getWidthOrHeight(HEAP32[$1 + 12 >> 2], 0);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function jswrap_pin_getMode($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_io_getPinMode(jshGetPinFromVar(HEAP32[$1 + 12 >> 2]) & 255);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function jspromise_resolve($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 _jswrap_promise_queueresolve(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
}
function jspSetInterrupted($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 label$1 : {
  if (HEAP8[$1 + 15 | 0] & 1) {
   HEAP32[80549] = HEAP32[80549] | 16;
   break label$1;
  }
  HEAP32[80549] = HEAP32[80549] & -17;
 }
}
function jsiShowInputLine() {
 var $0 = 0, $1 = 0;
 $1 = !(jsiEcho() & 1);
 $0 = 0;
 label$1 : {
  if ($1) {
   break label$1;
  }
  $0 = 0;
  if (HEAP8[322232] & 1) {
   break label$1;
  }
  $0 = jsiPasswordProtected() ^ -1;
 }
 return $0 & 1;
}
function jshTransmitClearDevice() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP8[$0 + 15 | 0] = 19;
 while (1) {
  if ((jshGetCharToTransmit(HEAPU8[$0 + 15 | 0]) | 0) >= 0) {
   continue;
  }
  break;
 }
 global$0 = $0 + 16 | 0;
}
function gen_jswrap_String_toUpperCase($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_string_toUpperLowerCase(HEAP32[$1 + 12 >> 2], 1);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function gen_jswrap_String_toLowerCase($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_string_toUpperLowerCase(HEAP32[$1 + 12 >> 2], 0);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function tflite___28anonymous_20namespace_29__AllocationInfoBuilder__Size_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 return HEAP32[$0 + 8 >> 2] + HEAP32[$0 + 12 >> 2] | 0;
}
function jswrap_typeerror_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = _jswrap_error_constructor(HEAP32[$1 + 12 >> 2], 119950);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function gen_jswrap_Object_keys($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_object_keys_or_property_names(HEAP32[$1 + 12 >> 2], 0);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function rand() {
 HEAP32[35417] = Math_imul(HEAP32[35417] & 65535, 36969) + (HEAP32[35417] >>> 16);
 HEAP32[35416] = Math_imul(HEAP32[35416] & 65535, 18e3) + (HEAP32[35416] >>> 16);
 return HEAP32[35416] + (HEAP32[35417] << 16) & 2147483647;
}
function jswrap_date_getMilliseconds($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 getTimeFromDateVar($1, HEAP32[$1 + 28 >> 2], 0);
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 4 >> 2];
}
function jsserialGetSerialList($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 15 | 0] = $0;
 $0 = jsvObjectGetChild(HEAP32[80546], 83551, (HEAP8[$1 + 15 | 0] & 1 ? 3 : 0) & 65535);
 global$0 = $1 + 16 | 0;
 return $0;
}
function jspromise_reject($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 _jswrap_promise_queuereject(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
}
function jswrap_banglejs_pwrBacklight() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP8[$0 + 15 | 0] = 1;
 jshPinOutput(8, HEAP8[$0 + 15 | 0] & 1);
 lcdMemLCD_extcominBacklight(HEAP8[$0 + 15 | 0] & 1);
 global$0 = $0 + 16 | 0;
}
function gen_jswrap_Graphics_getBgColor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_graphics_getColorX(HEAP32[$1 + 12 >> 2], 0);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function onewire_getpin($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jshGetPinFromVarAndUnLock(jsvObjectGetChild(HEAP32[$1 + 12 >> 2], 124318, 0));
 global$0 = $1 + 16 | 0;
 return $0 & 255;
}
function jswrap_error_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = _jswrap_error_constructor(HEAP32[$1 + 12 >> 2], 119932);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function jswrap_date_getMinutes($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 getTimeFromDateVar($1, HEAP32[$1 + 28 >> 2], 0);
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 12 >> 2];
}
function jshGetSystemTime() {
 var $0 = 0, $1 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP8[$0 + 15 | 0] = 0;
 $1 = jshGetTimeFromMilliseconds(+emscripten_asm_const_dii(109746, $0 + 15 | 0, 0));
 global$0 = $0 + 16 | 0;
 return $1;
}
function gen_jswrap_Graphics_getColor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_graphics_getColorX(HEAP32[$1 + 12 >> 2], 1);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function jswrap_object_getPrototypeOf($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jspGetNamedField(HEAP32[$1 + 12 >> 2], 123244, 0);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function jswrap_date_getSeconds($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 getTimeFromDateVar($1, HEAP32[$1 + 28 >> 2], 0);
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 8 >> 2];
}
function jswrap_date_getHours($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 32 | 0;
 global$0 = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 getTimeFromDateVar($1, HEAP32[$1 + 28 >> 2], 0);
 global$0 = $1 + 32 | 0;
 return HEAP32[$1 + 16 >> 2];
}
function gen_jswrap_Array_pop($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsvSkipNameAndUnLock(jsvArrayPop(HEAP32[$1 + 12 >> 2]));
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function tflite__RuntimeShape___RuntimeShape_28_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[HEAP32[$1 + 12 >> 2] >> 2] > 5) {
  abort();
  abort();
 }
 global$0 = $1 + 16 | 0;
}
function pipeGetArray($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 15 | 0] = $0;
 $0 = jsvObjectGetChild(HEAP32[80546], 124698, (HEAP8[$1 + 15 | 0] & 1 ? 3 : 0) & 65535);
 global$0 = $1 + 16 | 0;
 return $0;
}
function jswrap_interface_clearInterval($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 _jswrap_interface_clearTimeoutOrInterval(HEAP32[$1 + 12 >> 2], 0);
 global$0 = $1 + 16 | 0;
}
function jswrap_espruino_setClock($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[(global$0 - 16 | 0) + 12 >> 2] = HEAP32[$1 + 12 >> 2];
 global$0 = $1 + 16 | 0;
 return 0;
}
function jswrap_interface_clearTimeout($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 _jswrap_interface_clearTimeoutOrInterval(HEAP32[$1 + 12 >> 2], 1);
 global$0 = $1 + 16 | 0;
}
function gen_jswrap_Math_acos($0) {
 $0 = +$0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAPF64[$1 + 8 >> 3] = $0;
 $0 = 1.5707963267948966 - jswrap_math_asin(HEAPF64[$1 + 8 >> 3]);
 global$0 = $1 + 16 | 0;
 return +$0;
}
function jswrap_espruino_asm($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jsExceptionHere(1, 120891, 0);
 global$0 = $2 + 16 | 0;
}
function gen_jswrap_Serial_find($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 15 | 0] = $0;
 $0 = jshGetDeviceObjectFor(768, 848, HEAPU8[$1 + 15 | 0]);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function jshGetWatchedPinState($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 15 | 0] = $0;
 $0 = jshPinGetValue(HEAPU8[(HEAPU8[$1 + 15 | 0] - 1 | 0) + 336592 | 0]);
 global$0 = $1 + 16 | 0;
 return $0 & 1;
}
function gen_jswrap_Math_cos($0) {
 $0 = +$0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAPF64[$1 + 8 >> 3] = $0;
 $0 = jswrap_math_sin(HEAPF64[$1 + 8 >> 3] + 1.5707963267948966);
 global$0 = $1 + 16 | 0;
 return +$0;
}
function jsvUnLock2($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jsvUnLock(HEAP32[$2 + 12 >> 2]);
 jsvUnLock(HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
}
function jsiConsolePrintf($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 vcbprintf(7, 0, HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 global$0 = $2 + 16 | 0;
}
function fmt_o($0, $1, $2) {
 if ($0 | $1) {
  while (1) {
   $2 = $2 + -1 | 0;
   HEAP8[$2 | 0] = $0 & 7 | 48;
   $0 = ($1 & 7) << 29 | $0 >>> 3;
   $1 = $1 >>> 3;
   if ($0 | $1) {
    continue;
   }
   break;
  }
 }
 return $2;
}
function tflite__internal__ContextHelper__SetNodeIndex_28int_29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[HEAP32[$2 + 12 >> 2] + 16 >> 2] = HEAP32[$2 + 8 >> 2];
}
function jsvArrayBufferIteratorGetIndex($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsvNewFromInteger(HEAP32[HEAP32[$1 + 12 >> 2] + 48 >> 2]);
 global$0 = $1 + 16 | 0;
 return $0;
}
function jsvAppendCharacter($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 jsvAppendStringBuf(HEAP32[$2 + 12 >> 2], $2 + 11 | 0, 1);
 global$0 = $2 + 16 | 0;
}
function jspKill() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 jspSoftKill();
 HEAP32[$0 + 12 >> 2] = jsvFindOrCreateRoot();
 jsvUnRef(HEAP32[$0 + 12 >> 2]);
 jsvUnLock(HEAP32[$0 + 12 >> 2]);
 global$0 = $0 + 16 | 0;
}
function gen_jswrap_crypto_SHA512($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_crypto_SHAx(HEAP32[$1 + 12 >> 2], 512);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function gen_jswrap_crypto_SHA384($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_crypto_SHAx(HEAP32[$1 + 12 >> 2], 384);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function gen_jswrap_crypto_SHA256($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_crypto_SHAx(HEAP32[$1 + 12 >> 2], 256);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function gen_jswrap_crypto_SHA224($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_crypto_SHAx(HEAP32[$1 + 12 >> 2], 224);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function gen_jswrap_SPI_find($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 15 | 0] = $0;
 $0 = jshGetDeviceObjectFor(512, 544, HEAPU8[$1 + 15 | 0]);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function gen_jswrap_I2C_find($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 15 | 0] = $0;
 $0 = jshGetDeviceObjectFor(640, 688, HEAPU8[$1 + 15 | 0]);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function dly($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2]) {
  do_indexing(HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2]);
 }
 global$0 = $1 + 16 | 0;
}
function _jswrap_arraybufferview_sort_int($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 return HEAP32[$2 + 12 >> 2] - HEAP32[$2 + 8 >> 2] | 0;
}
function legalstub$dynCall_jiji($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $0 = FUNCTION_TABLE[$0]($1, $2, $3, $4) | 0;
 setTempRet0(i64toi32_i32$HIGH_BITS | 0);
 return $0 | 0;
}
function gen_jswrap_Math_min($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $2 = jswrap_math_minmax(HEAP32[$1 + 12 >> 2], 0);
 global$0 = $1 + 16 | 0;
 return +$2;
}
function gen_jswrap_Math_max($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $2 = jswrap_math_minmax(HEAP32[$1 + 12 >> 2], 1);
 global$0 = $1 + 16 | 0;
 return +$2;
}
function float_20tflite__TfLiteRound_float__28float_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAPF32[$1 + 12 >> 2] = $0;
 $0 = round_28float_29(HEAPF32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return $0;
}
function tflite__SimpleMemoryAllocator__ResetTempAllocations_28_29($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 16 >> 2];
}
function jsiInit() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP8[$0 + 15 | 0] = 1;
 HEAP16[161112] = 6144;
 HEAP8[141672] = 19;
 jsiSemiInit(HEAP8[$0 + 15 | 0] & 1);
 jsiSetBusy(1, 0);
 global$0 = $0 + 16 | 0;
}
function jsfNameFromVarAndUnLock($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 global$0 = $2;
 HEAP32[$2 + 12 >> 2] = $1;
 jsfNameFromVar($0, HEAP32[$2 + 12 >> 2]);
 jsvUnLock(HEAP32[$2 + 12 >> 2]);
 global$0 = $2 + 16 | 0;
}
function healthStateClear($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
}
function jswrap_pipe_src_close_listener($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jswrap_pipe_close_listener(HEAP32[$1 + 12 >> 2], 124503);
 global$0 = $1 + 16 | 0;
}
function jswrap_pipe_dst_close_listener($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jswrap_pipe_close_listener(HEAP32[$1 + 12 >> 2], 124510);
 global$0 = $1 + 16 | 0;
}
function jswrap_math_abs($0) {
 $0 = +$0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAPF64[$1 + 8 >> 3] = $0;
 if (HEAPF64[$1 + 8 >> 3] < 0) {
  $0 = -HEAPF64[$1 + 8 >> 3];
 } else {
  $0 = HEAPF64[$1 + 8 >> 3];
 }
 return +$0;
}
function gen_jswrap_crypto_SHA1($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_crypto_SHAx(HEAP32[$1 + 12 >> 2], 1);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function jsvArrayIsEmpty($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsvGetFirstChild(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return (($0 & 65535) != 0 ^ -1) & 1;
}
function jswrap_banglejs_setLCDPowerController($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 15 | 0] = $0;
 jshPinOutput(6, 0);
 jshPinOutput(7, HEAP8[$1 + 15 | 0] & 1);
 global$0 = $1 + 16 | 0;
}
function jsvSkipName($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsvSkipNameWithParent(HEAP32[$1 + 12 >> 2], 1, 0);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function dynCall_viiiiiii($0, $1, $2, $3, $4, $5, $6, $7) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 $7 = $7 | 0;
 FUNCTION_TABLE[$0]($1, $2, $3, $4, $5, $6, $7);
}
function mbedtls_sha512_free($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  mbedtls_zeroize(HEAP32[$1 + 12 >> 2], 216);
 }
 global$0 = $1 + 16 | 0;
}
function mbedtls_sha256_free($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  mbedtls_zeroize(HEAP32[$1 + 12 >> 2], 108);
 }
 global$0 = $1 + 16 | 0;
}
function double_20tflite__TfLiteRound_double__28double_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAPF64[$1 + 8 >> 3] = $0;
 $0 = +round(+HEAPF64[$1 + 8 >> 3]);
 global$0 = $1 + 16 | 0;
 return $0;
}
function jswrap_boolean_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsvGetBool(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return $0 & 1;
}
function jswrap_banglejs_setOptions($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 _jswrap_banglejs_setOptions(HEAP32[$1 + 12 >> 2], 0);
 global$0 = $1 + 16 | 0;
}
function _jswrap_arraybufferview_sort_float($0, $1) {
 $0 = +$0;
 $1 = +$1;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAPF64[$2 + 8 >> 3] = $0;
 HEAPF64[$2 >> 3] = $1;
 return +(HEAPF64[$2 + 8 >> 3] - HEAPF64[$2 >> 3]);
}
function mbedtls_sha1_free($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  mbedtls_zeroize(HEAP32[$1 + 12 >> 2], 92);
 }
 global$0 = $1 + 16 | 0;
}
function jsiConsolePrintStringVar($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsiConsolePrintStringVarWithNewLineChar(HEAP32[$1 + 12 >> 2], 0, 0);
 global$0 = $1 + 16 | 0;
}
function gen_jswrap_Array_isArray($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsvIsArray(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return $0 & 1;
}
function round_28float_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAPF32[$1 + 12 >> 2] = $0;
 $0 = Math_fround(roundf(Math_fround(HEAPF32[$1 + 12 >> 2])));
 global$0 = $1 + 16 | 0;
 return $0;
}
function jshGetMillisecondsFromTime($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 12 >> 2] = $1;
 return (+HEAPU32[$2 + 8 >> 2] + 4294967296 * +HEAP32[$2 + 12 >> 2]) / 1e3;
}
function int_20gemmlowp__ShiftRight_int__28int_2c_20int_29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 return HEAP32[$2 + 12 >> 2] >> HEAP32[$2 + 8 >> 2];
}
function jswrap_storage_hash($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsfHashFiles(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return $0 | 0;
}
function jsvGetFloatAndUnLock($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $2 = _jsvGetFloatAndUnLock(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return $2;
}
function i2c_pin_wr0($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 15 | 0] = $0;
 jshPinSetValue(HEAPU8[$1 + 15 | 0], 0);
 jshPinSetState(HEAPU8[$1 + 15 | 0], 1);
 global$0 = $1 + 16 | 0;
}
function jswrap_date_now() {
 return +((+(jshGetSystemTime() >>> 0) + 4294967296 * +(i64toi32_i32$HIGH_BITS | 0)) / (+(jshGetTimeFromMilliseconds(1e3) >>> 0) + 4294967296 * +(i64toi32_i32$HIGH_BITS | 0)) * 1e3);
}
function jshI2CWrite($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = global$0 - 16 | 0;
 HEAP8[$5 + 15 | 0] = $0;
 HEAP8[$5 + 14 | 0] = $1;
 HEAP32[$5 + 8 >> 2] = $2;
 HEAP32[$5 + 4 >> 2] = $3;
 HEAP8[$5 + 3 | 0] = $4;
}
function stringToFloat($0) {
 var $1 = 0, $2 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $2 = stringToFloatWithRadix(HEAP32[$1 + 12 >> 2], 0);
 global$0 = $1 + 16 | 0;
 return $2;
}
function jslNextCh() {
 var $0 = 0;
 if (HEAP32[HEAP32[35539] + 104 >> 2]) {
  $0 = HEAPU8[HEAP32[HEAP32[35539] + 104 >> 2] + HEAP32[HEAP32[35539] + 88 >> 2] | 0];
 } else {
  $0 = 0;
 }
 return $0 << 24 >> 24;
}
function jshGetPinShouldStayWatched($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 return (HEAP32[(HEAPU8[$1 + 15 | 0] >> 5 << 2) + 322208 >> 2] >>> (HEAPU8[$1 + 15 | 0] & 31) & 1) != 0;
}
function int_20gemmlowp__Add_int__28int_2c_20int_29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 return HEAP32[$2 + 12 >> 2] + HEAP32[$2 + 8 >> 2] | 0;
}
function gen_jswrap_ArrayBufferView_byteOffset($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 return HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8;
}
function jsvGetIntegerAndUnLock($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = _jsvGetIntegerAndUnLock(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return $0;
}
function int_20gemmlowp__BitAnd_int__28int_2c_20int_29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 return HEAP32[$2 + 12 >> 2] & HEAP32[$2 + 8 >> 2];
}
function get_input_offset($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = get_input_buffer_size(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return $0 & 65535;
}
function gen_jswrap_getTime() {
 return +((+(jshGetSystemTime() >>> 0) + 4294967296 * +(i64toi32_i32$HIGH_BITS | 0)) / (+(jshGetTimeFromMilliseconds(1e3) >>> 0) + 4294967296 * +(i64toi32_i32$HIGH_BITS | 0)));
}
function dynCall_iiiiiii($0, $1, $2, $3, $4, $5, $6) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 return FUNCTION_TABLE[$0]($1, $2, $3, $4, $5, $6) | 0;
}
function __DOUBLE_BITS($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAPF64[$1 + 8 >> 3] = $0;
 HEAPF64[$1 >> 3] = HEAPF64[$1 + 8 >> 3];
 i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
 return HEAP32[$1 >> 2];
}
function jsvGetBoolAndUnLock($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = _jsvGetBoolAndUnLock(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return $0 & 1;
}
function jshSetEventDataPin($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
 HEAP32[(HEAPU8[$2 + 15 | 0] << 2) + 322316 >> 2] = HEAPU8[$2 + 14 | 0] | -256;
}
function jshGetPinStateIsManual($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 return (HEAP32[(HEAPU8[$1 + 15 | 0] >> 5 << 2) + 322200 >> 2] >>> (HEAPU8[$1 + 15 | 0] & 31) & 1) != 0;
}
function jsfResetStorage() {
 jsiConsolePrintf(78265, 0);
 jsfEraseAll();
 jsiConsolePrintf(78290, 0);
 jsiConsolePrintf(78307, 0);
 jshFlashWrite(1040, 134217728, HEAP32[256]);
 jsiConsolePrintf(78344, 0);
}
function jsvSkipOneName($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsvSkipNameWithParent(HEAP32[$1 + 12 >> 2], 0, 0);
 global$0 = $1 + 16 | 0;
 return $0;
}
function dynCall_iidiiii($0, $1, $2, $3, $4, $5, $6) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = +$2;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 return FUNCTION_TABLE[$0]($1, $2, $3, $4, $5, $6) | 0;
}
function stringToInt($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = stringToIntWithRadix(HEAP32[$1 + 12 >> 2], 0, 0, 0);
 global$0 = $1 + 16 | 0;
 return $0;
}
function jspSetError() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 HEAP8[$0 + 15 | 0] = 0;
 HEAP32[80549] = HEAP32[80549] & -2 | 64;
 if (HEAP8[$0 + 15 | 0] & 1) {
  HEAP32[80549] = HEAP32[80549] | 128;
 }
}
function jshSetEventCallback($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[(HEAPU8[$2 + 15 | 0] << 2) + 322316 >> 2] = HEAP32[$2 + 8 >> 2];
}
function _jswrap_graphics_freeImageInfo($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 8 >> 2] + 20 >> 2]);
 global$0 = $1 + 16 | 0;
}
function tflite__SimpleMemoryAllocator__GetBufferHead_28_29_20const($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2];
}
function jsvGetArrayBufferLength($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 return HEAPU8[$0 + 2 | 0] | HEAPU8[$0 + 3 | 0] << 8;
}
function __wasm_call_ctors() {}
function stepcount_init() {
 AccelFilter_init();
 HEAP16[71070] = 0;
 HEAP16[71071] = 0;
 HEAP16[71072] = 0;
 HEAP32[35537] = 0;
 HEAP8[142152] = 0;
 HEAP8[142153] = 0;
}
function jsvInit() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP16[71084] = jsvInitJsVars(HEAP32[35415]);
 jsvCreateEmptyVarList();
 global$0 = $0 + 16 | 0;
}
function jshIsPinValid($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 return HEAPU8[$1 + 15 | 0] < 48 ? (HEAPU8[Math_imul(HEAPU8[$1 + 15 | 0], 3) + 109872 | 0] & 15) != 0 : 0;
}
function jsvHasRef($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsvIsStringExt(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return ($0 ^ -1) & 1;
}
function err($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 >> 2] = HEAP32[$1 + 12 >> 2];
 jsExceptionHere(1, 83315, $1);
 global$0 = $1 + 16 | 0;
}
function dynCall_viiiiii($0, $1, $2, $3, $4, $5, $6) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 FUNCTION_TABLE[$0]($1, $2, $3, $4, $5, $6);
}
function jswrap_math_atan($0) {
 $0 = +$0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAPF64[$1 + 8 >> 3] = $0;
 $0 = atan(HEAPF64[$1 + 8 >> 3]);
 global$0 = $1 + 16 | 0;
 return +$0;
}
function jslSetLex($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = HEAP32[35539];
 HEAP32[35539] = HEAP32[$1 + 12 >> 2];
 return HEAP32[$1 + 8 >> 2];
}
function can_take_byte($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAPU32[HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
}
function _jsvGetAddressOf($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP16[$1 + 14 >> 1] = $0;
 $0 = jsvGetAddressOf(HEAPU16[$1 + 14 >> 1]);
 global$0 = $1 + 16 | 0;
 return $0;
}
function jsvStringIteratorNext($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvStringIteratorNextInline(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
}
function jsvStringIteratorFree($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
 global$0 = $1 + 16 | 0;
}
function jswrap_math_sin($0) {
 $0 = +$0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAPF64[$1 + 8 >> 3] = $0;
 $0 = sin(HEAPF64[$1 + 8 >> 3]);
 global$0 = $1 + 16 | 0;
 return +$0;
}
function jswrap_banglejs_setLCDMode($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsExceptionHere(1, 110039, 0);
 global$0 = $1 + 16 | 0;
}
function jshIsPinStateDefault($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
 return HEAPU8[$2 + 14 | 0] != 4 ? HEAPU8[$2 + 14 | 0] == 7 : 1;
}
function jswrap_espruino_compiledC($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsExceptionHere(1, 120967, 0);
 global$0 = $1 + 16 | 0;
}
function jsvStringIteratorGetIndex($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] + HEAP32[HEAP32[$1 + 12 >> 2] >> 2] | 0;
}
function jshPinAnalogOutput($0, $1, $2, $3) {
 var $4 = 0;
 $4 = global$0 - 32 | 0;
 HEAP8[$4 + 31 | 0] = $0;
 HEAPF64[$4 + 16 >> 3] = $1;
 HEAPF64[$4 + 8 >> 3] = $2;
 HEAP32[$4 + 4 >> 2] = $3;
}
function jsvStringIteratorHasChar($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
}
function jsvObjectIteratorFree($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 global$0 = $1 + 16 | 0;
}
function jsiConsolePrintChar($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP8[$1 + 15 | 0] = $0;
 jshTransmit(HEAPU8[141672], HEAPU8[$1 + 15 | 0]);
 global$0 = $1 + 16 | 0;
}
function jsvGetLocks($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 return (HEAPU8[$0 + 13 | 0] | HEAPU8[$0 + 14 | 0] << 8) >> 9 & 15;
}
function jspeBlock() {
 if (jslMatch(123) & 1) {
  jspeBlockNoBrackets();
  if (!(HEAP32[80549] & 80)) {
   label$3 : {
    if (jslMatch(125) & 1) {
     break label$3;
    }
   }
  }
 }
}
function abort_message() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 12 >> 2] = 0;
 $0 = HEAP32[34654];
 __vfprintf_internal($0);
 fputc($0);
 abort();
 abort();
}
function st_save_backlog($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 save_backlog(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return 0;
}
function dynCall_iiiiii($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 return FUNCTION_TABLE[$0]($1, $2, $3, $4, $5) | 0;
}
function tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}
function tflite__NumOutputs_28TfLiteNode_20const__29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] >> 2];
}
function exp_28float_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAPF32[$1 + 12 >> 2] = $0;
 $0 = expf(HEAPF32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
 return $0;
}
function ruy__profiler__ScopeLabel__ScopeLabel_char_20const___28char_20const__29($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
}
function jshBusyIdle() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP8[$0 + 15 | 0] = 0;
 emscripten_asm_const_iii(109674, $0 + 15 | 0, 0) | 0;
 global$0 = $0 + 16 | 0;
}
function jslCharPosFree($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvStringIteratorFree(HEAP32[$1 + 12 >> 2]);
 global$0 = $1 + 16 | 0;
}
function dynCall_diiiii($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 return +FUNCTION_TABLE[$0]($1, $2, $3, $4, $5);
}
function tflite__SimpleMemoryAllocator__GetTail_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] + 20 >> 2];
}
function jshFlashGetFree() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[$0 + 12 >> 2] = jsvNewWithFlags(3);
 global$0 = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}
function mbedtls_sha512_init($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 memset(HEAP32[$1 + 12 >> 2], 0, 216);
 global$0 = $1 + 16 | 0;
}
function mbedtls_sha256_init($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 memset(HEAP32[$1 + 12 >> 2], 0, 108);
 global$0 = $1 + 16 | 0;
}
function jsvGetPrevSibling($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 return HEAPU8[$0 + 6 | 0] | HEAPU8[$0 + 7 | 0] << 8;
}
function jsvGetNextSibling($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 return HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8;
}
function jsvGetLastChild($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 return HEAPU8[$0 + 11 | 0] | HEAPU8[$0 + 12 | 0] << 8;
}
function tflite__NumInputs_28TfLiteNode_20const__29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[HEAP32[$1 + 12 >> 2] >> 2] >> 2];
}
function jsvGetFirstChild($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 return HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8;
}
function jsfCompact() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP8[$0 + 15 | 0] = jsfBankCompact() & 1;
 global$0 = $0 + 16 | 0;
 return HEAP8[$0 + 15 | 0] & 1;
}
function mbedtls_sha1_init($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 global$0 = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 memset(HEAP32[$1 + 12 >> 2], 0, 92);
 global$0 = $1 + 16 | 0;
}
function jswrap_banglejs_setHRMPower($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 return 0;
}
function tflite__RuntimeShape__DimensionsCount_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2];
}
function jslIsIDOrReservedWord() {
 return (HEAP16[HEAP32[35539] + 2 >> 1] != 128 ? HEAP16[HEAP32[35539] + 2 >> 1] >= 163 ? HEAP16[HEAP32[35539] + 2 >> 1] <= 198 : 0 : 1) & 1;
}
function jswrap_banglejs_accelRd($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 return 0;
}
function dynCall_viiiii($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 FUNCTION_TABLE[$0]($1, $2, $3, $4, $5);
}
function jspCheckStackPosition() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP8[$0 + 15 | 0] = 1;
 global$0 = $0 + 16 | 0;
 return HEAP8[$0 + 15 | 0] & 1;
}
function jspSoftKill() {
 jsvUnLock(HEAP32[80547]);
 HEAP32[80547] = 0;
 jsvUnLock(HEAP32[80546]);
 HEAP32[80546] = 0;
 jsvUnLock(HEAP32[80545]);
 HEAP32[80545] = 0;
}
function float_20flatbuffers__EndianScalar_float__28float_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAPF32[$1 + 12 >> 2] = $0;
 return HEAPF32[$1 + 12 >> 2];
}
function flatbuffers__Vector_int___Data_28_29_20const($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2] + 4 | 0;
}
function jswrap_banglejs_setStepCount($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[84168] = HEAP32[$1 + 12 >> 2];
}
function jswrap_banglejs_setPollInterval_internal($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP16[$1 + 14 >> 1] = $0;
 HEAP16[168306] = HEAPU16[$1 + 14 >> 1];
}
function dynCall_iiiii($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 return FUNCTION_TABLE[$0]($1, $2, $3, $4) | 0;
}
function utilTimerIsFull() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 HEAP8[$0 + 15 | 0] = HEAPU8[324177] + 1 & 15;
 return HEAPU8[$0 + 15 | 0] == HEAPU8[324178];
}
function jsInit() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 global$0 = $0;
 HEAP32[84146] = $0 + 12;
 jshInit();
 jsvInit();
 jsiInit();
 global$0 = $0 + 16 | 0;
}
function dynCall_diiii($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 return +FUNCTION_TABLE[$0]($1, $2, $3, $4);
}
function jsGfxChanged() {
 var $0 = 0;
 $0 = global$0 - 16 | 0;
 HEAP8[$0 + 15 | 0] = HEAP8[324605] & 1;
 HEAP8[324605] = 0;
 return HEAP8[$0 + 15 | 0] & 1;
}
function jsvGetAddressOf($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP16[$1 + 14 >> 1] = $0;
 return Math_imul(HEAPU16[$1 + 14 >> 1], 15) + 142157 | 0;
}
function jshPinAnalog($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 HEAPF64[$1 >> 3] = 0;
 return +HEAPF64[$1 >> 3];
}
function jsvObjectIteratorHasValue($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
}
function TfLiteIntArrayGetSizeInBytes($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return (HEAP32[$1 + 12 >> 2] << 2) + 4 | 0;
}
function isNumeric($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 return HEAP8[$1 + 15 | 0] >= 48 ? HEAP8[$1 + 15 | 0] <= 57 : 0;
}
function dynCall_idddi($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = +$1;
 $2 = +$2;
 $3 = +$3;
 $4 = $4 | 0;
 return FUNCTION_TABLE[$0]($1, $2, $3, $4) | 0;
}
function int_20gemmlowp__BitNot_int__28int_29($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2] ^ -1;
}
function jsfCachePut($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
}
function dynCall_viiii($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 FUNCTION_TABLE[$0]($1, $2, $3, $4);
}
function jshSPISend($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP8[$2 + 11 | 0] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 return HEAP32[$2 + 12 >> 2];
}
function jsfGetFileSize($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] & 16777215;
}
function jshPinPulse($0, $1, $2) {
 var $3 = 0;
 $3 = global$0 - 16 | 0;
 HEAP8[$3 + 15 | 0] = $0;
 HEAP8[$3 + 14 | 0] = $1;
 HEAPF64[$3 >> 3] = $2;
}
function dynCall_viidi($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = +$3;
 $4 = $4 | 0;
 FUNCTION_TABLE[$0]($1, $2, $3, $4);
}
function dlmemalign($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 if ($0 >>> 0 <= 8) {
  return dlmalloc($1) | 0;
 }
 return internal_memalign($0, $1) | 0;
}
function jsfGetFileFlags($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] >>> 24;
}
function jspSoftInit() {
 HEAP32[80545] = jsvFindOrCreateRoot();
 HEAP32[80546] = jsvObjectGetChild(HEAP32[80545], 80880, 5);
 HEAP32[80549] = 1;
}
function tflite__BuiltinDataAllocator___BuiltinDataAllocator_28_29_1($0) {
 $0 = $0 | 0;
 HEAP32[(global$0 - 16 | 0) + 12 >> 2] = $0;
 abort();
}
function is_finishing($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP8[HEAP32[$1 + 12 >> 2] + 11 | 0] & 1;
}
function jsfGetFlag($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 return (HEAPU8[142160] & HEAPU8[$1 + 15 | 0]) != 0;
}
function __wasm_i64_udiv($0, $1, $2, $3) {
 $0 = _ZN17compiler_builtins3int4udiv10divmod_u6417h6026910b5ed08e40E($0, $1, $2, $3);
 return $0;
}
function dynCall_iiii($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 return FUNCTION_TABLE[$0]($1, $2, $3) | 0;
}
function jsvGetRefs($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAPU8[HEAP32[$1 + 12 >> 2] + 10 | 0];
}
function jsiInputLineCursorMoved() {
 if (HEAP32[80566]) {
  jsvStringIteratorFree(322252);
  HEAP32[80566] = 0;
 }
 HEAP32[35419] = -1;
}
function dynCall_iidi($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = +$2;
 $3 = $3 | 0;
 return FUNCTION_TABLE[$0]($1, $2, $3) | 0;
}
function dynCall_diii($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 return +FUNCTION_TABLE[$0]($1, $2, $3);
}
function jsfAlignAddress($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2] + 3 & -4;
}
function __wasm_i64_mul($0, $1, $2, $3) {
 $0 = _ZN17compiler_builtins3int3mul3Mul3mul17h070e9a1c69faec5bE($0, $1, $2, $3);
 return $0;
}
function __wasm_rotl_i32($0) {
 var $1 = 0;
 $1 = $0 & 31;
 $0 = 0 - $0 & 31;
 return (-1 >>> $1 & -2) << $1 | (-1 << $0 & -2) >>> $0;
}
function jswrap_banglejs_beep_callback() {
 HEAP16[168371] = 0;
 if (HEAP32[84152] & 64) {
  _jswrap_banglejs_setVibration();
 }
}
function jshSetSystemTime($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 12 >> 2] = $1;
}
function dynCall_viii($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 FUNCTION_TABLE[$0]($1, $2, $3);
}
function dynCall_dddd($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = +$1;
 $2 = +$2;
 $3 = +$3;
 return +FUNCTION_TABLE[$0]($1, $2, $3);
}
function jsvIsUndefined($0) {
 var $1 = 0;
 $1 = global$0 - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return !HEAP32[$1 + 12 >> 2];
}
function setThrew($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 if (!HEAP32[84383]) {
  HEAP32[84384] = $1;
  HEAP32[84383] = $0;
 }
}
function jspeConditionalExpression() {
 return __jspeConditionalExpression(__jspeBinaryExpression(jspeUnaryExpression(), 0));
}
function dynCall_viid($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = +$3;
 FUNCTION_TABLE[$0]($1, $2, $3);
}
function dynCall_vidi($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = +$2;
 $3 = $3 | 0;
 FUNCTION_TABLE[$0]($1, $2, $3);
}
function jshUSARTSetup($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
}
function jshPinSetState($0, $1) {
 var $2 = 0;
 $2 = global$0 - 16 | 0;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
}
function jspDebuggerLoopIfCtrlC() {
 if (!(!(HEAP32[80549] & 4096) | (HEAP32[80549] & 63) != 1)) {
  jsiDebuggerLoop();
 }
}
function __wasm_i64_sdiv($0, $1, $2) {
 return _ZN17compiler_builtins3int4sdiv3Div3div17he78fc483e41d7ec7E($0, $1, $2);
}
function terminalControlCharsReset() {
 HEAP8[336940] = 0;
 HEAP8[336941] = 0;
 HEAP8[336942] = 0;
 HEAP8[336943] = 0;
}
function dynCall_iii($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 return FUNCTION_TABLE[$0]($1, $2) | 0;
}
function dynCall_iid($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = +$2;
 return FUNCTION_TABLE[$0]($1, $2) | 0;
}
function dynCall_dii($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 return +FUNCTION_TABLE[$0]($1, $2);
}
function legalfunc$wasm2js_scratch_store_i64($0, $1) {
 legalimport$wasm2js_scratch_store_i64($0 | 0, $1 | 0);
}
function dynCall_did($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = +$2;
 return +FUNCTION_TABLE[$0]($1, $2);
}
function jsiGetHistory() {
 return jsvObjectGetChild(HEAP32[80546], HEAPU16[161112] & 8 ? 81555 : 81563, 3);
}
function dynCall_ddd($0, $1, $2) {
 $0 = $0 | 0;
 $1 = +$1;
 $2 = +$2;
 return +FUNCTION_TABLE[$0]($1, $2);
}
function dynCall_vii($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 FUNCTION_TABLE[$0]($1, $2);
}
function jsdGetTimeZone() {
 return jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[80546], 119742, 0));
}
function dynCall_vid($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = +$2;
 FUNCTION_TABLE[$0]($1, $2);
}
function dynCall_vdi($0, $1, $2) {
 $0 = $0 | 0;
 $1 = +$1;
 $2 = $2 | 0;
 FUNCTION_TABLE[$0]($1, $2);
}
function jswrap_banglejs_factoryReset() {
 jsfResetStorage();
 HEAP16[161112] = HEAPU16[161112] | 64;
}
function jslSingleChar() {
 HEAP16[HEAP32[35539] + 2 >> 1] = HEAPU8[HEAP32[35539]];
 jslGetNextCh();
}
function jshIdle() {
 if (HEAP8[141684] & 1) {
  jsiOneSecondAfterStartup();
 }
 HEAP8[141684] = 0;
}
function jsfGetBankEndAddress($0) {
 HEAP32[(global$0 - 16 | 0) + 12 >> 2] = $0;
 return 142606336;
}
function __wasm_ctz_i32($0) {
 if ($0) {
  return 31 - Math_clz32($0 + -1 ^ $0) | 0;
 }
 return 32;
}
function stackAlloc($0) {
 $0 = $0 | 0;
 $0 = global$0 - $0 & -16;
 global$0 = $0;
 return $0 | 0;
}
function jswrap_graphics_getInstance() {
 return jsvObjectGetChild(HEAP32[80546], 127104, 0) | 0;
}
function __bswap_32($0) {
 return $0 << 8 & 16711680 | $0 << 24 | ($0 >>> 8 & 65280 | $0 >>> 24);
}
function jswrap_banglejs_buzz_callback() {
 HEAP8[336740] = 0;
 _jswrap_banglejs_setVibration();
}
function jswrap_modules_getModuleList() {
 return jsvObjectGetChild(HEAP32[80546], 123156, 5);
}
function get_input_buffer_size($0) {
 HEAP32[(global$0 - 16 | 0) + 12 >> 2] = $0;
 return 256;
}
function dynCall_ii($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 return FUNCTION_TABLE[$0]($1) | 0;
}
function __wasi_syscall_ret($0) {
 if (!$0) {
  return 0;
 }
 HEAP32[84242] = $0;
 return -1;
}
function __stdio_close($0) {
 $0 = $0 | 0;
 return __wasi_fd_close(HEAP32[$0 + 60 >> 2]) | 0;
}
function jshIsDeviceInitialised($0) {
 HEAP8[(global$0 - 16 | 0) + 15 | 0] = $0;
 return 1;
}
function _parse_int() {
 return stringToIntWithRadix(jslGetTokenValueAsString(), 10, 0, 0);
}
function gen_jswrap_Bangle_showLauncher() {
 jsvUnLock(jspExecuteJSFunction(98558, 0, 0));
}
function dynCall_id($0, $1) {
 $0 = $0 | 0;
 $1 = +$1;
 return FUNCTION_TABLE[$0]($1) | 0;
}
function dynCall_di($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 return +FUNCTION_TABLE[$0]($1);
}
function gen_jswrap_Bangle_loadWidgets() {
 jsvUnLock(jspExecuteJSFunction(96243, 0, 0));
}
function gen_jswrap_Bangle_drawWidgets() {
 jsvUnLock(jspExecuteJSFunction(95828, 0, 0));
}
function dynCall_dd($0, $1) {
 $0 = $0 | 0;
 $1 = +$1;
 return +FUNCTION_TABLE[$0]($1);
}
function jswrap_banglejs_getOptions() {
 return _jswrap_banglejs_setOptions(0, 1) | 0;
}
function out($0, $1, $2) {
 if (!(HEAPU8[$0 | 0] & 32)) {
  __fwritex($1, $2, $0);
 }
}
function do_indexing($0) {
 $0 = $0 | 0;
 HEAP32[(global$0 - 16 | 0) + 12 >> 2] = $0;
}
function jshPinGetState($0) {
 HEAP8[(global$0 - 16 | 0) + 15 | 0] = $0;
 return 0;
}
function dynCall_vi($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 FUNCTION_TABLE[$0]($1);
}
function jswrap_banglejs_isLocked() {
 return (HEAP32[84152] & 131072) != 0 | 0;
}
function jswrap_espruino_reboot() {
 jsiKill();
 jsExceptionHere(1, 109848, 0);
}
function dynCall_vd($0, $1) {
 $0 = $0 | 0;
 $1 = +$1;
 FUNCTION_TABLE[$0]($1);
}
function jswrap_banglejs_isLCDOn() {
 return (HEAP32[84152] & 32768) != 0 | 0;
}
function jswrap_banglejs_isCharging() {
 return (jshPinGetValue(23) ^ -1) & 1;
}
function wctomb($0, $1) {
 if (!$0) {
  return 0;
 }
 return wcrtomb($0, $1);
}
function gen_jswrap_process_version() {
 return jsvNewFromString(104256) | 0;
}
function gen_jswrap_NRF_getSecurityStatus() {
 return jsvNewWithFlags(5) | 0;
}
function jspeiClearScopes() {
 jsvUnLock(HEAP32[80547]);
 HEAP32[80547] = 0;
}
function gen_jswrap_NRF_getAddress() {
 return jsvNewFromString(104238) | 0;
}
function jswrap_serial_constructor() {
 return jspNewObject(0, 125406) | 0;
}
function jsIdle() {
 HEAP32[35420] = -1;
 jsiLoop();
 return HEAP32[35420];
}
function gen_jswrap_LED2() {
 return jspExecuteJSFunction(95499, 0, 0) | 0;
}
function gen_jswrap_LED1() {
 return jspExecuteJSFunction(95216, 0, 0) | 0;
}
function gen_jswrap_Math_random() {
 return +(+(rand() | 0) / 2147483647);
}
function jswrap_banglejs_isBarometerOn() {
 return HEAP32[84152] & 16384;
}
function jshUSARTUnSetup($0) {
 HEAP8[(global$0 - 16 | 0) + 15 | 0] = $0;
}
function gen_jswrap_Number_MIN_VALUE() {
 return 2.2250738585072014e-308;
}
function gen_jswrap_Number_MAX_VALUE() {
 return 1.7976931348623157e+308;
}
function gen_jswrap_LoopbackB() {
 return jspNewObject(95792, 94015) | 0;
}
function gen_jswrap_LoopbackA() {
 return jspNewObject(95782, 94015) | 0;
}
function jswrap_spi_constructor() {
 return jspNewObject(0, 125675) | 0;
}
function jswrap_i2c_constructor() {
 return jspNewObject(0, 125818) | 0;
}
function jsiPasswordProtected() {
 return (HEAPU16[161112] & 1024) != 0;
}
function gen_jswrap_Terminal() {
 return jspNewObject(95815, 94015) | 0;
}
function dynCall_i($0) {
 $0 = $0 | 0;
 return FUNCTION_TABLE[$0]() | 0;
}
function htons($0) {
 $0 = $0 | 0;
 return ($0 << 24 | $0 << 8) >>> 16;
}
function gen_jswrap_global() {
 return jsvLockAgain(HEAP32[80545]) | 0;
}
function gen_jswrap_Serial1() {
 return jspNewObject(95807, 94015) | 0;
}
function jswrap_banglejs_isCompassOn() {
 return HEAP32[84152] & 8192;
}
function dynCall_d($0) {
 $0 = $0 | 0;
 return +FUNCTION_TABLE[$0]();
}
function jsiTimersChanged() {
 HEAP16[161112] = HEAPU16[161112] | 4;
}
function gen_jswrap_SPI1() {
 return jspNewObject(95802, 94034) | 0;
}
function gen_jswrap_I2C1() {
 return jspNewObject(95211, 94038) | 0;
}
function jshHasEvents() {
 return HEAPU8[322306] != HEAPU8[322307];
}
function gen_jswrap_USB() {
 return jspNewObject(95824, 94015) | 0;
}
function gen_jswrap_Number_NEGATIVE_INFINITY() {
 return -infinity;
}
function jswrap_storage_getFree() {
 return jsfGetFreeSpace() | 0;
}
function jswrap_banglejs_isHRMOn() {
 return HEAP32[84152] & 2048;
}
function jswrap_banglejs_isGPSOn() {
 return HEAP32[84152] & 4096;
}
function jspSetNoExecute() {
 HEAP32[80549] = HEAP32[80549] & -64;
}
function __growWasmMemory($0) {
 $0 = $0 | 0;
 return abort() | 0;
}
function jswrap_banglejs_off() {
 jsExceptionHere(1, 111045, 0);
}
function jswrap_banglejs_getStepCount() {
 return HEAP32[84168];
}
function jspIsInterrupted() {
 return (HEAP32[80549] & 16) != 0;
}
function gen_jswrap_Math_SQRT1_2() {
 return .7071067811865476;
}
function jspromise_create() {
 return jspNewObject(0, 125172);
}
function htonl($0) {
 $0 = $0 | 0;
 return __bswap_32($0) | 0;
}
function gen_jswrap_Math_SQRT2() {
 return 1.4142135623730951;
}
function gen_jswrap_Math_LOG2E() {
 return 1.4426950408889634;
}
function gen_jswrap_Math_LOG10E() {
 return .4342944819032518;
}
function jsfEraseAll() {
 jsfEraseArea(134217728, 142606336);
}
function dynCall_v($0) {
 $0 = $0 | 0;
 FUNCTION_TABLE[$0]();
}
function jspHasError() {
 return (HEAP32[80549] & 112) != 0;
}
function gen_jswrap_Math_LN10() {
 return 2.302585092994046;
}
function gen_jswrap_Math_LN2() {
 return .6931471805599453;
}
function __cxa_pure_virtual() {
 abort_message();
 abort();
}
function gen_jswrap_Math_PI() {
 return 3.141592653589793;
}
function stackRestore($0) {
 $0 = $0 | 0;
 global$0 = $0;
}
function gen_jswrap_Math_E() {
 return 2.718281828459045;
}
function floor($0) {
 $0 = +$0;
 return +Math_floor($0);
}
function ceil($0) {
 $0 = +$0;
 return +Math_ceil($0);
}
function jswrap_storage_eraseAll() {
 jsfEraseAll();
}
function jsiEcho() {
 return !(HEAPU16[161112] & 3);
}
function gen_jswrap_Graphics_Graphics() {
 return 0;
}
function jshGetRandomNumber() {
 return rand() | 0;
}
function isdigit($0) {
 return $0 + -48 >>> 0 < 10;
}
function jswrap_storage_compact() {
 jsfCompact();
}
function gen_jswrap_Infinity() {
 return infinity;
}
function gen_jswrap_dump() {
 jsiDumpState(7, 0);
}
function jsiKill() {
 jsiSoftKill();
 jspKill();
}
function __errno_location() {
 return 336968;
}
function strcpy($0, $1) {
 __stpcpy($0, $1);
}
function stackSave() {
 return global$0 | 0;
}
function gen_jswrap_VIBRATE() {
 return 19;
}
function gen_jswrap_NaN() {
 return nan;
}
function gen_jswrap_HIGH() {
 return 1;
}
function gen_jswrap_BTN() {
 return 17;
}
function jsKill() {
 jsiKill();
}

// EMSCRIPTEN_END_FUNCS

 FUNCTION_TABLE[1] = jswrap_object_toString;
 FUNCTION_TABLE[2] = jsvStringIteratorPrintfCallback;
 FUNCTION_TABLE[3] = jsvIsInternalFunctionKey;
 FUNCTION_TABLE[4] = jsvIsInternalObjectKey;
 FUNCTION_TABLE[5] = jsvIterateCallbackCountCb;
 FUNCTION_TABLE[6] = jsvIterateCallbackToBytesCb;
 FUNCTION_TABLE[7] = jsiConsolePrintString;
 FUNCTION_TABLE[8] = espruino_snprintf_cb;
 FUNCTION_TABLE[9] = jswrap_eval;
 FUNCTION_TABLE[10] = jsiTabComplete_findCommon;
 FUNCTION_TABLE[11] = jsiTabComplete_printCommon;
 FUNCTION_TABLE[12] = jstPinTaskChecker;
 FUNCTION_TABLE[13] = jstBufferTaskChecker;
 FUNCTION_TABLE[14] = jsserialHardwareFunc;
 FUNCTION_TABLE[15] = jsserialSoftwareFunc;
 FUNCTION_TABLE[16] = jsserialEventCallback;
 FUNCTION_TABLE[17] = jsspiHardwareFunc;
 FUNCTION_TABLE[18] = jsspiFastSoftwareFunc;
 FUNCTION_TABLE[19] = jsspiSoftwareFunc;
 FUNCTION_TABLE[20] = gen_jswrap_Graphics_Graphics;
 FUNCTION_TABLE[21] = jswrap_dataview_constructor;
 FUNCTION_TABLE[22] = jswrap_date_constructor;
 FUNCTION_TABLE[23] = jswrap_error_constructor;
 FUNCTION_TABLE[24] = jswrap_syntaxerror_constructor;
 FUNCTION_TABLE[25] = jswrap_typeerror_constructor;
 FUNCTION_TABLE[26] = jswrap_internalerror_constructor;
 FUNCTION_TABLE[27] = jswrap_referenceerror_constructor;
 FUNCTION_TABLE[28] = jswrap_onewire_constructor;
 FUNCTION_TABLE[29] = jswrap_promise_constructor;
 FUNCTION_TABLE[30] = jswrap_regexp_constructor;
 FUNCTION_TABLE[31] = jswrap_serial_constructor;
 FUNCTION_TABLE[32] = gen_jswrap_Graphics_Graphics;
 FUNCTION_TABLE[33] = jswrap_spi_constructor;
 FUNCTION_TABLE[34] = jswrap_i2c_constructor;
 FUNCTION_TABLE[35] = jswrap_waveform_constructor;
 FUNCTION_TABLE[36] = gen_jswrap_Graphics_Graphics;
 FUNCTION_TABLE[37] = gen_jswrap_Graphics_Graphics;
 FUNCTION_TABLE[38] = gen_jswrap_Graphics_Graphics;
 FUNCTION_TABLE[39] = gen_jswrap_Graphics_Graphics;
 FUNCTION_TABLE[40] = gen_jswrap_Graphics_Graphics;
 FUNCTION_TABLE[41] = jswrap_array_constructor;
 FUNCTION_TABLE[42] = gen_jswrap_Graphics_Graphics;
 FUNCTION_TABLE[43] = gen_jswrap_Graphics_Graphics;
 FUNCTION_TABLE[44] = gen_jswrap_Graphics_Graphics;
 FUNCTION_TABLE[45] = gen_jswrap_Graphics_Graphics;
 FUNCTION_TABLE[46] = jswrap_number_constructor;
 FUNCTION_TABLE[47] = jswrap_object_constructor;
 FUNCTION_TABLE[48] = gen_jswrap_Graphics_Graphics;
 FUNCTION_TABLE[49] = gen_jswrap_Graphics_Graphics;
 FUNCTION_TABLE[50] = gen_jswrap_Graphics_Graphics;
 FUNCTION_TABLE[51] = jswrap_string_constructor;
 FUNCTION_TABLE[52] = gen_jswrap_Graphics_Graphics;
 FUNCTION_TABLE[53] = gen_jswrap_Graphics_Graphics;
 FUNCTION_TABLE[54] = gen_jswrap_Graphics_Graphics;
 FUNCTION_TABLE[55] = gen_jswrap_Graphics_Graphics;
 FUNCTION_TABLE[56] = jswrap_arraybuffer_constructor;
 FUNCTION_TABLE[57] = gen_jswrap_Graphics_Graphics;
 FUNCTION_TABLE[58] = jswrap_pin_constructor;
 FUNCTION_TABLE[59] = jswrap_function_constructor;
 FUNCTION_TABLE[60] = gen_jswrap_BTN;
 FUNCTION_TABLE[61] = gen_jswrap_BTN;
 FUNCTION_TABLE[62] = jswrap_boolean_constructor;
 FUNCTION_TABLE[63] = gen_jswrap_Float32Array_Float32Array;
 FUNCTION_TABLE[64] = gen_jswrap_Float64Array_Float64Array;
 FUNCTION_TABLE[65] = gen_jswrap_HIGH;
 FUNCTION_TABLE[66] = gen_jswrap_I2C1;
 FUNCTION_TABLE[67] = gen_jswrap_Infinity;
 FUNCTION_TABLE[68] = gen_jswrap_Int16Array_Int16Array;
 FUNCTION_TABLE[69] = gen_jswrap_Int32Array_Int32Array;
 FUNCTION_TABLE[70] = gen_jswrap_Int8Array_Int8Array;
 FUNCTION_TABLE[71] = gen_jswrap_LED1;
 FUNCTION_TABLE[72] = gen_jswrap_LED2;
 FUNCTION_TABLE[73] = gen_jswrap_Graphics_Graphics;
 FUNCTION_TABLE[74] = gen_jswrap_LoopbackA;
 FUNCTION_TABLE[75] = gen_jswrap_LoopbackB;
 FUNCTION_TABLE[76] = gen_jswrap_NaN;
 FUNCTION_TABLE[77] = gen_jswrap_SPI1;
 FUNCTION_TABLE[78] = gen_jswrap_Serial1;
 FUNCTION_TABLE[79] = gen_jswrap_Terminal;
 FUNCTION_TABLE[80] = gen_jswrap_USB;
 FUNCTION_TABLE[81] = gen_jswrap_Uint16Array_Uint16Array;
 FUNCTION_TABLE[82] = gen_jswrap_Uint24Array_Uint24Array;
 FUNCTION_TABLE[83] = gen_jswrap_Uint32Array_Uint32Array;
 FUNCTION_TABLE[84] = gen_jswrap_Uint8Array_Uint8Array;
 FUNCTION_TABLE[85] = gen_jswrap_Uint8ClampedArray_Uint8ClampedArray;
 FUNCTION_TABLE[86] = gen_jswrap_VIBRATE;
 FUNCTION_TABLE[87] = jshPinAnalog;
 FUNCTION_TABLE[88] = jswrap_io_analogWrite;
 FUNCTION_TABLE[89] = jswrap_arguments;
 FUNCTION_TABLE[90] = jswrap_atob;
 FUNCTION_TABLE[91] = jswrap_btoa;
 FUNCTION_TABLE[92] = jswrap_interface_changeInterval;
 FUNCTION_TABLE[93] = jswrap_interface_clearInterval;
 FUNCTION_TABLE[94] = jswrap_interface_clearTimeout;
 FUNCTION_TABLE[95] = jswrap_interface_clearWatch;
 FUNCTION_TABLE[96] = jswrap_decodeURIComponent;
 FUNCTION_TABLE[97] = jswrap_io_digitalPulse;
 FUNCTION_TABLE[98] = jswrap_io_digitalRead;
 FUNCTION_TABLE[99] = jswrap_io_digitalWrite;
 FUNCTION_TABLE[100] = gen_jswrap_dump;
 FUNCTION_TABLE[101] = jswrap_interface_echo;
 FUNCTION_TABLE[102] = jswrap_interface_edit;
 FUNCTION_TABLE[103] = jswrap_encodeURIComponent;
 FUNCTION_TABLE[104] = jswrap_io_getPinMode;
 FUNCTION_TABLE[105] = jswrap_interface_getSerial;
 FUNCTION_TABLE[106] = gen_jswrap_getTime;
 FUNCTION_TABLE[107] = gen_jswrap_global;
 FUNCTION_TABLE[108] = jswrap_isFinite;
 FUNCTION_TABLE[109] = jswrap_isNaN;
 FUNCTION_TABLE[110] = jswrap_interface_load;
 FUNCTION_TABLE[111] = jswrap_parseFloat;
 FUNCTION_TABLE[112] = jswrap_parseInt;
 FUNCTION_TABLE[113] = gen_jswrap_peek16;
 FUNCTION_TABLE[114] = gen_jswrap_peek32;
 FUNCTION_TABLE[115] = gen_jswrap_peek8;
 FUNCTION_TABLE[116] = jswrap_io_pinMode;
 FUNCTION_TABLE[117] = gen_jswrap_poke16;
 FUNCTION_TABLE[118] = gen_jswrap_poke32;
 FUNCTION_TABLE[119] = gen_jswrap_poke8;
 FUNCTION_TABLE[120] = jswrap_interface_print;
 FUNCTION_TABLE[121] = jswrap_require;
 FUNCTION_TABLE[122] = jswrap_interface_reset;
 FUNCTION_TABLE[123] = jswrap_interface_setBusyIndicator;
 FUNCTION_TABLE[124] = jswrap_interface_setInterval;
 FUNCTION_TABLE[125] = jswrap_interface_setSleepIndicator;
 FUNCTION_TABLE[126] = jswrap_interactive_setTime;
 FUNCTION_TABLE[127] = jswrap_interface_setTimeout;
 FUNCTION_TABLE[128] = jswrap_interface_setWatch;
 FUNCTION_TABLE[129] = jswrap_io_shiftOut;
 FUNCTION_TABLE[130] = jswrap_interface_trace;
 FUNCTION_TABLE[131] = gen_jswrap_HIGH;
 FUNCTION_TABLE[132] = jswrap_banglejs_accelRd;
 FUNCTION_TABLE[133] = jsfCachePut;
 FUNCTION_TABLE[134] = jswrap_banglejs_appRect;
 FUNCTION_TABLE[135] = jswrap_banglejs_accelRd;
 FUNCTION_TABLE[136] = jsfCachePut;
 FUNCTION_TABLE[137] = jswrap_banglejs_beep;
 FUNCTION_TABLE[138] = jswrap_banglejs_buzz;
 FUNCTION_TABLE[139] = jswrap_banglejs_accelRd;
 FUNCTION_TABLE[140] = jsfCachePut;
 FUNCTION_TABLE[141] = jswrap_banglejs_dbg;
 FUNCTION_TABLE[142] = gen_jswrap_Bangle_drawWidgets;
 FUNCTION_TABLE[143] = jswrap_banglejs_factoryReset;
 FUNCTION_TABLE[144] = jswrap_banglejs_getAccel;
 FUNCTION_TABLE[145] = gen_jswrap_Graphics_Graphics;
 FUNCTION_TABLE[146] = gen_jswrap_Graphics_Graphics;
 FUNCTION_TABLE[147] = jswrap_banglejs_getHealthStatus;
 FUNCTION_TABLE[148] = jswrap_banglejs_getLCDMode;
 FUNCTION_TABLE[149] = jswrap_banglejs_getLogo;
 FUNCTION_TABLE[150] = jswrap_banglejs_getOptions;
 FUNCTION_TABLE[151] = gen_jswrap_Graphics_Graphics;
 FUNCTION_TABLE[152] = jswrap_banglejs_getStepCount;
 FUNCTION_TABLE[153] = jswrap_banglejs_accelRd;
 FUNCTION_TABLE[154] = jsfCachePut;
 FUNCTION_TABLE[155] = jswrap_banglejs_isBarometerOn;
 FUNCTION_TABLE[156] = jswrap_banglejs_isCharging;
 FUNCTION_TABLE[157] = jswrap_banglejs_isCompassOn;
 FUNCTION_TABLE[158] = jswrap_banglejs_isGPSOn;
 FUNCTION_TABLE[159] = jswrap_banglejs_isHRMOn;
 FUNCTION_TABLE[160] = jswrap_banglejs_isLCDOn;
 FUNCTION_TABLE[161] = jswrap_banglejs_isLocked;
 FUNCTION_TABLE[162] = jswrap_banglejs_lcdWr;
 FUNCTION_TABLE[163] = gen_jswrap_Bangle_loadWidgets;
 FUNCTION_TABLE[164] = jswrap_banglejs_off;
 FUNCTION_TABLE[165] = jswrap_banglejs_project;
 FUNCTION_TABLE[166] = __wasm_call_ctors;
 FUNCTION_TABLE[167] = jswrap_banglejs_setHRMPower;
 FUNCTION_TABLE[168] = jswrap_banglejs_setHRMPower;
 FUNCTION_TABLE[169] = jswrap_banglejs_setHRMPower;
 FUNCTION_TABLE[170] = jswrap_banglejs_setHRMPower;
 FUNCTION_TABLE[171] = jswrap_banglejs_setLCDBrightness;
 FUNCTION_TABLE[172] = jswrap_banglejs_setLCDMode;
 FUNCTION_TABLE[173] = do_indexing;
 FUNCTION_TABLE[174] = jswrap_banglejs_setLCDPower;
 FUNCTION_TABLE[175] = jswrap_banglejs_setLCDTimeout;
 FUNCTION_TABLE[176] = jswrap_banglejs_setLocked;
 FUNCTION_TABLE[177] = jswrap_banglejs_setOptions;
 FUNCTION_TABLE[178] = jswrap_banglejs_setPollInterval;
 FUNCTION_TABLE[179] = jswrap_banglejs_setStepCount;
 FUNCTION_TABLE[180] = gen_jswrap_Bangle_setUI;
 FUNCTION_TABLE[181] = gen_jswrap_Bangle_showLauncher;
 FUNCTION_TABLE[182] = jswrap_banglejs_off;
 FUNCTION_TABLE[183] = jswrap_espruino_CRC32;
 FUNCTION_TABLE[184] = jswrap_espruino_FFT;
 FUNCTION_TABLE[185] = jswrap_espruino_HSBtoRGB;
 FUNCTION_TABLE[186] = jswrap_espruino_asm;
 FUNCTION_TABLE[187] = jswrap_espruino_clip;
 FUNCTION_TABLE[188] = jswrap_espruino_compiledC;
 FUNCTION_TABLE[189] = jswrap_espruino_convolve;
 FUNCTION_TABLE[190] = jswrap_espruino_decodeUTF8;
 FUNCTION_TABLE[191] = jsvDefragment;
 FUNCTION_TABLE[192] = jswrap_e_dumpFragmentation;
 FUNCTION_TABLE[193] = jswrap_e_dumpStr;
 FUNCTION_TABLE[194] = jswrap_e_dumpVariables;
 FUNCTION_TABLE[195] = jswrap_espruino_enableWatchdog;
 FUNCTION_TABLE[196] = jswrap_espruino_getAddressOf;
 FUNCTION_TABLE[197] = gen_jswrap_NaN;
 FUNCTION_TABLE[198] = gen_jswrap_Graphics_Graphics;
 FUNCTION_TABLE[199] = jswrap_espruino_getConsole;
 FUNCTION_TABLE[200] = jswrap_espruino_getErrorFlags;
 FUNCTION_TABLE[201] = jsfGetFlags;
 FUNCTION_TABLE[202] = jswrap_espruino_getSizeOf;
 FUNCTION_TABLE[203] = gen_jswrap_NaN;
 FUNCTION_TABLE[204] = jshGetRandomNumber;
 FUNCTION_TABLE[205] = __wasm_call_ctors;
 FUNCTION_TABLE[206] = jswrap_espruino_lockConsole;
 FUNCTION_TABLE[207] = jswrap_espruino_lookupNoCase;
 FUNCTION_TABLE[208] = jswrap_espruino_mapInPlace;
 FUNCTION_TABLE[209] = jswrap_espruino_memoryArea;
 FUNCTION_TABLE[210] = jswrap_espruino_memoryMap;
 FUNCTION_TABLE[211] = jswrap_espruino_nativeCall;
 FUNCTION_TABLE[212] = jswrap_pipe;
 FUNCTION_TABLE[213] = jswrap_espruino_reboot;
 FUNCTION_TABLE[214] = jswrap_espruino_reverseByte;
 FUNCTION_TABLE[215] = jswrap_espruino_setBootCode;
 FUNCTION_TABLE[216] = jswrap_espruino_setClock;
 FUNCTION_TABLE[217] = jswrap_espruino_setConsole;
 FUNCTION_TABLE[218] = jsfSetFlags;
 FUNCTION_TABLE[219] = jswrap_espruino_setPassword;
 FUNCTION_TABLE[220] = jswrap_espruino_setTimeZone;
 FUNCTION_TABLE[221] = gen_jswrap_E_showAlert;
 FUNCTION_TABLE[222] = gen_jswrap_E_showMenu;
 FUNCTION_TABLE[223] = gen_jswrap_E_showMessage;
 FUNCTION_TABLE[224] = gen_jswrap_E_showPrompt;
 FUNCTION_TABLE[225] = gen_jswrap_E_showScroller;
 FUNCTION_TABLE[226] = srand;
 FUNCTION_TABLE[227] = jswrap_espruino_sum;
 FUNCTION_TABLE[228] = jswrap_espruino_toArrayBuffer;
 FUNCTION_TABLE[229] = jswrap_espruino_toJS;
 FUNCTION_TABLE[230] = jswrap_espruino_toString;
 FUNCTION_TABLE[231] = jswrap_espruino_toUint8Array;
 FUNCTION_TABLE[232] = jswrap_espruino_variance;
 FUNCTION_TABLE[233] = jswrap_graphics_asBMP;
 FUNCTION_TABLE[234] = jswrap_graphics_asImage;
 FUNCTION_TABLE[235] = jswrap_graphics_asURL;
 FUNCTION_TABLE[236] = jswrap_graphics_blit;
 FUNCTION_TABLE[237] = jswrap_graphics_clear;
 FUNCTION_TABLE[238] = jswrap_graphics_clearRect;
 FUNCTION_TABLE[239] = jswrap_graphics_drawCircle;
 FUNCTION_TABLE[240] = jswrap_graphics_drawEllipse;
 FUNCTION_TABLE[241] = jswrap_graphics_drawImage;
 FUNCTION_TABLE[242] = jswrap_graphics_drawImages;
 FUNCTION_TABLE[243] = jswrap_graphics_drawLine;
 FUNCTION_TABLE[244] = gen_jswrap_Graphics_drawPoly;
 FUNCTION_TABLE[245] = jswrap_graphics_drawRect;
 FUNCTION_TABLE[246] = jswrap_graphics_drawString;
 FUNCTION_TABLE[247] = jswrap_graphics_dump;
 FUNCTION_TABLE[248] = jswrap_graphics_fillCircle;
 FUNCTION_TABLE[249] = jswrap_graphics_fillEllipse;
 FUNCTION_TABLE[250] = gen_jswrap_Graphics_fillPoly;
 FUNCTION_TABLE[251] = jswrap_graphics_fillRect;
 FUNCTION_TABLE[252] = jswrap_graphics_getBPP;
 FUNCTION_TABLE[253] = gen_jswrap_Graphics_getBgColor;
 FUNCTION_TABLE[254] = gen_jswrap_Graphics_getColor;
 FUNCTION_TABLE[255] = jswrap_graphics_getFont;
 FUNCTION_TABLE[256] = jswrap_graphics_getFontHeight;
 FUNCTION_TABLE[257] = jswrap_graphics_getFonts;
 FUNCTION_TABLE[258] = gen_jswrap_Graphics_getHeight;
 FUNCTION_TABLE[259] = jswrap_graphics_getModified;
 FUNCTION_TABLE[260] = jswrap_graphics_getPixel;
 FUNCTION_TABLE[261] = gen_jswrap_Graphics_getWidth;
 FUNCTION_TABLE[262] = jswrap_graphics_imageMetrics;
 FUNCTION_TABLE[263] = jswrap_graphics_lineTo;
 FUNCTION_TABLE[264] = jswrap_graphics_moveTo;
 FUNCTION_TABLE[265] = jswrap_graphics_quadraticBezier;
 FUNCTION_TABLE[266] = jswrap_graphics_reset;
 FUNCTION_TABLE[267] = jswrap_graphics_scroll;
 FUNCTION_TABLE[268] = gen_jswrap_Graphics_setBgColor;
 FUNCTION_TABLE[269] = jswrap_graphics_setClipRect;
 FUNCTION_TABLE[270] = gen_jswrap_Graphics_setColor;
 FUNCTION_TABLE[271] = jswrap_graphics_setFont;
 FUNCTION_TABLE[272] = jswrap_graphics_setFont12x20;
 FUNCTION_TABLE[273] = jswrap_graphics_setFont6x15;
 FUNCTION_TABLE[274] = jswrap_graphics_setFontAlign;
 FUNCTION_TABLE[275] = gen_jswrap_Graphics_setFontBitmap;
 FUNCTION_TABLE[276] = jswrap_graphics_setFontCustom;
 FUNCTION_TABLE[277] = gen_jswrap_Graphics_setFontVector;
 FUNCTION_TABLE[278] = jswrap_graphics_setPixel;
 FUNCTION_TABLE[279] = jswrap_graphics_setRotation;
 FUNCTION_TABLE[280] = jswrap_graphics_setTheme;
 FUNCTION_TABLE[281] = jswrap_graphics_stringMetrics;
 FUNCTION_TABLE[282] = jswrap_graphics_stringWidth;
 FUNCTION_TABLE[283] = jswrap_graphics_theme;
 FUNCTION_TABLE[284] = jswrap_graphics_toColor;
 FUNCTION_TABLE[285] = jswrap_graphics_transformVertices;
 FUNCTION_TABLE[286] = jswrap_graphics_wrapString;
 FUNCTION_TABLE[287] = gen_jswrap_NRF_getAddress;
 FUNCTION_TABLE[288] = gen_jswrap_NRF_getSecurityStatus;
 FUNCTION_TABLE[289] = jsfCachePut;
 FUNCTION_TABLE[290] = jsfCachePut;
 FUNCTION_TABLE[291] = __wasm_call_ctors;
 FUNCTION_TABLE[292] = jswrap_array_concat;
 FUNCTION_TABLE[293] = jswrap_array_every;
 FUNCTION_TABLE[294] = jswrap_array_fill;
 FUNCTION_TABLE[295] = jswrap_array_filter;
 FUNCTION_TABLE[296] = jswrap_array_find;
 FUNCTION_TABLE[297] = jswrap_array_findIndex;
 FUNCTION_TABLE[298] = jswrap_array_forEach;
 FUNCTION_TABLE[299] = jswrap_array_includes;
 FUNCTION_TABLE[300] = jswrap_array_indexOf;
 FUNCTION_TABLE[301] = jswrap_array_join;
 FUNCTION_TABLE[302] = jswrap_object_length;
 FUNCTION_TABLE[303] = jswrap_array_map;
 FUNCTION_TABLE[304] = gen_jswrap_Array_pop;
 FUNCTION_TABLE[305] = jswrap_array_push;
 FUNCTION_TABLE[306] = jswrap_array_reduce;
 FUNCTION_TABLE[307] = jswrap_array_reverse;
 FUNCTION_TABLE[308] = jswrap_array_shift;
 FUNCTION_TABLE[309] = jswrap_array_slice;
 FUNCTION_TABLE[310] = jswrap_array_some;
 FUNCTION_TABLE[311] = jswrap_array_sort;
 FUNCTION_TABLE[312] = jswrap_array_splice;
 FUNCTION_TABLE[313] = jswrap_array_unshift;
 FUNCTION_TABLE[314] = gen_jswrap_Array_isArray;
 FUNCTION_TABLE[315] = jsvGetArrayBufferLength;
 FUNCTION_TABLE[316] = gen_jswrap_ArrayBufferView_buffer;
 FUNCTION_TABLE[317] = gen_jswrap_ArrayBufferView_byteLength;
 FUNCTION_TABLE[318] = gen_jswrap_ArrayBufferView_byteOffset;
 FUNCTION_TABLE[319] = jswrap_arraybufferview_map;
 FUNCTION_TABLE[320] = jswrap_arraybufferview_set;
 FUNCTION_TABLE[321] = jswrap_arraybufferview_sort;
 FUNCTION_TABLE[322] = jswrap_arraybufferview_subarray;
 FUNCTION_TABLE[323] = gen_jswrap_DataView_getFloat32;
 FUNCTION_TABLE[324] = gen_jswrap_DataView_getFloat64;
 FUNCTION_TABLE[325] = gen_jswrap_DataView_getInt16;
 FUNCTION_TABLE[326] = gen_jswrap_DataView_getInt32;
 FUNCTION_TABLE[327] = gen_jswrap_DataView_getInt8;
 FUNCTION_TABLE[328] = gen_jswrap_DataView_getUint16;
 FUNCTION_TABLE[329] = gen_jswrap_DataView_getUint32;
 FUNCTION_TABLE[330] = gen_jswrap_DataView_getUint8;
 FUNCTION_TABLE[331] = gen_jswrap_DataView_setFloat32;
 FUNCTION_TABLE[332] = gen_jswrap_DataView_setFloat64;
 FUNCTION_TABLE[333] = gen_jswrap_DataView_setInt16;
 FUNCTION_TABLE[334] = gen_jswrap_DataView_setInt32;
 FUNCTION_TABLE[335] = gen_jswrap_DataView_setInt8;
 FUNCTION_TABLE[336] = gen_jswrap_DataView_setUint16;
 FUNCTION_TABLE[337] = gen_jswrap_DataView_setUint32;
 FUNCTION_TABLE[338] = gen_jswrap_DataView_setUint8;
 FUNCTION_TABLE[339] = jswrap_date_now;
 FUNCTION_TABLE[340] = jswrap_date_parse;
 FUNCTION_TABLE[341] = jswrap_date_getDate;
 FUNCTION_TABLE[342] = jswrap_date_getDay;
 FUNCTION_TABLE[343] = jswrap_date_getFullYear;
 FUNCTION_TABLE[344] = jswrap_date_getHours;
 FUNCTION_TABLE[345] = jswrap_date_getMilliseconds;
 FUNCTION_TABLE[346] = jswrap_date_getMinutes;
 FUNCTION_TABLE[347] = jswrap_date_getMonth;
 FUNCTION_TABLE[348] = jswrap_date_getSeconds;
 FUNCTION_TABLE[349] = jswrap_date_getTime;
 FUNCTION_TABLE[350] = jswrap_date_getTimezoneOffset;
 FUNCTION_TABLE[351] = jswrap_date_setDate;
 FUNCTION_TABLE[352] = jswrap_date_setFullYear;
 FUNCTION_TABLE[353] = jswrap_date_setHours;
 FUNCTION_TABLE[354] = jswrap_date_setMilliseconds;
 FUNCTION_TABLE[355] = jswrap_date_setMinutes;
 FUNCTION_TABLE[356] = jswrap_date_setMonth;
 FUNCTION_TABLE[357] = jswrap_date_setSeconds;
 FUNCTION_TABLE[358] = jswrap_date_setTime;
 FUNCTION_TABLE[359] = jswrap_date_toISOString;
 FUNCTION_TABLE[360] = jswrap_date_toString;
 FUNCTION_TABLE[361] = jswrap_date_toUTCString;
 FUNCTION_TABLE[362] = jswrap_error_toString;
 FUNCTION_TABLE[363] = jswrap_flash_erasePage;
 FUNCTION_TABLE[364] = jswrap_flash_getFree;
 FUNCTION_TABLE[365] = jswrap_flash_getPage;
 FUNCTION_TABLE[366] = jswrap_flash_read;
 FUNCTION_TABLE[367] = jswrap_flash_write;
 FUNCTION_TABLE[368] = jswrap_json_parse;
 FUNCTION_TABLE[369] = jswrap_json_stringify;
 FUNCTION_TABLE[370] = jswrap_modules_addCached;
 FUNCTION_TABLE[371] = jswrap_modules_getCached;
 FUNCTION_TABLE[372] = jswrap_modules_removeAllCached;
 FUNCTION_TABLE[373] = jswrap_modules_removeCached;
 FUNCTION_TABLE[374] = jswrap_pin_getInfo;
 FUNCTION_TABLE[375] = jswrap_pin_getMode;
 FUNCTION_TABLE[376] = jswrap_pin_mode;
 FUNCTION_TABLE[377] = jswrap_pin_read;
 FUNCTION_TABLE[378] = jswrap_pin_reset;
 FUNCTION_TABLE[379] = jswrap_pin_set;
 FUNCTION_TABLE[380] = jswrap_pin_toggle;
 FUNCTION_TABLE[381] = jswrap_pin_write;
 FUNCTION_TABLE[382] = jswrap_pin_writeAtTime;
 FUNCTION_TABLE[383] = gen_jswrap_Number_MAX_VALUE;
 FUNCTION_TABLE[384] = gen_jswrap_Number_MIN_VALUE;
 FUNCTION_TABLE[385] = gen_jswrap_Number_NEGATIVE_INFINITY;
 FUNCTION_TABLE[386] = gen_jswrap_NaN;
 FUNCTION_TABLE[387] = gen_jswrap_Infinity;
 FUNCTION_TABLE[388] = jswrap_number_toFixed;
 FUNCTION_TABLE[389] = jswrap_object_clone;
 FUNCTION_TABLE[390] = jswrap_object_emit;
 FUNCTION_TABLE[391] = jswrap_object_hasOwnProperty;
 FUNCTION_TABLE[392] = jswrap_object_on;
 FUNCTION_TABLE[393] = jswrap_object_removeAllListeners;
 FUNCTION_TABLE[394] = jswrap_object_removeListener;
 FUNCTION_TABLE[395] = jswrap_object_valueOf;
 FUNCTION_TABLE[396] = jswrap_object_assign;
 FUNCTION_TABLE[397] = jswrap_object_create;
 FUNCTION_TABLE[398] = jswrap_object_defineProperties;
 FUNCTION_TABLE[399] = jswrap_object_defineProperty;
 FUNCTION_TABLE[400] = jswrap_object_getOwnPropertyDescriptor;
 FUNCTION_TABLE[401] = gen_jswrap_Object_getOwnPropertyNames;
 FUNCTION_TABLE[402] = jswrap_object_getPrototypeOf;
 FUNCTION_TABLE[403] = gen_jswrap_Object_keys;
 FUNCTION_TABLE[404] = jswrap_object_setPrototypeOf;
 FUNCTION_TABLE[405] = jswrap_function_apply_or_call;
 FUNCTION_TABLE[406] = jswrap_function_bind;
 FUNCTION_TABLE[407] = jswrap_function_replaceWith;
 FUNCTION_TABLE[408] = jswrap_onewire_read;
 FUNCTION_TABLE[409] = jswrap_onewire_reset;
 FUNCTION_TABLE[410] = jswrap_onewire_search;
 FUNCTION_TABLE[411] = jswrap_onewire_select;
 FUNCTION_TABLE[412] = jswrap_onewire_skip;
 FUNCTION_TABLE[413] = jswrap_onewire_write;
 FUNCTION_TABLE[414] = jswrap_process_env;
 FUNCTION_TABLE[415] = jswrap_process_memory;
 FUNCTION_TABLE[416] = gen_jswrap_process_version;
 FUNCTION_TABLE[417] = jswrap_promise_all;
 FUNCTION_TABLE[418] = jswrap_promise_reject;
 FUNCTION_TABLE[419] = jswrap_promise_resolve;
 FUNCTION_TABLE[420] = jswrap_promise_catch;
 FUNCTION_TABLE[421] = jswrap_promise_then;
 FUNCTION_TABLE[422] = jswrap_regexp_exec;
 FUNCTION_TABLE[423] = jswrap_regexp_test;
 FUNCTION_TABLE[424] = gen_jswrap_Serial_find;
 FUNCTION_TABLE[425] = jswrap_stream_available;
 FUNCTION_TABLE[426] = jswrap_serial_inject;
 FUNCTION_TABLE[427] = jswrap_serial_print;
 FUNCTION_TABLE[428] = jswrap_serial_println;
 FUNCTION_TABLE[429] = jswrap_stream_read;
 FUNCTION_TABLE[430] = jswrap_serial_setConsole;
 FUNCTION_TABLE[431] = jswrap_serial_setup;
 FUNCTION_TABLE[432] = jswrap_serial_unsetup;
 FUNCTION_TABLE[433] = jswrap_serial_write;
 FUNCTION_TABLE[434] = jswrap_storage_compact;
 FUNCTION_TABLE[435] = jswrap_storage_erase;
 FUNCTION_TABLE[436] = jswrap_storage_eraseAll;
 FUNCTION_TABLE[437] = jswrap_storage_getFree;
 FUNCTION_TABLE[438] = jswrap_storage_hash;
 FUNCTION_TABLE[439] = jswrap_storage_list;
 FUNCTION_TABLE[440] = jswrap_storage_open;
 FUNCTION_TABLE[441] = jswrap_storage_read;
 FUNCTION_TABLE[442] = jswrap_storage_readArrayBuffer;
 FUNCTION_TABLE[443] = jswrap_storage_readJSON;
 FUNCTION_TABLE[444] = jswrap_storage_write;
 FUNCTION_TABLE[445] = jswrap_storage_writeJSON;
 FUNCTION_TABLE[446] = jswrap_storagefile_erase;
 FUNCTION_TABLE[447] = jswrap_storagefile_getLength;
 FUNCTION_TABLE[448] = jswrap_storagefile_read;
 FUNCTION_TABLE[449] = jswrap_storagefile_readLine;
 FUNCTION_TABLE[450] = jswrap_storagefile_write;
 FUNCTION_TABLE[451] = gen_jswrap_SPI_find;
 FUNCTION_TABLE[452] = jswrap_spi_send;
 FUNCTION_TABLE[453] = jswrap_spi_send4bit;
 FUNCTION_TABLE[454] = jswrap_spi_send8bit;
 FUNCTION_TABLE[455] = jswrap_spi_setup;
 FUNCTION_TABLE[456] = jswrap_spi_write;
 FUNCTION_TABLE[457] = gen_jswrap_I2C_find;
 FUNCTION_TABLE[458] = jswrap_i2c_readFrom;
 FUNCTION_TABLE[459] = jswrap_i2c_setup;
 FUNCTION_TABLE[460] = jswrap_i2c_writeTo;
 FUNCTION_TABLE[461] = jswrap_string_charAt;
 FUNCTION_TABLE[462] = jswrap_string_charCodeAt;
 FUNCTION_TABLE[463] = jswrap_string_endsWith;
 FUNCTION_TABLE[464] = gen_jswrap_String_includes;
 FUNCTION_TABLE[465] = gen_jswrap_String_indexOf;
 FUNCTION_TABLE[466] = gen_jswrap_String_lastIndexOf;
 FUNCTION_TABLE[467] = jswrap_string_match;
 FUNCTION_TABLE[468] = gen_jswrap_String_padEnd;
 FUNCTION_TABLE[469] = gen_jswrap_String_padStart;
 FUNCTION_TABLE[470] = jswrap_string_repeat;
 FUNCTION_TABLE[471] = jswrap_string_replace;
 FUNCTION_TABLE[472] = jswrap_string_slice;
 FUNCTION_TABLE[473] = jswrap_string_split;
 FUNCTION_TABLE[474] = jswrap_string_startsWith;
 FUNCTION_TABLE[475] = jswrap_string_substr;
 FUNCTION_TABLE[476] = jswrap_string_substring;
 FUNCTION_TABLE[477] = gen_jswrap_String_toLowerCase;
 FUNCTION_TABLE[478] = gen_jswrap_String_toUpperCase;
 FUNCTION_TABLE[479] = jswrap_string_trim;
 FUNCTION_TABLE[480] = jswrap_string_fromCharCode;
 FUNCTION_TABLE[481] = jswrap_waveform_startInput;
 FUNCTION_TABLE[482] = jswrap_waveform_startOutput;
 FUNCTION_TABLE[483] = jswrap_waveform_stop;
 FUNCTION_TABLE[484] = jswrap_heatshrink_compress;
 FUNCTION_TABLE[485] = jswrap_heatshrink_decompress;
 FUNCTION_TABLE[486] = gen_jswrap_Math_E;
 FUNCTION_TABLE[487] = gen_jswrap_Math_LN10;
 FUNCTION_TABLE[488] = gen_jswrap_Math_LN2;
 FUNCTION_TABLE[489] = gen_jswrap_Math_LOG10E;
 FUNCTION_TABLE[490] = gen_jswrap_Math_LOG2E;
 FUNCTION_TABLE[491] = gen_jswrap_Math_PI;
 FUNCTION_TABLE[492] = gen_jswrap_Math_SQRT1_2;
 FUNCTION_TABLE[493] = gen_jswrap_Math_SQRT2;
 FUNCTION_TABLE[494] = jswrap_math_abs;
 FUNCTION_TABLE[495] = gen_jswrap_Math_acos;
 FUNCTION_TABLE[496] = jswrap_math_asin;
 FUNCTION_TABLE[497] = jswrap_math_atan;
 FUNCTION_TABLE[498] = jswrap_math_atan2;
 FUNCTION_TABLE[499] = ceil;
 FUNCTION_TABLE[500] = jswrap_espruino_clip;
 FUNCTION_TABLE[501] = gen_jswrap_Math_cos;
 FUNCTION_TABLE[502] = exp;
 FUNCTION_TABLE[503] = floor;
 FUNCTION_TABLE[504] = log;
 FUNCTION_TABLE[505] = gen_jswrap_Math_max;
 FUNCTION_TABLE[506] = gen_jswrap_Math_min;
 FUNCTION_TABLE[507] = jswrap_math_pow;
 FUNCTION_TABLE[508] = gen_jswrap_Math_random;
 FUNCTION_TABLE[509] = jswrap_math_round;
 FUNCTION_TABLE[510] = jswrap_math_sin;
 FUNCTION_TABLE[511] = jswrap_math_sqrt;
 FUNCTION_TABLE[512] = gen_jswrap_Math_tan;
 FUNCTION_TABLE[513] = wrapAround;
 FUNCTION_TABLE[514] = jswrap_graphics_createArrayBuffer;
 FUNCTION_TABLE[515] = jswrap_graphics_createCallback;
 FUNCTION_TABLE[516] = jswrap_graphics_createImage;
 FUNCTION_TABLE[517] = jswrap_graphics_getInstance;
 FUNCTION_TABLE[518] = gen_jswrap_crypto_SHA1;
 FUNCTION_TABLE[519] = gen_jswrap_crypto_SHA224;
 FUNCTION_TABLE[520] = gen_jswrap_crypto_SHA256;
 FUNCTION_TABLE[521] = gen_jswrap_crypto_SHA384;
 FUNCTION_TABLE[522] = gen_jswrap_crypto_SHA512;
 FUNCTION_TABLE[523] = jswrap_tensorflow_create;
 FUNCTION_TABLE[524] = jswrap_tfmicrointerpreter_getInput;
 FUNCTION_TABLE[525] = jswrap_tfmicrointerpreter_getOutput;
 FUNCTION_TABLE[526] = jswrap_tfmicrointerpreter_invoke;
 FUNCTION_TABLE[527] = heatshrink_ptr_output_cb;
 FUNCTION_TABLE[528] = graphicsFallbackScroll;
 FUNCTION_TABLE[529] = graphicsFallbackBlit;
 FUNCTION_TABLE[530] = graphicsFallbackFillRect;
 FUNCTION_TABLE[531] = graphicsFallbackGetPixel;
 FUNCTION_TABLE[532] = graphicsFallbackSetPixel;
 FUNCTION_TABLE[533] = graphicsSetPixel;
 FUNCTION_TABLE[534] = lcdFillRect_ArrayBuffer_flat1;
 FUNCTION_TABLE[535] = lcdGetPixel_ArrayBuffer_flat;
 FUNCTION_TABLE[536] = lcdSetPixel_ArrayBuffer_flat1;
 FUNCTION_TABLE[537] = lcdScroll_ArrayBuffer_flat8;
 FUNCTION_TABLE[538] = lcdFillRect_ArrayBuffer_flat8;
 FUNCTION_TABLE[539] = lcdGetPixel_ArrayBuffer_flat8;
 FUNCTION_TABLE[540] = lcdSetPixel_ArrayBuffer_flat8;
 FUNCTION_TABLE[541] = lcdFillRect_ArrayBuffer_flat;
 FUNCTION_TABLE[542] = lcdSetPixel_ArrayBuffer_flat;
 FUNCTION_TABLE[543] = lcdFillRect_ArrayBuffer;
 FUNCTION_TABLE[544] = lcdGetPixel_ArrayBuffer;
 FUNCTION_TABLE[545] = lcdSetPixel_ArrayBuffer;
 FUNCTION_TABLE[546] = lcdFillRect_JS;
 FUNCTION_TABLE[547] = lcdSetPixel_JS;
 FUNCTION_TABLE[548] = lcdMemLCD_scroll;
 FUNCTION_TABLE[549] = lcdMemLCD_getPixel;
 FUNCTION_TABLE[550] = lcdMemLCD_fillRect;
 FUNCTION_TABLE[551] = lcdMemLCD_setPixel;
 FUNCTION_TABLE[552] = lcd_flip;
 FUNCTION_TABLE[553] = btn1Handler;
 FUNCTION_TABLE[554] = __wasm_call_ctors;
 FUNCTION_TABLE[555] = jswrap_banglejs_beep_callback;
 FUNCTION_TABLE[556] = jswrap_banglejs_buzz_callback;
 FUNCTION_TABLE[557] = _jswrap_arraybufferview_sort_float;
 FUNCTION_TABLE[558] = _jswrap_arraybufferview_sort_int;
 FUNCTION_TABLE[559] = _jswrap_espruino_toString_char;
 FUNCTION_TABLE[560] = _jswrap_espruino_toUint8Array_char;
 FUNCTION_TABLE[561] = jswrap_io_shiftOutCallback;
 FUNCTION_TABLE[562] = jsvArrayAddUnique;
 FUNCTION_TABLE[563] = _jswrap_onewire_write_cb;
 FUNCTION_TABLE[564] = jswrap_pipe_dst_close_listener;
 FUNCTION_TABLE[565] = jswrap_pipe_drain_listener;
 FUNCTION_TABLE[566] = jswrap_pipe_src_close_listener;
 FUNCTION_TABLE[567] = jsvLockAgainSafe;
 FUNCTION_TABLE[568] = jsvUnLock;
 FUNCTION_TABLE[569] = jsvSkipName;
 FUNCTION_TABLE[570] = jsvMathsOp;
 FUNCTION_TABLE[571] = jsvNewWithFlags;
 FUNCTION_TABLE[572] = jsvNewFromFloat;
 FUNCTION_TABLE[573] = jsvNewFromInteger;
 FUNCTION_TABLE[574] = jsvNewFromString;
 FUNCTION_TABLE[575] = jsvNewFromBool;
 FUNCTION_TABLE[576] = jsvGetFloat;
 FUNCTION_TABLE[577] = jsvGetInteger;
 FUNCTION_TABLE[578] = jsvGetBool;
 FUNCTION_TABLE[579] = jsvReplaceWith;
 FUNCTION_TABLE[580] = jspeFunctionCall;
 FUNCTION_TABLE[581] = jspGetNamedVariable;
 FUNCTION_TABLE[582] = jspGetNamedField;
 FUNCTION_TABLE[583] = jspGetVarNamedField;
 FUNCTION_TABLE[584] = _jswrap_promise_queuereject;
 FUNCTION_TABLE[585] = _jswrap_promise_queueresolve;
 FUNCTION_TABLE[586] = _jswrap_promise_reject;
 FUNCTION_TABLE[587] = _jswrap_promise_resolve;
 FUNCTION_TABLE[588] = jswrap_promise_all_reject;
 FUNCTION_TABLE[589] = jswrap_promise_all_resolve;
 FUNCTION_TABLE[590] = _jswrap_serial_inject_cb;
 FUNCTION_TABLE[591] = jswrap_spi_send_cb;
 FUNCTION_TABLE[592] = jswrap_spi_write_cb;
 FUNCTION_TABLE[593] = heatshrink_var_input_cb;
 FUNCTION_TABLE[594] = heatshrink_var_output_cb;
 FUNCTION_TABLE[595] = jswrap_graphics_getFonts_callback;
 FUNCTION_TABLE[596] = graphicsDrawLine;
 FUNCTION_TABLE[597] = tflite__SimpleMemoryAllocator__SimpleMemoryAllocator_28tflite__ErrorReporter__2c_20unsigned_20char__2c_20unsigned_20long_29;
 FUNCTION_TABLE[598] = tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29;
 FUNCTION_TABLE[599] = tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29_1;
 FUNCTION_TABLE[600] = tflite__SimpleMemoryAllocator__EnsureHeadSize_28unsigned_20long_2c_20unsigned_20long_29;
 FUNCTION_TABLE[601] = tflite__SimpleMemoryAllocator__AllocateFromTail_28unsigned_20long_2c_20unsigned_20long_29;
 FUNCTION_TABLE[602] = tflite__SimpleMemoryAllocator__AllocateTemp_28unsigned_20long_2c_20unsigned_20long_29;
 FUNCTION_TABLE[603] = tflite__SimpleMemoryAllocator__ResetTempAllocations_28_29;
 FUNCTION_TABLE[604] = tflite__internal__ContextHelper__ContextHelper_28tflite__ErrorReporter__2c_20tflite__MicroAllocator__2c_20tflite__Model_20const__29;
 FUNCTION_TABLE[605] = tflite__internal__ContextHelper__GetEvalTensor_28TfLiteContext_20const__2c_20int_29;
 FUNCTION_TABLE[606] = tflite__internal__ContextHelper__GetTensor_28TfLiteContext_20const__2c_20int_29;
 FUNCTION_TABLE[607] = tflite__internal__ContextHelper__ReportOpError_28TfLiteContext__2c_20char_20const__2c_20____29;
 FUNCTION_TABLE[608] = tflite__internal__ContextHelper__AllocatePersistentBuffer_28TfLiteContext__2c_20unsigned_20long_29;
 FUNCTION_TABLE[609] = tflite__internal__ContextHelper__RequestScratchBufferInArena_28TfLiteContext__2c_20unsigned_20long_2c_20int__29;
 FUNCTION_TABLE[610] = tflite__internal__ContextHelper__GetScratchBuffer_28TfLiteContext__2c_20int_29;
 FUNCTION_TABLE[611] = tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29;
 FUNCTION_TABLE[612] = tflite__MicroAllocator__MicroAllocator_28tflite__SimpleMemoryAllocator__2c_20tflite__ErrorReporter__29;
 FUNCTION_TABLE[613] = tflite__MicroAllocator__AllocatePersistentTfLiteTensor_28tflite__Model_20const__2c_20TfLiteEvalTensor__2c_20int_29;
 FUNCTION_TABLE[614] = tflite__MicroAllocator__AllocateTempTfLiteTensor_28tflite__Model_20const__2c_20TfLiteEvalTensor__2c_20int_29;
 FUNCTION_TABLE[615] = tflite__MicroAllocator__ResetTempAllocations_28_29;
 FUNCTION_TABLE[616] = tflite__MicroAllocator___MicroAllocator_28_29_1;
 FUNCTION_TABLE[617] = tflite__MicroAllocator__AllocateNodeAndRegistrations_28tflite__Model_20const__2c_20tflite__NodeAndRegistration___29;
 FUNCTION_TABLE[618] = tflite__MicroAllocator__PrepareNodeAndRegistrationDataFromFlatbuffer_28tflite__Model_20const__2c_20tflite__MicroOpResolver_20const__2c_20tflite__NodeAndRegistration__29;
 FUNCTION_TABLE[619] = tflite__MicroAllocator__AllocateTfLiteEvalTensors_28tflite__Model_20const__2c_20TfLiteEvalTensor___29;
 FUNCTION_TABLE[620] = tflite__MicroAllocator__AllocateVariables_28tflite__SubGraph_20const__2c_20TfLiteEvalTensor__29;
 FUNCTION_TABLE[621] = tflite__MicroAllocator__AllocatePersistentTfLiteTensorInternal_28tflite__Model_20const__2c_20TfLiteEvalTensor__2c_20int_29;
 FUNCTION_TABLE[622] = tflite__MicroAllocator__PopulateTfLiteTensorFromFlatbuffer_28tflite__Model_20const__2c_20tflite__SubGraph_20const__2c_20TfLiteTensor__2c_20int_2c_20bool_29;
 FUNCTION_TABLE[623] = tflite__MicroAllocator__CommitStaticMemoryPlan_28tflite__Model_20const__2c_20tflite__SubGraph_20const__2c_20TfLiteEvalTensor__29;
 FUNCTION_TABLE[624] = tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator__Allocate_28unsigned_20long_2c_20unsigned_20long_29;
 FUNCTION_TABLE[625] = jsfCachePut;
 FUNCTION_TABLE[626] = tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator___MicroBuiltinDataAllocator_28_29;
 FUNCTION_TABLE[627] = tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator___MicroBuiltinDataAllocator_28_29_1;
 FUNCTION_TABLE[628] = __cxa_pure_virtual;
 FUNCTION_TABLE[629] = tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29;
 FUNCTION_TABLE[630] = tflite__BuiltinDataAllocator___BuiltinDataAllocator_28_29_1;
 FUNCTION_TABLE[631] = tflite__ops__micro__depthwise_conv__Eval_28TfLiteContext__2c_20TfLiteNode__29;
 FUNCTION_TABLE[632] = tflite__ops__micro__depthwise_conv__Prepare_28TfLiteContext__2c_20TfLiteNode__29;
 FUNCTION_TABLE[633] = tflite__ops__micro__depthwise_conv__Init_28TfLiteContext__2c_20char_20const__2c_20unsigned_20long_29;
 FUNCTION_TABLE[634] = tflite__ops__micro__conv__Eval_28TfLiteContext__2c_20TfLiteNode__29;
 FUNCTION_TABLE[635] = tflite__ops__micro__conv__Prepare_28TfLiteContext__2c_20TfLiteNode__29;
 FUNCTION_TABLE[636] = tflite__ops__micro__depthwise_conv__Init_28TfLiteContext__2c_20char_20const__2c_20unsigned_20long_29;
 FUNCTION_TABLE[637] = tflite__ops__micro__pooling__AverageEval_28TfLiteContext__2c_20TfLiteNode__29;
 FUNCTION_TABLE[638] = tflite__ops__micro__pooling__Prepare_28TfLiteContext__2c_20TfLiteNode__29;
 FUNCTION_TABLE[639] = tflite__ops__micro__pooling__Init_28TfLiteContext__2c_20char_20const__2c_20unsigned_20long_29;
 FUNCTION_TABLE[640] = tflite__ops__micro__pooling__MaxEval_28TfLiteContext__2c_20TfLiteNode__29;
 FUNCTION_TABLE[641] = tflite__ops__micro__activations__SoftmaxEval_28TfLiteContext__2c_20TfLiteNode__29;
 FUNCTION_TABLE[642] = tflite__ops__micro__activations__SoftmaxPrepare_28TfLiteContext__2c_20TfLiteNode__29;
 FUNCTION_TABLE[643] = tflite__ops__micro__activations__SoftmaxInit_28TfLiteContext__2c_20char_20const__2c_20unsigned_20long_29;
 FUNCTION_TABLE[644] = tflite__ops__micro__fully_connected__Eval_28TfLiteContext__2c_20TfLiteNode__29;
 FUNCTION_TABLE[645] = tflite__ops__micro__fully_connected__Prepare_28TfLiteContext__2c_20TfLiteNode__29;
 FUNCTION_TABLE[646] = tflite__ops__micro__pooling__Init_28TfLiteContext__2c_20char_20const__2c_20unsigned_20long_29;
 FUNCTION_TABLE[647] = tflite__ops__micro__quantize__Eval_28TfLiteContext__2c_20TfLiteNode__29;
 FUNCTION_TABLE[648] = tflite__ops__micro__quantize__Prepare_28TfLiteContext__2c_20TfLiteNode__29;
 FUNCTION_TABLE[649] = tflite__ops__micro__pooling__Init_28TfLiteContext__2c_20char_20const__2c_20unsigned_20long_29;
 FUNCTION_TABLE[650] = tflite__ops__micro__dequantize__Eval_28TfLiteContext__2c_20TfLiteNode__29;
 FUNCTION_TABLE[651] = tflite__ops__micro__dequantize__Prepare_28TfLiteContext__2c_20TfLiteNode__29;
 FUNCTION_TABLE[652] = tflite__ops__micro__pooling__Init_28TfLiteContext__2c_20char_20const__2c_20unsigned_20long_29;
 FUNCTION_TABLE[653] = tflite__ops__micro__reshape__Eval_28TfLiteContext__2c_20TfLiteNode__29;
 FUNCTION_TABLE[654] = tflite__ops__micro__reshape__Prepare_28TfLiteContext__2c_20TfLiteNode__29;
 FUNCTION_TABLE[655] = tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29;
 FUNCTION_TABLE[656] = tflite__BuiltinDataAllocator___BuiltinDataAllocator_28_29_1;
 FUNCTION_TABLE[657] = tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator___MicroBuiltinDataAllocator_28_29;
 FUNCTION_TABLE[658] = tflite__GreedyMemoryPlanner___GreedyMemoryPlanner_28_29_1;
 FUNCTION_TABLE[659] = tflite__GreedyMemoryPlanner__AddBuffer_28tflite__ErrorReporter__2c_20int_2c_20int_2c_20int_29;
 FUNCTION_TABLE[660] = tflite__GreedyMemoryPlanner__GetMaximumMemorySize_28_29;
 FUNCTION_TABLE[661] = tflite__SimpleMemoryAllocator__GetBufferHead_28_29_20const;
 FUNCTION_TABLE[662] = tflite__GreedyMemoryPlanner__GetOffsetForBuffer_28tflite__ErrorReporter__2c_20int_2c_20int__29;
 FUNCTION_TABLE[663] = tflite__ParseDepthwiseConv2D_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29;
 FUNCTION_TABLE[664] = tflite__ParseConv2D_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29;
 FUNCTION_TABLE[665] = tflite__ParsePool_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29;
 FUNCTION_TABLE[666] = tflite__ParseFullyConnected_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29;
 FUNCTION_TABLE[667] = tflite__ParseSoftmax_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29;
 FUNCTION_TABLE[668] = tflite__ParseDequantize_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29;
 FUNCTION_TABLE[669] = tflite__ParseDequantize_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29;
 FUNCTION_TABLE[670] = tflite__ParseReshape_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29;
 FUNCTION_TABLE[671] = tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator___MicroBuiltinDataAllocator_28_29;
 FUNCTION_TABLE[672] = tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator___MicroBuiltinDataAllocator_28_29_1;
 FUNCTION_TABLE[673] = tflite__EspruinoErrorReporter__Report_28char_20const__2c_20void__29;
 FUNCTION_TABLE[674] = tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29;
 FUNCTION_TABLE[675] = tflite__BuiltinDataAllocator___BuiltinDataAllocator_28_29_1;
 FUNCTION_TABLE[676] = tflite__MicroOpResolver__FindOp_28tflite__BuiltinOperator_2c_20int_29_20const;
 FUNCTION_TABLE[677] = tflite__MicroOpResolver__FindOp_28char_20const__2c_20int_29_20const;
 FUNCTION_TABLE[678] = tflite__OpResolver__GetDelegates_28int_29_20const;
 FUNCTION_TABLE[679] = tflite__MicroMutableOpResolver_9u____MicroMutableOpResolver_28_29;
 FUNCTION_TABLE[680] = tflite__MicroMutableOpResolver_9u____MicroMutableOpResolver_28_29_1;
 FUNCTION_TABLE[681] = tflite__MicroMutableOpResolver_9u___FindOp_28tflite__BuiltinOperator_29_20const;
 FUNCTION_TABLE[682] = tflite__MicroMutableOpResolver_9u___FindOp_28char_20const__29_20const;
 FUNCTION_TABLE[683] = tflite__MicroMutableOpResolver_9u___GetOpDataParser_28tflite__BuiltinOperator_29_20const;
 FUNCTION_TABLE[684] = tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator___MicroBuiltinDataAllocator_28_29;
 FUNCTION_TABLE[685] = tflite__BuiltinDataAllocator___BuiltinDataAllocator_28_29_1;
 FUNCTION_TABLE[686] = tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29;
 FUNCTION_TABLE[687] = tflite__BuiltinDataAllocator___BuiltinDataAllocator_28_29_1;
 FUNCTION_TABLE[688] = fmt_fp;
 FUNCTION_TABLE[689] = pop_arg_long_double;
 FUNCTION_TABLE[690] = __stdio_close;
 FUNCTION_TABLE[691] = __stdio_write;
 FUNCTION_TABLE[692] = __stdio_seek;
 function __wasm_memory_size() {
  return buffer.byteLength / 65536 | 0;
}
 
 return {
  "__wasm_call_ctors": __wasm_call_ctors, 
  "jshPushIOCharEvent": jshPushIOCharEvent, 
  "jshGetCharToTransmit": jshGetCharToTransmit, 
  "jshGetDeviceToTransmit": jshGetDeviceToTransmit, 
  "jsGfxChanged": jsGfxChanged, 
  "jsGfxGetPtr": jsGfxGetPtr, 
  "malloc": dlmalloc, 
  "free": dlfree, 
  "jsInit": jsInit, 
  "jsIdle": jsIdle, 
  "jsSendPinWatchEvent": jsSendPinWatchEvent, 
  "jsSendTouchEvent": jsSendTouchEvent, 
  "jsKill": jsKill, 
  "htons": htons, 
  "ntohs": htons, 
  "htonl": htonl, 
  "fflush": fflush, 
  "__errno_location": __errno_location, 
  "_ZSt18uncaught_exceptionv": gen_jswrap_Graphics_Graphics, 
  "setThrew": setThrew, 
  "emscripten_builtin_memalign": dlmemalign, 
  "stackSave": stackSave, 
  "stackAlloc": stackAlloc, 
  "stackRestore": stackRestore, 
  "__growWasmMemory": __growWasmMemory, 
  "dynCall_iii": dynCall_iii, 
  "dynCall_vii": dynCall_vii, 
  "dynCall_ii": dynCall_ii, 
  "dynCall_viii": dynCall_viii, 
  "dynCall_vi": dynCall_vi, 
  "dynCall_viiii": dynCall_viiii, 
  "dynCall_i": dynCall_i, 
  "dynCall_iiii": dynCall_iiii, 
  "dynCall_d": dynCall_d, 
  "dynCall_di": dynCall_di, 
  "dynCall_vidi": dynCall_vidi, 
  "dynCall_vid": dynCall_vid, 
  "dynCall_v": dynCall_v, 
  "dynCall_iidi": dynCall_iidi, 
  "dynCall_vd": dynCall_vd, 
  "dynCall_iid": dynCall_iid, 
  "dynCall_idddi": dynCall_idddi, 
  "dynCall_dddd": dynCall_dddd, 
  "dynCall_diii": dynCall_diii, 
  "dynCall_vdi": dynCall_vdi, 
  "dynCall_did": dynCall_did, 
  "dynCall_iiiiii": dynCall_iiiiii, 
  "dynCall_iiiii": dynCall_iiiii, 
  "dynCall_dii": dynCall_dii, 
  "dynCall_diiii": dynCall_diiii, 
  "dynCall_diiiii": dynCall_diiiii, 
  "dynCall_viid": dynCall_viid, 
  "dynCall_viiiii": dynCall_viiiii, 
  "dynCall_viidi": dynCall_viidi, 
  "dynCall_dd": dynCall_dd, 
  "dynCall_ddd": dynCall_ddd, 
  "dynCall_id": dynCall_id, 
  "dynCall_viiiiiii": dynCall_viiiiiii, 
  "dynCall_viiiiii": dynCall_viiiiii, 
  "dynCall_iiiiiii": dynCall_iiiiiii, 
  "dynCall_iidiiii": dynCall_iidiiii, 
  "dynCall_jiji": legalstub$dynCall_jiji
};
}

var writeSegment = (
    function(mem) {
      var _mem = new Uint8Array(mem);
      return function(offset, s) {
        var bytes, i;
        if (typeof Buffer === 'undefined') {
          bytes = atob(s);
          for (i = 0; i < bytes.length; i++)
            _mem[offset + i] = bytes.charCodeAt(i);
        } else {
          bytes = Buffer.from(s, 'base64');
          for (i = 0; i < bytes.length; i++)
            _mem[offset + i] = bytes[i];
        }
      }
    }
  )(wasmMemory.buffer);
writeSegment(1024, "PCkB");
writeSegment(1040, "MAAAAC5ib290MA==");
writeSegment(1072, "CmV2YWwocmVxdWlyZSgnU3RvcmFnZScpLnJlYWQoJ2Jvb3R1cGRhdGUuanMnKSk7FwIAAC5ib290Y2Rl");
writeSegment(1152, "CqxjbG9ja0FwcD0ocmVxdWlyZSgiU3RvcmFnZSIpLnJlYWRKU09OKCJzZXR0aW5nLmpzb24iLDEpoHt9KS5jbG9jazsKoyhjbG9ja0FwcCljbG9ja0FwcD1yZXF1aXJlKCJTdG9yYWdlIikucmVhZChjbG9ja0FwcCk7CqMoIWNsb2NrQXBwKXtjbG9ja0FwcD1yZXF1aXJlKCJTdG9yYWdlIikubGlzdCgvXC5pbmZvJC8pLm1hcChmaWxlonuuYXBwPXJlcXVpcmUoIlN0b3JhZ2UiKS5yZWFkSlNPTihmaWxlLDEpO6MoYXBwnmFwcC50eXBliiJjbG9jayIpe6thcHA7fX0pLmZpbHRlcih4ongpLnNvcnQoKGEsYimiYS5zb3J0b3JkZXItYi5zb3J0b3JkZXIpWzBdO6MoY2xvY2tBcHApY2xvY2tBcHA9cmVxdWlyZSgiU3RvcmFnZSIpLnJlYWQoY2xvY2tBcHAuc3JjKTt9CqMoIWNsb2NrQXBwKWNsb2NrQXBwPWBFLnNob3dNZXNzYWdlKCJObyBDbG9jayBGb3VuZCIpO3NldFdhdGNoKCgpPT57QmFuZ2xlLnNob3dMYXVuY2hlcigpO30sIEJUTjIsIHtyZXBlYXQ6ZmFsc2UsZWRnZToiZmFsbGluZyJ9KTtgOwpldmFsKGNsb2NrQXBwKTsKvmNsb2NrQXBwO/9CHwAAYm9vdHVwZGF0ZS5qcw==");
writeSegment(1720, "CkUuc2hvd01lc3NhZ2UoIlVwZGF0aW5nIGJvb3QwLi4uIik7CqxzPXJlcXVpcmUoJ1N0b3JhZ2UnKS5yZWFkSlNPTignc2V0dGluZy5qc29uJywxKaB7fTsKrEJBTkdMRUpTMj1wcm9jZXNzLmVudi5IV1ZFUlNJT06KMjsKrGJvb3Q9IiI7CqMocmVxdWlyZSgnU3RvcmFnZScpLmhhc2gpe6xDUkM9RS5DUkMzMihyZXF1aXJlKCdTdG9yYWdlJykucmVhZCgnc2V0dGluZy5qc29uJykpK3JlcXVpcmUoJ1N0b3JhZ2UnKS5oYXNoKC9cLmJvb3RcLmpzLyk7Ym9vdJZgaWYgKEUuQ1JDMzIocmVxdWlyZSgnU3RvcmFnZScpLnJlYWQoJ3NldHRpbmcuanNvbicpKStyZXF1aXJlKCdTdG9yYWdlJykuaGFzaCgvXFwuYm9vdFxcLmpzLykhPSR7Q1JDfSlgO32ke6xDUkM9RS5DUkMzMihyZXF1aXJlKCdTdG9yYWdlJykucmVhZCgnc2V0dGluZy5qc29uJykpK0UuQ1JDMzIocmVxdWlyZSgnU3RvcmFnZScpLmxpc3QoL1wuYm9vdFwuanMvKSk7Ym9vdJZgaWYgKEUuQ1JDMzIocmVxdWlyZSgnU3RvcmFnZScpLnJlYWQoJ3NldHRpbmcuanNvbicpKStFLkNSQzMyKHJlcXVpcmUoJ1N0b3JhZ2UnKS5saXN0KC9cXC5ib290XFwuanMvKSkhPSR7Q1JDfSlgO31ib290lmAgeyBldmFsKHJlcXVpcmUoJ1N0b3JhZ2UnKS5yZWFkKCdib290dXBkYXRlLmpzJykpOyB0aHJvdyAiU3RvcmFnZSBVcGRhdGVkISJ9XG5gO2Jvb3SWYEUuc2V0RmxhZ3Moe3ByZXRva2VuaXNlOjF9KTtcbmA7Ym9vdJZgdmFyIGJsZVNlcnZpY2VzID0ge30sIGJsZVNlcnZpY2VPcHRpb25zID0geyB1YXJ0IDogdHJ1ZX07XG5gO6Mocy5ibGWNtSl7oyhzLkhJRCl7oyhzLkhJRIoiam95Iilib290lmBCYW5nbGUuSElEID0gRS50b1VpbnQ4QXJyYXkoYXRvYigiQlFFSkJLRUJDUUdoQUFVSkdRRXBCUlVBSlFHVkJYVUJnUUtWQTNVQmdRTUZBUWt3Q1RFVmdTVi9kUWlWQW9FQ3dNQT0iKSk7YDukoyhzLkhJRIoia2IiKWJvb3SWYEJhbmdsZS5ISUQgPSBFLnRvVWludDhBcnJheShhdG9iKCJCUUVKQnFFQkJRY1o0Q25uRlFBbEFYVUJsUWlCQXBVQmRRaUJBWlVGZFFFRkNCa0JLUVdSQXBVQmRRT1JBWlVHZFFnVkFDVnpCUWNaQUNsemdRQUpCUlVBSnY4QWRRaVZBckVDd0E9PSIpKTtgpGJvb3SWYEJhbmdsZS5ISUQgPSBFLnRvVWludDhBcnJheShhdG9iKCJCUUVKQnFFQmhRSUZCeG5nS2VjVkFDVUJkUUdWQ0lFQ2xRRjFDSUVCbFFWMUFRVUlHUUVwQlpFQ2xRRjFBNUVCbFFaMUNCVUFKWE1GQnhrQUtYT0JBQWtGRlFBbS93QjFDSlVDc1FMQUJRd0pBYUVCaFFFVkFDVUJkUUdWQVFtMWdRSUp0b0VDQ2JlQkFnbTRnUUlKellFQ0NlS0JBZ25wZ1FJSjZvRUN3QT09IikpO2A7Ym9vdJZgYmxlU2VydmljZU9wdGlvbnMuaGlkPUJhbmdsZS5ISUQ7XG5gO319oyhzLmxvZ4oyKXtib290lmBfREJHTE9HPXJlcXVpcmUoIlN0b3JhZ2UiKS5vcGVuKCJsb2cudHh0IiwiYSIpOwpgO32jKHMuYmxlcmVwbIu1KXujKHMubG9nijIpYm9vdJZgX0RCR0xPRz1yZXF1aXJlKCJTdG9yYWdlIikub3BlbigibG9nLnR4dCIsImEiKTsKTG9vcGJhY2tCLm9uKCdkYXRhJyxmdW5jdGlvbihkKSB7X0RCR0xPRy53cml0ZShkKTtUZXJtaW5hbC53cml0ZShkKTt9KTsKTG9vcGJhY2tBLnNldENvbnNvbGUodHJ1ZSk7XG5gO6SjKHMubG9nKWJvb3SWYFRlcm1pbmFsLnNldENvbnNvbGUodHJ1ZSk7XG5gO6Rib290lmBFLnNldENvbnNvbGUobnVsbCx7Zm9yY2U6dHJ1ZX0pO1xuYDtib290lmAKQmx1ZXRvb3RoLmxpbmU9IiI7CkJsdWV0b290aC5vbignZGF0YScsZnVuY3Rpb24oZCkgewogIHZhciBsID0gKEJsdWV0b290aC5saW5lICsgZCkuc3BsaXQoIlxuIik7CiAgQmx1ZXRvb3RoLmxpbmUgPSBsLnBvcCgpOwogIGwuZm9yRWFjaChuPT5CbHVldG9vdGguZW1pdCgibGluZSIsbikpOwp9KTsKQmx1ZXRvb3RoLm9uKCdsaW5lJyxmdW5jdGlvbihsKSB7CiAgaWYgKGwuc3RhcnRzV2l0aCgnXHgxMCcpKSBsPWwuc2xpY2UoMSk7CiAgaWYgKGwuc3RhcnRzV2l0aCgnR0IoeycpICYmIGwuZW5kc1dpdGgoJ30pJykgJiYgZ2xvYmFsLkdCKQogICAgdHJ5IHsgZ2xvYmFsLkdCKEpTT04ucGFyc2UobC5zbGljZSgzLC0xKSkpOyB9IGNhdGNoKGUpIHt9Cn0pO1xuYDt9pHujKHMubG9nijIpYm9vdJZgX0RCR0xPRz1yZXF1aXJlKCJTdG9yYWdlIikub3BlbigibG9nLnR4dCIsImEiKTsKTG9vcGJhY2tCLm9uKCdkYXRhJyxmdW5jdGlvbihkKSB7X0RCR0xPRy53cml0ZShkKTtUZXJtaW5hbC53cml0ZShkKTt9KTsKaWYgKCFOUkYuZ2V0U2VjdXJpdHlTdGF0dXMoKS5jb25uZWN0ZWQpIExvb3BiYWNrQS5zZXRDb25zb2xlKCk7XG5gO6SjKHMubG9nKWJvb3SWYGlmICghTlJGLmdldFNlY3VyaXR5U3RhdHVzKCkuY29ubmVjdGVkKSBUZXJtaW5hbC5zZXRDb25zb2xlKCk7XG5gO6Rib290lmBCbHVldG9vdGguc2V0Q29uc29sZSh0cnVlKTtcbmA7faMocy5ibGWLtSlib290lmBpZiAoIU5SRi5nZXRTZWN1cml0eVN0YXR1cygpLmNvbm5lY3RlZCkgTlJGLnNsZWVwKCk7XG5gO6Mocy50aW1lb3V0jbcpYm9vdJZgQmFuZ2xlLnNldExDRFRpbWVvdXQoJHtzLnRpbWVvdXR9KTtcbmA7oyghcy50aW1lb3V0KWJvb3SWYEJhbmdsZS5zZXRMQ0RQb3dlcigxKTtcbmA7Ym9vdJZgRS5zZXRUaW1lWm9uZSgke3MudGltZXpvbmV9KTtgO6MoIUJhbmdsZS5GX0JFRVBTRVQpe6MoIXMudmlicmF0ZSlib290lmBCYW5nbGUuYnV6ej1Qcm9taXNlLnJlc29sdmU7XG5goyhzLmJlZXCLtSlib290lmBCYW5nbGUuYmVlcD1Qcm9taXNlLnJlc29sdmU7XG5gpKMocy5iZWVwiiJ2aWIiniFCQU5HTEVKUzIpYm9vdJZgQmFuZ2xlLmJlZXAgPSBmdW5jdGlvbiAodGltZSwgZnJlcSkgewogICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHsKICAgICAgaWYgKCgwfGZyZXEpPD0wKSBmcmVxPTQwMDA7CiAgICAgIGlmICgoMHx0aW1lKTw9MCkgdGltZT0yMDA7CiAgICAgIGlmICh0aW1lPjUwMDApIHRpbWU9NTAwMDsKICAgICAgYW5hbG9nV3JpdGUoRDEzLDAuMSx7ZnJlcTpmcmVxfSk7CiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAgICAgICAgZGlnaXRhbFdyaXRlKEQxMywwKTsKICAgICAgICByZXNvbHZlKCk7CiAgICAgIH0sIHRpbWUpOwogICAgfSk7CiAgfTtcbmA7fWJvb3SWYEUub24oJ2Vycm9yRmxhZycsIGZ1bmN0aW9uKGVycm9yRmxhZ3MpIHsKICBnLnJlc2V0KDEpLnNldENvbG9yKCIjZmYwMDAwIikuc2V0Rm9udCgiNng4Iikuc2V0Rm9udEFsaWduKDAsMSkuZHJhd1N0cmluZyhlcnJvckZsYWdzLGcuZ2V0V2lkdGgoKS8yLGcuZ2V0SGVpZ2h0KCktMSkuZmxpcCgpOwogIHByaW50KCJJbnRlcnByZXRlciBlcnJvcjoiLCBlcnJvckZsYWdzKTsKICBFLmdldEVycm9yRmxhZ3MoKTsgLy8gY2xlYXIgZmxhZ3Mgc28gd2UgZ2V0IGNhbGxlZCBuZXh0IHRpbWUKfSk7XG5gO6MoZ2xvYmFsLnNhdmUpYm9vdJZgZ2xvYmFsLnNhdmUgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKCJZb3UgY2FuJ3QgdXNlIHNhdmUoKSBvbiBCYW5nbGUuanMgd2l0aG91dCBvdmVyd3JpdGluZyB0aGUgYm9vdGxvYWRlciEiKTsgfVxuYDujKHMub3B0aW9ucylib290lmBCYW5nbGUuc2V0T3B0aW9ucygke0UudG9KUyhzLm9wdGlvbnMpfSk7XG5gO6Mocy5icmlnaHRuZXNznnMuYnJpZ2h0bmVzc4wxKWJvb3SWYEJhbmdsZS5zZXRMQ0RCcmlnaHRuZXNzKCR7cy5icmlnaHRuZXNzfSk7XG5gO6Mocy5wYXNza2V5jbeecy5wYXNza2V5Lmxlbmd0aIo2KWJvb3SWYE5SRi5zZXRTZWN1cml0eSh7cGFzc2tleToke0UudG9KUyhzLnBhc3NrZXkudG9TdHJpbmcoKSl9LCBtaXRtOjEsIGRpc3BsYXk6MX0pO1xuYDujKHMud2hpdGVsaXN0KWJvb3SWYE5SRi5vbignY29ubmVjdCcsIGZ1bmN0aW9uKGFkZHIpIHsgaWYgKCEocmVxdWlyZSgnU3RvcmFnZScpLnJlYWRKU09OKCdzZXR0aW5nLmpzb24nLDEpfHx7fSkud2hpdGVsaXN0LmluY2x1ZGVzKGFkZHIpKSBOUkYuZGlzY29ubmVjdCgpOyB9KTtcbmA7vmcudGhlbWU7oyghZy50aGVtZSl7Ym9vdJZgZy50aGVtZT17Zmc6LTEsYmc6MCxmZzI6LTEsYmcyOjcsZmdIOi0xLGJnSDoweDAyRjcsZGFyazp0cnVlfTtcbmA7fb5CYW5nbGUuc2V0VUk7oyghQmFuZ2xlLnNldFVJKXtib290lmBCYW5nbGUuc2V0VUk9ZnVuY3Rpb24obW9kZSwgY2IpIHsKaWYgKEJhbmdsZS5idG5XYXRjaGVzKSB7CiAgQmFuZ2xlLmJ0bldhdGNoZXMuZm9yRWFjaChjbGVhcldhdGNoKTsKICBkZWxldGUgQmFuZ2xlLmJ0bldhdGNoZXM7Cn0KaWYgKEJhbmdsZS5zd2lwZUhhbmRsZXIpIHsKICBCYW5nbGUucmVtb3ZlTGlzdGVuZXIoInN3aXBlIiwgQmFuZ2xlLnN3aXBlSGFuZGxlcik7CiAgZGVsZXRlIEJhbmdsZS5zd2lwZUhhbmRsZXI7Cn0KaWYgKEJhbmdsZS50b3VjaEhhbmRsZXIpIHsKICBCYW5nbGUucmVtb3ZlTGlzdGVuZXIoInRvdWNoIiwgQmFuZ2xlLnRvdWNoSGFuZGxlcik7CiAgZGVsZXRlIEJhbmdsZS50b3VjaEhhbmRsZXI7Cn0KaWYgKCFtb2RlKSByZXR1cm47CmVsc2UgaWYgKG1vZGU9PSJ1cGRvd24iKSB7CiAgQmFuZ2xlLmJ0bldhdGNoZXMgPSBbCiAgICBzZXRXYXRjaChmdW5jdGlvbigpIHsgY2IoLTEpOyB9LCBCVE4xLCB7cmVwZWF0OjF9KSwKICAgIHNldFdhdGNoKGZ1bmN0aW9uKCkgeyBjYigxKTsgfSwgQlROMywge3JlcGVhdDoxfSksCiAgICBzZXRXYXRjaChmdW5jdGlvbigpIHsgY2IoKTsgfSwgQlROMiwge3JlcGVhdDoxfSkKICBdOwp9IGVsc2UgaWYgKG1vZGU9PSJsZWZ0cmlnaHQiKSB7CiAgQmFuZ2xlLmJ0bldhdGNoZXMgPSBbCiAgICBzZXRXYXRjaChmdW5jdGlvbigpIHsgY2IoLTEpOyB9LCBCVE4xLCB7cmVwZWF0OjF9KSwKICAgIHNldFdhdGNoKGZ1bmN0aW9uKCkgeyBjYigxKTsgfSwgQlROMywge3JlcGVhdDoxfSksCiAgICBzZXRXYXRjaChmdW5jdGlvbigpIHsgY2IoKTsgfSwgQlROMiwge3JlcGVhdDoxfSkKICBdOwogIEJhbmdsZS5zd2lwZUhhbmRsZXIgPSBkID0+IHtjYihkKTt9OwogIEJhbmdsZS5vbigic3dpcGUiLCBCYW5nbGUuc3dpcGVIYW5kbGVyKTsKICBCYW5nbGUudG91Y2hIYW5kbGVyID0gZCA9PiB7Y2IoKTt9OwogIEJhbmdsZS5vbigidG91Y2giLCBCYW5nbGUudG91Y2hIYW5kbGVyKTsKfSBlbHNlIGlmIChtb2RlPT0iY2xvY2siKSB7CiAgQmFuZ2xlLkNMT0NLPTE7CiAgQmFuZ2xlLmJ0bldhdGNoZXMgPSBbCiAgICBzZXRXYXRjaChCYW5nbGUuc2hvd0xhdW5jaGVyLCBCVE4yLCB7cmVwZWF0OjEsZWRnZToiZmFsbGluZyJ9KQogIF07Cn0gZWxzZSBpZiAobW9kZT09ImNsb2NrdXBkb3duIikgewogIEJhbmdsZS5DTE9DSz0xOwogIEJhbmdsZS5idG5XYXRjaGVzID0gWwogICAgc2V0V2F0Y2goZnVuY3Rpb24oKSB7IGNiKC0xKTsgfSwgQlROMSwge3JlcGVhdDoxfSksCiAgICBzZXRXYXRjaChmdW5jdGlvbigpIHsgY2IoMSk7IH0sIEJUTjMsIHtyZXBlYXQ6MX0pLAogICAgc2V0V2F0Y2goQmFuZ2xlLnNob3dMYXVuY2hlciwgQlROMiwge3JlcGVhdDoxLGVkZ2U6ImZhbGxpbmcifSkKICBdOwp9IGVsc2UKICB0aHJvdyBuZXcgRXJyb3IoIlVua25vd24gVUkgbW9kZSIpOwp9O1xuYDt9vkUuc2hvd1Njcm9sbGVyO6MoIUUuc2hvd1Njcm9sbGVyKXtib290lmBFLnNob3dTY3JvbGxlciA9IChmdW5jdGlvbihhKXtmdW5jdGlvbiBuKCl7Zy5yZXNldCgpO2I+PWwrYyYmKGM9MStiLWwpO2I8YyYmKGM9Yik7Zy5zZXRDb2xvcihnLnRoZW1lLmZnKTtmb3IodmFyIGQ9MDtkPGw7ZCsrKXt2YXIgbT1kK2M7aWYoMD5tfHxtPj1hLmMpYnJlYWs7dmFyIGY9MjQrZCphLmg7YS5kcmF3KG0se3g6MCx5OmYsdzpoLGg6YS5ofSk7ZCtjPT1iJiZnLnNldENvbG9yKGcudGhlbWUuZmcpLmRyYXdSZWN0KDAsZixoLTEsZithLmgtMSkuZHJhd1JlY3QoMSxmKzEsaC0yLGYrYS5oLTIpfWcuc2V0Q29sb3IoYz9nLnRoZW1lLmZnOmcudGhlbWUuYmcpO2cuZmlsbFBvbHkoW2UsNixlLTE0LDIwLGUrMTQsMjBdKTtnLnNldENvbG9yKGEuYz5sK2M/Zy50aGVtZS5mZzpnLnRoZW1lLmJnKTtnLmZpbGxQb2x5KFtlLGstNyxlLTE0LGstMjEsZSsxNCxrLTIxXSl9aWYoIWEpcmV0dXJuIEJhbmdsZS5zZXRVSSgpO3ZhciBiPTAsYz0wLGg9Zy5nZXRXaWR0aCgpLAprPWcuZ2V0SGVpZ2h0KCksZT1oLzIsbD1NYXRoLmZsb29yKChrLTQ4KS9hLmgpO2cucmVzZXQoKS5jbGVhclJlY3QoMCwyNCxoLTEsay0xKTtuKCk7QmFuZ2xlLnNldFVJKCJ1cGRvd24iLGQ9PntkPyhiKz1kLDA+YiYmKGI9YS5jLTEpLGI+PWEuYyYmKGI9MCksbigpKTphLnNlbGVjdChiKX0pfSk7XG5gO32+Zy5pbWFnZU1ldHJpY3M7oyghZy5pbWFnZU1ldHJpY3Mpe2Jvb3SWYEdyYXBoaWNzLnByb3RvdHlwZS5pbWFnZU1ldHJpY3M9ZnVuY3Rpb24oc3JjKSB7CiAgaWYgKHNyY1swXSkgcmV0dXJuIHt3aWR0aDpzcmNbMF0saGVpZ2h0OnNyY1sxXX07CiAgZWxzZSBpZiAoJ29iamVjdCc9PXR5cGVvZiBzcmMpIHJldHVybiB7CiAgICB3aWR0aDooIndpZHRoIiBpbiBzcmMpID8gc3JjLndpZHRoIDogc3JjLmdldFdpZHRoKCksCiAgICBoZWlnaHQ6KCJoZWlnaHQiIGluIHNyYykgPyBzcmMuaGVpZ2h0IDogc3JjLmdldEhlaWdodCgpfTsKICB2YXIgaW0gPSBFLnRvU3RyaW5nKHNyYyk7CiAgcmV0dXJuIHt3aWR0aDppbS5jaGFyQ29kZUF0KDApLCBoZWlnaHQ6aW0uY2hhckNvZGVBdCgxKX07Cn07XG5gO32+Zy5zdHJpbmdNZXRyaWNzO6MoIWcuc3RyaW5nTWV0cmljcyl7Ym9vdJZgR3JhcGhpY3MucHJvdG90eXBlLnN0cmluZ01ldHJpY3M9ZnVuY3Rpb24odHh0KSB7CiAgdHh0ID0gdHh0LnRvU3RyaW5nKCkuc3BsaXQoIlxcbiIpOwogIHJldHVybiB7d2lkdGg6TWF0aC5tYXguYXBwbHkobnVsbCx0eHQubWFwKHg9Pmcuc3RyaW5nV2lkdGgoeCkpKSwgaGVpZ2h0OnRoaXMuZ2V0Rm9udEhlaWdodCgpKnR4dC5sZW5ndGh9Owp9O1xuYDt9vmcud3JhcFN0cmluZzujKCFnLndyYXBTdHJpbmcpe2Jvb3SWYEdyYXBoaWNzLnByb3RvdHlwZS53cmFwU3RyaW5nPWZ1bmN0aW9uKHN0ciwgbWF4V2lkdGgpIHsKICB2YXIgbGluZXMgPSBbXTsKICBmb3IgKHZhciB1bndyYXBwZWRMaW5lIG9mIHN0ci5zcGxpdCgiXFxuIikpIHsKICAgIHZhciB3b3JkcyA9IHVud3JhcHBlZExpbmUuc3BsaXQoIiAiKTsKICAgIHZhciBsaW5lID0gd29yZHMuc2hpZnQoKTsKICAgIGZvciAodmFyIHdvcmQgb2Ygd29yZHMpIHsKICAgICAgaWYgKGcuc3RyaW5nV2lkdGgobGluZSArICIgIiArIHdvcmQpID4gbWF4V2lkdGgpIHsKICAgICAgICBsaW5lcy5wdXNoKGxpbmUpOwogICAgICAgIGxpbmUgPSB3b3JkOwogICAgICB9IGVsc2UgewogICAgICAgIGxpbmUgKz0gIiAiICsgd29yZDsKICAgICAgfQogICAgfQogICAgbGluZXMucHVzaChsaW5lKTsKICB9CiAgcmV0dXJuIGxpbmVzOwp9O1xuYDt9vkJhbmdsZS5hcHBSZWN0O6MoIUJhbmdsZS5hcHBSZWN0KXtib290lmBCYW5nbGUuYXBwUmVjdCA9ICgoeSx3LGgpPT4oe3g6MCx5OjAsdzp3LGg6aCx4Mjp3LTEseTI6aC0xfSkpKGcuZ2V0V2lkdGgoKSxnLmdldEhlaWdodCgpKTsKICAobHc9PnsgQmFuZ2xlLmxvYWRXaWRnZXRzID0gKCkgPT4geyBsdygpOyBCYW5nbGUuYXBwUmVjdCA9ICgoeSx3LGgpPT4oe3g6MCx5Onksdzp3LGg6aC15LHgyOnctMSx5MjpoLSgxK2gpfSkpKGdsb2JhbC5XSURHRVRTPzI0OjAsZy5nZXRXaWR0aCgpLGcuZ2V0SGVpZ2h0KCkpOyB9OyB9KShCYW5nbGUubG9hZFdpZGdldHMpO1xuYDt9cmVxdWlyZSgnU3RvcmFnZScpLmxpc3QoL1wuYm9vdFwuanMvKS5mb3JFYWNoKGJvb3RGaWxlontib290liIvLyIrYm9vdEZpbGUrIlxuIityZXF1aXJlKCdTdG9yYWdlJykucmVhZChib290RmlsZSkrIjtcbiI7fSk7Ym9vdJZgTlJGLnNldFNlcnZpY2VzKGJsZVNlcnZpY2VzLCBibGVTZXJ2aWNlT3B0aW9ucyk7ZGVsZXRlIGJsZVNlcnZpY2VzLGJsZVNlcnZpY2VPcHRpb25zO1xuYDtyZXF1aXJlKCdTdG9yYWdlJykud3JpdGUoJy5ib290MCcsYm9vdCk7vmJvb3Q7RS5zaG93TWVzc2FnZSgiUmVsb2FkaW5nLi4uIik7ZXZhbChyZXF1aXJlKCdTdG9yYWdlJykucmVhZCgnLmJvb3QwJykpO///nQAAAGJvb3QuaW5mbw==");
writeSegment(9756, "eyJpZCI6ImJvb3QiLCJuYW1lIjoiQm9vdGxvYWRlciIsInR5cGUiOiJib290bG9hZGVyIiwic29ydG9yZGVyIjotMTAsInZlcnNpb24iOiIwLjM5IiwidGFncyI6InRvb2wsc3lzdGVtIiwiZmlsZXMiOiJib290LmluZm8sLmJvb3QwLC5ib290Y2RlLGJvb3R1cGRhdGUuanMiff///3oGAABsYXVuY2guYXBwLmpz");
writeSegment(9948, "rHM9cmVxdWlyZSgiU3RvcmFnZSIpOwqtZm9udHM9Zy5nZXRGb250cygpOwqsc2NhbGV2YWw9MTsKrHZlY3RvcnZhbD0yMDsKrGZvbnQ9Zy5nZXRGb250cygpLmluY2x1ZGVzKCIxMngyMCIpPyIxMngyMCI6IjZ4ODoyIjsKrXNldHRpbmdzPXJlcXVpcmUoJ1N0b3JhZ2UnKS5yZWFkSlNPTigibGF1bmNoLmpzb24iLLQpoHt9OwqjKCJ2ZWN0b3JzaXplIrlzZXR0aW5ncyl7dmVjdG9ydmFsPXBhcnNlSW50KHNldHRpbmdzLnZlY3RvcnNpemUpO30KoygiZm9udCK5c2V0dGluZ3Mpe6Moc2V0dGluZ3MuZm9udIoiVmVjdG9yIil7c2NhbGV2YWw9dmVjdG9ydmFsLzIwO2ZvbnQ9IlZlY3RvciIrKHZlY3RvcnZhbCkudG9TdHJpbmcoKTt9pHtmb250PXNldHRpbmdzLmZvbnQ7c2NhbGV2YWw9KGZvbnQuc3BsaXQoJ3gnKVsxXSkvMjA7fX0KrGFwcHM9cy5saXN0KC9cLmluZm8kLykubWFwKGFwcKJ7rGE9cy5yZWFkSlNPTihhcHAsMSk7q2Gee25hbWU6YS5uYW1lLHR5cGU6YS50eXBlLGljb246YS5pY29uLHNvcnRvcmRlcjphLnNvcnRvcmRlcixzcmM6YS5zcmN9O30pLmZpbHRlcihhcHCiYXBwnihhcHAudHlwZYoiYXBwIqBhcHAudHlwZYoiY2xvY2sioCFhcHAudHlwZSkpOwphcHBzLnNvcnQoKGEsYimie6xuPSgwfGEuc29ydG9yZGVyKS0oMHxiLnNvcnRvcmRlcik7oyhuKatuO6MoYS5uYW1lPGIubmFtZSmrLTE7oyhhLm5hbWU+Yi5uYW1lKasxO6swO30pOwphcHBzLmZvckVhY2goYXBwonujKGFwcC5pY29uKWFwcC5pY29uPXMucmVhZChhcHAuaWNvbik7fSk7CqMoZy53cmFwU3RyaW5nKXtnLnNldEZvbnQoZm9udCk7YXBwcy5mb3JFYWNoKGFwcKJhcHAubmFtZT1nLndyYXBTdHJpbmcoYXBwLm5hbWUsZy5nZXRXaWR0aCgpLTY0KS5qb2luKCJcbiIpKTt9CqpkcmF3QXBwKGkscil7rGFwcD1hcHBzW2ldO6MoIWFwcCmrO2cuY2xlYXJSZWN0KChyLngpLChyLnkpLChyLngrci53LTEpLChyLnkrci5oLTEpKTtnLnNldEZvbnQoZm9udCkuc2V0Rm9udEFsaWduKC0xLDApLmRyYXdTdHJpbmcoYXBwLm5hbWUsNjQqc2NhbGV2YWwsci55KygzMipzY2FsZXZhbCkpO6MoYXBwLmljb24psXtnLmRyYXdJbWFnZShhcHAuaWNvbiw4KnNjYWxldmFsLHIueSsoOCpzY2FsZXZhbCkse3NjYWxlOnNjYWxldmFsfSk7fWNhdGNoKGUpe319CmcuY2xlYXIoKTsKQmFuZ2xlLmxvYWRXaWRnZXRzKCk7CkJhbmdsZS5kcmF3V2lkZ2V0cygpOwpFLnNob3dTY3JvbGxlcih7aDo2NCpzY2FsZXZhbCxjOmFwcHMubGVuZ3RoLGRyYXc6ZHJhd0FwcCxzZWxlY3Q6aaJ7rGFwcD1hcHBzW2ldO6MoIWFwcCmrO6MoIWFwcC5zcmOgcmVxdWlyZSgiU3RvcmFnZSIpLnJlYWQoYXBwLnNyYymLtyl7RS5zaG93TWVzc2FnZSgiQXBwIFNvdXJjZVxuTm90IGZvdW5kIik7c2V0VGltZW91dChkcmF3TWVudSwyMDAwKTt9pHtFLnNob3dNZXNzYWdlKCJMb2FkaW5nLi4uIik7bG9hZChhcHAuc3JjKTt9fX0pOwpzZXRXYXRjaChfomxvYWQoKSxCVE4xLHtlZGdlOiJmYWxsaW5nIn0pOwpCYW5nbGUuc2V0TG9ja2VkKLUpOwqsbG9ja1RpbWVvdXQ7CkJhbmdsZS5vbignbG9jaycsbG9ja2VkonujKGxvY2tUaW1lb3V0KWNsZWFyVGltZW91dChsb2NrVGltZW91dCk7bG9ja1RpbWVvdXQ9tzujKGxvY2tlZClsb2NrVGltZW91dD1zZXRUaW1lb3V0KF+ibG9hZCgpLDEwMDAwKTt9KTv//zACAABsYXVuY2guc2V0dGluZ3MuanM=");
writeSegment(11640, "KKooYmFjayl7rXNldHRpbmdzPXJlcXVpcmUoJ1N0b3JhZ2UnKS5yZWFkSlNPTignbGF1bmNoLmpzb24nLDEpoHt9O61mb250cz1nLmdldEZvbnRzKCk7qnNhdmUoa2V5LHZhbHVlKXtzZXR0aW5nc1trZXldPXZhbHVlO3JlcXVpcmUoJ1N0b3JhZ2UnKS53cml0ZSgnbGF1bmNoLmpzb24nLHNldHRpbmdzKTt9rmFwcE1lbnU9eycnOnsndGl0bGUnOidMYXVuY2hlciBTZXR0aW5ncyd9LCc8IEJhY2snOmJhY2ssJ0ZvbnQnOnt2YWx1ZTpmb250cy5pbmNsdWRlcyhzZXR0aW5ncy5mb250KT9mb250cy5pbmRleE9mKHNldHRpbmdzLmZvbnQpOmZvbnRzLmluZGV4T2YoIjEyeDIwIiksbWluOjAsbWF4OmZvbnRzLmxlbmd0aC0xLHN0ZXA6MSx3cmFwOrQsb25jaGFuZ2U6KG0pontzYXZlKCdmb250Jyxmb250c1ttXSl9LGZvcm1hdDp2omZvbnRzW3ZdfSwnVmVjdG9yIGZvbnQgc2l6ZSc6e3ZhbHVlOnNldHRpbmdzLnZlY3RvcnNpemWgMTAsbWluOjEwLG1heDoyMCxzdGVwOjEsd3JhcDq0LG9uY2hhbmdlOihtKaJ7c2F2ZSgndmVjdG9yc2l6ZScsbSl9fX07RS5zaG93TWVudShhcHBNZW51KTt9KTvSAAAAbGF1bmNoLmluZm8=");
writeSegment(12232, "eyJpZCI6ImxhdW5jaCIsIm5hbWUiOiJMYXVuY2hlciIsInR5cGUiOiJsYXVuY2giLCJzcmMiOiJsYXVuY2guYXBwLmpzIiwic29ydG9yZGVyIjotMTAsInZlcnNpb24iOiIwLjEwIiwidGFncyI6InRvb2wsc3lzdGVtLGxhdW5jaGVyIiwiZmlsZXMiOiJsYXVuY2guaW5mbyxsYXVuY2guYXBwLmpzLGxhdW5jaC5zZXR0aW5ncy5qcyIsImRhdGEiOiJsYXVuY2guanNvbiJ9//9bGgAAYW50b25jbGsuYXBwLmpz");
writeSegment(12476, "R3JhcGhpY3MucHJvdG90eXBlLnNldEZvbnRBbnRvbj2qKHNjYWxlKXtnLnNldEZvbnRDdXN0b20oYXRvYigiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWYvZ0FBQUFBQUFBQUFmL2dBQUFBQUFBQUFBZi9nQUFBQUFBQUFBQWYvZ0FBQUFBQUFBQUFmL2dBQUFBQUFBQUFBZi9nQUFBQUFBQUFBQWYvZ0FBQUFBQUFBQUFmL2dBQUFBQUFBQUFBZi9nQUFBQUFBQUFBQWYvZ0FBQUFBQUFBQUFmL2dBQUFBQUFBQUFBZi9nQUFBQUFBQUFBQWYvZ0FBQUFBQUFBQUFmL2dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEZ0FBQUFBQUFBQUFBL2dBQUFBQUFBQUFBUC9nQUFBQUFBQUFBSC8vZ0FBQUFBQUFBQi8vL2dBQUFBQUFBQWYvLy9nQUFBQUFBQVAvLy8vZ0FBQUFBQUQvLy8vL2dBQUFBQUEvLy8vLy9nQUFBQUFQLy8vLy8vZ0FBQUFILy8vLy8vL2dBQUFCLy8vLy8vLy9nQUFBZi8vLy8vLy8vZ0FBUC8vLy8vLy8vL2dBRC8vLy8vLy8vLy9BQS8vLy8vLy8vLy9nQUEvLy8vLy8vLy80QUFBLy8vLy8vLy8rQUFBQS8vLy8vLy8vZ0FBQUEvLy8vLy8vd0FBQUFBLy8vLy8vOEFBQUFBQS8vLy8vL0FBQUFBQUEvLy8vL2dBQUFBQUFBLy8vLzRBQUFBQUFBQS8vLytBQUFBQUFBQUEvLy9nQUFBQUFBQUFBLy93QUFBQUFBQUFBQS84QUFBQUFBQUFBQUEvQUFBQUFBQUFBQUFBZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFELy8vLy8vQUFBQUFCLy8vLy8vLzhBQUFBSC8vLy8vLy8vQUFBQWYvLy8vLy8vL3dBQUEvLy8vLy8vLy80QUFCLy8vLy8vLy8vOEFBRC8vLy8vLy8vLytBQUgvLy8vLy8vLy8vQUFQLy8vLy8vLy8vL2dBUC8vLy8vLy8vLy9nQVAvLy8vLy8vLy8vZ0FmLy8vLy8vLy8vL3dBZi8vLy8vLy8vLy93QWYvLy8vLy8vLy8vd0FmLy8vLy8vLy8vL3dBLy84QUFBQUFCLy80QS8vd0FBQUFBQWYvNEEvL2dBQUFBQUFQLzRBLy9nQUFBQUFBUC80QS8vZ0FBQUFBQVAvNEEvL3dBQUFBQUFmLzRBLy8vLy8vLy8vLy80QWYvLy8vLy8vLy8vd0FmLy8vLy8vLy8vL3dBZi8vLy8vLy8vLy93QWYvLy8vLy8vLy8vd0FQLy8vLy8vLy8vL2dBUC8vLy8vLy8vLy9nQUgvLy8vLy8vLy8vQUFILy8vLy8vLy8vL0FBRC8vLy8vLy8vLytBQUIvLy8vLy8vLy84QUFBLy8vLy8vLy8vNEFBQVAvLy8vLy8vL2dBQUFELy8vLy8vLytBQUFBQWYvLy8vLy80QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVAvZ0FBQUFBQUFBQUFQL2dBQUFBQUFBQUFBZi9nQUFBQUFBQUFBQWYvZ0FBQUFBQUFBQUFmL0FBQUFBQUFBQUFBLy9BQUFBQUFBQUFBQS8rQUFBQUFBQUFBQUIvOEFBQUFBQUFBQUFELy8vLy8vLy8vL2dBSC8vLy8vLy8vLy9nQVAvLy8vLy8vLy8vZ0EvLy8vLy8vLy8vL2dBLy8vLy8vLy8vLy9nQS8vLy8vLy8vLy8vZ0EvLy8vLy8vLy8vL2dBLy8vLy8vLy8vLy9nQS8vLy8vLy8vLy8vZ0EvLy8vLy8vLy8vL2dBLy8vLy8vLy8vLy9nQS8vLy8vLy8vLy8vZ0EvLy8vLy8vLy8vL2dBLy8vLy8vLy8vLy9nQS8vLy8vLy8vLy8vZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFILzRBQUFBQi9nQUFELy80QUFBQWYvZ0FBUC8vNEFBQUIvL2dBQS8vLzRBQUFILy9nQUIvLy80QUFBZi8vZ0FELy8vNEFBQS8vL2dBSC8vLzRBQUQvLy9nQVAvLy80QUFILy8vZ0FQLy8vNEFBUC8vL2dBZi8vLzRBQWYvLy9nQWYvLy80QUIvLy8vZ0FmLy8vNEFELy8vL2dBLy8vLzRBSC8vLy9nQS8vLy80QWYvLy8vZ0EvLy8vNEEvLy8vL2dBLy93QUFCLy8vLy9nQS8vZ0FBSC8vLy8vZ0EvL2dBQVAvLy8vL2dBLy9nQUEvLy84Ly9nQS8vZ0FELy8vdy8vZ0EvL3dBLy8vL2cvL2dBLy8vLy8vLy9BLy9nQS8vLy8vLy84QS8vZ0EvLy8vLy8vNEEvL2dBZi8vLy8vL3dBLy9nQWYvLy8vLy9nQS8vZ0FmLy8vLy8rQUEvL2dBUC8vLy8vOEFBLy9nQVAvLy8vLzRBQS8vZ0FILy8vLy9nQUEvL2dBRC8vLy8vQUFBLy9nQUIvLy8vOEFBQS8vZ0FBLy8vL3dBQUEvL2dBQVAvLy9BQUFBLy9nQUFELy84QUFBQS8vZ0FBQVArQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCLytBQUFBQUQvd0FBQi8vOEFBQUFQL3dBQUIvLy9BQUFBLy93QUFCLy8vd0FBQi8vd0FBQi8vLzRBQUQvL3dBQUIvLy84QUFILy93QUFCLy8vK0FBUC8vd0FBQi8vLytBQVAvL3dBQUIvLy8vQUFmLy93QUFCLy8vL0FBZi8vd0FBQi8vLy9nQWYvL3dBQUIvLy8vZ0EvLy93QUFCLy8vL2dBLy8vd0FBQi8vLy9nQS8vL3cvL0FBZi8vd0EvLzRBLy9BQUEvL3dBLy9nQS8vQUFBZi93QS8vZ0IvL2dBQWYvd0EvL2dCLy9nQUFmL3dBLy9nRC8vd0FBLy93QS8vd0gvLzhBQi8vd0EvLy8vLy8vLy8vL2dBLy8vLy8vLy8vLy9nQS8vLy8vLy8vLy8vZ0EvLy8vLy8vLy8vL2dBZi8vLy8vLy8vLy9BQWYvLy8vLy8vLy8vQUFQLy8vLy8vLy8vL0FBUC8vLy8vLy8vLytBQUgvLy8vLy8vLy84QUFILy8vKy8vLy8vNEFBRC8vLytmLy8vL3dBQUEvLy84UC8vLy9nQUFBZi8vNEgvLy8rQUFBQUgvL2dCLy8vd0FBQUFBUDRBQUgvOEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEL3dBQUFBQUFBQUFBLy93QUFBQUFBQUFBUC8vd0FBQUFBQUFBQi8vL3dBQUFBQUFBQWYvLy93QUFBQUFBQUgvLy8vd0FBQUFBQUEvLy8vL3dBQUFBQUFQLy8vLy93QUFBQUFCLy8vLy8vd0FBQUFBZi8vLy8vL3dBQUFBSC8vLy8vLy93QUFBQS8vLy8vLy8vd0FBQVAvLy8vLy8vL3dBQUEvLy8vLy8vSC93QUFBLy8vLy8vd0gvd0FBQS8vLy8vOEFIL3dBQUEvLy8vL0FBSC93QUFBLy8vL2dBQUgvd0FBQS8vLzRBQUFIL3dBQUEvLytBQUFBSC93QUFBLy8vLy8vLy8vLy9nQS8vLy8vLy8vLy8vZ0EvLy8vLy8vLy8vL2dBLy8vLy8vLy8vLy9nQS8vLy8vLy8vLy8vZ0EvLy8vLy8vLy8vL2dBLy8vLy8vLy8vLy9nQS8vLy8vLy8vLy8vZ0EvLy8vLy8vLy8vL2dBLy8vLy8vLy8vLy9nQS8vLy8vLy8vLy8vZ0EvLy8vLy8vLy8vL2dBLy8vLy8vLy8vLy9nQS8vLy8vLy8vLy8vZ0FBQUFBQUFBSC80QUFBQUFBQUFBQUgvd0FBQUFBQUFBQUFIL3dBQUFBQUFBQUFBSC93QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQi8vOEFBQS8vLy8vK0IvLy9BQUEvLy8vLytCLy8vd0FBLy8vLy8rQi8vLzRBQS8vLy8vK0IvLy84QUEvLy8vLytCLy8vOEFBLy8vLy8rQi8vLytBQS8vLy8vK0IvLy8vQUEvLy8vLytCLy8vL0FBLy8vLy8rQi8vLy9BQS8vLy8vK0IvLy8vZ0EvLy8vLytCLy8vL2dBLy8vLy8rQi8vLy9nQS8vLy8vK0EvLy8vZ0EvL2dQL2dBQUIvL3dBLy9nZi9BQUFBLy93QS8vZ2YvQUFBQWYvd0EvL2cvL0FBQUFmL3dBLy9nLy9BQUFBLy93QS8vZy8vZ0FBQS8vd0EvL2cvLytBQVAvL3dBLy9nLy8vLy8vLy9nQS8vZy8vLy8vLy8vZ0EvL2cvLy8vLy8vL2dBLy9nLy8vLy8vLy9nQS8vZy8vLy8vLy8vQUEvL2dmLy8vLy8vL0FBLy9nZi8vLy8vLytBQS8vZ1AvLy8vLy8rQUEvL2dILy8vLy8vOEFBLy9nRC8vLy8vLzRBQS8vZ0IvLy8vLy93QUEvL2dBLy8vLy8vQUFBQUFBQUgvLy8vOEFBQUFBQUFBLy8vL0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFELy8vLy8vZ0FBQUFCLy8vLy8vLytBQUFBSC8vLy8vLy8vZ0FBQWYvLy8vLy8vLzRBQUIvLy8vLy8vLy84QUFELy8vLy8vLy8vK0FBSC8vLy8vLy8vLy9BQUgvLy8vLy8vLy8vZ0FQLy8vLy8vLy8vL2dBUC8vLy8vLy8vLy9nQWYvLy8vLy8vLy8vd0FmLy8vLy8vLy8vL3dBZi8vLy8vLy8vLy93QWYvLy8vLy8vLy8vd0FmLy8vLy8vLy8vLzRBLy93QUQvNEFBZi80QS8vZ0FIL3dBQVAvNEEvL2dBSC93QUFQLzRBLy9nQVAvd0FBUC80QS8vZ0FQLzRBQWYvNEEvL3dBUC8rQUQvLzRBLy8vd1AvLy8vLy80QWYvLzRQLy8vLy8vd0FmLy80UC8vLy8vL3dBZi8vNFAvLy8vLy93QWYvLzRQLy8vLy8vd0FQLy80UC8vLy8vL2dBUC8vNEgvLy8vLy9nQUgvLzRILy8vLy8vQUFILy80RC8vLy8vK0FBRC8vNEQvLy8vLzhBQUIvLzRCLy8vLy80QUFBLy80QS8vLy8vd0FBQVAvNEFQLy8vL0FBQUFCLzRBRC8vLzRBQUFBQUFBQUFILzhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBLy9BQUFBQUFBQUFBQS8vZ0FBQUFBQUFBQUEvL2dBQUFBQUFBQUFBLy9nQUFBQUFBQURnQS8vZ0FBQUFBQVAvZ0EvL2dBQUFBQUgvL2dBLy9nQUFBQUIvLy9nQS8vZ0FBQUFQLy8vZ0EvL2dBQUFELy8vL2dBLy9nQUFBZi8vLy9nQS8vZ0FBQi8vLy8vZ0EvL2dBQVAvLy8vL2dBLy9nQUIvLy8vLy9nQS8vZ0FILy8vLy8vZ0EvL2dBLy8vLy8vL2dBLy9nRC8vLy8vLy9nQS8vZ2YvLy8vLy8vZ0EvL2gvLy8vLy8vL2dBLy9uLy8vLy8vLy9nQS8vLy8vLy8vLy9nQUEvLy8vLy8vLy9BQUFBLy8vLy8vLy93QUFBQS8vLy8vLy80QUFBQUEvLy8vLy8vQUFBQUFBLy8vLy8vNEFBQUFBQS8vLy8vL0FBQUFBQUEvLy8vLzRBQUFBQUFBLy8vLy9BQUFBQUFBQS8vLy84QUFBQUFBQUEvLy8vZ0FBQUFBQUFBLy8vK0FBQUFBQUFBQS8vLzRBQUFBQUFBQUEvLy9BQUFBQUFBQUFBLy80QUFBQUFBQUFBQS8rQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUQvL2dCLy8vd0FBQUFQLy80SC8vLytBQUFBLy8vOFAvLy8vZ0FBQi8vLytmLy8vLzRBQUQvLy8rLy8vLy84QUFILy8vLy8vLy8vK0FBSC8vLy8vLy8vLy9BQVAvLy8vLy8vLy8vZ0FQLy8vLy8vLy8vL2dBZi8vLy8vLy8vLy9nQWYvLy8vLy8vLy8vd0FmLy8vLy8vLy8vL3dBZi8vLy8vLy8vLy93QS8vLy8vLy8vLy8vd0EvLzRELy93QUIvLzRBLy93Qi8vZ0FBLy80QS8vZ0EvL2dBQWYvNEEvL2dBLy9BQUFmLzRBLy9nQS8vZ0FBZi80QS8vd0IvL2dBQS8vNEEvLy9QLy84QUgvLzRBZi8vLy8vLy8vLy93QWYvLy8vLy8vLy8vd0FmLy8vLy8vLy8vL3dBZi8vLy8vLy8vLy93QWYvLy8vLy8vLy8vZ0FQLy8vLy8vLy8vL2dBUC8vLy8vLy8vLy9BQUgvLy8vLy8vLy8vQUFELy8vLy8vLy8vK0FBRC8vLysvLy8vLzhBQUIvLy84Zi8vLy93QUFBZi8vNFAvLy8vQUFBQUgvL3dELy8vOEFBQUFBLytBQWYvL0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFILy9nQUFBQUFBQUFCLy8vK0FBLytBQUFBUC8vLy9nQS8vd0FBQWYvLy8vd0EvLzRBQUIvLy8vLzRBLy84QUFELy8vLy84QS8vK0FBRC8vLy8vK0EvLy9BQUgvLy8vLytBLy8vQUFQLy8vLy8vQS8vL2dBUC8vLy8vL0EvLy9nQWYvLy8vLy9BLy8vd0FmLy8vLy8vQS8vL3dBZi8vLy8vL0EvLy93QWYvLy8vLy9BLy8vd0EvLy8vLy8vQUIvLzRBLy80QUQvL0FBUC80QS8vZ0FCLy9BQVAvNEEvL2dBQS8vQUFQLzRBLy9nQUEvK0FBUC80QS8vZ0FCLzhBQVAvNEEvL3dBQi84QUFmLzRBZi8vLy8vLy8vLy93QWYvLy8vLy8vLy8vd0FmLy8vLy8vLy8vL3dBZi8vLy8vLy8vLy93QWYvLy8vLy8vLy8vd0FQLy8vLy8vLy8vL2dBUC8vLy8vLy8vLy9nQUgvLy8vLy8vLy8vQUFILy8vLy8vLy8vK0FBRC8vLy8vLy8vLzhBQUIvLy8vLy8vLy80QUFBZi8vLy8vLy8vd0FBQVAvLy8vLy8vL0FBQUFCLy8vLy8vLzRBQUFBQUQvLy8vL3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFmL0FBQi84QUFBQUFBLy9BQUQvOEFBQUFBQS8vQUFELzhBQUFBQUEvL0FBRC84QUFBQUFBLy9BQUQvOEFBQUFBQS8vQUFELzhBQUFBQUEvL0FBRC84QUFBQUFBLy9BQUQvOEFBQUFBQS8vQUFELzhBQUFBQUEvL0FBRC84QUFBQUFBLy9BQUQvOEFBQUFBQS8vQUFELzhBQUFBQUEvL0FBRC84QUFBQUFBLy9BQUQvOEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUE9PSIpLDQ2LGF0b2IoIkVpQW5HaWNuSnljbkp5Y25Fdz09IiksNzgrKHNjYWxljzgpKygxjzE2KSk7fQqsZHJhd1RpbWVvdXQ7CqpxdWV1ZURyYXcoKXujKGRyYXdUaW1lb3V0KWNsZWFyVGltZW91dChkcmF3VGltZW91dCk7ZHJhd1RpbWVvdXQ9c2V0VGltZW91dCiqKCl7ZHJhd1RpbWVvdXQ9tztkcmF3KCk7fSw2MDAwMC0oRGF0ZS5ub3coKSU2MDAwMCkpO30KqmRyYXcoKXuseD1nLmdldFdpZHRoKCkvMjuseT1nLmdldEhlaWdodCgpLzI7Zy5yZXNldCgpO6xkYXRlPbhEYXRlKCk7rHRpbWVTdHI9cmVxdWlyZSgibG9jYWxlIikudGltZShkYXRlLDEpO6xkYXRlU3RyPXJlcXVpcmUoImxvY2FsZSIpLmRhdGUoZGF0ZSkudG9VcHBlckNhc2UoKTusZG93U3RyPXJlcXVpcmUoImxvY2FsZSIpLmRvdyhkYXRlKS50b1VwcGVyQ2FzZSgpO2cuc2V0Rm9udEFsaWduKDAsMCkuc2V0Rm9udCgiQW50b24iKTtnLmNsZWFyUmVjdCgwLHktNDAsZy5nZXRXaWR0aCgpLHkrMzUpO2cuZHJhd1N0cmluZyh0aW1lU3RyLHgseSk7eZY0MDtnLnNldEZvbnRBbGlnbigwLDApLnNldEZvbnQoIjZ4OCIsMik7Zy5jbGVhclJlY3QoMCx5LTgsZy5nZXRXaWR0aCgpLHkrOCk7Zy5kcmF3U3RyaW5nKGRhdGVTdHIseCx5KTt5ljE2O2cuY2xlYXJSZWN0KDAseS04LGcuZ2V0V2lkdGgoKSx5KzgpO2cuZHJhd1N0cmluZyhkb3dTdHIseCx5KTtxdWV1ZURyYXcoKTt9CmcuY2xlYXIoKTsKZHJhdygpOwpCYW5nbGUub24oJ2xjZFBvd2VyJyxvbqJ7oyhvbil7ZHJhdygpO32ke6MoZHJhd1RpbWVvdXQpY2xlYXJUaW1lb3V0KGRyYXdUaW1lb3V0KTtkcmF3VGltZW91dD23O319KTsKQmFuZ2xlLnNldFVJKCJjbG9jayIpOwpCYW5nbGUubG9hZFdpZGdldHMoKTsKQmFuZ2xlLmRyYXdXaWRnZXRzKCk7/0MCAABhbnRvbmNsay5pbWc=");
writeSegment(19256, "MDAC//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////6v/q///+r6qqr///AP9Av//0DwAAC//5AP0Av//QDwAAC//AAMAAv/0ADwAAC//AAMAAtV0AD1VQD//BAMEAoA0AD//QD//vAO8AsA7wD//AH///AP8AoA/wD//AL///AP8Av//wD/8AP///AP8Av//wD/8Av///AP8Av//wD/0A////AP8Av//wD/wA////AP8Av//wD/wC////AP8AsV/wD/AD////AP8AoA/wD/AH////AP8AsA/wD/AL////AP8AoA/wD+AL////AP8Av//wD9AP////AP8Av//wD8AP////AP8Av//wD8AP////AP8Av//wD8Av////AP8A///wD4Av///////////////////////////////////62tr/66v/r56vv//6297//vv/+qvuv///r9v/6/v/rrq/v//66v//q+v/q66ub//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////7gAAABhbnRvbmNsay5pbmZv");
writeSegment(19868, "eyJpZCI6ImFudG9uY2xrIiwibmFtZSI6IkFudG9uIENsb2NrIiwidHlwZSI6ImNsb2NrIiwic3JjIjoiYW50b25jbGsuYXBwLmpzIiwiaWNvbiI6ImFudG9uY2xrLmltZyIsInZlcnNpb24iOiIwLjAzIiwidGFncyI6ImNsb2NrIiwiZmlsZXMiOiJhbnRvbmNsay5pbmZvLGFudG9uY2xrLmFwcC5qcyxhbnRvbmNsay5pbWciffstAABzZXR0aW5nLmFwcC5qcw==");
writeSegment(20084, "QmFuZ2xlLmxvYWRXaWRnZXRzKCk7CkJhbmdsZS5kcmF3V2lkZ2V0cygpOwquQkFOR0xFSlMyPXByb2Nlc3MuZW52LkhXVkVSU0lPTooyOwquc3RvcmFnZT1yZXF1aXJlKCdTdG9yYWdlJyk7Cq1zZXR0aW5nczsKqnVwZGF0ZVNldHRpbmdzKCl7c3RvcmFnZS53cml0ZSgnc2V0dGluZy5qc29uJyxzZXR0aW5ncyk7fQqqdXBkYXRlT3B0aW9ucygpe3VwZGF0ZVNldHRpbmdzKCk7QmFuZ2xlLnNldE9wdGlvbnMoc2V0dGluZ3Mub3B0aW9ucyl9CqpnVG9JbnRlcm5hbChnKXurZyo4MTkyO30KqmludGVybmFsVG9HKHUpe6t1LzgxOTJ9CqpyZXNldFNldHRpbmdzKCl7c2V0dGluZ3M9e2JsZTq0LGJsZXJlcGw6tCxsb2c6tSxxdWlldDowLHRpbWVvdXQ6MTAsdmlicmF0ZTq0LGJlZXA6QkFOR0xFSlMyP7Q6InZpYiIsdGltZXpvbmU6MCxISUQ6tSxjbG9jazq2LCIxMmhvdXIiOrUsYnJpZ2h0bmVzczoxLG9wdGlvbnM6e3dha2VPbkJUTjE6tCx3YWtlT25CVE4yOrQsd2FrZU9uQlROMzq0LHdha2VPbkZhY2VVcDq1LHdha2VPblRvdWNoOrUsd2FrZU9uVHdpc3Q6tCx0d2lzdFRocmVzaG9sZDo4MTkuMix0d2lzdE1heFk6LTgwMCx0d2lzdFRpbWVvdXQ6MTAwMH0sfTt1cGRhdGVTZXR0aW5ncygpO30Kc2V0dGluZ3M9c3RvcmFnZS5yZWFkSlNPTignc2V0dGluZy5qc29uJywxKTsKoyghc2V0dGluZ3MpcmVzZXRTZXR0aW5ncygpOwquYm9vbEZvcm1hdD12onY/Ik9uIjoiT2ZmIjsKqnNob3dNYWluTWVudSgpe6xiZWVwTWVudUl0ZW07oyhCQU5HTEVKUzIpe2JlZXBNZW51SXRlbT17dmFsdWU6c2V0dGluZ3MuYmVlcIy1LGZvcm1hdDpib29sRm9ybWF0LG9uY2hhbmdlOnaie3NldHRpbmdzLmJlZXA9djt1cGRhdGVTZXR0aW5ncygpO6Moc2V0dGluZ3MuYmVlcCl7YW5hbG9nV3JpdGUoVklCUkFURSwwLjEse2ZyZXE6MjAwMH0pO3NldFRpbWVvdXQoKCmiVklCUkFURS5yZXNldCgpLDIwMCk7fX19O32ke6xiZWVwVj1btSy0LCJ2aWIiXTusYmVlcE49WyJPZmYiLCJQaWV6byIsIlZpYnJhdGUiXTtiZWVwTWVudUl0ZW09e3ZhbHVlOk1hdGgubWF4KDB8YmVlcFYuaW5kZXhPZihzZXR0aW5ncy5iZWVwKSwwKSxtaW46MCxtYXg6YmVlcFYubGVuZ3RoLTEsZm9ybWF0OnaiYmVlcE5bdl0sb25jaGFuZ2U6dqJ7c2V0dGluZ3MuYmVlcD1iZWVwVlt2XTujKHaKMSl7YW5hbG9nV3JpdGUoRDE4LDAuNSx7ZnJlcToyMDAwfSk7c2V0VGltZW91dCgoKaJEMTgucmVzZXQoKSwyMDApO32koyh2ijIpe2FuYWxvZ1dyaXRlKFZJQlJBVEUsMC4xLHtmcmVxOjIwMDB9KTtzZXRUaW1lb3V0KCgpolZJQlJBVEUucmVzZXQoKSwyMDApO311cGRhdGVTZXR0aW5ncygpO319O32ubWFpbm1lbnU9eycnOnsndGl0bGUnOidTZXR0aW5ncyd9LCc8IEJhY2snOigpomxvYWQoKSwnQXBwIFNldHRpbmdzJzooKaJzaG93QXBwU2V0dGluZ3NNZW51KCksJ0JMRSc6KCmic2hvd0JMRU1lbnUoKSwnQmVlcCc6YmVlcE1lbnVJdGVtLCdWaWJyYXRpb24nOnt2YWx1ZTpzZXR0aW5ncy52aWJyYXRlLGZvcm1hdDpib29sRm9ybWF0LG9uY2hhbmdlOigpontzZXR0aW5ncy52aWJyYXRlPSFzZXR0aW5ncy52aWJyYXRlO3VwZGF0ZVNldHRpbmdzKCk7oyhzZXR0aW5ncy52aWJyYXRlKXtWSUJSQVRFLndyaXRlKDEpO3NldFRpbWVvdXQoKCmiVklCUkFURS53cml0ZSgwKSwxMCk7fX19LCJRdWlldCBNb2RlIjp7dmFsdWU6c2V0dGluZ3MucXVpZXR8MCxmb3JtYXQ6dqJbIk9mZiIsIkFsYXJtcyIsIlNpbGVudCJdW3YlM10sb25jaGFuZ2U6dqJ7c2V0dGluZ3MucXVpZXQ9diUzO3VwZGF0ZVNldHRpbmdzKCk7dXBkYXRlT3B0aW9ucygpO6MoInFtc2NoZWQiuVdJREdFVFMpV0lER0VUU1sicW1zY2hlZCJdLmRyYXcoKTt9LH0sJ0xvY2FsZSc6KCmic2hvd0xvY2FsZU1lbnUoKSwnU2VsZWN0IENsb2NrJzooKaJzaG93Q2xvY2tNZW51KCksJ1NldCBUaW1lJzooKaJzaG93U2V0VGltZU1lbnUoKSwnTENEJzooKaJzaG93TENETWVudSgpLCdUaGVtZSc6KCmic2hvd1RoZW1lTWVudSgpLCdVdGlscyc6KCmic2hvd1V0aWxNZW51KCksJ1R1cm4gT2ZmJzooKaJ7oyhCYW5nbGUuc29mdE9mZilCYW5nbGUuc29mdE9mZigpO6RCYW5nbGUub2ZmKCl9LH07q0Uuc2hvd01lbnUobWFpbm1lbnUpO30KqnNob3dCTEVNZW51KCl7rGhpZFY9W7UsImtibWVkaWEiLCJrYiIsImpveSJdO6xoaWROPVsiT2ZmIiwiS2JyZCAmIE1lZGlhIiwiS2JyZCIsIkpveXN0aWNrIl07RS5zaG93TWVudSh7JzwgQmFjayc6KCmic2hvd01haW5NZW51KCksJ01ha2UgQ29ubmVjdGFibGUnOigpom1ha2VDb25uZWN0YWJsZSgpLCdCTEUnOnt2YWx1ZTpzZXR0aW5ncy5ibGUsZm9ybWF0OmJvb2xGb3JtYXQsb25jaGFuZ2U6KCmie3NldHRpbmdzLmJsZT0hc2V0dGluZ3MuYmxlO3VwZGF0ZVNldHRpbmdzKCk7fX0sJ1Byb2dyYW1tYWJsZSc6e3ZhbHVlOnNldHRpbmdzLmJsZXJlcGwsZm9ybWF0OmJvb2xGb3JtYXQsb25jaGFuZ2U6KCmie3NldHRpbmdzLmJsZXJlcGw9IXNldHRpbmdzLmJsZXJlcGw7dXBkYXRlU2V0dGluZ3MoKTt9fSwnSElEJzp7dmFsdWU6TWF0aC5tYXgoMCwwfGhpZFYuaW5kZXhPZihzZXR0aW5ncy5ISUQpKSxtaW46MCxtYXg6Myxmb3JtYXQ6dqJoaWROW3ZdLG9uY2hhbmdlOnaie3NldHRpbmdzLkhJRD1oaWRWW3ZdO3VwZGF0ZVNldHRpbmdzKCk7fX0sJ1Bhc3NrZXkgQkVUQSc6e3ZhbHVlOnNldHRpbmdzLnBhc3NrZXk/c2V0dGluZ3MucGFzc2tleToibm9uZSIsb25jaGFuZ2U6KCmic2V0VGltZW91dChzaG93UGFzc2tleU1lbnUpfSwnV2hpdGVsaXN0Jzp7dmFsdWU6c2V0dGluZ3Mud2hpdGVsaXN0PyhzZXR0aW5ncy53aGl0ZWxpc3QubGVuZ3RoKyIgZGV2cyIpOiJvZmYiLG9uY2hhbmdlOigponNldFRpbWVvdXQoc2hvd1doaXRlbGlzdE1lbnUpfX0pO30KqnNob3dUaGVtZU1lbnUoKXuqY2woeCl7q2cuc2V0Q29sb3IoeCkuZ2V0Q29sb3IoKTt9qnVwZCh0aCl7Zy50aGVtZT10aDtzZXR0aW5ncy50aGVtZT10aDt1cGRhdGVTZXR0aW5ncygpO75nLnJlc2V0O2cuX3Jlc2V0PWcucmVzZXQ7Zy5yZXNldD2qKG4pe6tnLl9yZXNldCgpLnNldENvbG9yKHRoLmZnKS5zZXRCZ0NvbG9yKHRoLmJnKTt9O2cuY2xlYXI9qihuKXujKG4pZy5yZXNldCgpO6tnLmNsZWFyUmVjdCgwLDAsZy5nZXRXaWR0aCgpLGcuZ2V0SGVpZ2h0KCkpO307Zy5jbGVhcigxKTtCYW5nbGUuZHJhd1dpZGdldHMoKTttLmRyYXcoKTt9rG09RS5zaG93TWVudSh7Jyc6e3RpdGxlOidUaGVtZSd9LCc8IEJhY2snOigponNob3dNYWluTWVudSgpLCdEYXJrIEJXJzooKaJ7dXBkKHtmZzpjbCgiI2ZmZiIpLGJnOmNsKCIjMDAwIiksZmcyOmNsKCIjMGZmIiksYmcyOmNsKCIjMDAwIiksZmdIOmNsKCIjZmZmIiksYmdIOmNsKCIjMDBmIiksZGFyazq0fSk7fSwnTGlnaHQgQlcnOigpont1cGQoe2ZnOmNsKCIjMDAwIiksYmc6Y2woIiNmZmYiKSxmZzI6Y2woIiMwMDAiKSxiZzI6Y2woIiNjZmYiKSxmZ0g6Y2woIiMwMDAiKSxiZ0g6Y2woIiMwZmYiKSxkYXJrOrV9KTt9LCdDdXN0b21pemUnOigponNob3dDdXN0b21UaGVtZU1lbnUoKSx9KTuqc2hvd0N1c3RvbVRoZW1lTWVudSgpe6pjdih4KXurZy5zZXRDb2xvcih4KS5nZXRDb2xvcigpO32qc2V0VCh0LHYpe610aD1nLnRoZW1lO3RoW3RdPXY7oyh0iyJiZyIpe3RoWydkYXJrJ109KHaLY3YoIiMwMDAiKSk7fXVwZCh0aCk7fa5yZ2I9e2JsYWNrOiIjMDAwIix3aGl0ZToiI2ZmZiIscmVkOiIjZjAwIixncmVlbjoiIzBmMCIsYmx1ZToiIzAwZiIsY3lhbjoiIzBmZiIsbWFnZW50YToiI2YwZiIseWVsbG93OiIjZmYwIix9O61jb2xvcnM9W10sbmFtZXM9W107pyiuY7lyZ2Ipe25hbWVzLnB1c2goYyk7Y29sb3JzLnB1c2goY3YocmdiW2NdKSk7fapjbih2KXuuaT1jb2xvcnMuaW5kZXhPZih2KTuraY0tMT9uYW1lc1tpXTp2O32tbWVudT17Jyc6e3RpdGxlOidDdXN0b20gVGhlbWUnfSwiPCBCYWNrIjooKaJzaG93VGhlbWVNZW51KCl9O65sYWJlbHM9e2ZnOidGb3JlZ3JvdW5kJyxiZzonQmFja2dyb3VuZCcsZmcyOidGb3JlZ3JvdW5kIDInLGJnMjonQmFja2dyb3VuZCAyJyxmZ0g6J0hpZ2hsaWdodCBGRycsYmdIOidIaWdobGlnaHQgQkcnLH07WyJmZyIsImJnIiwiZmcyIiwiYmcyIiwiZmdIIiwiYmdIIl0uZm9yRWFjaCh0onttZW51W2xhYmVsc1t0XV09e3ZhbHVlOmNvbG9ycy5pbmRleE9mKGcudGhlbWVbdF0pLGZvcm1hdDooKaJjbihnLnRoZW1lW3RdKSxvbmNoYW5nZTqqKHYpe6ModpFjb2xvcnMubGVuZ3RoKXt2PTA7faModjwwKXt2PWNvbG9ycy5sZW5ndGgtMTt9ry52YWx1ZT12O65jPWNvbG9yc1t2XTujKHSLJ2ZnJ55nLnRoZW1lLmJni2Mpc2V0VCgnYmcnLGcudGhlbWUuZmcpO6ModIsnYmcnnmcudGhlbWUuZmeLYylzZXRUKCdmZycsZy50aGVtZS5iZyk7c2V0VCh0LGMpO30sfTt9KTttZW51WyI8IEJhY2siXT0oKaJzaG93VGhlbWVNZW51KCk7bT1FLnNob3dNZW51KG1lbnUpO319CqpzaG93UGFzc2tleU1lbnUoKXusbWVudT17IjwgQmFjayI6KCmic2hvd0JMRU1lbnUoKSwiRGlzYWJsZSI6KCmie3NldHRpbmdzLnBhc3NrZXk9tzt1cGRhdGVTZXR0aW5ncygpO3Nob3dCTEVNZW51KCk7fX07oyghc2V0dGluZ3MucGFzc2tleaBzZXR0aW5ncy5wYXNza2V5Lmxlbmd0aIw2KXtzZXR0aW5ncy5wYXNza2V5PSIxMjM0NTYiO3VwZGF0ZVNldHRpbmdzKCk7facorGk9MDtpPDY7aZgpKKooaSl7bWVudVtgRGlnaXQgJHtpKzF9YF09e3ZhbHVlOjB8c2V0dGluZ3MucGFzc2tleVtpXSxtaW46MCxtYXg6OSxvbmNoYW5nZTp2onuscD1zZXR0aW5ncy5wYXNza2V5LnNwbGl0KCIiKTtwW2ldPXY7c2V0dGluZ3MucGFzc2tleT1wLmpvaW4oIiIpO3VwZGF0ZVNldHRpbmdzKCk7fX07fSkoaSk7CkUuc2hvd01lbnUobWVudSk7Cn2qc2hvd1doaXRlbGlzdE1lbnUoKXsKrG1lbnU9eyI8IEJhY2siOigponNob3dCTEVNZW51KCksIkRpc2FibGUiOigpontzZXR0aW5ncy53aGl0ZWxpc3Q9tzt1cGRhdGVTZXR0aW5ncygpO3Nob3dCTEVNZW51KCk7fX07CqMoc2V0dGluZ3Mud2hpdGVsaXN0KXNldHRpbmdzLndoaXRlbGlzdC5mb3JFYWNoKKooZCl7bWVudVtkLnN1YnN0cigwLDE3KV09qigpe0Uuc2hvd1Byb21wdCgnUmVtb3ZlXG4nK2QpLnRoZW4oKHYponujKHYpe3NldHRpbmdzLndoaXRlbGlzdC5zcGxpY2Uoc2V0dGluZ3Mud2hpdGVsaXN0LmluZGV4T2YoZCksMSk7dXBkYXRlU2V0dGluZ3MoKTt9c2V0VGltZW91dChzaG93V2hpdGVsaXN0TWVudSw1MCk7fSk7fX0pOwptZW51WydBZGQgRGV2aWNlJ109qigpe0Uuc2hvd0FsZXJ0KCJDb25uZWN0IGRldmljZVxudG8gYWRkIHRvXG53aGl0ZWxpc3QiLCJXaGl0ZWxpc3QiKS50aGVuKKooKXtOUkYucmVtb3ZlQWxsTGlzdGVuZXJzKCdjb25uZWN0Jyk7c2hvd1doaXRlbGlzdE1lbnUoKTt9KTtOUkYucmVtb3ZlQWxsTGlzdGVuZXJzKCdjb25uZWN0Jyk7TlJGLm9uKCdjb25uZWN0JyyqKGFkZHIpe6MoIXNldHRpbmdzLndoaXRlbGlzdClzZXR0aW5ncy53aGl0ZWxpc3Q9W107c2V0dGluZ3Mud2hpdGVsaXN0LnB1c2goYWRkcik7dXBkYXRlU2V0dGluZ3MoKTtOUkYucmVtb3ZlQWxsTGlzdGVuZXJzKCdjb25uZWN0Jyk7c2hvd1doaXRlbGlzdE1lbnUoKTt9KTt9OwpFLnNob3dNZW51KG1lbnUpOwp9qnNob3dMQ0RNZW51KCl7Cq5sY2RNZW51PXsnJzp7J3RpdGxlJzonTENEJ30sJzwgQmFjayc6KCmic2hvd01haW5NZW51KCksJ0xDRCBCcmlnaHRuZXNzJzp7dmFsdWU6c2V0dGluZ3MuYnJpZ2h0bmVzcyxtaW46MC4xLG1heDoxLHN0ZXA6MC4xLG9uY2hhbmdlOnaie3NldHRpbmdzLmJyaWdodG5lc3M9dqAxO3VwZGF0ZVNldHRpbmdzKCk7QmFuZ2xlLnNldExDREJyaWdodG5lc3Moc2V0dGluZ3MuYnJpZ2h0bmVzcyk7fX0sJ0xDRCBUaW1lb3V0Jzp7dmFsdWU6c2V0dGluZ3MudGltZW91dCxtaW46MCxtYXg6NjAsc3RlcDo1LG9uY2hhbmdlOnaie3NldHRpbmdzLnRpbWVvdXQ9MHx2O3VwZGF0ZVNldHRpbmdzKCk7QmFuZ2xlLnNldExDRFRpbWVvdXQoc2V0dGluZ3MudGltZW91dCk7fX0sJ1dha2Ugb24gQlROMSc6e3ZhbHVlOnNldHRpbmdzLm9wdGlvbnMud2FrZU9uQlROMSxmb3JtYXQ6Ym9vbEZvcm1hdCxvbmNoYW5nZTooKaJ7c2V0dGluZ3Mub3B0aW9ucy53YWtlT25CVE4xPSFzZXR0aW5ncy5vcHRpb25zLndha2VPbkJUTjE7dXBkYXRlT3B0aW9ucygpO319fTsKoyghQkFOR0xFSlMyKQpPYmplY3QuYXNzaWduKGxjZE1lbnUseydXYWtlIG9uIEJUTjInOnt2YWx1ZTpzZXR0aW5ncy5vcHRpb25zLndha2VPbkJUTjIsZm9ybWF0OmJvb2xGb3JtYXQsb25jaGFuZ2U6KCmie3NldHRpbmdzLm9wdGlvbnMud2FrZU9uQlROMj0hc2V0dGluZ3Mub3B0aW9ucy53YWtlT25CVE4yO3VwZGF0ZU9wdGlvbnMoKTt9fSwnV2FrZSBvbiBCVE4zJzp7dmFsdWU6c2V0dGluZ3Mub3B0aW9ucy53YWtlT25CVE4zLGZvcm1hdDpib29sRm9ybWF0LG9uY2hhbmdlOigpontzZXR0aW5ncy5vcHRpb25zLndha2VPbkJUTjM9IXNldHRpbmdzLm9wdGlvbnMud2FrZU9uQlROMzt1cGRhdGVPcHRpb25zKCk7fX19KTsKT2JqZWN0LmFzc2lnbihsY2RNZW51LHsnV2FrZSBvbiBGYWNlVXAnOnt2YWx1ZTpzZXR0aW5ncy5vcHRpb25zLndha2VPbkZhY2VVcCxmb3JtYXQ6Ym9vbEZvcm1hdCxvbmNoYW5nZTooKaJ7c2V0dGluZ3Mub3B0aW9ucy53YWtlT25GYWNlVXA9IXNldHRpbmdzLm9wdGlvbnMud2FrZU9uRmFjZVVwO3VwZGF0ZU9wdGlvbnMoKTt9fSwnV2FrZSBvbiBUb3VjaCc6e3ZhbHVlOnNldHRpbmdzLm9wdGlvbnMud2FrZU9uVG91Y2gsZm9ybWF0OmJvb2xGb3JtYXQsb25jaGFuZ2U6KCmie3NldHRpbmdzLm9wdGlvbnMud2FrZU9uVG91Y2g9IXNldHRpbmdzLm9wdGlvbnMud2FrZU9uVG91Y2g7dXBkYXRlT3B0aW9ucygpO319LCdXYWtlIG9uIFR3aXN0Jzp7dmFsdWU6c2V0dGluZ3Mub3B0aW9ucy53YWtlT25Ud2lzdCxmb3JtYXQ6Ym9vbEZvcm1hdCxvbmNoYW5nZTooKaJ7c2V0dGluZ3Mub3B0aW9ucy53YWtlT25Ud2lzdD0hc2V0dGluZ3Mub3B0aW9ucy53YWtlT25Ud2lzdDt1cGRhdGVPcHRpb25zKCk7fX0sJ1R3aXN0IFRocmVzaG9sZCc6e3ZhbHVlOmludGVybmFsVG9HKHNldHRpbmdzLm9wdGlvbnMudHdpc3RUaHJlc2hvbGQpLG1pbjotMC41LG1heDowLjUsc3RlcDowLjAxLG9uY2hhbmdlOnaie3NldHRpbmdzLm9wdGlvbnMudHdpc3RUaHJlc2hvbGQ9Z1RvSW50ZXJuYWwodqAwLjEpO3VwZGF0ZU9wdGlvbnMoKTt9fSwnVHdpc3QgTWF4IFknOnt2YWx1ZTpzZXR0aW5ncy5vcHRpb25zLnR3aXN0TWF4WSxtaW46LTE1MDAsbWF4OjE1MDAsc3RlcDoxMDAsb25jaGFuZ2U6dqJ7c2V0dGluZ3Mub3B0aW9ucy50d2lzdE1heFk9dqAtODAwO3VwZGF0ZU9wdGlvbnMoKTt9fSwnVHdpc3QgVGltZW91dCc6e3ZhbHVlOnNldHRpbmdzLm9wdGlvbnMudHdpc3RUaW1lb3V0LG1pbjowLG1heDoyMDAwLHN0ZXA6MTAwLG9uY2hhbmdlOnaie3NldHRpbmdzLm9wdGlvbnMudHdpc3RUaW1lb3V0PXagMTAwMDt1cGRhdGVPcHRpb25zKCk7fX19KTsKq0Uuc2hvd01lbnUobGNkTWVudSkKfapzaG93TG9jYWxlTWVudSgpewqubG9jYWxlbWVudT17Jyc6eyd0aXRsZSc6J0xvY2FsZSd9LCc8IEJhY2snOigponNob3dNYWluTWVudSgpLCdUaW1lIFpvbmUnOnt2YWx1ZTpzZXR0aW5ncy50aW1lem9uZSxtaW46LTExLG1heDoxMyxzdGVwOjAuNSxvbmNoYW5nZTp2ontzZXR0aW5ncy50aW1lem9uZT12oDA7dXBkYXRlU2V0dGluZ3MoKTt9fSwnQ2xvY2sgU3R5bGUnOnt2YWx1ZTohIXNldHRpbmdzWyIxMmhvdXIiXSxmb3JtYXQ6dqJ2PyIxMmhyIjoiMjRociIsb25jaGFuZ2U6dqJ7c2V0dGluZ3NbIjEyaG91ciJdPXY7dXBkYXRlU2V0dGluZ3MoKTt9fX07CqtFLnNob3dNZW51KGxvY2FsZW1lbnUpOwp9qnNob3dVdGlsTWVudSgpewqsbWVudT17Jyc6eyd0aXRsZSc6J1V0aWxpdGllcyd9LCc8IEJhY2snOigponNob3dNYWluTWVudSgpLCdEZWJ1ZyBJbmZvJzp7dmFsdWU6RS5jbGlwKDB8c2V0dGluZ3MubG9nLDAsMiksZm9ybWF0OnaiWyJIaWRlIiwiU2hvdyIsIkxvZyJdW0UuY2xpcCgwfHYsMCwyKV0sb25jaGFuZ2U6dqJ7c2V0dGluZ3MubG9nPXY7dXBkYXRlU2V0dGluZ3MoKTt9fSwnQ29tcGFjdCBTdG9yYWdlJzooKaJ7RS5zaG93TWVzc2FnZSgiQ29tcGFjdGluZy4uLlxuVGFrZXMgYXBwcm94XG4xIG1pbnV0ZSIse3RpdGxlOiJTdG9yYWdlIn0pO3JlcXVpcmUoIlN0b3JhZ2UiKS5jb21wYWN0KCk7c2hvd1V0aWxNZW51KCk7fSwnUmV3cml0ZSBTZXR0aW5ncyc6KCmie3JlcXVpcmUoIlN0b3JhZ2UiKS53cml0ZSgiLmJvb3QwIiwiZXZhbChyZXF1aXJlKCdTdG9yYWdlJykucmVhZCgnYm9vdHVwZGF0ZS5qcycpKTsiKTtsb2FkKCJzZXR0aW5nLmFwcC5qcyIpO30sJ0ZsYXR0ZW4gQmF0dGVyeSc6KCmie0Uuc2hvd01lc3NhZ2UoJ0ZsYXR0ZW5pbmcgYmF0dGVyeSAtIHRoaXMgY2FuIHRha2UgaG91cnMuXG5Mb25nLXByZXNzIGJ1dHRvbiB0byBjYW5jZWwuJyk7QmFuZ2xlLnNldExDRFRpbWVvdXQoMCk7QmFuZ2xlLnNldExDRFBvd2VyKDEpO6MoQmFuZ2xlLnNldEdQU1Bvd2VyKUJhbmdsZS5zZXRHUFNQb3dlcigxLCJmbGF0Iik7oyhCYW5nbGUuc2V0SFJNUG93ZXIpQmFuZ2xlLnNldEhSTVBvd2VyKDEsImZsYXQiKTujKEJhbmdsZS5zZXRDb21wYXNzUG93ZXIpQmFuZ2xlLnNldENvbXBhc3NQb3dlcigxLCJmbGF0Iik7oyhCYW5nbGUuc2V0QmFyb21ldGVyUG93ZXIpQmFuZ2xlLnNldEJhcm9tZXRlclBvd2VyKDEsImZsYXQiKTujKEJhbmdsZS5zZXRIUk1Qb3dlcilCYW5nbGUuc2V0R1BTUG93ZXIoMSwiZmxhdCIpO3NldEludGVydmFsKKooKXusaT0xMDAwO6YoaZkpO30sMSk7fSwnUmVzZXQgU2V0dGluZ3MnOigpontFLnNob3dQcm9tcHQoJ1Jlc2V0IHRvIERlZmF1bHRzPycse3RpdGxlOiJTZXR0aW5ncyJ9KS50aGVuKCh2KaJ7oyh2KXtFLnNob3dNZXNzYWdlKCdSZXNldHRpbmcnKTtyZXNldFNldHRpbmdzKCk7c2V0VGltZW91dChzaG93TWFpbk1lbnUsNTApO32kc2hvd1V0aWxNZW51KCk7fSk7fX07CqMoQmFuZ2xlLmZhY3RvcnlSZXNldCl7bWVudVsnRmFjdG9yeSBSZXNldCddPSgpontFLnNob3dQcm9tcHQoJ1RoaXMgd2lsbCByZW1vdmUgZXZlcnl0aGluZyEnLHt0aXRsZToiRmFjdG9yeSBSZXNldCJ9KS50aGVuKCh2KaJ7oyh2KXtFLnNob3dNZXNzYWdlKCk7VGVybWluYWwuc2V0Q29uc29sZSgpO0JhbmdsZS5mYWN0b3J5UmVzZXQoKTt9pHNob3dVdGlsTWVudSgpO30pO319CqtFLnNob3dNZW51KG1lbnUpOwp9qm1ha2VDb25uZWN0YWJsZSgpewqxe05SRi53YWtlKCk7fWNhdGNoKGUpe30KQmx1ZXRvb3RoLnNldENvbnNvbGUoMSk7CqxuYW1lPSJCYW5nbGUuanMgIitOUkYuZ2V0QWRkcmVzcygpLnN1YnN0cigtNSkucmVwbGFjZSgiOiIsIiIpOwpFLnNob3dQcm9tcHQobmFtZSsiXG5TdGF5IENvbm5lY3RhYmxlPyIse3RpdGxlOiJDb25uZWN0YWJsZSJ9KS50aGVuKHKie6Moc2V0dGluZ3MuYmxljHIpe3NldHRpbmdzLmJsZT1yO3VwZGF0ZVNldHRpbmdzKCk7faMoIXIpsXtOUkYuc2xlZXAoKTt9Y2F0Y2goZSl7fXNob3dNYWluTWVudSgpO30pOwp9qnNob3dDbG9ja01lbnUoKXsKrGNsb2NrQXBwcz1yZXF1aXJlKCJTdG9yYWdlIikubGlzdCgvXC5pbmZvJC8pCi5tYXAoYXBwonusYT1zdG9yYWdlLnJlYWRKU09OKGFwcCwxKTurKGGeYS50eXBliiJjbG9jayIpP2E6t30pCi5maWx0ZXIoYXBwomFwcCkKLnNvcnQoKGEsYimiYS5zb3J0b3JkZXItYi5zb3J0b3JkZXIpOwquY2xvY2tNZW51PXsnJzp7J3RpdGxlJzonU2VsZWN0IENsb2NrJyx9LCc8IEJhY2snOigponNob3dNYWluTWVudSgpLH07CmNsb2NrQXBwcy5mb3JFYWNoKChhcHAsaW5kZXgponusbGFiZWw9YXBwLm5hbWU7oygoIXNldHRpbmdzLmNsb2NrnmluZGV4izApoChzZXR0aW5ncy5jbG9ja4thcHAuc3JjKSl7bGFiZWw9IiogIitsYWJlbDt9Y2xvY2tNZW51W2xhYmVsXT0oKaJ7oyhzZXR0aW5ncy5jbG9ja41hcHAuc3JjKXtzZXR0aW5ncy5jbG9jaz1hcHAuc3JjO3VwZGF0ZVNldHRpbmdzKCk7c2hvd01haW5NZW51KCk7fX07fSk7CqMoY2xvY2tBcHBzLmxlbmd0aIswKXtjbG9ja01lbnVbIk5vIENsb2NrcyBGb3VuZCJdPSgpont9O30Kq0Uuc2hvd01lbnUoY2xvY2tNZW51KTsKfapzaG93U2V0VGltZU1lbnUoKXsKZD24RGF0ZSgpOwqudGltZW1lbnU9eycnOnsndGl0bGUnOidTZXQgVGltZSd9LCc8IEJhY2snOqooKXtzZXRUaW1lKGQuZ2V0VGltZSgpLzEwMDApO3Nob3dNYWluTWVudSgpO30sJ0hvdXInOnt2YWx1ZTpkLmdldEhvdXJzKCksb25jaGFuZ2U6qih2KXuvLnZhbHVlPSh2KzI0KSUyNDtkLnNldEhvdXJzKK8udmFsdWUpO319LCdNaW51dGUnOnt2YWx1ZTpkLmdldE1pbnV0ZXMoKSxvbmNoYW5nZTqqKHYpe68udmFsdWU9KHYrNjApJTYwO2Quc2V0TWludXRlcyivLnZhbHVlKTt9fSwnU2Vjb25kJzp7dmFsdWU6ZC5nZXRTZWNvbmRzKCksb25jaGFuZ2U6qih2KXuvLnZhbHVlPSh2KzYwKSU2MDtkLnNldFNlY29uZHMory52YWx1ZSk7fX0sJ0RhdGUnOnt2YWx1ZTpkLmdldERhdGUoKSxvbmNoYW5nZTqqKHYpe68udmFsdWU9KCh2KzMwKSUzMSkrMTtkLnNldERhdGUory52YWx1ZSk7fX0sJ01vbnRoJzp7dmFsdWU6ZC5nZXRNb250aCgpKzEsb25jaGFuZ2U6qih2KXuvLnZhbHVlPSgodisxMSklMTIpKzE7ZC5zZXRNb250aCivLnZhbHVlLTEpO319LCdZZWFyJzp7dmFsdWU6ZC5nZXRGdWxsWWVhcigpLG1pbjoyMDE5LG1heDoyMTAwLG9uY2hhbmdlOqoodil7ZC5zZXRGdWxsWWVhcih2KTt9fX07CqtFLnNob3dNZW51KHRpbWVtZW51KTsKfapzaG93QXBwU2V0dGluZ3NNZW51KCl7Cq1hcHBtZW51PXsnJzp7J3RpdGxlJzonQXBwIFNldHRpbmdzJ30sJzwgQmFjayc6KCmic2hvd01haW5NZW51KCksfQquYXBwcz1zdG9yYWdlLmxpc3QoL1wuc2V0dGluZ3NcLmpzJC8pCi5tYXAoc6JzLnN1YnN0cigwLHMubGVuZ3RoLTEyKSkKLm1hcChpZKJ7rmE9c3RvcmFnZS5yZWFkSlNPTihpZCsnLmluZm8nLDEpoHtuYW1lOmlkfTure2lkOmlkLG5hbWU6YS5uYW1lLHNvcnRvcmRlcjphLnNvcnRvcmRlcn07fSkKLnNvcnQoKGEsYimie65uPSgwfGEuc29ydG9yZGVyKS0oMHxiLnNvcnRvcmRlcik7oyhuKatuO6MoYS5uYW1lPGIubmFtZSmrLTE7oyhhLm5hbWU+Yi5uYW1lKasxO6swO30pCqMoYXBwcy5sZW5ndGiLMCl7YXBwbWVudVsnTm8gYXBwIGhhcyBzZXR0aW5ncyddPSgpont9O30KYXBwcy5mb3JFYWNoKKooYXBwKXthcHBtZW51W2FwcC5uYW1lXT0oKaJ7c2hvd0FwcFNldHRpbmdzKGFwcCl9O30pCkUuc2hvd01lbnUoYXBwbWVudSkKfapzaG93QXBwU2V0dGluZ3MoYXBwKXsKrnNob3dFcnJvcj1tc2eie0Uuc2hvd01lc3NhZ2UoYCR7YXBwLm5hbWV9OlxuJHttc2d9IVxuXG5CVE4xIHRvIGdvIGJhY2tgKTtzZXRXYXRjaChzaG93QXBwU2V0dGluZ3NNZW51LEJUTjEse3JlcGVhdDq1fSk7fa1hcHBTZXR0aW5ncz1zdG9yYWdlLnJlYWQoYXBwLmlkKycuc2V0dGluZ3MuanMnKTuxe2FwcFNldHRpbmdzPWV2YWwoYXBwU2V0dGluZ3MpO31jYXRjaChlKXtjb25zb2xlLmxvZyhgJHthcHAubmFtZX0gc2V0dGluZ3MgZXJyb3I6YCxlKatzaG93RXJyb3IoJ0Vycm9yIGluIHNldHRpbmdzJyk7faMov2FwcFNldHRpbmdzjSJmdW5jdGlvbiIpe6tzaG93RXJyb3IoJ0ludmFsaWQgc2V0dGluZ3MnKTt9sXthcHBTZXR0aW5ncygoKaJzaG93QXBwU2V0dGluZ3NNZW51KCkpO31jYXRjaChlKXtjb25zb2xlLmxvZyhgJHthcHAubmFtZX0gc2V0dGluZ3MgZXJyb3I6YCxlKatzaG93RXJyb3IoJ0Vycm9yIGluIHNldHRpbmdzJyk7fX1zaG93TWFpbk1lbnUoKTv/TAIAAHNldHRpbmcuaW1n");
writeSegment(31888, "MDDCAP//8WPMQm9T");
writeSegment(31952, "AVVVQA==");
writeSegment(31964, "AVVVQA==");
writeSegment(31976, "AVVVUA==");
writeSegment(31988, "AVVVUA==");
writeSegment(32000, "BVVVUA==");
writeSegment(32012, "BVVVUAAAAAAAABAABVVVUAAFAAAAAFUAVVVVVQBVAAAAAVVRVVVVVUVVQAAAAVVVVfqvVVVVUAAABVVVXqqqtVVVUAAAFVVV6qqqq1VVVAAAFVVXqqqqqtVVVAAAVVVeqqqqqrVVVQAAVVVaqqqqqqVVVQAAVVV6qqqqqq1VVQAAFVVqqqAKqqlVVAAAAVXqqgAAqqtVQAAAAFXqqgAAqqtVAAAAABWqqAAAKqpVAAAAABWqqAAAKqpVAAAAABWqqAAAKqpVAAAAABWqqAAAKqpVAAAAAFXqqgAAqqtVAAAAAVXqqgAAqqtVQAAAFVVqqqAKqqlVVAAAVVV6qqqqqq1VVQAAVVVaqqqqqqVVVQAAVVVeqqqqqrVVVQAAFVVXqqqqqtVVVAAAFVVV6qqqq1VVVAAABVVVXqqqtVVVUAAABVVVVfqvVVVVQAAAAVVRVVVVVUVVQAAAAFUAVVVVVQBVAAAAAFAABVVVUAAEAAAAAAAABVVVUA==");
writeSegment(32396, "BVVVUA==");
writeSegment(32408, "BVVVQA==");
writeSegment(32420, "BVVVQA==");
writeSegment(32432, "AVVVQA==");
writeSegment(32444, "AVVVQA==");
writeSegment(32476, "TgEAAHNldHRpbmcuanNvbg==");
writeSegment(32508, "eyJibGUiOnRydWUsImJsZXJlcGwiOnRydWUsImxvZyI6ZmFsc2UsInRpbWVvdXQiOjEwLCJ2aWJyYXRlIjp0cnVlLCJiZWVwIjoidmliIiwidGltZXpvbmUiOjAsIkhJRCI6ZmFsc2UsImNsb2NrIjpudWxsLCIxMmhvdXIiOmZhbHNlLCJicmlnaHRuZXNzIjoxLCJvcHRpb25zIjp7Indha2VPbkJUTjEiOnRydWUsIndha2VPbkJUTjIiOnRydWUsIndha2VPbkJUTjMiOnRydWUsIndha2VPbkZhY2VVcCI6ZmFsc2UsIndha2VPblRvdWNoIjpmYWxzZSwid2FrZU9uVHdpc3QiOnRydWUsInR3aXN0VGhyZXNob2xkIjo4MTkuMiwidHdpc3RNYXhZIjotODAwLCJ0d2lzdFRpbWVvdXQiOjEwMDB9ff//2AAAAHNldHRpbmcuaW5mbw==");
writeSegment(32876, "eyJpZCI6InNldHRpbmciLCJuYW1lIjoiU2V0dGluZ3MiLCJzcmMiOiJzZXR0aW5nLmFwcC5qcyIsImljb24iOiJzZXR0aW5nLmltZyIsInNvcnRvcmRlciI6LTUsInZlcnNpb24iOiIwLjM3IiwidGFncyI6InRvb2wsc3lzdGVtIiwiZmlsZXMiOiJzZXR0aW5nLmluZm8sc2V0dGluZy5hcHAuanMsc2V0dGluZy5pbWcsc2V0dGluZy5qc29uIiwiZGF0YSI6InNldHRpbmcuanNvbiJ9YzgAAGFib3V0LmFwcC5qcw==");
writeSegment(33124, "QmFuZ2xlLmxvYWRXaWRnZXRzKCk7CkJhbmdsZS5kcmF3V2lkZ2V0cygpOwqsVz1nLmdldFdpZHRoKCksSD1nLmdldEhlaWdodCgpOwqsRU5WPXByb2Nlc3MuZW52OwqsTUVNPXByb2Nlc3MubWVtb3J5KCk7CqxzPXJlcXVpcmUoIlN0b3JhZ2UiKTsKrGltZz1hdG9iKCJzSXdEa20yUzY2RFl3QTJBQUFBQUhBSEdTUnhKRWtBQWdtR0dCeERJQURJZEFGSkliQUhGOUhQMDBrQlVDNkR0ekRnQWlXT3h3a2dBR2JBODZDVzIyMjJra2dCNGhPMjYvWEREd0F3a0VFRWdZWUErVlcyMndFQUFnZ3dFbTJBWlpaVEZvdE1JREFBOXZCNTIwQUpVblhBdHdBZ0FpR3hPdzJ3bytiQW1pU0FINEFRVWtBSE1rTzIvNjZUWTJHd2dnZ2doQjUvK1NSeEpBRUFBbG0yRWh4U1RMS1lGRkZCQURBLzk5SFAwMGtIb0M2RHV6QUFBQ1dPeHdrZyt1ekc4NkNRSDdiU1VnQUIraVNRQUFBRERBQXRFa0VrQUFBQTJraHhJQUhBQWdtR0xBREtETExvQUFBRUREU1FRQ0FBQUFBSEE0QUF1d0FBQUFRRERERERBd0FJSUFBTWdBWVFVQUFBNGlvbmdBSUFHQUJxRWtra0FISEdHaGh4SUhIWGE2NkFEWWJTU0NjRUh6VUJEYlFDU1NRQUFBQUhBdHREREREQUFDUURERERBMTRHR0dBQkVFQVlRV0JBSURpUTg0QUFvd3hJWVFra2lTNGc0MmtoeElBNGluTlBBQTF3QW9Ua2tBQkNTQUFTUVFpa20yU1FIQUZBQUFHd0FBQUFvdG9vdUp3QUlJQUJFZ1lZQUFKSUlvQ0k4NEFGdDJ4SkM0RWtiWUVFSFBBQnhJQUFmU3FxU1Exd0ZDY0VFQUFDU0FBQUFBZ2dtQUN0di85MWdHZ0V3SC9BdG9GRkcyd0dHQUFCRUVEWUFBSkpBdEFJMkd3OXR3d3dmNEFtMkFILzU1QVIwazBSQUhOUEt0MjFvVDRBQW9GQ1NoWUNTQWdrbXdDdEFBRldvV2dFeUNTQW90dG91YjJHQUFBQU1nQUFBQUpKQUZDQXd3dzlGQUcxdDQ5dGg1QWcvUEVSMjJUL0FDNjZLb3B1Q2Q4a2tzQUVBVFFDQUFnZ21GQ3RzbkZhd0dnRXdFa0FBQURidXR3R0FJQklBQUFBQUptaElZQUF3QTM1eEFnMjI0OXQ1UEFBNEFFUnlTTSs0a0FFaWtGb3pvKzIydkpQQVpnQ0NFQWdtMkN0Z0F0dEd2R3dCSkFBQUdBREdHR0d4QkJBQUFKQkJNa2tJQVNRQUE1KzJFRTB6Yjl0bi9BSDR1QVIxdG8vQW40a2trZ0NlQTl0dHNBRUFBQUNTQUFBQUFBdGdBb29BR0FBQkFBeHdHQURHR0dBQUlCSUFBSUJCTWtrUC9RVWtBSDV4QW5HTEQ0QUFFa0FRdVFSdFNWNEFFQUVra0FUb3c0QUFBQUFTakRGQ1NBQUFBUUFnQXRvQW9BQUJJQXZnR0RERzJHQUFBQUFHd0pCQUpraFBKU0cyQ1N3QUFDVHpiNEVFQWdHQ3VRUXR5MTRIa0F3a2dnZEFHNEFRQUFBMHpERkNBQzJ3RERBRW50b0gxOUF0MkF5d0dBWUdHQUFBQUFBd0FBQUFCTUpIL1FRQUFDR0FBU0ZZQTREakFnd0N1Q0F0UzFvQUFCSkVFRGJiYmJiYllBQWlUYnRxVkNiWVFRUUFBdHRBYnJGQUdBUUFHMkdHR0d3QUFBUXd3QUFBa2hJR21MVElrQ3dEQUM0UElBQUFBZ0FRdVFBdEpOb0FBQkFNbi9KSUFJTUFFRUFBRERGQzIxQW9EREFBQUFBQWJyQXUyU1JKQUFJQUFBQUFBQUF3R0FBQWtnQUVrTks2aUNEREFBQStQQURiQUcyQXVDQXRKVm9Jb3BTRXo3SkFBQkVnRWdBQURERkN3d0FBQVFDQ0FBQUFickFGQVFRSUFKSUFLY3U0QUFDR3dBSC9rbi9HbWphU2tTQVpCWUFKNEFEckFHRkF1QVFGS05BQXRwSm1YdkJOQklNa0VFQUFEREZDMndKSklBVVVRQUFBQUZGb0FTUU1naElBQUFBQUFBQ0FBQS9INC9IQUFaSzZFSEE0SUFBQUFBRGJEWUZBdUFDRnJ0b3dGQk15ZElCQUFCRWdHMjJBQUFFczN3QUxiQVVVUUFBQkpBQ1FTQUZJZ2c4azgva244QUFDYUFBSi80QUdvUVJZa0UvQkIvK0FHQUFBWUFBdEF3QVZ2ZHUyQUptVG9BQklBSU1Bd0FBd0FBZ2duLzRMQUFFVUFBQUJBSVFDQVZsd0hBKzIyKysrM0FBd0gvQnhKQVlFQWdISEFISEFBZDJ3MjJFQURBQUFBQUFxbzdvd0JLU2RJQUE0NEFBQUdHMkFBQUVrQS8vTEFBQWdBQTRCQUlTU0FWdTJBQTZxNjY2NlhFa3dIL0JJSURiRGdnbjRGb213QU1XR0dHRUFBWUFBQUFFdHNIZG9BalRwd0FBRUFBQUFHQUFBYmJZZ0hJNExGZEhIQzJBQkJBUUNTbG93a0E3Yjc3NzdmRUF3SC9JSUFiYmFBa0FBMXNHR0FTV0Vtd0VnYkVIRUFBQXhPdEZwSnpkUEFBQTQ0QUFBQTJ3QUFZQUFCSkxiRERINENHQUJKQVFDa2xBSGNBLzk5OTl2OUVrQ2FBSklBRGJCb2dsdTJBbXdHU1dnbUdFODRILy9BQUFDUUFBSWhScDRvQ0E4NEFDU1N3QUFZWW9BSEk0QUZkQUFDU0pKSkpKSmtsQXdrQURBQVlBR0FFQUFiWU1JQUFZQUFnbDIxQUdHR1NRa2dBRW1nQTQ0U1NTU0lFQkdhZFBBZ2tnL2lTU0pLR0FBRFlISENRQUFIWEFBQVlBQUFBQk1rb0F3a0FEQURBUTF3RUFERkFnZ0FBQUFETDIydEEyQXdDQWdnSUU4NENIQVd5MlNMb0ltYnBnZ1lnZ2tpdHRKS0FZQUFBSEhWcUJnU1NTL2tJR0F3d3hKa29BQUFBREFZQVFHQUgvRHVva2dFRWcyQWF1MnRvQUFBaWd3QkJBQUFCLzRTU1NRSkJFeWQ4NFlRa2dBQ1NTSktKSkpra0hIUUNBblM2Uy9rWXd3d3d4NWtvQXdZWUREMlFRQUdIWERGRGxnRUFnd3hWbDJ0QWtnRWtrSkFJd0FBQmtnU1NTUUxvbVQ1L2dDSURBREFBQ1NTUVFRLy9IL0NRQWdXQVMva0kydzJ3eEprb0F3WUFEZTJDQUFnZy9EQURGQUVBZzJDTE04bG9CZ0FuZ0JBQWdnUUFBQVNTU1FKRXlkUDg0SUFERERIWEFBQUFBQVNTQUFBRGJBQUFTL2tZd3d3d0I1a05BQVlZRGUyQUFFR0VIQWJZbEFBa0F3elpmLzlCQmdFLzhHR0FiWUFBQUdBRWJBSW1Uc0VnQkpBRFlZSDZBQURiQUFBQUFBTUlZMncydzJrSXd3d3d3SkpOQUFBQUREd0FBZ0dBZ0FBRUZZQUFBQUVMTThscEJnQW5nQkpBZ2dBQ0FBQUVZWkV5ZElnSUVrSG5BQUNTUUcyekJTSmxsSUpMUUdBd0Eya0FBQUFBQUtTSUFIL0FEQVlBU0hNYnRiaDRrQUFBQXdGSllBQUJCZ0dXV1dXQUF3QUFBQUVFYkFtVHB3aE9FRUVrR0p3QUFBMlliQUFsQUlNTGIwdzJ3RWtFQWduSkpLU0lBNEE0REFEQUNITWtra2g0SEFBQUFTR1RKSklnSWdBQUFBQUU4ODg4RzJBZ1ljeWRFMm1KQUJIbkdrd1FDQTJZWUFBQUp4SUFBQUF3QUVrRWdnL08yTEpJQW9Bb0FBQUZrc0FrQ1NTSEFIQUFCSlBZT2VJRWtBQUFHT0VrUUFBQUcyQUVrbWtoQmsyeEFBQ1NCa0lBQUF3QUVnZ0FBSUFIL2toSkFFa0VFZ0pPMU5BQUZqRGxBQUdBc2dBZ0cyV0FBQUF3eEpPZ0xMSUFBRGI0QnhBZ1FFQWtHMkFFRWljSUFFQUFBQWtpMEFBQ0FBQUFFRWdBQUlBSC9raEpBNDRFQWdBMkZ0QUFGa2NsQUdHR0VBQWtHeTI0SEo0QUFKRm9EYkFBL0FENEdPQWlRRUVBbTJBTW1qa2tKMHcvNEFDaWd3Q0FBVWtra2tnQUFBQUgva2hKQUhBQUFBR3dBREFBQWNrZUFHR0dBQUFFR1cyQUlBQUNBQkp3RllBQUFEREFBQ1FBWllrRW1RUUV5bElCTjAxLzRBQWd3REFTU0gvLzhrZ0FBQUFBNEVBSUNYa0c0RTgyQWJBZ2tqakd3QXd3QUFIa0NTU0hBSEVra0JKSUZ3WUFIQVlra2dlWUxJQUFXU1FrRWhBQkpBRWdBQUdBZ1lZRWdCSkpJa0FBQUFvQUFBQUFBWGdIT1AvQXdBQS8vNFkyQUFBNDQ0NDRBdG9TWEFFRUVCSlFFR1lBSEFBQWdRWVlaWUFBWFJVRWRnQUFJZ2dqQUFBbUFiWUVBQUFBQUEyYms5b0Y0RUhOdEhBbTAwOEFJQUFKSklBR3lTUTQ0NEhBQUFvUUFnQUFBQWNnRUF3QUhBQUFnQ2tnQUFBQVNRbVVwZ0FBSUVqYmJBQUFBWVpFZ0U4SC9BR0F3RnFWb0FISEJBMkhPSUVXQUFBUGtra2dRRVFFQW5ISEFGQVNBYjJRUUFqWVlZYmZIQUFBZ0FFR3dBQXdCRXljSWdBQUFnakNEQUVTUUFRQWdFOEVrQUdHRU1WcUFBWDlwSXdHNENRaUFBQVBuLy80QWtRZ2dnNEhXVkFRQWYyQUFBY0FFa0FBNlNTUWdBRUdCSkhBQW1raEFBQUFFZ2c3NDg4NkFIWEVnOGtBLzRHd0JGVm9BQVhIQkEyU1NRU0VBQUFQaEpKSVFpQWtnaDVEQURBU1c1OVFRQWpTUWlBQUNRQ1gvQUVBeEFBQkF4a01kR0EyQUdBREFuL2lBd1F3QUFBSC8vR0dCRlZTQUFYRkFBQW9vQUlBQUFBa2tnQWtrZ0FnZ25IbzJ3b0F3d0FBQUFjUUFpQUFhVmFSSkFrbXhJQUJoUmhUcjJ3d3d3d0lJODg2SEFBSEFBQUFrZ0dBME1WcUFBUUFBQUF0b29BQUFpQS8vNEE0QUFBQUFCNWd3d2dFR0VBRkFnalNBQ1FBcVRDWFBBQUFCQUFCUmRJVWQyd3d3MndDQUhuU0NDQ0FBQUFFRUVBQUFCcVFCSnUyQUFZb29vUUFFQVFKSklTU1FBQTQ0NEFBd3dKSWtnQWJZd2NRRGJBRllkQUhQQUFBQkFBaEpwQVN3MU4yQXd3QUF6YkFBRVVRd0FBOWdnNEFBRXRvQUJvQkFEREFBSEhBQWlBQVhuL0F0b0FBQUFBQUdBQkFFQUFEQVFqUWdZQUFFRUVBQUFBQUhBYmFmSUpJd0FJQUF0b0FHMllCSk1rUS80SDRFQS9BRUlBQUJKb2hDRGJBSEF3QUFnUUE0NUpBMndBQUFiWUFBQUpDRUNBWVlBY0FZWkJKQTJ3QXdBQUE2NGJiNjRJd3dBd0FBb29DQ29TUUpNVVFrZ3R2QUhBYllBQUd4QW9BQ0RBQUEvNEFBQ0lJblVrYmJZQUFERERiYmJZQVVRQUFBaEFBYmZCNUVFRUdHT082NEFiZEFBSkdTUW9BQXRvQ1NvU1JJQUFBd0F0by80QUE0QUFHR0piYmFBYkFBNDRBSUlJSVFCSWJBQVlBREREdHR0dkhFQUFHQStRa1N2QjVBQUFBeHh4U1F0YmRvQUlBU1F3QUFvQWlDdFFRUC8vNHdBdHZnbkF3NFNBR0dBQUEvSEFBSUFBQUJBSUk0a2tBQUFENEFiWS8vLzc3RVhOa2dPOGdTSUFBdG9BQ0FPMDY0cmJidUFJQVNRQUFBb3dnQUUwQlBKSjREWWY4RUUvYllTUUdHQUFIQTVBQUlnZ2dRUUpJQkpKSUFBQVlBUEl0dHR2L0V6akVBQVVrUkxBRHJva2lRTUFBYmJiYmJZSXdBQUhnREFtZ0FHT0FEQUFZRGJZNGdnNEFBUUFHd0M4QS9IQS9KRUVBQ0FFRVNBQXR0QUFEQS80YmJiWTRBSUFnZ0lCa0pMdHJ0bzJ3UU9tQWNqamprWUFBQUFIa0pZMHdERTBBQi8vSUFiQUFFbVJBQ1NBQUFDOEFnZ0EvQ3FxQWdnR21TQUZBQW9Gb1lQSUFBQUgvSEtYSUE0QWtBTG1EZ0FBa0lJa21ja3Rza2V3d0FBSDhKREFBYkFBQUFBQUFBQUFBa3lOZ0FTRm8vNjhFc3NBVEFWV0dFd0J4U0FvMndGRGRvQUFBQUFISDRSNEZ0a00vMklnd2xsbGhqYkV5YmJiYmJlQXdBZ2dqWUFiREFZQUFBQUFBQUFDQ1dSdHdvUVF0NENFRXNzQS9BS0cyR0FBSVN3b3dHRklMZENDUUFBSEhBQWdBb1VrQS9NbTJrRUFrSTRBRHBBQUFBMkNTd2dnakRFQVlBQUFBQUFRQVFiYVNRQUlJb0NBby9DRUFqZ0EvQUFCeEF3QUFTQW93R0hISEFDQ0FBUzhBREFnQW9NTS90QXd3d0ZBQUE4QUZJRHZyQUFDQ0FFTURZeHdBd0REQUFBU0NRdHFDRnRKSUFZWVk0Q0VBamdCSkJIQXdIR0FBU0FvMndCQUJBU0NRQVg0QVlFOG9vUkprQUd3dzJFQUFBQUFCQUR2ckFBQ1NBQmhERUlNQUFMSkJBQVFRUTJ3QUNTSUxERERELzRBQWJZQkpBQW9Bb3dBQVNBb3dBdkhIQUFBQUEvZ213QS9vb0pBUUFXRzJHRkFBQUFBSUlEdnJBbEtDQWQ5YkF4d0FBTElZREFBQS9BQUFGdElJWUFBQUFBQUFBQUcyVlJQdjRBQUFTWUZ3RkFRQUFBQUFBZ0VBd0FudG9SSVNDV3dBMkg0NEFBQURBRHZyZ2xMQXBzY3BBRUFoZ0xKQkFBQUhIQkpKTWtBSFBBQUFIblNRQVllMlZScHZ2QUFBU09HdG9BQUE0SEFIQklBQVFBbi80SkFRUVEyMndISEdHR0dBWURIcm5sSW9vc2tvQUFBSUFBQUFBQVlIL0FBQUgva2g1Q0JFQkpTQ0FiRWtTUk52OUh3QUFJQUVBODRISEFBQXdCQUFDQ1NIZ1IvUUFRQUFBSC8rd0F3Q0FBQUVrbExGb0ZsQXdBQWdBRENBQUQ3SEhILy84azIzUEFBQUhuUVNBYkVrVlJwdnZBK2dnVzJrZ2tnSC9BRUEySUFBQUFFRUFKQS8vbkFBSEZ0dUdBd0lRb0FFNGxMQXNFb2p3RUFJQURVUUFEQUFBQWdnZ0FBQUFBQUFBQUNTQVlZQVZSTnY0SHdnZ1FFRUU4NEhISEFId0JBQUFBQWdBb0o1Zkh3RTQ5QUFBQUFlQW9BRTF0QUFnZ2dnd2dnaGdiU1FTUVlBMUI0NDRBLzRELy8vN0FBQVFBUkFJQVNBQUFBRUFBUE1BQUFBQUEvOGhJQUgvQWtrZ0dBN1BBd0M0NHRBQUFBSXdvQUU5dEVnRTBBL3dFQUFBYlFRQVFERzFvazAydzhrQUVra0FBQ1FHa3hMSUNRQVBnQUFFazU4QVN5YmJZQW0wQUE2UzRnZ2cyMi83QTIyNDlBQWdrQVlZdUFFRnRtMEFnd3dFaWtIL2tuL0FUN0FTR0d3dzI4OEFBRUFBa1FDQW1oWklDUWtra2trRzJQSUFDU1lZWUVHd2dIeVNYQUFBR0E1NUEyS0hEcll3d3dJd29BSGtnbTBBR0dHQUNBR0owM25RUVlBUUEyMjIyLzhBQUVZWWtnQVRFMGtrQU1ra2tra0hHd0VpU0NiYjg4MjJrK1NDUzRBZ0FBN1BId0NBQVlHd0FBREFvQkRXUUVnQUdHR0FDQUVrMDMvQ0RBQUFBQUFBQThrREVFYll0Z2tLSUFnZ0JCa2tra2tIK3dFdFZBYzBmL3plLytRQ1M0RUFFa0FBRVFHZ0RiWUEyM0FIb0FIUVFDQWtrbUFDQ0N3QUFBRnRlWUd3b0FBQUFRQWJja1lZSmdFUkFBZ0VQSElBQUVrSEdBRXRWQS9IODhERGsrUVNTNEVnRWsvNEFBQUFBQjFJa3dBQW9CWUVBU0FDQ0FBQVNRQUFJQU5WYll3QXRiQUFDNkRZYkFBQUpFZ0FBQUFBSUFJQUFFa0FBQUVpUUEvLzRBRXdBK1NTUzRFQUVrNDRJQkJJSkd0Z0EzSEhvQTRBYmFRQ0NBQ0FBQUhTUkJGdFlZd0F0YkFIWFhYYllvQW9BQUFBQUFBQUJKd0FBRWtBQUFBQUFBLy80QUVHRGZTU1hFa2dBQS80QUFBSUxCc0l3d0F3QXRvSGJhQUFBUVNRUURBNFRMQVFBQXdBYmRvQUM2QURBb0FvQUFBQUJTSUFBQXdBQUVrQUJJQUNDU1AvSUFFR2JiLy80QXVvRFlBNElCQklJWmdJMndBSUFvNEFCQUFFOFFDQVFyQUNURENTa0FHd2JpSUFBUS80R0ZGQkpBQUFCL0k0QTR3QUFra0FCQjJ5Q0FKSklBRUdiYjQvNEF5d2Nqa2dJQkFBQURKQWtnQVFBdEFBQm9BZ2dpU1NBVEE0UUFDQ0FBQUFiMWdBQTQ4NHcxRkJCQUFBQlNJQUFBMjIyRWtBQklKS0NRNUo0QUFBWWIvQTRBTEljajB3SUJBQUFBWTRBQVF3Z3ZBQUJBRUFBRVNRQVRIU1gvQ1NnMEFBYktZQkFBLzQvd29CQkFBQUFBQUF3QURNUVNrUUJCa2lTQTRBNEFBQUFiSC9BQUFBY2prZ0JJQUFFQURBQUFIUEF0b0FRQWdBQUFnQUF0QUFHQUNDQTBENGJiQUJyd0FHLzNISUlBQUFDQUFnQWdaaUNDQ0FCSUFBQUEvLzRBSUltVEE0QUFBQURZQUFDNEFBa2dBWWdFQUFBQUNDWHZBQUEvbjgvazhRMndDQ2swSFliYkFCcllBdzJDU0FBQXdRREFRRWtETUNDQ1FBQVNEQVlBRGV3QUpNeVlBQUFBRUFEWS8vSENBRWtrQURFZ0FJSUJDQ3Jyb0FBSG44bm44VzJ3QUFBQUFBQUFCQnRZZ2dBa2tnNDRBREZEQUFnQUFIREFBQUNBRERiQVllR0dPSUFBQUFBQWtnRnRBNDZIQWtrZ2dEY2dBSUlJS0NBQUFBQUhrODhuL1d4MkFia2tra2traEpCQWdnQW4vZy84Z0F1b0EvNEFBSFlZd0ZDQURBWUFZZUdHT0lBSmFRd0VFRUZBQS9IUUVra0hFQUFBQXd3MndRQUFBQUFIbjg4azhXMjJBZWUyMjIyMndBQTRHRmRudmcvOGlkMzFha2dDQUhZWXdGQVNiQUFBRGVHbUdFQUFZUXdBa2dGdHc0d3dBa2tnQUEyMjIyd3d3QUFBQUFBL0VBQUFBVzIyQWJFQVBJSC9BbmdBZ2pybi9nLy80QXVvQVNRQUEvREdBRnRBQUFBRUFHMDUwa0FJYVFBRUVFRkEyMndvd0Vra0hBMkFBQUFBQUdBQUFBQTJFLzhybzJ3MkFZZFkvNDRBNC80QWdsZGtrZy81SURGREFvRWtrQW9GRUVra0VUQTJEQW5PZ2dnSllRd0FBQUZBd3d3d0FBa2dBQUFILzR3d3dHZWJiQUEyRTg4ZFkyQUdBREdDUEk0SDRubXdBQkpBQUEvNUlRREFRb0FBQUZBa0Vra2trakVrWUE1QUVrQUFBSC9BQUdtQUFBQXVvQUVBQUgvNDRId3dBRzIyMkFBL0UvOHJvd21sRnR2bElBNDQ0QUdCQkJIQUFBSUFRQUNBQW9iWUFxVkZFMGtrMFRHekFBQUFBRnRDU0FIQUFFMDRDQ0FBQUEvQUFIQUg0SDJ3d1dlYmJBQStrbFZHZ20yMXRGRWtBQUgvQUFHeElCQkFBa01nQ0FCLy9vZVlGQWdGRUdrbWNqRWFCSmdBQUZ0Q1NBNEFBR21GUVFRd2lnNGsySENBNEh3d3dRQWdBQUYra2lLR0VHbWxGRkFRUVNEYkFBR0JCQkpBQWdJaVNKSkpKb2JZcVZBRUVBMHpjVER5QkVFQUFEYkNTSDJTUUVFQ0NDQUFSUS9nWVlWUS80d0FBV0FnZ0FBMmtsVkdFR2trNjRBU0FRVEFBQUFBQUhBcnJBQUFBQUFra29ZRkFodHRFRGViY2pmeUJJd2dBdHRvQTRBUUF3d3dBUUFBaWdBRWJDQUNHMnhBU1NRa0FILzNrZ2tHLytBZ2lnQVFBU0RiRnRBQUFBNHRyQUF3QXdBQUFvWXFWWnVzRURlYmNURHlCR0VBQUJKODVKR1NBUUFYUzJrRkFIWWtBQUgvLy8vQUFWdGdnSGZra2trazhnZ2c2NEVnWVFUUUFyQTY0LzRydEFBQkJBd0Vnb0ZBb1p0dDhEZUFjakFhQkFnQUVCSjg1SkFRQUREQlMya0ZvdkQ0SG9za2tra0VBVkFnRUgvQUFBQUEvNGtnRFlZQUFBREFBcllVUnhJQUFBQUJoR0dFQW9xVUFadXM4WUFERVRRVEJFRTJnaDU4NTVBUUFBb0dTMmtGRkhZNEhvdi8vLy9FQVZGQUFrQWJBUUFRQklrQVlEQUEvL0FKSXJZNisyd0VrZ0FCQkF3SDR0QW9BWnR0OFlBREVqQ0NhQW1tMEIvOC81QUFBQUFEQUFBRkFIREZJdG9BQUFFa0FWdEFBZ2dZWVFRUUlBZ2dEWVlBOG5BSUZ0QUFCeEtTa2pZQUFRQkJBb0VBQWJZRThEWUFjVENDRHRzdUFBQUFBU1NBQUFBQS8zL0ZBSFlCb29vQUFBRVJKSUFBQWtBYkd5Q0d4SWt4SmdBQThuZ0pJQUFiWUFBUWtnREFrZ0FCSUFBSElBQUJKQUFBQUFDQ1FvQ29ZWVkydy8vQUFBQUErM0hBQUFHdUFBeXdBRkVoQUFBQUFnQUFHMjIyd0FBeElDQTQvOGdBSTQ0QWE4UVFnQUFrb25Bb0hISC9QLy8vMy9IL0gvSC9IRlNvYllZd0FKSkpKSUFBLzMvQUd3RnRBSVdRQUFBaEFILzlBZ2dBQUcyd0FBSmlDQ0FBQUF0SklBQVlZQVNVZ0FBWUNBREFBQUFKSkpJQXdBQUFBQUFBQW9Db1lZWTIyQUFBQUFBQTczZkF6R0d1SEd5d0FBQWhKQTRBRmtBQUFBMnRvQUpCSkpBQUE5QW9FQUViZWtEWWJBYllBR0cyd0REL1AvNEFBRERBWVlDU0F0b3Rza2tndy8vLy80QUE3emZBd0dBQVFnUUFBQUFoQUEvRm9nQUFBQTJvRkRiRkFGMjJ3b3R0RUVFQUcwR0dHQUFZa2dHQUdEWWJrZ0NBSVlBTDQ3QUFBdXd1RUVBZ3dBYmJiWUFBYnpiWUd3QUFHSEFBRkFBaEFBNFNXR0lKQUEyb0ZZQUZvdEF3RkFvQUFnZ0FBQXR0dG9BWTRrR0FBREREbWdRUUFBb0FiWXdRQXUxd0VrZ2d0dHR0dHRwSi9BQUFPSUFyRElBQUZ0QWhBWTRDRzJCQlNRMm9vWUFGRkZBMW9IRnR0QUFBQUZFa2tGQVlFZ0gzKzRBQWtnR0FBWUFJQUF3UUF1dUdZQUZvMjIzLy8vNUo5NEFBMndGb1lQSUhGRkZtc0E0U1dHQUJSSTJBQURiRkZGQXdHZ0E0NEFBQUZBbTIyZ29FRWcvLy8vQkpCSXd6REJCQUFBMFFBb0FBWURBQWJiZHR0dHBKL3RvMk9KMnJEUElIQUZ0aUZBWURBQUFBU1FFa2tBQWRGRkF3R2dISEhIWEF0RXlhYTBGQWtBLy8vL0E0TWh3d2dBQUJiWndRQW9BQVlEb0ZBQWJiYmJhUzk0QXh3QjJRQUpJQTIxRmhXREFZRzIyd0pJRUVFRGJGQUZEd0dnQTQ0NDZBQW03cnIrZ29BQS9INC9ISEJJR29BcmJEQURGK0F0b0RZYkZvQUFBQS9raUNIRS8yLzVLU2svSUEyR0FnQUFZWUFBQXhhd0Vna0EvNEFBWVlBWUhISEhYWTRuZGxsZmdvQXcvNEgvQUFHMkFGdEFZREdERitTUVFBQUFBQUhJUEhIMmlRQUVuMy8vLzRBSklBdXdBZ0pBQUNBRzJ4VzRBMndBWFFBQVlBRUVBNDQ2NllBbWRrbGVnb0FHSC8vNEFBd0F3QTRBWURBREFHU1FFRUFBZ0FBQUFBSDBpQ0VFazMvLy80RzU0QXVHQWJaQUFBUUdHeGF3QUNBQS9RQUFEQUlZUEhISFhZb21Uc3JXZ3V3R0EvL0RUR1NyZUFBa2dCYlpFa1NRRWtBQWdBRUFFQUgyaVNua24vLy90MndKSUFtd0FZWlFTU1FBWXdKSUFDQUVBQUFHQVpBZ0I0NDY0WW9neWRhd2dvRzJ3QUFDcUdBb0dISGtnQUFBL240QUVFQUFnQUEyd0VIa2dBRUUvL24vOXRBQUFBZ0FBYllRUUFnRGJBQUE0Q0JXMkdBR1lZQXozSEhIWFlGRUdUV0VGR3piWUFBRFRBU3JZQWdIRERBMy8vL3dFRUFBZ0FBQUFBQURiWVlULzhrLy80QUFBQWRvQUpLUVNBQUFBQkpJQUlPT1dHQUdEQUFiWTQ0NjRZb29nendrc0FEYllBQUFHMlFBWUhISGx0QS9rOG40QjhBZ2dBQUNRQ0FEQUFZWGYvbi8yMGtra2dSQVFJSUd3R0JKQUJBSUFJUnUwdzJ3REFBejNISEhiWUFGRUdFQkJBRGJmSklJT3VTcllBQUhnb0cva2tuK0I4QWtnQUpRQ0NBemJZYUhmL24va20yMjJ4QUtRSU13QUdCaEFCSUlCTUgzR2V3a1FnQUFBNDQ0NEZBRm9nbW9Jd0RiZlBKSU8yQUFBQXdBZ29BMzhrL3dBRmxsbGxKSUNDR0dBQUFILy9uLzJ3QUFBQkJDUUFFR0VtQkpGb0FBQklvb294d2dQb0FkZG9DRWtGRkZBRXd3QUd3QUhKSUlKQkFBQUcyQWpEQUcvbitBQUJCQkJBZ2dYaTMveEkxMy8vLy8vNEFBQUJJQ1FERWswbUJBRnFBQklIQ1NIMndrZ3c0RkRDQ0huQW9vQW9HQUFBQUF3RnR0R0FBQUFHR0Fra2trbi90dHJBREFBQUFBWDZuUGhTdHYvLy8vK21tYllCQkNRWlkyQUdBQUFDQUJJb3FTb29rRUFBQURGQ1NFbmJiYkFGaWdBQUFNRUFGQTJ3QUFBL3E2Z0VrQUE0QUFGQkJFQWtnRUhnaEppUjEzLy8vLzg4MGNZQkFJRExMQUFBQUFrQ0FCQUhDU0hDQWtCQkhBSktDRGJGQXJBQUVFZ2tJTWtBRkFHQUFBQXZxNkRFOEFZR1BPRkFBRUFnZ0VVaU9PSUpiZi8vLy8rbW1iWUFBQUJaWkEyd0VnZ2lRUVFBb3dvQVFDQklIQklDSURBRkZZQTJHRUVFTk1FQUZBR0FRUVl0cVN3MGtEREFIQUZDQ0VZZ2djSGdKeElBZmIvLy8vODQwQkpBOUZBTElBQUFnZ2tBQ0NrRW5BSEFDb3BCL0pKSkpEYkZyRFN3dzBBRUFJd0FGQWtnU1RaSm1Cd3dnamJHSU9GQkpFWWtnY0FBSC9CcGJiQUFBREFBbUlRSEZvQUJITWtrRUFnZ0FBZ2tnZ2dFZ0VEYkcyMjJQdnZGZENBd3d3QkpKSUFBQUFBQVFRWkJnQjJ3Z2piQUFBQURBQWJBRFlBVWc0RkZrakFBSERnRTBJUUE5RkFBQk1rZ0FBZ0VBQWtFRUFCSkpKRHIyR0cyUHZ2RkFvU0RBREJKSkFBR1dBQUFvQUJKZ0J3d0FBQUFBQVJQOGdZWVlZQVdnNEZJaWpiRERia0VtUVNRQUFBQUVra2dBQUFBZ0FBQUFnZ0FBZ2piMjIyMlB2dmJEYkFEWWJCSkpBQUNpQUFBb29CaGs1WURIL0NBQ0NCUDhnYkFEWUFVZzRCRmtqREFERGdrMGdRUWtnQUFHQUFBR0FCSmcyQUFIRUhBQUVBRjJBQTFQdnZEYkFZREREWUJBWUFHV0FBQW9Fa0EvQURZLy82Q0NBUlA4Z1NRQUFBYmJZQUF0ckFERER3QW1nU1FBa2trQVlEQUZHU0lrR0FBQVNra0FnZ0ErMjI4Ti8vQVlERERBQWJCQVlBYllBQUFvdi9nQS9EWTQ0NkhDQ0FKSkZRRkFFa0FZQU1nU3JEREREU1FNRWtCNEFBd0dBREFvdVdJSUdBQUFXMGtBNDRBRm90QkpBU2JhUVlEQUFHeFlZWVlZQUFvcy8vOEhBWUQ0NDZBNkFRQUJGUUZBRUFnYllJRVNyRERBYlFCSW9RWUVnR0FBWUFZRkNXSkJ3QUFBU2trQUlJa1FEQUFEYmFiYUFBMkFBQUJiYlliWWdBdHQ3NzhBQUFBLy82LzZDQUFCRlFGQUVBZ1lZSUV0b2JBQWdTSUlHQUJBQUFBR0FERERIL0pCQUFBQTRBNEFCQWlnRkFBU1RpYWFoQUJnZG9CQUFBQUZ0QUFBbi9nQUF0b0gvQ1FTQVFJQkZTVkFFa0FiSk1nSklCSkVnUkFJcVNBNGdBQUFZRFlZZm5BQUFISEFBSC9BSUlrUUJRQUFUalRUaEFCZ1lxQkFBQTJ0dG9BQWQ4WUpBQW9BKzJTV3l3QklGdEZ0RUFnWVlBQTU0QkFnZ0FBRUNBQmtnQUFHQURBREgvQUFBSEhBQUFBQUFBaWdvREFBVGNjY1poaGdkcUNIL0F3c3NvQUFiellJQUZBQUdBQ0dBUTR3NHc0dzR3NGJZQUFKSUJCa2tBQUFDU1AvNEFBQVlBZHZRUUFBQUFBR0FBQUEvQUgrQUVBQVRiampZZ2dnYUNTSkpBMnR0b0FBWVlZSUFBQUErR0FHQXdiYmdFSk1NQUFBQUFBMndCSkFnQWc1Ly9KLzRBQUdBQUYvQ0FBQUFHV1dXV0xJL0dINEFvQVFRYmJiQUVBa2lTQS8vQXdsbGdBQVlSWUpBQTNBSDJBQUd3YmJBQUcyd0FHMndBQU9JQUFBQUVFUEpKSlA4a2tBRVVsdkNKSUFBQXd3d3dMSUFHSkpHQUFDSkFTUVlBQUFBQ0FJQUEyRWtBQUFhSVlCQUEvQUhGQUFBQURBQUF3QUcyd25PQUFFQUFBQVg0RTUvSkpKOG5rRkVpZ0FDLzRBQUF3eHd3TElBR0pCNEFBQUlJQVFiN0F3QVNRWUFBQWdBa2dBUklFQkFBQS80QUFBQUhISEVuOGdBMkFJZ0FBZ2dBUUFINGdBQUFKSk0vOHRFa1NBQXRxU0pBR0FHQUFBZ0FJaElFQUFJT0NHNEdBQUdGemJZdUFnQWdBQ0lCdEpBQUE0NEVBQTVJZ2dFbjhnR0F3Z0lNM0VBQ1FBQUVrQUFiZTIwbmtGRUFRUTF3QVFJSXd4d3drZ2tra0FDWUFBSUlRQVlBd3d3QVFZR0FJZ0FrZ1JBQm9BQUFBQW9tZ294Z2tnRW44Z0FEWTVoZytFQUFBRnRBQUg0WUdTa2trQUlDQ0NHdUNRSUlBQUFBb0EyMjJBQUFBQUpBU1E0QUcyQUFvekFHQWdBQWdJSkl0QUFBQUFBRUNBOGdFQUFBQUFBb0ZRRFBjZ2dBUUZGQVFBQURFa2tuZ0J4QVFRQTF3QUpBMjNnSkZBa2trQUZ3UUFRQUdBRDdBd0FRVUVBb0FrZ2tnRkVrb0dEdG9vb0FXU0FDQVFBQUFBQUhBUVlBeGdnR3dGdERiYkFBWUFFLy9BSUFDQUFBQUFKSU9rL0pBb0FBZ0FISVVrUUFBQUJKQUFBR0VnR01JQUFBQXJzSnR3enRGRkZGU1NRU1FRQWtRLzlBb0VBR0dWUWsxQUFGcm9BYllBRW5nQnhGdEFBL0hBQkJHNGtJU1E0RUFBQUFRUVFDQ0ZGb3RBRkZzRXRBQUFBQUZkRU1Bd0Rkb29vQVFTQ0NDUUFtZ0pJYkFra0cycW9HMndBRHJ0b3FTSkVBQ0FJRmtvQUFIQUJHT0U0SUFBQWtrQUFBaVNnQ0NBSUFJQUFBQUFBQUFILy9Gb0ZGQUdiYllBQUFBQ0FDQVFBVWdTUVNYNEFHR3FzRTJBU0Ridm9vQUJFQVRRYmRrb0kvSFFBQUFDUUFra2dBQUFBQWtFZ0FBRkpBTkdHMkdBWUFBWUhBUVFGRkFBd1pKQUFFZ2tCSUFBNDQ0UVFRWDZTU1NWVWt4d1hVZ3R0cVNCRUFRUVlkdEJJL0FBQUFBUUN3L1g0dzg0QUFnZ2dBUUZJSU5HR0FHQURBRGtuQUVBWUFZd3daQUgvRUVFSUFBQUJKQVNRU0FCQWlCcXNFMklTVThvb29CQkVDQUNiZEFPeElDU0FBQVd5QTZTNEFpZ0FBZ0FnQVFGSUJOR0FHR0FEREQybkdFR0Q3QUdBWkJIUEVFRUlBQUFBZ0FRQVFRQmtFQlZVRXh3UVVnb29xU0pNZ0ZBWUZGaEpKU1NRQUFRQ0Fra2dBODRBQWdBZ0NDRklBTjJHMkd3QVlZMDNBMndYQUgvNlpKSC9FQUVCSUFBSEhBUUFTQUJna0IiKTsKrGltZ0hlaWdodD1nLmltYWdlTWV0cmljcyhpbWcpLmhlaWdodDsKrGltZ1Njcm9sbD1NYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqaW1nSGVpZ2h0KTsKZy5yZXNldCgpLnNldEZvbnQoIjZ4MTUiKS5zZXRGb250QWxpZ24oMCwwKTsKZy5kcmF3U3RyaW5nKEVOVi5WRVJTSU9OKyIgICIrTlJGLmdldEFkZHJlc3MoKSxnLmdldFdpZHRoKCkvMiwxNzEpOwpnLmRyYXdJbWFnZShpbWcsMCwyNCk7CqpnZXRWZXJzaW9uKG5hbWUsZmlsZSl7rGo9cy5yZWFkSlNPTihmaWxlLDEpO6x2PSgib2JqZWN0Ioq/aik/ai52ZXJzaW9uOrU7q3Y/KG5hbWUrIiAiKyh2PyJ2Iit2OiJVbmtub3duIikpOiJOTyAiK25hbWU7fQqsdmVyc2lvbnM9W2dldFZlcnNpb24oIkJvb3Rsb2FkZXIiLCJib290LmluZm8iKSxnZXRWZXJzaW9uKCJMYXVuY2hlciIsImxhdW5jaC5pbmZvIiksZ2V0VmVyc2lvbigiU2V0dGluZ3MiLCJzZXR0aW5nLmluZm8iKV07Cqxsb2dvPUUudG9BcnJheUJ1ZmZlcihhdG9iKCJQQndCQUFBQUFBQUIvZ0FBQUFBQUFCL2dBQUFBQUFBQi9nQUFBQUFBQUIvZ0FBQUFBQUFCL2dBQUFBQUFBQi9nQUFBQUFBQUQvdytBQUFBUUFIQTRoQUFBQVFBTUFNaEFBQUFRQVlCbWhBQUFBUUFZQkdpQUFBQVFBUUNEL0g3NCtSNHdHRGhvS0pDU0V3RURnb0tKQ1Q4d0ZEZ29LSkNTQXdIRGhvS0pDU0VRSGovSDZJK1I0WUhtQUFBQUNBQVlFR0FBQUJDQUFNRU1BQUFBOEFBSEE0QUFBQUFBQUQvd0FBQUFBQUFCL2dBQUFBQUFBQi9nQUFBQUFBQUIvZ0FBQUFBQUFCL2dBQUFBQUFBQi9nQUFBQUFBQUIvZyIpKTsKrGltYWdlVG9wPTI0OwqqZHJhd0luZm8oKXtnLnJlc2V0KCkuY2xlYXJSZWN0KEJhbmdsZS5hcHBSZWN0KTtnLmRyYXdJbWFnZShsb2dvLFctNjAsMjQpO2cuc2V0Rm9udCgiNHg2Iikuc2V0Rm9udEFsaWduKDAsMCkuZHJhd1N0cmluZygiQkFOR0xFSlMuQ09NIixXLTMwLDU2KTusaD04LHk9MjQtaDtnLnNldEZvbnQoIjZ4OCIpLnNldEZvbnRBbGlnbigtMSwtMSk7Zy5kcmF3U3RyaW5nKCJQb3dlcmVkIGJ5IEVzcHJ1aW5vIiwwLHmWNCtoKTtnLmRyYXdTdHJpbmcoIlZlcnNpb24gIitFTlYuVkVSU0lPTiwwLHmWaCk7Zy5kcmF3U3RyaW5nKCJDb21taXQgIitFTlYuR0lUX0NPTU1JVCwwLHmWaCk7Z2V0VmVyc2lvbigiQm9vdGxvYWRlciIsImJvb3QuaW5mbyIpO2dldFZlcnNpb24oIkxhdW5jaGVyIiwibGF1bmNoLmluZm8iKTtnZXRWZXJzaW9uKCJTZXR0aW5ncyIsInNldHRpbmcuaW5mbyIpO2cuZHJhd1N0cmluZyhNRU0udG90YWwrIiBKUyBWYXJzIiwwLHmWaCk7Zy5kcmF3U3RyaW5nKCJTdG9yYWdlOiAiKyhyZXF1aXJlKCJTdG9yYWdlIikuZ2V0RnJlZSgpkjEwKSsiayBmcmVlIiwwLHmWaCk7oyhFTlYuU1RPUkFHRSlnLmRyYXdTdHJpbmcoIiAgICAgICAgICIrKEVOVi5TVE9SQUdFkjEwKSsiayB0b3RhbCIsMCx5lmgpO6MoRU5WLlNQSUZMQVNIKWcuZHJhd1N0cmluZygiU1BJIEZsYXNoOiAiKyhFTlYuU1BJRkxBU0iSMTApKyJrIiwwLHmWaCk7aW1hZ2VUb3A9eStoO2ltZ1Njcm9sbD1pbWdIZWlnaHQtaW1hZ2VUb3A7Zy5yZXNldCgpLnNldEZvbnQoIjZ4MTUiKS5zZXRGb250QWxpZ24oMCwwKTtnLmRyYXdTdHJpbmcoRU5WLlZFUlNJT04rIiAgIitOUkYuZ2V0QWRkcmVzcygpLGcuZ2V0V2lkdGgoKS8yLDE3MSk7ZHJhd0ltYWdlKCk7c2V0SW50ZXJ2YWwoqigpe2RyYXdJbWFnZSgpO2cuZmxpcCgpO2ltZ1Njcm9sbD0oaW1nU2Nyb2xsKzEpJWltZ0hlaWdodDt9LDIwKTt9CqpkcmF3SW1hZ2UoKXtnLnNldENsaXBSZWN0KDAsaW1hZ2VUb3AsVy0xLEgtMTQpO2cuZHJhd0ltYWdlKGltZywwLGltYWdlVG9wLWltZ1Njcm9sbCk7Zy5kcmF3SW1hZ2UoaW1nLDAsaW1hZ2VUb3AraW1nSGVpZ2h0LWltZ1Njcm9sbCk7Zy5zZXRDbGlwUmVjdCgwLDAsVy0xLEgtMSk7fQpzZXRUaW1lb3V0KGRyYXdJbmZvLDEwMDApOwpzZXRXYXRjaChfomxvYWQoKSxCVE4xKTv/BAkAAGFib3V0LmltZw==");
writeSegment(47592, "MDCI/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+VVVVVVVVVVVV/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/lVVVVVVVVVVVVVV/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+VVVVVVVVVVVVVVVVVVVVVf7+/v7+/v7+/v4QEP7+/v7+/v7+/v7+/v7+/v7+/v5VVVVVVVVVVVVVVVVVVVVVVVX+/v7+/v7+/hAQEBD+/v7+/v7+/v7+/v7+/v7+/lVVVVVVVVVVVVVVVVVVVVVVVVVV/v7+/v7+/hAQEBD+/v7+/v7+/v7+/v7+/v7+VVVVVVVVVVVVVVVVVVVVVVVVVVVVVf7+/v7+/v4QEP7+/v7+/v7+/v7+/v7+/v5VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v5VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/lVVVVVVVVVVVVVVVVVVVXmjeVVVVVVVVVVV/v7+EBAQEBD+/v7+/v7+/v7+/v7+/lVVVVVVVVVVVVVVVVV5o87OznlVVVVVVVVV/v7+EBAQEBD+/v7+/v7+/v7+/v7+VVVVVVVVVVVVVVVVVXnIzs7Ozsd5VVVVVVVVVf7+EBAQEBD+/v7+/v7+/v7+/v7+VVVVVVVVVVVVVVV5o87Ozs7Ozs6jVVVVVVVVVf7+/v4QEBD+/v7+/v7+/v7+/v7+VVVVVVVVVVVVeaPOzs7Ozs7Ozs7Oo1VVVVVVVf7+/v4QEBD+/v7+/v7+/v7+/v7+VVVVVVVVVVWjyM7Ozs7Ozs7Ozs7OzlVVVVVVVf7+/v4QEBD+/v7+/v7+/v7+/v5VVVVVVVVVecfOzs7Ozs7Ozs7Ozs7OzlVVVVVVVVX+/v4QEBD+/v7+/v7+/v7+/v5VVVVVVVVVzs7Ozs7Ozs7Ozs7Ozs7OzlVVVVVVVVX+/v4QEBD+/v7+/v7+/v7+/v5VVVVVVVVVzs7OeXnOzs7Ozs55ec7OzlVVVVVVVVX+/v4QEBD+/v7+/v7+/v7+/v5VVVVVVVVVzs7OeXnOzs7Ozs55ec7OzlVVVVVVVVX+/v4QEBD+/v7+/v7+/v7+/v5VVVVVVVVVzs7Ozs7Ozs7Ozs7Ozs7OzlVVVVVVVVX+/v4QEBD+/v7+/v7+/v7+/v5VVVVVVVVVzs7Ozs7Ozs7Ozs7Ozs7OzlVVVVVVVVX+/v7+/v7+/v7+/v7+/v7+/v5VVVVVVVVVzs7Ozs7Ozs7Ozs7Ozs7OzlVVVVVVVVX+/v7+/v7+/v7+/v7+/v7+/v5VVVVVVVVVzc7Ozs7Ozs7Ozs7Ozs7OzlVVVVVVVVX+/v7+/v7+/v7+/v7+/v7+/v5VVVVVVVVVec7Ozs7Ozs7Ozs7Ozs7OeVVVVVVVVVX+/v7+/v7+/v7+/v7+/v7+/v5VVVVVVVVVT53Ozs7Ozs7Ozs7Ozs55T1VVVVVVVf7+/v7+/v7+/v7+/v7+/v7+/v7+VVVVVVVVT095x87Ozs7Ozs7Ox3lPT1VVVVX+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v5VVVVVT09PxsbHx83Nx8fGxk9PT1VVVf7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+VVVVT09PxsbGxsbGxsbGxk9PT1VV/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v5VVjMPx8bGxsbGxsbGxw8zVlX+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v5lZQ8PgMbGxsbGxsbGgA8PZWX+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+ZWVlZToPOc3GxsbGxsbNOQ86ZWVlZf7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v5lZWVlZToPD87Nx8bGx83ODw86ZWVlZWX+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/mVlZWVlZWUPD4HOzs7Ozs5dDw9lZWVlZWVl/v7+/v7+/v7+/v7+/v7+/v7+/v7+ZWVlZWVlZWU6Dw+kzs7OzqQPDzplZWVlZWVlZf7+/v7+/v7+/v7+/v7+/v7+/v7+ZWVlZWVlZWVlEA8PXc7OXQ8PEGVlZWVlZWVlZf7+/v7+/v7+/v7+/v7+/v7+/v5lZWVlZWVlZWVlQQ8PDw8PDw8QQWVlZWVlZWVlZWX+/v7+/v7+/v7+/v7+/v7+/v5lZWVlZWVlZWVlZWU6Dw8PDzplZWVlZWVlZWVlZWX+/v7+/v7+/v7+/v7+/v7+/mVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVl/v7+/v7+/v7+/v7+/v7+/mVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVl/v7+/v7+/v7+/v7+/v7+/mVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVl/v7+/v7+/v7+/v7+/v7+/mVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVl/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/qYAAABhYm91dC5pbmZv");
writeSegment(49932, "eyJpZCI6ImFib3V0IiwibmFtZSI6IkFib3V0Iiwic3JjIjoiYWJvdXQuYXBwLmpzIiwiaWNvbiI6ImFib3V0LmltZyIsInNvcnRvcmRlciI6LTQsInZlcnNpb24iOiIwLjEyIiwidGFncyI6InRvb2wsc3lzdGVtIiwiZmlsZXMiOiJhYm91dC5pbmZvLGFib3V0LmFwcC5qcyxhYm91dC5pbWciff//qQoAAGFsYXJtLmFwcC5qcw==");
writeSegment(50132, "QmFuZ2xlLmxvYWRXaWRnZXRzKCk7CkJhbmdsZS5kcmF3V2lkZ2V0cygpOwqsYWxhcm1zPXJlcXVpcmUoIlN0b3JhZ2UiKS5yZWFkSlNPTigiYWxhcm0uanNvbiIsMSmgW107Cqpmb3JtYXRUaW1lKHQpe6xocnM9MHx0O6xtaW5zPU1hdGgucm91bmQoKHQtaHJzKSo2MCk7q2hycysiOiIrKCIwIittaW5zKS5zdWJzdHIoLTIpO30KqmZvcm1hdE1pbnModCl7bWlucz0oMHx0KSU2MDtocnM9MHwodC82MCk7q2hycysiOiIrKCIwIittaW5zKS5zdWJzdHIoLTIpO30KqmdldEN1cnJlbnRIcigpe6x0aW1lPbhEYXRlKCk7q3RpbWUuZ2V0SG91cnMoKSsodGltZS5nZXRNaW51dGVzKCkvNjApKyh0aW1lLmdldFNlY29uZHMoKS8zNjAwKTt9CqpzaG93TWFpbk1lbnUoKXuubWVudT17Jyc6eyd0aXRsZSc6J0FsYXJtL1RpbWVyJ30sJzwgQmFjayc6KCmie2xvYWQoKTt9LCdOZXcgQWxhcm0nOigpomVkaXRBbGFybSgtMSksJ05ldyBUaW1lcic6KCmiZWRpdFRpbWVyKC0xKX07YWxhcm1zLmZvckVhY2goKGFsYXJtLGlkeCmie6MoYWxhcm0udGltZXIpe3R4dD0iVElNRVIgIisoYWxhcm0ub24/Im9uICAiOiJvZmYgIikrZm9ybWF0TWlucyhhbGFybS50aW1lcik7faR7dHh0PSJBTEFSTSAiKyhhbGFybS5vbj8ib24gICI6Im9mZiAiKStmb3JtYXRUaW1lKGFsYXJtLmhyKTujKGFsYXJtLnJwKXR4dJYiIChyZXBlYXQpIjt9bWVudVt0eHRdPaooKXujKGFsYXJtLnRpbWVyKWVkaXRUaW1lcihpZHgpO6RlZGl0QWxhcm0oaWR4KTt9O30pO6MoV0lER0VUU1siYWxhcm0iXSlXSURHRVRTWyJhbGFybSJdLnJlbG9hZCgpO6tFLnNob3dNZW51KG1lbnUpO30KqmVkaXRBbGFybShhbGFybUluZGV4KXusbmV3QWxhcm09YWxhcm1JbmRleDwwO6xocnM9MTI7rG1pbnM9MDusZW49tDuscmVwZWF0PbQ7rGFzPbU7oyghbmV3QWxhcm0pe6xhPWFsYXJtc1thbGFybUluZGV4XTtocnM9MHxhLmhyO21pbnM9TWF0aC5yb3VuZCgoYS5oci1ocnMpKjYwKTtlbj1hLm9uO3JlcGVhdD1hLnJwO2FzPWEuYXM7fa5tZW51PXsnJzp7J3RpdGxlJzonQWxhcm0nfSwnPCBCYWNrJzpzaG93TWFpbk1lbnUsJ0hvdXJzJzp7dmFsdWU6aHJzLG9uY2hhbmdlOqoodil7oyh2PDApdj0yMzujKHY+MjMpdj0wO2hycz12O68udmFsdWU9djt9fSwnTWludXRlcyc6e3ZhbHVlOm1pbnMsb25jaGFuZ2U6qih2KXujKHY8MCl2PTU5O6Modj41OSl2PTA7bWlucz12O68udmFsdWU9djt9fSwnRW5hYmxlZCc6e3ZhbHVlOmVuLGZvcm1hdDp2onY/Ik9uIjoiT2ZmIixvbmNoYW5nZTp2omVuPXZ9LCdSZXBlYXQnOnt2YWx1ZTplbixmb3JtYXQ6dqJ2PyJZZXMiOiJObyIsb25jaGFuZ2U6dqJyZXBlYXQ9dn0sJ0F1dG8gc25vb3plJzp7dmFsdWU6YXMsZm9ybWF0Onaidj8iWWVzIjoiTm8iLG9uY2hhbmdlOnaiYXM9dn19O6pnZXRBbGFybSgpe6xocj1ocnMrKG1pbnMvNjApO6xkYXk9MDujKGhyPGdldEN1cnJlbnRIcigpKWRheT0ouERhdGUoKSkuZ2V0RGF0ZSgpO6t7b246ZW4saHI6aHIsbGFzdDpkYXkscnA6cmVwZWF0LGFzOmFzfTt9bWVudVsiPiBTYXZlIl09qigpe6MobmV3QWxhcm0pYWxhcm1zLnB1c2goZ2V0QWxhcm0oKSk7pGFsYXJtc1thbGFybUluZGV4XT1nZXRBbGFybSgpO3JlcXVpcmUoIlN0b3JhZ2UiKS53cml0ZSgiYWxhcm0uanNvbiIsSlNPTi5zdHJpbmdpZnkoYWxhcm1zKSk7c2hvd01haW5NZW51KCk7fTujKCFuZXdBbGFybSl7bWVudVsiPiBEZWxldGUiXT2qKCl7YWxhcm1zLnNwbGljZShhbGFybUluZGV4LDEpO3JlcXVpcmUoIlN0b3JhZ2UiKS53cml0ZSgiYWxhcm0uanNvbiIsSlNPTi5zdHJpbmdpZnkoYWxhcm1zKSk7c2hvd01haW5NZW51KCk7fTt9q0Uuc2hvd01lbnUobWVudSk7fQqqZWRpdFRpbWVyKGFsYXJtSW5kZXgpe6xuZXdBbGFybT1hbGFybUluZGV4PDA7rGhycz0wO6xtaW5zPTU7rGVuPbQ7oyghbmV3QWxhcm0pe6xhPWFsYXJtc1thbGFybUluZGV4XTttaW5zPSgwfGEudGltZXIpJTYwO2hycz0wfChhLnRpbWVyLzYwKTtlbj1hLm9uO32ubWVudT17Jyc6eyd0aXRsZSc6J1RpbWVyJ30sJ0hvdXJzJzp7dmFsdWU6aHJzLG9uY2hhbmdlOqoodil7oyh2PDApdj0yMzujKHY+MjMpdj0wO2hycz12O68udmFsdWU9djt9fSwnTWludXRlcyc6e3ZhbHVlOm1pbnMsb25jaGFuZ2U6qih2KXujKHY8MCl2PTU5O6Modj41OSl2PTA7bWlucz12O68udmFsdWU9djt9fSwnRW5hYmxlZCc6e3ZhbHVlOmVuLGZvcm1hdDp2onY/Ik9uIjoiT2ZmIixvbmNoYW5nZTp2omVuPXZ9fTuqZ2V0VGltZXIoKXusZD24RGF0ZShEYXRlLm5vdygpKygoaHJzKjYwKSttaW5zKSo2MDAwMCk7rGhyPWQuZ2V0SG91cnMoKSsoZC5nZXRNaW51dGVzKCkvNjApKyhkLmdldFNlY29uZHMoKS8zNjAwKTure29uOmVuLHRpbWVyOihocnMqNjApK21pbnMsaHI6aHIscnA6tSxhczq1fTt9bWVudVsiPiBTYXZlIl09qigpe6MobmV3QWxhcm0pYWxhcm1zLnB1c2goZ2V0VGltZXIoKSk7pGFsYXJtc1thbGFybUluZGV4XT1nZXRUaW1lcigpO3JlcXVpcmUoIlN0b3JhZ2UiKS53cml0ZSgiYWxhcm0uanNvbiIsSlNPTi5zdHJpbmdpZnkoYWxhcm1zKSk7c2hvd01haW5NZW51KCk7fTujKCFuZXdBbGFybSl7bWVudVsiPiBEZWxldGUiXT2qKCl7YWxhcm1zLnNwbGljZShhbGFybUluZGV4LDEpO3JlcXVpcmUoIlN0b3JhZ2UiKS53cml0ZSgiYWxhcm0uanNvbiIsSlNPTi5zdHJpbmdpZnkoYWxhcm1zKSk7c2hvd01haW5NZW51KCk7fTt9q0Uuc2hvd01lbnUobWVudSk7fQpzaG93TWFpbk1lbnUoKTv////yAQAAYWxhcm0uYm9vdC5qcw==");
writeSegment(52896, "KKooKXusYWxhcm1zPXJlcXVpcmUoJ1N0b3JhZ2UnKS5yZWFkSlNPTignYWxhcm0uanNvbicsMSmgW107rHRpbWU9uERhdGUoKTusYWN0aXZlPWFsYXJtcy5maWx0ZXIoYaJhLm9uKTujKGFjdGl2ZS5sZW5ndGgpe2FjdGl2ZT1hY3RpdmUuc29ydCgoYSxiKaIoYS5oci1iLmhyKSsoYS5sYXN0LWIubGFzdCkqMjQpO6xocj10aW1lLmdldEhvdXJzKCkrKHRpbWUuZ2V0TWludXRlcygpLzYwKSsodGltZS5nZXRTZWNvbmRzKCkvMzYwMCk7oyghcmVxdWlyZSgnU3RvcmFnZScpLnJlYWQoImFsYXJtLmpzIikpe2NvbnNvbGUubG9nKCJObyBhbGFybSBhcHAhIik7cmVxdWlyZSgnU3RvcmFnZScpLndyaXRlKCdhbGFybS5qc29uJywiW10iKTt9pHusdD0zNjAwMDAwKihhY3RpdmVbMF0uaHItaHIpO6MoYWN0aXZlWzBdLmxhc3SKdGltZS5nZXREYXRlKCmgdDwwKXSWODY0MDAwMDA7oyh0PDEwMDApdD0xMDAwO3NldFRpbWVvdXQoqigpe2xvYWQoImFsYXJtLmpzIik7fSx0KTt9fX0pKCk7//+eBAAAYWxhcm0uanM=");
writeSegment(53428, "CmNsZWFySW50ZXJ2YWwoKTsKqmZvcm1hdFRpbWUodCl7rGhycz0wfHQ7rG1pbnM9TWF0aC5yb3VuZCgodC1ocnMpKjYwKTuraHJzKyI6IisoIjAiK21pbnMpLnN1YnN0cigtMik7fQqqZ2V0Q3VycmVudEhyKCl7rHRpbWU9uERhdGUoKTurdGltZS5nZXRIb3VycygpKyh0aW1lLmdldE1pbnV0ZXMoKS82MCkrKHRpbWUuZ2V0U2Vjb25kcygpLzM2MDApO30KqnNob3dBbGFybShhbGFybSl7rG1zZz1mb3JtYXRUaW1lKGFsYXJtLmhyKTusYnV6ekNvdW50PTEwO6MoYWxhcm0ubXNnKW1zZ5YiXG4iK2FsYXJtLm1zZztCYW5nbGUubG9hZFdpZGdldHMoKTtCYW5nbGUuZHJhd1dpZGdldHMoKTtFLnNob3dQcm9tcHQobXNnLHt0aXRsZTphbGFybS50aW1lcj8iVElNRVIhIjoiQUxBUk0hIixidXR0b25zOnsiU2xlZXAiOrQsIk9rIjq1fX0pLnRoZW4oqihzbGVlcCl7YnV6ekNvdW50PTA7oyhzbGVlcCl7oyhhbGFybS5vaHKLtylhbGFybS5vaHI9YWxhcm0uaHI7YWxhcm0uaHKWMTAvNjA7faR7YWxhcm0ubGFzdD0ouERhdGUoKSkuZ2V0RGF0ZSgpO6MoYWxhcm0ub2hyjbcpe2FsYXJtLmhyPWFsYXJtLm9ocju+YWxhcm0ub2hyO32jKCFhbGFybS5ycClhbGFybS5vbj21O31yZXF1aXJlKCJTdG9yYWdlIikud3JpdGUoImFsYXJtLmpzb24iLEpTT04uc3RyaW5naWZ5KGFsYXJtcykpO2xvYWQoKTt9KTuqYnV6eigpe6MoKHJlcXVpcmUoJ1N0b3JhZ2UnKS5yZWFkSlNPTignc2V0dGluZy5qc29uJywxKaB7fSkucXVpZXQ+MSmrO0JhbmdsZS5idXp6KDEwMCkudGhlbigoKaJ7c2V0VGltZW91dCgoKaJ7QmFuZ2xlLmJ1enooMTAwKS50aGVuKKooKXujKGJ1enpDb3VudJkpc2V0VGltZW91dChidXp6LDMwMDApO6SjKGFsYXJtLmFzKXtidXp6Q291bnQ9MTA7c2V0VGltZW91dChidXp6LDYwMDAwMCk7fX0pO30sMTAwKTt9KTt9YnV6eigpO30KrGRheT0ouERhdGUoKSkuZ2V0RGF0ZSgpOwqsaHI9Z2V0Q3VycmVudEhyKCkrMTAwMDA7CqxhbGFybXM9cmVxdWlyZSgiU3RvcmFnZSIpLnJlYWRKU09OKCJhbGFybS5qc29uIiwxKaBbXTsKrGFjdGl2ZT1hbGFybXMuZmlsdGVyKGGiYS5vbp4oYS5ocjxocimeKGEubGFzdIxkYXkpKTsKoyhhY3RpdmUubGVuZ3RoKXthY3RpdmU9YWN0aXZlLnNvcnQoKGEsYimiYS5oci1iLmhyKTtzaG93QWxhcm0oYWN0aXZlWzBdKTt9pHtzZXRUaW1lb3V0KGxvYWQsMTAwKTt9//+EBAAAYWxhcm0uaW1n");
writeSegment(54644, "MDCEBmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmERFmZmZmZmZmZmZmZmZmZmYRERFmZmZmERFmZmZmERERZmZmZmZmZhERERERZmZmERFmZmYREREREWZmZmZmYREREREWZmbMzMzMZmZhERERERZmZmZmERERERFmzMzMzMzMzMxmERERERFmZmZhERERERbMzMzMzMzMzMzMYREREREWZmZhERERERzMzMzMzMzMzMzMwREREREWZmYRERERFMzMzEQz//8zRMzMzEERERERZmYRERERTMzMQ////////zTMzMQRERERZmYREREUzMzD//////////88zMxBERERZmYRERFMzMQ/////8A/////zTMzEERERZmYRERHMzE//////8A//////9MzMERERZmYREWzMxP//////8A///////0zMxhERZmZhFszMw///////8A///////zzMzGEWZmZhZszMP///////8A////////PMzGYWZmZmbMzE////////8A////////9MzMZmZmZmbMzD////////8A////////88zMZmZmZmbMxP////////8A/////////0zMZmZmZmbMxP////////8A/////////0zMZmZmZmzMw/////////8A/////////zzMxmZmZmzMw/////////8A/////////zzMxmZmZmzMz/////////MAP/////////zMxmZmZmzMz/////////BVD/////////zMxmZmZmzMz/////////BVA/////////zMxmZmZmzMz////////zQAAD////////zMxmZmZmzMw///////80PzAAP//////zzMxmZmZmzMw///////ND//MAA//////zzMxmZmZmbMxP/////zQ///8wAD/////0zMZmZmZmbMxP////80P////zAAP////0zMZmZmZmbMzD////ND//////MC////88zMZmZmZmbMzE///zQ///////8/////9MzMZmZmZmZszMP/80P/////////////PMzGZmZmZmZszMw//z/////////////zzMzGZmZmZmZmzMxP///////////////0zMxmZmZmZmZmbMzE//////////////9MzMZmZmZmZmZmbMzMQ////////////zTMzMZmZmZmZmZmZszMzD//////////88zMzGZmZmZmZmZmZmzMzMQ////////zTMzMxmZmZmZmZmZmZmFMzMzEQz//8zRMzMzEFmZmZmZmZmZmZhERzMzMzMzMzMzMzMwREWZmZmZmZmZmYRERbMzMzMzMzMzMzMYRERZmZmZmZmZmEREWZmzMzMzMzMzMxmZhERFmZmZmZmZmERFmZmZmbMzMzMZmZmZmERFmZmZmZmZmERZmZmZmZmZmZmZmZmZmYRFmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZk4BAABhbGFybS53aWQuanM=");
writeSegment(55832, "V0lER0VUU1siYWxhcm0iXT17YXJlYToidGwiLHdpZHRoOjAsZHJhdzqqKCl7oyivLndpZHRoKWcucmVzZXQoKS5kcmF3SW1hZ2UoYXRvYigiR0JnQkFBQUFBQUFBQUJnQURoaHdERHd3R1A4WUdmK1lNZitNTS8vTU0vL01BLy9BQS8vQUEvL0FBLy9BQS8vQUEvL0FCLy9nRC8vd0QvL3dBQUFBQUR3QUFCZ0FBQUFBQUFBQSIpLK8ueCyvLnkpO30scmVsb2FkOqooKXtXSURHRVRTWyJhbGFybSJdLndpZHRoPShyZXF1aXJlKCdTdG9yYWdlJykucmVhZEpTT04oJ2FsYXJtLmpzb24nLDEpoFtdKS5zb21lKGFsYXJtomFsYXJtLm9uKT8yNDowO319OwpXSURHRVRTWyJhbGFybSJdLnJlbG9hZCgpO///1gAAAGFsYXJtLmluZm8=");
writeSegment(56200, "eyJpZCI6ImFsYXJtIiwibmFtZSI6IkFsYXJtcyIsInNyYyI6ImFsYXJtLmFwcC5qcyIsImljb24iOiJhbGFybS5pbWciLCJ2ZXJzaW9uIjoiMC4xNCIsInRhZ3MiOiJ0b29sLGFsYXJtLHdpZGdldCIsImZpbGVzIjoiYWxhcm0uaW5mbyxhbGFybS5hcHAuanMsYWxhcm0uYm9vdC5qcyxhbGFybS5qcyxhbGFybS5pbWcsYWxhcm0ud2lkLmpzIiwiZGF0YSI6ImFsYXJtLmpzb24iff//KQEAAHdpZGxvY2sud2lkLmpz");
writeSegment(56448, "KKooKXujKCFCYW5nbGUuaXNMb2NrZWQpqztCYW5nbGUub24oImxvY2siLKoob24pe1dJREdFVFNbImxvY2siXS53aWR0aD1CYW5nbGUuaXNMb2NrZWQoKT8xNjowO0JhbmdsZS5kcmF3V2lkZ2V0cygpO30pO1dJREdFVFNbImxvY2siXT17YXJlYToidGwiLHdpZHRoOkJhbmdsZS5pc0xvY2tlZCgpPzE2OjAsZHJhdzqqKHcpe6MoQmFuZ2xlLmlzTG9ja2VkKCkpZy5yZXNldCgpLmRyYXdJbWFnZShhdG9iKCJEaEFCSCtEL3d3TU1EREF3d01mL3YvLzRmK0gvaC84Ly9QL3ovLy9mL2c9PSIpLHcueCsxLHcueSs0KTt9fTt9KSgp////gQAAAHdpZGxvY2suaW5mbw==");
writeSegment(56780, "eyJpZCI6IndpZGxvY2siLCJuYW1lIjoiTG9jayBXaWRnZXQiLCJ0eXBlIjoid2lkZ2V0IiwidmVyc2lvbiI6IjAuMDMiLCJ0YWdzIjoid2lkZ2V0LGxvY2siLCJmaWxlcyI6IndpZGxvY2suaW5mbyx3aWRsb2NrLndpZC5qcyJ9////YgMAAHdpZGJhdC53aWQuanM=");
writeSegment(56944, "KKooKXuqc2V0V2lkdGgoKXtXSURHRVRTWyJiYXQiXS53aWR0aD00MCsoQmFuZ2xlLmlzQ2hhcmdpbmcoKT8xNjowKTt9QmFuZ2xlLm9uKCdjaGFyZ2luZycsqihjaGFyZ2luZyl7oyhjaGFyZ2luZylCYW5nbGUuYnV6eigpO3NldFdpZHRoKCk7QmFuZ2xlLmRyYXdXaWRnZXRzKCk7Zy5mbGlwKCk7fSk7rGJhdHRlcnlJbnRlcnZhbD1CYW5nbGUuaXNMQ0RPbigpP3NldEludGVydmFsKCgpoldJREdFVFNbImJhdCJdLmRyYXcoKSw2MDAwMCk6tztCYW5nbGUub24oJ2xjZFBvd2VyJyyqKG9uKXujKG9uKXtXSURHRVRTWyJiYXQiXS5kcmF3KCk7oyghYmF0dGVyeUludGVydmFsKWJhdHRlcnlJbnRlcnZhbD1zZXRJbnRlcnZhbCgoKaJXSURHRVRTWyJiYXQiXS5kcmF3KCksNjAwMDApO32ke6MoYmF0dGVyeUludGVydmFsKXtjbGVhckludGVydmFsKGJhdHRlcnlJbnRlcnZhbCk7YmF0dGVyeUludGVydmFsPbc7fX19KTtXSURHRVRTWyJiYXQiXT17YXJlYToidHIiLHdpZHRoOjQwLGRyYXc6qigpe6xzPTM5O6x4Pa8ueCx5Pa8ueTtnLnJlc2V0KCk7oyhCYW5nbGUuaXNDaGFyZ2luZygpKXtnLnNldENvbG9yKCIjMGYwIikuZHJhd0ltYWdlKGF0b2IoIkRoZ0JIT0J6Z2M0SE9QLy8vLy8vLy8vLy8vLy8vLy8vLy8zLzRIZ0I0QWVBSGdCNEFlQUhnQjRBZUFIZyIpLHgseSk7eJYxNjt9Zy5zZXRDb2xvcihnLnRoZW1lLmZnKS5maWxsUmVjdCh4LHkrMix4K3MtNCx5KzIxKS5jbGVhclJlY3QoeCsyLHkrNCx4K3MtNix5KzE5KS5maWxsUmVjdCh4K3MtMyx5KzEwLHgrcyx5KzE0KTtnLnNldENvbG9yKCIjMGYwIikuZmlsbFJlY3QoeCs0LHkrNix4KzQrRS5nZXRCYXR0ZXJ5KCkqKHMtMTIpLzEwMCx5KzE3KTt9fTtzZXRXaWR0aCgpO30pKCn//4oAAAB3aWRiYXQuaW5mbw==");
writeSegment(57844, "eyJpZCI6IndpZGJhdCIsIm5hbWUiOiJCYXR0ZXJ5IExldmVsIFdpZGdldCIsInR5cGUiOiJ3aWRnZXQiLCJ2ZXJzaW9uIjoiMC4wOSIsInRhZ3MiOiJ3aWRnZXQsYmF0dGVyeSIsImZpbGVzIjoid2lkYmF0LmluZm8sd2lkYmF0LndpZC5qcyJ9//+7AQAAd2lkYnQud2lkLmpz");
writeSegment(58016, "V0lER0VUU1siYmx1ZXRvb3RoIl09e2FyZWE6InRyIix3aWR0aDoxNSxkcmF3OqooKXtnLnJlc2V0KCk7oyhOUkYuZ2V0U2VjdXJpdHlTdGF0dXMoKS5jb25uZWN0ZWQpZy5zZXRDb2xvcigoZy5nZXRCUFAoKT44KT8iIzA3ZiI6KGcudGhlbWUuZGFyaz8iIzBmZiI6IiMwMGYiKSk7pGcuc2V0Q29sb3IoZy50aGVtZS5kYXJrPyIjNjY2IjoiIzk5OSIpO2cuZHJhd0ltYWdlKGF0b2IoIkN4UUJCZ0RnRmdKZ1I0alpNYXdmQWNBNEQ0Tll5YkVZSXdUQXNCd0RBQT09IiksMiuvLngsMiuvLnkpO30sY2hhbmdlZDqqKCl7V0lER0VUU1siYmx1ZXRvb3RoIl0uZHJhdygpO0JhbmdsZS5zZXRMQ0RQb3dlcigxKTt9fTsKTlJGLm9uKCdjb25uZWN0JyxXSURHRVRTWyJibHVldG9vdGgiXS5jaGFuZ2VkKTsKTlJGLm9uKCdkaXNjb25uZWN0JyxXSURHRVRTWyJibHVldG9vdGgiXS5jaGFuZ2VkKTv/hQAAAHdpZGJ0LmluZm8=");
writeSegment(58492, "eyJpZCI6IndpZGJ0IiwibmFtZSI6IkJsdWV0b290aCBXaWRnZXQiLCJ0eXBlIjoid2lkZ2V0IiwidmVyc2lvbiI6IjAuMDciLCJ0YWdzIjoid2lkZ2V0LGJsdWV0b290aCIsImZpbGVzIjoid2lkYnQuaW5mbyx3aWRidC53aWQuanMiff////wAAAB3aWRpZC53aWQuanM=");
writeSegment(58660, "KCgponuqZHJhdygpe6xpZD1OUkYuZ2V0QWRkcmVzcygpLnN1YnN0cigpLnN1YnN0cigxMikuc3BsaXQoIjoiKTtnLnJlc2V0KCkuc2V0Q29sb3IoZy50aGVtZS5kYXJrPyIjMGZmIjoiIzAwZiIpLnNldEZvbnQoIjZ4OCIsMSk7Zy5kcmF3U3RyaW5nKGlkWzBdLK8ueCsyLK8ueSs0LLQpO2cuZHJhd1N0cmluZyhpZFsxXSyvLngrMiyvLnkrMTQstCk7fVdJREdFVFNbIndpZGlkIl09e2FyZWE6InRyIix3aWR0aDoxNixkcmF3OmRyYXd9O30pKCk7igAAAHdpZGlkLmluZm8=");
writeSegment(58944, "eyJpZCI6IndpZGlkIiwibmFtZSI6IkJsdWV0b290aCBJRCBXaWRnZXQiLCJ0eXBlIjoid2lkZ2V0IiwidmVyc2lvbiI6IjAuMDMiLCJ0YWdzIjoid2lkZ2V0LGFkZHJlc3MsbWFjIiwiZmlsZXMiOiJ3aWRpZC5pbmZvLHdpZGlkLndpZC5qcyJ9//+pAAAAd2VsY29tZS5ib290Lmpz");
writeSegment(59116, "KKooKXutcz1yZXF1aXJlKCdTdG9yYWdlJykucmVhZEpTT04oJ3dlbGNvbWUuanNvbicsMSmge307oyghcy53ZWxjb21lZCl7c2V0VGltZW91dCgoKaJ7cmVxdWlyZSgnU3RvcmFnZScpLndyaXRlKCd3ZWxjb21lLmpzb24nLHt3ZWxjb21lZDq0fSlsb2FkKCd3ZWxjb21lLmFwcC5qcycpfSl9fSkoKf///14XAAB3ZWxjb21lLmFwcC5qcw==");
writeSegment(59320, "CqphbmltYXRlKHNlcSxwZXJpb2Qpe6xjPWcuZ2V0Q29sb3IoKTusaT1zZXRJbnRlcnZhbCiqKCl7oyhzZXEubGVuZ3RoKXusZj1zZXEuc2hpZnQoKTtnLnNldENvbG9yKGMpO6MoZilmKCk7faRjbGVhckludGVydmFsKGkpO30scGVyaW9kKTt9CqpmYWRlKGNvbCxjYWxsYmFjayl7rG49MDuqZigpeyJyYW0iZy5zZXRDb2xvcihjb2wpO6corGk9bjtpPDI0MDtpljEwKWcuZHJhd0xpbmUoaSwwLDAsaSkuZHJhd0xpbmUoaSwyNDAsMjQwLGkpO2cuZmxpcCgpO26YO6MobjwxMClzZXRUaW1lb3V0KGYsMCk7pGNhbGxiYWNrKCk7fWYoKTt9CqxTQ0VORV9DT1VOVD0xMDsKqmdldFNjZW5lKG4pe6MoboowKauqKCl7Zy5yZXNldCgpLnNldEJnQ29sb3IoMCkuY2xlYXJSZWN0KDAsMCwxNzYsMTc2KTtnLnNldEZvbnQoIjZ4MTUiKTusbj0wO6xsPUJhbmdsZS5nZXRMb2dvKCk7rGltPWcuaW1hZ2VNZXRyaWNzKGwpO6xpPXNldEludGVydmFsKKooKXtuljAuMTtnLnNldENvbG9yKG4sbixuKTtnLmRyYXdJbWFnZShsLCgxNzYtaW0ud2lkdGgpLzIsKDE3Ni1pbS5oZWlnaHQpLzIpO6MobpExKXtjbGVhckludGVydmFsKGkpO3NldFRpbWVvdXQoKCmiZy5kcmF3U3RyaW5nKCJPcGVuIiw0NCwxMDQpLDUwMCk7c2V0VGltZW91dCgoKaJnLmRyYXdTdHJpbmcoIkhhY2thYmxlIiw0NCwxMTYpLDEwMDApO3NldFRpbWVvdXQoKCmiZy5kcmF3U3RyaW5nKCJTbWFydCBXYXRjaCIsNDQsMTI4KSwxNTAwKTt9fSw1MCk7fTujKG6KMSmrqigpe6xpbWc9cmVxdWlyZSgiaGVhdHNocmluayIpLmRlY29tcHJlc3MoYXRvYigicHRSNG4vai80Z0grOEg1d2wrak91a1ZWb0haOGR0L24vL24zN090Z0g5c0hod0hwNEg1eG1rR2lINzJNUmplL0xMLzdpSUFFRTdzUEVnb0FDK0FsYWdJbElpTVFFclB4RHdVWXhBQUJ3SUhDajhON25PbDN1RXFhNkJFZ2duRmpmTTVuQ2tVaWwzZ0VxNUtEQUFRbUM2UW1CRTRKeFNFaElBQmlRbUI4UW1TWG9RbENZUk1kRXdJbENBQUlsTmhZbE9pTzg1bk5FeU1QRW9ad0lBQWNzWUlZbVBYb1lsTWlLYUZFeFgvdTlWRXFMQkJPWXJDSCtjem10VnFKeURFcGlhQ09Zc2dTWXN6bWMzcXRURXFNUjdoekc4QWxHbWQxT1FnbE9PWTZhRWdZbENtbVpvSk1DVEJybkQ2U2FJRW9VL3pPVXVvbFNqYm5CSmdxYUNFb1U1ek9YWDRSeVFZQkJ6Q1M0WDV6TkRxcVpDSmlFUkpnNXpCRW9WSkVvTTFKZ1lsUWpoTUhjNEpMRW1aTUVFcDZaSUpnUHpTNFdUbVpNVlRJTG1GWUFLK0JtZ2xDbWQxSmdVWUppUE5Fb3JBQkVJT1p5Z0RCbTVNQ2lKTVFsaE1IOEJ5Qlh3SWxCSmdVeEppTWQ1bk9USXpsQlRBSytCQUFOVnE0alBBQVMvSEpnSnlDVEFUQUVBQ0MvQjRTL0lKZ0lsQ1lBZ0FQaVMvS241eUVZQU5URXlQYzVuaU9ReE1CL0xsQ09hcHlKSmdicEJZQVp6Uk9RSy9HbDBBVElXZkVvWnpCYzZJbEI2U1lHZ0JKQkpncHpTbGh5SDhFQWg1TUJUSWpuQ3VJbE9qamxIVEFKekMvTG1EVFNTWUlFb1RBQk9ZSWxFVFNLWUhYd0lBQk9ZTTB5WW1FVFNDWUhFb2JuRE9ZcWFCRXh1OFRBd2xFYzRVNUVvaWFDbUsrTlRBb2xGRXdYMFRRekJNWHdYaUVwVEJDQUFvbU5Fb1MrRUVvNG1JWUlJbUtFb1MrRUVwRG9CRXlVYkVvM2dFbzRtSmRBSW1JSlk0bEpFeWNkRW9QT09CWW1QdUlsRStIY0pZaEtLVFoxZmhZa0IyRUFobk5jWU11RWhvbU1yOEEzWUFCRW9KeUI1Z2pPQUFZbUhtOVZnRUxFb0pNQkVvWEFFeVh6RTQ1WUJKZ1h3RXF4MUkrQnlET1lKeVZKdzV5Q2dFQjNjUUdnSk1XSndRbkN1Ni9DZ0ZCaWdEQjEzUy9nbFZBQWYxcW9tQ2dsRW9BREIxUURCQURFUEVvTlZxRUFvbEVnRUtvbEtFckpNRFlBSk1EMGxFMEFtYUVvTmFBZ0pNQ0ZJWUFhaFYvSWdJaURPVGdBQk5ZSk1FT1RvaUNJb0pNQ09UemZDTjRSTUJPVHhzREpJUnlmSXdaTUJLUVp6ZkpnUnlmT1laTUJPVUJ6Q0pnTktPVDV6REpnTG9DQUR4S0JPQUlBQk9UNmFDQUFSeWZPWVJ5ak9ZUnlqT1lsS0VzQnpFRXNCekVPVUp6RE9VSUFCT1VpYURPVVJ6Q09VWnpDRXNjS0NpWSIpKTusaW09Zy5pbWFnZU1ldHJpY3MoaW1nKTtnLnJlc2V0KCk7Zy5zZXRCZ0NvbG9yKCIjZmYwMGZmIik7rHk9MTc2LHNwZWVkPTU7qmJhbGxvb24oY2FsbGJhY2spe3mXc3BlZWQ7rHg9KDE3Ni1pbS53aWR0aCkvMjtnLmRyYXdJbWFnZShpbWcseCx5KTtnLmNsZWFyUmVjdCh4LHkrODEseCs3Nyx5KzgxK3NwZWVkKTujKHk+MzApc2V0VGltZW91dChiYWxsb29uLDAsY2FsbGJhY2spO6RjYWxsYmFjaygpO31mYWRlKCIjZmYwMGZmIiyqKCl7YmFsbG9vbiiqKCl7Zy5zZXRDb2xvcigtMSkuc2V0Rm9udCgiNngxNToyIikuc2V0Rm9udEFsaWduKDAsMCk7Zy5kcmF3U3RyaW5nKCJXZWxjb21lLiIsODgsMTMwKTt9KTt9KTtzZXRUaW1lb3V0KKooKXusbj0wO6xpPXNldEludGVydmFsKKooKXtuljQ7Zy5zY3JvbGwoMCwtNCk7oyhuPjE1MCljbGVhckludGVydmFsKGkpO30sMjApO30sMzUwMCk7fTujKG6KMimrqigpe2cucmVzZXQoKTtnLnNldEJnQ29sb3IoIiNmZmZmMDAiKS5zZXRDb2xvcigwKS5jbGVhcigpO2cuc2V0Rm9udCgiMTJ4MjAiKS5zZXRGb250QWxpZ24oMCwwKTuseD03MCx5PTI1LGg9MjU7YW5pbWF0ZShbKCmiZy5kcmF3U3RyaW5nKCJZb3VyIix4LHmWaCksKCmiZy5kcmF3U3RyaW5nKCJCYW5nbGUuanMiLHgseZZoKSwoKaJnLmRyYXdTdHJpbmcoImhhcyBvbmUiLHgseZZoKSwoKaJnLmRyYXdTdHJpbmcoImJ1dHRvbiIseCx5lmgpLCgpontnLnNldEZvbnQoIjEyeDIwOjIiKS5zZXRGb250QWxpZ24oMCwwLDEpLmRyYXdTdHJpbmcoIkhFUkUhIiwxNTAsODgpO31dLDIwMCk7fTujKG6KMymrqigpe2cucmVzZXQoKTtnLnNldEJnQ29sb3IoIiMwMGZmZmYiKS5zZXRDb2xvcigwKS5jbGVhcigpO2cuc2V0Rm9udEFsaWduKDAsMCkuc2V0Rm9udCgiNngxNToyIik7Zy5kcmF3U3RyaW5nKCJQcmVzcyIsODgsNDApLnNldEZvbnRBbGlnbigwLC0xKTtnLnNldEZvbnQoIjEyeDIwIik7Zy5kcmF3U3RyaW5nKCJUbyB3YWtlIHRoZVxuc2NyZWVuIHVwLCBvciB0b1xuc2VsZWN0Iiw4OCw2MCk7fTujKG6KNCmrqigpe2cucmVzZXQoKTtnLnNldEJnQ29sb3IoIiMwMGZmZmYiKS5zZXRDb2xvcigwKS5jbGVhcigpO2cuc2V0Rm9udEFsaWduKDAsMCkuc2V0Rm9udCgiNngxNToyIik7Zy5kcmF3U3RyaW5nKCJMb25nIFByZXNzIiw4OCw0MCkuc2V0Rm9udEFsaWduKDAsLTEpO2cuc2V0Rm9udCgiMTJ4MjAiKTtnLmRyYXdTdHJpbmcoIlRvIGdvIGJhY2sgdG9cbnRoZSBjbG9jayIsODgsNjApO307oyhuijUpq6ooKXtnLnJlc2V0KCk7Zy5zZXRCZ0NvbG9yKCIjZmYwMDAwIikuc2V0Q29sb3IoMCkuY2xlYXIoKTtnLnNldEZvbnRBbGlnbigwLDApLnNldEZvbnQoIjEyeDIwIik7Zy5kcmF3U3RyaW5nKCJJZiBCYW5nbGUuanMgZXZlclxuc3RvcHMsIGhvbGQgdGhlXG5idXR0b24gZm9yXG50ZW4gc2Vjb25kcy5cblxuQmFuZ2xlLmpzIHdpbGxcbnRoZW4gcmVib290LiIsODgsNzgpO307oyhuijYpq6ooKXtnLnJlc2V0KCk7Zy5zZXRCZ0NvbG9yKCIjMDAwMGZmIikuc2V0Q29sb3IoLTEpLmNsZWFyKCk7Zy5zZXRGb250KCIxMngyMCIpLnNldEZvbnRBbGlnbigwLDApO6x4PTg4LHk9LTIwLGg9NjA7YW5pbWF0ZShbKCmie2cuZHJhd1N0cmluZygiQmFuZ2xlLmpzIGhhcyBhXG5mdWxsIHRvdWNoc2NyZWVuIix4LHmWaCk7fSwwLDAsKCmie2cuZHJhd1N0cmluZygiRHJhZyB1cCBhbmQgZG93blxudG8gc2Nyb2xsIGFuZFxudGFwIHRvIHNlbGVjdCIseCx5lmgpO30sXSwzMDApO307oyhuijcpq6ooKXtnLnJlc2V0KCk7Zy5zZXRCZ0NvbG9yKCIjMDBmZjAwIikuc2V0Q29sb3IoMCkuY2xlYXIoKTtnLnNldEZvbnQoIjEyeDIwIikuc2V0Rm9udEFsaWduKDAsMCk7rHg9ODgseT0tMzUsaD04MDthbmltYXRlKFsoKaJ7Zy5kcmF3U3RyaW5nKCJCYW5nbGUuanMgY29tZXNcbndpdGggYSBmZXdcbmFwcHMgaW5zdGFsbGVkIix4LHmWaCk7fSwwLDAsKCmie2cuZHJhd1N0cmluZygiVG8gYWRkIG1vcmUsIHZpc2l0XG5iYW5nbGVqcy5jb20vYXBwcyIseCx5lmgpO30sXSw0MDApO307oyhuijgpq6ooKXtnLnJlc2V0KCk7Zy5zZXRCZ0NvbG9yKCIjZmYwMDAwIikuc2V0Q29sb3IoMCkuY2xlYXIoKTtnLnNldEZvbnQoIjEyeDIwIikuc2V0Rm9udEFsaWduKDAsMCk7rHg9ODg7Zy5kcmF3U3RyaW5nKCJZb3UgY2FuIGFsc28gbWFrZVxueW91ciBvd24gYXBwcyEiLHgsMzApO2cuZHJhd1N0cmluZygiQ2hlY2sgb3V0XG5iYW5nbGVqcy5jb20iLHgsMTMwKTuscng9MCxyeT0wO6pkcmF3KCl7cniWMC4xO3J5ljAuMTE7rHJjeD1NYXRoLmNvcyhyeCkscnN4PU1hdGguc2luKHJ4KSxyY3k9TWF0aC5jb3MocnkpLHJzeT1NYXRoLnNpbihyeSk7qnAoeCx5LHope6x0O3Q9eCpyY3kreipyc3k7ej16KnJjeS14KnJzeTt4PXQ7dD15KnJjeCt6KnJzeDt6PXoqcmN4LXkqcnN4O3k9dDt6ljQ7q1s4OCs2MCp4L3osNzgrNjAqeS96XTt9rGE7rHM9MzA7Zy5jbGVhclJlY3QoODgtcyw3OC1zLDg4K3MsNzgrcyk7YT1wKC0xLC0xLC0xKTtnLm1vdmVUbyhhWzBdLGFbMV0pO2E9cCgxLC0xLC0xKTtnLmxpbmVUbyhhWzBdLGFbMV0pO2E9cCgxLDEsLTEpO2cubGluZVRvKGFbMF0sYVsxXSk7YT1wKC0xLDEsLTEpO2cubGluZVRvKGFbMF0sYVsxXSk7YT1wKC0xLC0xLC0xKTtnLmxpbmVUbyhhWzBdLGFbMV0pO2E9cCgtMSwtMSwxKTtnLm1vdmVUbyhhWzBdLGFbMV0pO2E9cCgxLC0xLDEpO2cubGluZVRvKGFbMF0sYVsxXSk7YT1wKDEsMSwxKTtnLmxpbmVUbyhhWzBdLGFbMV0pO2E9cCgtMSwxLDEpO2cubGluZVRvKGFbMF0sYVsxXSk7YT1wKC0xLC0xLDEpO2cubGluZVRvKGFbMF0sYVsxXSk7YT1wKC0xLC0xLC0xKTtnLm1vdmVUbyhhWzBdLGFbMV0pO2E9cCgtMSwtMSwxKTtnLmxpbmVUbyhhWzBdLGFbMV0pO2E9cCgxLC0xLC0xKTtnLm1vdmVUbyhhWzBdLGFbMV0pO2E9cCgxLC0xLDEpO2cubGluZVRvKGFbMF0sYVsxXSk7YT1wKDEsMSwtMSk7Zy5tb3ZlVG8oYVswXSxhWzFdKTthPXAoMSwxLDEpO2cubGluZVRvKGFbMF0sYVsxXSk7YT1wKC0xLDEsLTEpO2cubW92ZVRvKGFbMF0sYVsxXSk7YT1wKC0xLDEsMSk7Zy5saW5lVG8oYVswXSxhWzFdKTt9c2V0SW50ZXJ2YWwoZHJhdyw1MCk7fTujKG6KOSmrqigpe2cucmVzZXQoKTtnLnNldEJnQ29sb3IoIiNmZmZmZmYiKTtnLmNsZWFyKCk7Zy5zZXRGb250QWxpZ24oMCwwKTtnLnNldEZvbnQoIjEyeDIwIik7rHg9ODgseT0xMCxoPTIxO2FuaW1hdGUoWygpomcuZHJhd1N0cmluZygiVGhhdCdzIGl0ISIseCx5lmgpLCgpontnLmRyYXdTdHJpbmcoIlByZXNzIix4LHmWaCoyKTtnLmRyYXdTdHJpbmcoInRoZSBidXR0b24iLHgseZZoKTtnLmRyYXdTdHJpbmcoInRvIHN0YXJ0Iix4LHmWaCk7Zy5kcmF3U3RyaW5nKCJCYW5nbGUuanMiLHgseZZoKTt9XSw0MDApO319CqxzY2VuZU51bWJlcj0wOwqqbW92ZShkaXIpe6MoZGlyPjCec2NlbmVOdW1iZXIrMYpTQ0VORV9DT1VOVCmrO3NjZW5lTnVtYmVyPShzY2VuZU51bWJlcitkaXIpJVNDRU5FX0NPVU5UO6Moc2NlbmVOdW1iZXI8MClzY2VuZU51bWJlcj0wO2NsZWFySW50ZXJ2YWwoKTtnZXRTY2VuZShzY2VuZU51bWJlcikoKTujKHNjZW5lTnVtYmVyPjEpe6xsPVNDRU5FX0NPVU5UO6corGk9MDtpPGwtMjtpmCl7rHg9ODgrKGktKGwtMikvMikqMTI7oyhpPHNjZW5lTnVtYmVyLTEpe2cuc2V0Q29sb3IoLTEpLmZpbGxDaXJjbGUoeCwxNjYsNCk7faR7Zy5zZXRDb2xvcigwKS5maWxsQ2lyY2xlKHgsMTY2LDQpO2cuc2V0Q29sb3IoLTEpLmRyYXdDaXJjbGUoeCwxNjYsNCk7fX19oyhzY2VuZU51bWJlcjxTQ0VORV9DT1VOVC0xKXNldFRpbWVvdXQoqigpe21vdmUoMSk7fSw1MDAwKTt9CkJhbmdsZS5vbignc3dpcGUnLGRpcqJtb3ZlKGRpcikpOwpzZXRXYXRjaCgoKaJ7oyhzY2VuZU51bWJlcopTQ0VORV9DT1VOVC0xKWxvYWQoKTukbW92ZSgxKTt9LEJUTjEse3JlcGVhdDq0fSk7CkJhbmdsZS5zZXRMQ0RUaW1lb3V0KDApOwpCYW5nbGUuc2V0TG9ja2VkKDApOwpCYW5nbGUuc2V0TENEUG93ZXIoMSk7Cm1vdmUoMCk7///qAQAAd2VsY29tZS5zZXR0aW5ncy5qcw==");
writeSegment(65336, "KKooYmFjayl7rXNldHRpbmdzPXJlcXVpcmUoJ1N0b3JhZ2UnKS5yZWFkSlNPTignd2VsY29tZS5qc29uJywxKaByZXF1aXJlKCdTdG9yYWdlJykucmVhZEpTT04oJ3NldHRpbmcuanNvbicsMSmge31FLnNob3dNZW51KHsnJzp7J3RpdGxlJzonV2VsY29tZSBBcHAnfSwnUnVuIG5leHQgYm9vdCc6e3ZhbHVlOiFzZXR0aW5ncy53ZWxjb21lZCxmb3JtYXQ6dqJ2PydZZXMnOidObycsb25jaGFuZ2U6dqJyZXF1aXJlKCdTdG9yYWdlJykud3JpdGUoJ3dlbGNvbWUuanNvbicse3dlbGNvbWVkOiF2fSksfSwnUnVuIE5vdyc6KCmibG9hZCgnd2VsY29tZS5hcHAuanMnKSwnVHVybiBvZmYgJiBydW4gbmV4dCc6KCmie3JlcXVpcmUoJ1N0b3JhZ2UnKS53cml0ZSgnd2VsY29tZS5qc29uJyx7d2VsY29tZWQ6tX0pO0JhbmdsZS5zZXRMb2NrZWQotCk7oyhCYW5nbGUuc29mdE9mZigpKUJhbmdsZS5zb2Z0T2ZmKCk7pEJhbmdsZS5vZmYoKTt9LCc8IEJhY2snOmJhY2ssfSl9Kf//BAkAAHdlbGNvbWUuaW1n");
writeSegment(65860, "MDCI/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/szMzMzMzP7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7MzMzMzMzMzMzM/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+zMzMzc7W1tbWzs3MzMaWlrq6uv7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7MzMzO1tfWzs3MzMzMzMzAlpa6urq6uv7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7MzNXX1s3MzMzMzMzMzMzMupa6urq6urr+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/szMztfWzczMzMzMzMzMzMzMxpaWurq6urq6/v7+/v7+/v7+/v7+/v7+/v7+YVtbf8zN1tbNzMzMzMzMzMzMzMzMzLqWurq6urq6uv7+/v7+/v7+/v7+/v7+/mFhYVtbqczO187MzMzMzMzMzMzMzMzMzMCWurq6urq6uv7+/v7+/v7+/v7+/v7+YWGGq6yHzMzV1szMzMzMzMzMzMzMzMzMzMaWlrq6urq6uv7+/v7+/v7+/v7+/v5hYYfWq1tbzMzWzszMzMzMzMzMzMzMzMzMzMyWlrq6urq6urr+/v7+/v7+/v7+/mFhh9erYVtbzMzWzczMzMzMzMzMzMzMzMzMzMyWlrq6urq6urr+/v7+/v7+/v7+/mGG16xhYVtbzMzVzMzMzMzMzMzMzMzMzMzMzMaWlrq6urq6urr+/v7+/v7+/v7+YWGs14ZhYVtbqMzOzMzMzMzMzMzMzMzMzMzMzMCWurq6urq6urr+/v7+/v7+/v7+YYXWrGFhYVtbf8zMzczMzMzMzMzMzMzMzMzMzMCWurq6urq6urr+/v7+/v7+/v7+YYbXh2FhYVtbW8zMzMzMzMzMzMzMzMzMzMzMzJaWurq6urq6uv7+/v7+/v7+/v7+YYbXhmFhYVtbW6jMzMzMzMzMzMzMzMzMzMzMxpaWurq6urq6uv7+/v7+/v7+/v7+YYbXhmFhYWFbW3/MzMzMzMzMzMzMzMzMzMzMupa6urq6urq6uv7+/v7+/v7+/v7+YWGyhmFhYWFbW1vMzMzMzMzMzMzMzMzMzMzGlpa6urq6urq6/v7+/v7+/v7+/v7+/mGGq2FhYWFhW1t/zMzMzMzMzMzMzMzMzMy6lrq6urq6urr+/v7+/v7+/v7+/v7+/mFhq2FhYWFhW1tbqMzMzMzMzMzMzMzMzMCWlrq6urq6uv7+/v7+/v7+/v7+/v7+/v5hhoZhYWFhYVtbW8zMzMzMzMzMzMzMxpaWurq6urq6/v7+/v7+/v7+/v7+/v7+/v7+YWFhYWFhYWFbW1vMzMzMzMzMzMzGlpa6urq6urr+/v7+/v7+/v7+/v7+/v7+/v7+YWFhYWFhYWFbW1tbqMzMzMzMzMaWlpa6urq6/v7+/v7+/v7+/v7+/v7+/v7+/v7+/mFhYWFhYWFhW1tbW3/MzMzM/v66urq6uv7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+YWFhYWFhYVtbW/7GxsbG/paWlv7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/lthYWFhYWFb/v7GxsbG/paWlv7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+YWFhW1tbW/7+pKT+/p6Xlv7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/ltbW/7+iIj+/oiI/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/ltbXP7+iIj+/oiI/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v6BiP7+iIj+iIj+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v6IiP7+iIj+iIj+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+iIj+iIj+iIj+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+iIj+iIiIiP7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/oiIiIiIiP7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/oiIiIiIiP7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/oiIiIiI/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v6IiIiI/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v6IiIiI/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v6IiIiI/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+iIj+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/uEAAAB3ZWxjb21lLmluZm8=");
writeSegment(68200, "eyJpZCI6IndlbGNvbWUiLCJuYW1lIjoiV2VsY29tZSIsInNyYyI6IndlbGNvbWUuYXBwLmpzIiwiaWNvbiI6IndlbGNvbWUuaW1nIiwidmVyc2lvbiI6IjAuMTQiLCJ0YWdzIjoic3RhcnQsd2VsY29tZSIsImZpbGVzIjoid2VsY29tZS5pbmZvLHdlbGNvbWUuYm9vdC5qcyx3ZWxjb21lLmFwcC5qcyx3ZWxjb21lLnNldHRpbmdzLmpzLHdlbGNvbWUuaW1nIiwiZGF0YSI6IndlbGNvbWUuanNvbiJ9////CxAAAGhlYWx0aC5hcHAuanM=");
writeSegment(68460, "CqpnZXRTZXR0aW5ncygpe6tyZXF1aXJlKCJTdG9yYWdlIikucmVhZEpTT04oImhlYWx0aC5qc29uIiwxKaB7fTt9CqpzZXRTZXR0aW5ncyhzKXtyZXF1aXJlKCJTdG9yYWdlIikud3JpdGVKU09OKCJoZWFsdGguanNvbiIscyk7fQqqbWVudU1haW4oKXtzd2lwZV9lbmFibGVkPbU7Y2xlYXJCdXR0b24oKTtFLnNob3dNZW51KHsiIjp7dGl0bGU6IkhlYWx0aCBUcmFja2luZyJ9LCI8IEJhY2siOigpomxvYWQoKSwiU3RlcCBDb3VudGluZyI6KCmibWVudVN0ZXBDb3VudCgpLCJNb3ZlbWVudCI6KCmibWVudU1vdmVtZW50KCksIkhlYXJ0IFJhdGUiOigpom1lbnVIUk0oKSwiU2V0dGluZ3MiOigpom1lbnVTZXR0aW5ncygpfSk7fQqqbWVudVNldHRpbmdzKCl7c3dpcGVfZW5hYmxlZD21O2NsZWFyQnV0dG9uKCk7rHM9Z2V0U2V0dGluZ3MoKTtFLnNob3dNZW51KHsiIjp7dGl0bGU6IkhlYWx0aCBUcmFja2luZyJ9LCI8IEJhY2siOigpom1lbnVNYWluKCksIkhlYXJ0IFJ0Ijp7dmFsdWU6MHxzLmhybSxtaW46MCxtYXg6Mixmb3JtYXQ6dqJbIk9mZiIsIjEwIG1pbnMiLCJBbHdheXMiXVt2XSxvbmNoYW5nZTp2ontzLmhybT12O3NldFNldHRpbmdzKHMpO319fSk7fQqqbWVudVN0ZXBDb3VudCgpe3N3aXBlX2VuYWJsZWQ9tTtjbGVhckJ1dHRvbigpO0Uuc2hvd01lbnUoeyIiOnt0aXRsZToiU3RlcCBDb3VudGluZyJ9LCI8IEJhY2siOigpom1lbnVNYWluKCksInBlciBob3VyIjooKaJzdGVwc1BlckhvdXIoKSwicGVyIGRheSI6KCmic3RlcHNQZXJEYXkoKX0pO30Kqm1lbnVNb3ZlbWVudCgpe3N3aXBlX2VuYWJsZWQ9tTtjbGVhckJ1dHRvbigpO0Uuc2hvd01lbnUoeyIiOnt0aXRsZToiTW92ZW1lbnQifSwiPCBCYWNrIjooKaJtZW51TWFpbigpLCJwZXIgaG91ciI6KCmibW92ZW1lbnRQZXJIb3VyKCksInBlciBkYXkiOigpom1vdmVtZW50UGVyRGF5KCksfSk7fQqqbWVudUhSTSgpe3N3aXBlX2VuYWJsZWQ9tTtjbGVhckJ1dHRvbigpO0Uuc2hvd01lbnUoeyIiOnt0aXRsZToiSGVhcnQgUmF0ZSJ9LCI8IEJhY2siOigpom1lbnVNYWluKCksInBlciBob3VyIjooKaJocm1QZXJIb3VyKCksInBlciBkYXkiOigpomhybVBlckRheSgpLH0pO30KqnN0ZXBzUGVySG91cigpe0Uuc2hvd01lc3NhZ2UoIkxvYWRpbmcuLi4iKTusZGF0YT24VWludDE2QXJyYXkoMjQpO3JlcXVpcmUoImhlYWx0aCIpLnJlYWREYXkouERhdGUoKSxoomRhdGFbaC5ocl2WaC5zdGVwcyk7Zy5jbGVhcigxKTtCYW5nbGUuZHJhd1dpZGdldHMoKTtnLnJlc2V0KCk7c2V0QnV0dG9uKG1lbnVTdGVwQ291bnQpO2JhckNoYXJ0KCJIT1VSIixkYXRhKTt9CqpzdGVwc1BlckRheSgpe0Uuc2hvd01lc3NhZ2UoIkxvYWRpbmcuLi4iKTusZGF0YT24VWludDE2QXJyYXkoMzEpO3JlcXVpcmUoImhlYWx0aCIpLnJlYWREYWlseVN1bW1hcmllcyi4RGF0ZSgpLGiiZGF0YVtoLmRheV2WaC5zdGVwcyk7Zy5jbGVhcigxKTtCYW5nbGUuZHJhd1dpZGdldHMoKTtnLnJlc2V0KCk7c2V0QnV0dG9uKG1lbnVTdGVwQ291bnQpO2JhckNoYXJ0KCJEQVkiLGRhdGEpO30KqmhybVBlckhvdXIoKXtFLnNob3dNZXNzYWdlKCJMb2FkaW5nLi4uIik7rGRhdGE9uFVpbnQxNkFycmF5KDI0KTusY250PbhVaW50OEFycmF5KDIzKTtyZXF1aXJlKCJoZWFsdGgiKS5yZWFkRGF5KLhEYXRlKCksaKJ7ZGF0YVtoLmhyXZZoLmJwbTujKGguYnBtKWNudFtoLmhyXZg7fSk7ZGF0YS5mb3JFYWNoKChkLGkpomRhdGFbaV09ZC9jbnRbaV0pO2cuY2xlYXIoMSk7QmFuZ2xlLmRyYXdXaWRnZXRzKCk7Zy5yZXNldCgpO3NldEJ1dHRvbihtZW51SFJNKTtiYXJDaGFydCgiSE9VUiIsZGF0YSk7fQqqaHJtUGVyRGF5KCl7RS5zaG93TWVzc2FnZSgiTG9hZGluZy4uLiIpO6xkYXRhPbhVaW50MTZBcnJheSgzMSk7rGNudD24VWludDhBcnJheSgzMSk7cmVxdWlyZSgiaGVhbHRoIikucmVhZERhaWx5U3VtbWFyaWVzKLhEYXRlKCksaKJ7ZGF0YVtoLmRheV2WaC5icG07oyhoLmJwbSljbnRbaC5kYXldmDt9KTtkYXRhLmZvckVhY2goKGQsaSmiZGF0YVtpXT1kL2NudFtpXSk7Zy5jbGVhcigxKTtCYW5nbGUuZHJhd1dpZGdldHMoKTtnLnJlc2V0KCk7c2V0QnV0dG9uKG1lbnVIUk0pO2JhckNoYXJ0KCJEQVkiLGRhdGEpO30Kqm1vdmVtZW50UGVySG91cigpe0Uuc2hvd01lc3NhZ2UoIkxvYWRpbmcuLi4iKTusZGF0YT24VWludDE2QXJyYXkoMjQpO3JlcXVpcmUoImhlYWx0aCIpLnJlYWREYXkouERhdGUoKSxoomRhdGFbaC5ocl2WaC5tb3ZlbWVudCk7Zy5jbGVhcigxKTtCYW5nbGUuZHJhd1dpZGdldHMoKTtnLnJlc2V0KCk7c2V0QnV0dG9uKG1lbnVNb3ZlbWVudCk7YmFyQ2hhcnQoIkhPVVIiLGRhdGEpO30Kqm1vdmVtZW50UGVyRGF5KCl7RS5zaG93TWVzc2FnZSgiTG9hZGluZy4uLiIpO6xkYXRhPbhVaW50MTZBcnJheSgzMSk7cmVxdWlyZSgiaGVhbHRoIikucmVhZERhaWx5U3VtbWFyaWVzKLhEYXRlKCksaKJkYXRhW2guZGF5XZZoLm1vdmVtZW50KTtnLmNsZWFyKDEpO0JhbmdsZS5kcmF3V2lkZ2V0cygpO2cucmVzZXQoKTtzZXRCdXR0b24obWVudU1vdmVtZW50KTtiYXJDaGFydCgiREFZIixkYXRhKTt9Cq53PWcuZ2V0V2lkdGgoKTsKrmg9Zy5nZXRIZWlnaHQoKTsKrGRhdGFfbGVuOwqsY2hhcnRfaW5kZXg7CqxjaGFydF9tYXhfZGF0dW07CqxjaGFydF9sYWJlbDsKrGNoYXJ0X2RhdGE7Cqxzd2lwZV9lbmFibGVkPbU7CqxidG47CqptYXgoYXJyKXusbT0tSW5maW5pdHk7pyisaT0wO2k8YXJyLmxlbmd0aDtpmCmjKGFycltpXT5tKW09YXJyW2ldO6ttO30KqmdldF9kYXRhX2xlbmd0aChhcnIpe6xubGVuPWFyci5sZW5ndGg7pyisaT1hcnIubGVuZ3RoLTE7aT4wnmFycltpXYowO2mZKW5sZW6ZO6tubGVuO30KqmJhckNoYXJ0KGxhYmVsLGR0KXtkYXRhX2xlbj1nZXRfZGF0YV9sZW5ndGgoZHQpO2NoYXJ0X2luZGV4PU1hdGgubWF4KGRhdGFfbGVuLTUsLTUpO2NoYXJ0X21heF9kYXR1bT1tYXgoZHQpO2NoYXJ0X2xhYmVsPWxhYmVsO2NoYXJ0X2RhdGE9ZHQ7ZHJhd0JhckNoYXJ0KCk7c3dpcGVfZW5hYmxlZD20O30KqmRyYXdCYXJDaGFydCgpe65iYXJfYm90PTE0MDuuYmFyX3dpZHRoPSh3LTIpLzk7rGJhcl90b3A7rGJhcjtnLnNldENvbG9yKGcudGhlbWUuYmcpO2cuZmlsbFJlY3QoMCwyNCx3LGgpO6coYmFyPTE7YmFyPDEwO2Jhcpgpe6MoYmFyijUpe2cuc2V0Rm9udCgnNng4JywyKTtnLnNldEZvbnRBbGlnbigwLC0xKWcuc2V0Q29sb3IoZy50aGVtZS5mZyk7Zy5kcmF3U3RyaW5nKGNoYXJ0X2xhYmVsKyIgIisoY2hhcnRfaW5kZXgrYmFyLTEpKyIgICAiK2NoYXJ0X2RhdGFbY2hhcnRfaW5kZXgrYmFyLTFdLGcuZ2V0V2lkdGgoKS8yLDE1MCk7Zy5zZXRDb2xvcigiIzAwZiIpO32ke2cuc2V0Q29sb3IoIiMwZmYiKTt9oygoY2hhcnRfaW5kZXgrYmFyLTEpkTCeKGNoYXJ0X2luZGV4K2Jhci0xKTxkYXRhX2xlbiliYXJfdG9wPWJhcl9ib3QtMTAwKihjaGFydF9kYXRhW2NoYXJ0X2luZGV4K2Jhci0xXSkvY2hhcnRfbWF4X2RhdHVtO6RiYXJfdG9wPWJhcl9ib3Q7Zy5maWxsUmVjdCgxKyhiYXItMSkqYmFyX3dpZHRoLGJhcl9ib3QsMStiYXIqYmFyX3dpZHRoLGJhcl90b3ApO2cuc2V0Q29sb3IoZy50aGVtZS5mZyk7Zy5kcmF3UmVjdCgxKyhiYXItMSkqYmFyX3dpZHRoLGJhcl9ib3QsMStiYXIqYmFyX3dpZHRoLGJhcl90b3ApO319CqpuZXh0X2Jhcigpe2NoYXJ0X2luZGV4PU1hdGgubWluKGRhdGFfbGVuLTUsY2hhcnRfaW5kZXgrMSk7fQqqcHJldl9iYXIoKXtjaGFydF9pbmRleD1NYXRoLm1heCgoY2hhcnRfbGFiZWyKIkRBWSIpPy0zOi00LGNoYXJ0X2luZGV4LTEpO30KQmFuZ2xlLm9uKCdzd2lwZScsZGlyonujKCFzd2lwZV9lbmFibGVkKas7oyhkaXKKMSlwcmV2X2JhcigpO6RuZXh0X2JhcigpO2RyYXdCYXJDaGFydCgpO30pOwqqc2V0QnV0dG9uKGZuKXtCYW5nbGUuc2V0VUkoInVwZG93biIstyk7oyhwcm9jZXNzLmVudi5IV1ZFUlNJT06KMSlidG49c2V0V2F0Y2goZm4sQlROMik7pGJ0bj1zZXRXYXRjaChmbixCVE4xKTt9CqpjbGVhckJ1dHRvbigpe6MoYnRujbcpe2NsZWFyV2F0Y2goYnRuKTtidG49tzt9fQpCYW5nbGUubG9hZFdpZGdldHMoKTsKQmFuZ2xlLmRyYXdXaWRnZXRzKCk7Cm1lbnVNYWluKCk7/0wCAABoZWFsdGguaW1n");
writeSegment(72600, "MDDCAP//4Pn//zv/");
writeSegment(72698, "AVVQAAAFVUAAAAAAFVVVAABVVVQAAAAAVVVVQAFVVVoAAAABVVVVUAVVVWqAAAAFVVVVVBVVVeqgAAAVVVVVVVVVV6q0AAAVVVVVVVVVXqrUAABVVVVVVVVVeqtVAABVVVVVVVVV6q1VAABVVXrVVVVXqrVVAABVVWq1VVVeqtVVAABVVWqtVVV6q1VVAABVVXqrVVXqrVVVAABVVV6q1VeqtVVVAAAVVVeqtV6q1VVUAAAVVVXqrXqrVVVUAAAFVVV6q+qtVVVQAAABVVVeqqq1VVVAAAAAVVVXqqrVVVUAAAAAFVVV6qtVVVQAAAAABVVVeq1VVVAAAAAAAVVVXrVVVUAAAAAAAFVVV9VVVQAAAAAAABVVVVVVVAAAAAAAAAVVVVVVUAAAAAAAAAFVVVVVQAAAAAAAAABVVVVV");
writeSegment(73024, "FVVVVA==");
writeSegment(73036, "BVVVUA==");
writeSegment(73048, "AVVVQA==");
writeSegment(73061, "VVU=");
writeSegment(73073, "FVQ=");
writeSegment(73085, "BVA=");
writeSegment(73097, "AUA=");
writeSegment(73188, "/AcAAGhlYWx0aC5ib290Lmpz");
writeSegment(73220, "KKooKXusc2V0dGluZ3M9cmVxdWlyZSgiU3RvcmFnZSIpLnJlYWRKU09OKCJoZWFsdGguanNvbiIsMSmge307rGhybT0wfHNldHRpbmdzLmhybTujKGhybYoxKXuqb25IZWFsdGgoKXtCYW5nbGUuc2V0SFJNUG93ZXIoMSwiaGVhbHRoIik7c2V0VGltZW91dCgoKaJCYW5nbGUuc2V0SFJNUG93ZXIoMCwiaGVhbHRoIiksMio2MDAwMCk7fUJhbmdsZS5vbigiaGVhbHRoIixvbkhlYWx0aCk7QmFuZ2xlLm9uKCdIUk0nLGiie6MoaC5jb25maWRlbmNlPjgwKUJhbmdsZS5zZXRIUk1Qb3dlcigwLCJoZWFsdGgiKTt9KTujKEJhbmdsZS5nZXRIZWFsdGhTdGF0dXMoKS5icG1Db25maWRlbmNlKas7b25IZWFsdGgoKTt9pEJhbmdsZS5zZXRIUk1Qb3dlcihocm2MMCwiaGVhbHRoIik7fSkoKTsKQmFuZ2xlLm9uKCJoZWFsdGgiLGhlYWx0aKJ7rGQ9uERhdGUoRGF0ZS5ub3coKS01OTAwMDApO65EQl9SRUNPUkRfTEVOPTQ7rkRCX1JFQ09SRFNfUEVSX0hSPTY7rkRCX1JFQ09SRFNfUEVSX0RBWT1EQl9SRUNPUkRTX1BFUl9IUioyNCsxO65EQl9SRUNPUkRTX1BFUl9NT05USD1EQl9SRUNPUkRTX1BFUl9EQVkqMzE7rkRCX0hFQURFUl9MRU49ODuuREJfRklMRV9MRU49REJfSEVBREVSX0xFTitEQl9SRUNPUkRTX1BFUl9NT05USCpEQl9SRUNPUkRfTEVOO6pnZXRSZWNvcmRGTihkKXurImhlYWx0aC0iK2QuZ2V0RnVsbFllYXIoKSsiLSIrZC5nZXRNb250aCgpKyIucmF3Ijt9qmdldFJlY29yZElkeChkKXurKERCX1JFQ09SRFNfUEVSX0RBWSooZC5nZXREYXRlKCktMSkpKyhEQl9SRUNPUkRTX1BFUl9IUipkLmdldEhvdXJzKCkpKygwfChkLmdldE1pbnV0ZXMoKSpEQl9SRUNPUkRTX1BFUl9IUi82MCkpO32qZ2V0UmVjb3JkRGF0YShoZWFsdGgpe6tTdHJpbmcuZnJvbUNoYXJDb2RlKGhlYWx0aC5zdGVwc5I4LGhlYWx0aC5zdGVwcyYyNTUsaGVhbHRoLmJwbSxNYXRoLm1pbihoZWFsdGgubW92ZW1lbnQvOCwyNTUpKTt9rHJlYz1nZXRSZWNvcmRJZHgoZCk7rGZuPWdldFJlY29yZEZOKGQpO6xmPXJlcXVpcmUoIlN0b3JhZ2UiKS5yZWFkKGZuKTujKGYpe6xkdD1mLnN1YnN0cihEQl9IRUFERVJfTEVOKyhyZWMqREJfUkVDT1JEX0xFTiksREJfUkVDT1JEX0xFTik7oyhkdIwiXHhGRlx4RkZceEZGXHhGRiIpe3ByaW50KCJIRUFMVEggRVJSOiBBbHJlYWR5IHdyaXR0ZW4hIik7qzt9faR7cmVxdWlyZSgiU3RvcmFnZSIpLndyaXRlKGZuLCJIRUFMVEgxXDAiLDAsREJfRklMRV9MRU4pO32scmVjb3JkUG9zPURCX0hFQURFUl9MRU4rKHJlYypEQl9SRUNPUkRfTEVOKTtyZXF1aXJlKCJTdG9yYWdlIikud3JpdGUoZm4sZ2V0UmVjb3JkRGF0YShoZWFsdGgpLHJlY29yZFBvcyxEQl9GSUxFX0xFTik7oyhyZWMlREJfUkVDT1JEU19QRVJfREFZjERCX1JFQ09SRFNfUEVSX0RBWS0yKas7rHN1bVBvcz1yZWNvcmRQb3MrREJfUkVDT1JEX0xFTjujKGYuc3Vic3RyKHN1bVBvcyxEQl9SRUNPUkRfTEVOKYwiXHhGRlx4RkZceEZGXHhGRiIpe3ByaW50KCJIRUFMVEggRVJSOiBEYWlseSBzdW1tYXJ5IGFscmVhZHkgd3JpdHRlbiEiKTurO31oZWFsdGg9e3N0ZXBzOjAsYnBtOjAsbW92ZW1lbnQ6MCxtb3ZDbnQ6MCxicG1DbnQ6MH07rHJlY29yZHM9REJfUkVDT1JEU19QRVJfSFIqMjQ7pyisaT0wO2k8cmVjb3JkcztpmCl7rGR0PWYuc3Vic3RyKHJlY29yZFBvcyxEQl9SRUNPUkRfTEVOKTujKGR0jCJceEZGXHhGRlx4RkZceEZGIil7aGVhbHRoLnN0ZXBzlihkdC5jaGFyQ29kZUF0KDApjzgpK2R0LmNoYXJDb2RlQXQoMSk7aGVhbHRoLm1vdmVtZW50lmR0LmNoYXJDb2RlQXQoMik7aGVhbHRoLm1vdkNudJg7rGJwbT1kdC5jaGFyQ29kZUF0KDIpO2hlYWx0aC5icG2WYnBtO6MoYnBtKWhlYWx0aC5icG1DbnSYO31yZWNvcmRQb3OXREJfUkVDT1JEX0xFTjt9oyhoZWFsdGguYnBtQ250KWhlYWx0aC5icG2baGVhbHRoLmJwbUNudDujKGhlYWx0aC5tb3ZDbnQpaGVhbHRoLm1vdmVtZW50m2hlYWx0aC5tb3ZDbnQ7cmVxdWlyZSgiU3RvcmFnZSIpLndyaXRlKGZuLGdldFJlY29yZERhdGEoaGVhbHRoKSxzdW1Qb3MsREJfRklMRV9MRU4pO30pO0UGAABoZWFsdGg=");
writeSegment(75296, "rkRCX1JFQ09SRF9MRU49NDsKrkRCX1JFQ09SRFNfUEVSX0hSPTY7Cq5EQl9SRUNPUkRTX1BFUl9EQVk9REJfUkVDT1JEU19QRVJfSFIqMjQrMTsKrkRCX1JFQ09SRFNfUEVSX01PTlRIPURCX1JFQ09SRFNfUEVSX0RBWSozMTsKrkRCX0hFQURFUl9MRU49ODsKrkRCX0ZJTEVfTEVOPURCX0hFQURFUl9MRU4rREJfUkVDT1JEU19QRVJfTU9OVEgqREJfUkVDT1JEX0xFTjsKqmdldFJlY29yZEZOKGQpe6siaGVhbHRoLSIrZC5nZXRGdWxsWWVhcigpKyItIitkLmdldE1vbnRoKCkrIi5yYXciO30KqmdldFJlY29yZElkeChkKXurKERCX1JFQ09SRFNfUEVSX0RBWSooZC5nZXREYXRlKCktMSkpKyhEQl9SRUNPUkRTX1BFUl9IUipkLmdldEhvdXJzKCkpKygwfChkLmdldE1pbnV0ZXMoKSpEQl9SRUNPUkRTX1BFUl9IUi82MCkpO30KZXhwb3J0cy5yZWFkQWxsUmVjb3Jkcz2qKGQsY2Ipe6xmbj1nZXRSZWNvcmRGTihkKTusZj1yZXF1aXJlKCJTdG9yYWdlIikucmVhZChmbik7oyhmi7cpqzusaWR4PURCX0hFQURFUl9MRU47pyisZGF5PTA7ZGF5PDMxO2RheZgpe6corGhyPTA7aHI8MjQ7aHKYKXunKKxtPTA7bTxEQl9SRUNPUkRTX1BFUl9IUjttmCl7rGg9Zi5zdWJzdHIoaWR4LERCX1JFQ09SRF9MRU4pO6MoaIwiXHhGRlx4RkZceEZGXHhGRiIpe2NiKHtkYXk6ZGF5KzEsaHI6aHIsbWluOm0qMTAsc3RlcHM6KGguY2hhckNvZGVBdCgwKY84KXxoLmNoYXJDb2RlQXQoMSksYnBtOmguY2hhckNvZGVBdCgyKSxtb3ZlbWVudDpoLmNoYXJDb2RlQXQoMyl9KTt9aWR4lkRCX1JFQ09SRF9MRU47fX1pZHiWREJfUkVDT1JEX0xFTjt9fQpleHBvcnRzLnJlYWREYWlseVN1bW1hcmllcz2qKGQsY2Ipe6xyZWM9Z2V0UmVjb3JkSWR4KGQpO6xmbj1nZXRSZWNvcmRGTihkKTusZj1yZXF1aXJlKCJTdG9yYWdlIikucmVhZChmbik7oyhmi7cpqzusaWR4PURCX0hFQURFUl9MRU4rKERCX1JFQ09SRFNfUEVSX0RBWS0xKSpEQl9SRUNPUkRfTEVOO6corGRheT0wO2RheTwzMTtkYXmYKXusaD1mLnN1YnN0cihpZHgsREJfUkVDT1JEX0xFTik7oyhojCJceEZGXHhGRlx4RkZceEZGIil7Y2Ioe2RheTpkYXkrMSxzdGVwczooaC5jaGFyQ29kZUF0KDApjzgpfGguY2hhckNvZGVBdCgxKSxicG06aC5jaGFyQ29kZUF0KDIpLG1vdmVtZW50OmguY2hhckNvZGVBdCgzKX0pO31pZHiWREJfUkVDT1JEU19QRVJfREFZKkRCX1JFQ09SRF9MRU47fX0KZXhwb3J0cy5yZWFkRGF5PaooZCxjYil7rHJlYz1nZXRSZWNvcmRJZHgoZCk7rGZuPWdldFJlY29yZEZOKGQpO6xmPXJlcXVpcmUoIlN0b3JhZ2UiKS5yZWFkKGZuKTujKGaLtymrO6xpZHg9REJfSEVBREVSX0xFTisoREJfUkVDT1JEX0xFTipEQl9SRUNPUkRTX1BFUl9EQVkqKGQuZ2V0RGF0ZSgpLTEpKTunKKxocj0wO2hyPDI0O2hymCl7pyisbT0wO208REJfUkVDT1JEU19QRVJfSFI7bZgpe6xoPWYuc3Vic3RyKGlkeCxEQl9SRUNPUkRfTEVOKTujKGiMIlx4RkZceEZGXHhGRlx4RkYiKXtjYih7aHI6aHIsbWluOm0qMTAsc3RlcHM6KGguY2hhckNvZGVBdCgwKY84KXxoLmNoYXJDb2RlQXQoMSksYnBtOmguY2hhckNvZGVBdCgyKSxtb3ZlbWVudDpoLmNoYXJDb2RlQXQoMyl9KTt9aWR4lkRCX1JFQ09SRF9MRU47fX19////xAAAAGhlYWx0aC5pbmZv");
writeSegment(76936, "eyJpZCI6ImhlYWx0aCIsIm5hbWUiOiJIZWFsdGggVHJhY2tpbmciLCJzcmMiOiJoZWFsdGguYXBwLmpzIiwiaWNvbiI6ImhlYWx0aC5pbWciLCJ2ZXJzaW9uIjoiMC4wOCIsInRhZ3MiOiJ0b29sLHN5c3RlbSxoZWFsdGgiLCJmaWxlcyI6ImhlYWx0aC5pbmZvLGhlYWx0aC5hcHAuanMsaGVhbHRoLmltZyxoZWFsdGguYm9vdC5qcyxoZWFsdGgifQAAAAAEAgMACQcCAwMKBQMGAQwBAQEBAQEBAQEBAwMNDg8DAw==");
writeSegment(77194, "AwMDCwAC");
writeSegment(77226, "AwhicmVhawBjYXNlAGNhdGNoAGNsYXNzAGNvbnN0AGNvbnRpbnVlAGRlZmF1bHQAZGVsZXRlAGRvAGRlYnVnZ2VyAGVsc2UAZXh0ZW5kcwBmYWxzZQBmaW5hbGx5AGZvcgBmdW5jdGlvbgBpZgBpbgBpbnN0YW5jZW9mAGxldABuZXcAbnVsbABvZgByZXR1cm4Ac3RhdGljAHN1cGVyAHN3aXRjaAB0aGlzAHRocm93AHRydWUAdHJ5AHR5cGVvZgB1bmRlZmluZWQAd2hpbGUAdmFyAHZvaWQ=");
writeSegment(77456, "PT0APT09ACE9ACE9PQA8PQA8PAA8PD0APj0APj4APj4+AD4+PQA+Pj49ACs9AC09ACsrAC0tACo9AC89ACU9ACY9ACYmAHw9AHx8AF49AD0+AGlmAGVsc2UAZG8Ad2hpbGUAZm9yAGJyZWFrAGNvbnRpbnVlAGZ1bmN0aW9uAHJldHVybgB2YXIAbGV0AGNvbnN0AHRoaXMAdGhyb3cAdHJ5AGNhdGNoAGZpbmFsbHkAdHJ1ZQBmYWxzZQBudWxsAHVuZGVmaW5lZABuZXcAaW4AaW5zdGFuY2VvZgBzd2l0Y2gAY2FzZQBkZWZhdWx0AGRlbGV0ZQB0eXBlb2YAdm9pZABkZWJ1Z2dlcgBjbGFzcwBleHRlbmRzAHN1cGVyAHN0YXRpYwBvZgAARU9GAElEAElOVABGTE9BVABTVFJJTkcAVU5GSU5JU0hFRCBTVFJJTkcAVEVNUExBVEUgTElURVJBTABVTkZJTklTSEVEIFRFTVBMQVRFIExJVEVSQUwAUkVHRVgAVU5GSU5JU0hFRCBSRUdFWABVTkZJTklTSEVEIENPTU1FTlQAW0VSQVNFRF0AP1slZF0ASUQ6JXMAU3RyaW5nOiclcycAIABsaW5lICVkIGNvbCAlZCBpbiAldgoAbGluZSAlZCBjb2wgJWQKAC4uLgAKAF4KADB4Pz8AMAAAAABHb3QgJXMgZXhwZWN0ZWQgJXMAZGVlcFNsZWVwAHByZXRva2VuaXNlAHVuc2FmZUZsYXNoAHVuc3luY0ZpbGVzAABOb3QgZW5vdWdoIHN0YWNrIG1lbW9yeSB0byBkZWNvZGUgZGF0YQBVbmFibGUgdG8gZmluZCBvciBjcmVhdGUgZmlsZQBUb28gbXVjaCBkYXRhIGZvciBmaWxlIHNpemUARmlsZSBhbHJlYWR5IHdyaXR0ZW4gd2l0aCBkaWZmZXJlbnQgZGF0YQBOb3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBidWlsZAoALmJvb3RjZGUALmJvb3Ryc3QALmJvb3RYAEVyYXNpbmcgc2F2ZWQgY29kZS4ACkRvbmUhCgBFcmFzaW5nIFN0b3JhZ2UgQXJlYS4uLgoARXJhc2UgY29tcGxldGUuCgBXcml0aW5nIGluaXRpYWwgc3RvcmFnZSBjb250ZW50cy4uLgoAV3JpdGUgY29tcGxldGUuCgD/Y29kAHVuZGVmaW5lZABudWxsAHRydWUAZmFsc2UAb2JqZWN0AGZ1bmN0aW9uAHN0cmluZwBib29sZWFuAG51bWJlcgA/AHZhbHVlT2YAVmFyaWFibGUgdHlwZSBjYW5ub3QgYmUgY29udmVydGVkIHRvIHN0cmluZwB0b1N0cmluZwBbb2JqZWN0IE9iamVjdF0ALABTdHJpbmcgdG9vIGJpZyB0byBjb252ZXJ0IHRvIGludGVnZXIKAFN0cmluZyB0b28gYmlnIHRvIGNvbnZlcnQgdG8gZmxvYXQKAEluZmluaXR5AC1JbmZpbml0eQBnZXQAc2V0AFVuYWJsZSB0byBhc3NpZ24gdmFsdWUgdG8gbm9uLXJlZmVyZW5jZSAldABGaWVsZCBvciBtZXRob2QgIiV2IiBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LCBhbmQgY2FuJ3QgY3JlYXRlIGl0IG9uICV0ACVxIGlzIG5vdCBkZWZpbmVkAE9wZXJhdGlvbiAlcyBub3Qgc3VwcG9ydGVkIG9uIHRoZSAlcyBkYXRhdHlwZQBJbnRlZ2VyAERvdWJsZQBBcnJheQBPYmplY3QAU3RyaW5nACMlZFtyJWQsbCVkXSAAIABST09UAC4uLgoATmV3Q2hpbGQgUEFSRU5UOgBDSElMRDogAE5hbWUgAE9iamVjdCB7IABHZXR0ZXIvU2V0dGVyIHsgAEFycmF5KCVkKSBbIABOYXRpdmVGdW5jdGlvbiAweCV4ICglZCkgeyAARnVuY3Rpb24geyAAcmV0dXJuIABQaW4gJWQASW50ZWdlciAlZABCb29sICVzAERvdWJsZSAlZgBQYXJhbSAlcSAAQXJyYXlCdWZmZXJOYW1lWyVkXSAAJXMgKG9mZnMgJWQsIGxlbiAlZCkAdW5rbm93biBBcnJheUJ1ZmZlcgAARmxhdABOYXRpdmUARmxhc2gAJXNTdHJpbmcgWyVkIGJsb2Nrc10gJXEAVW5rbm93biAlZAA9IGludCAlZAoAPSBib29sICVzCgAKACVjAF9fcHJvdG9fXwBjb25zdHJ1Y3RvcgBFeHBlY3RpbmcgYW4gT2JqZWN0LCBvciB1bmRlZmluZWQAVW5rbm93biBvcHRpb24gJXEAJXYuJXYAJXZbJXFdAGNhbGxiYWNrAGNvdW50AGRhdGEASWYgc3BlY2lmeWluZyBhbiBvYmplY3QsIGl0IG11c3QgYmUgb2YgdGhlIGZvcm0ge2RhdGEgOiAuLi4sIGNvdW50IDogTn0gb3Ige2NhbGxiYWNrIDogZm59IC0gZ290ICVqAEV4cGVjdGluZyBhIG51bWJlciBvciBzb21ldGhpbmcgaXRlcmFibGUsIGdvdCAldABcYgBcdABcbgBcdgBcZgBccgBcXABcIgBFUlJPUjogAAoAV0FSTklORzogAE5hTgAtSW5maW5pdHkASW5maW5pdHkAIAAwACIAbnVsbABUb28gbWFueSBzY29wZXMgcmVtb3ZlZABwcm90b3R5cGUAX19wcm90b19fAE9iamVjdABUb28gbXVjaCByZWN1cnNpb24gLSB0aGUgc3RhY2sgaXMgYWJvdXQgdG8gb3ZlcmZsb3cAZXhjZXB0AHNUcmFjZQAgYXQgAHN0YWNrAGNvbXBpbGVkAEZ1bmN0aW9uIG1hcmtlZCB3aXRoICJjb21waWxlZCIgdXBsb2FkZWQgaW4gc291cmNlIGZvcm0AcmFtAP9jb2QA/3NjbwD/bmFtAEZ1bmN0aW9uICVxIG5vdCBmb3VuZCEARnVuY3Rpb24gbm90IGZvdW5kIQBFeHBlY3RpbmcgYSBmdW5jdGlvbiB0byBjYWxsLCBnb3QgJXQASW5zdWZmaWNpZW50IHN0YWNrIGZvciB0aGlzIG1hbnkgYXJndW1lbnRzAP90aHMAU3RlcHBpbmcgaW50byAldgoAU3RlcHBpbmcgaW50byBmdW5jdGlvbgoAcmV0dXJuAFZhbHVlIHJldHVybmVkIGlzID0AaW4gZnVuY3Rpb24gJXEgY2FsbGVkIGZyb20gAGluIGZ1bmN0aW9uIGNhbGxlZCBmcm9tIABzeXN0ZW0KAENhbm5vdCByZWFkIHByb3BlcnR5ICclcycgb2YgdW5kZWZpbmVkAEZpZWxkIG9yIG1ldGhvZCAlcSBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LCBhbmQgY2FuJ3QgY3JlYXRlIGl0IG9uICV0AENvbnN0cnVjdG9yIHNob3VsZCBiZSBhIGZ1bmN0aW9uLCBidXQgaXMgJXQATmVzdGluZyAnbmV3JyBvcGVyYXRvcnMgaXMgdW5zdXBwb3J0ZWQAZ2V0AHNldABQcm90b3R5cGUgc2hvdWxkIGJlIGFuIG9iamVjdCwgZ290ICV0AGNvbnN0cnVjdG9yAHVuZGVmaW5lZABpZih0aGlzLl9fcHJvdG9fXy5fX3Byb3RvX18uY29uc3RydWN0b3IpdGhpcy5fX3Byb3RvX18uX19wcm90b19fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsYXJndW1lbnRzKQAnZXh0ZW5kcycgYXJndW1lbnQgc2hvdWxkIGJlIGEgZnVuY3Rpb24sIGdvdCAldABUYWdnZWQgdGVtcGxhdGUgbGl0ZXJhbHMgbm90IHN1cHBvcnRlZABDYWxsaW5nICdzdXBlcicgb3V0c2lkZSBvZiBjbGFzcwBVbmV4cGVjdGVkIGVuZCBvZiBJbnB1dAoAQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIHRvIHNlYXJjaCBhICV0AEV4cGVjdGluZyBhIGZ1bmN0aW9uIG9uIFJIUyBpbiBpbnN0YW5jZW9mIGNoZWNrLCBnb3QgJXQAYXQgAEVzcHJ1aW5vIGRvZXNuJ3Qgc3VwcG9ydCBDQVNFIGFmdGVyIERFRkFVTFQAQXJyYXkAZm9yKGEgJXMgYikgLSAnYScgbXVzdCBiZSBhIHZhcmlhYmxlIG5hbWUsIG5vdCAldABvZgBpbgBGT1IgbG9vcCBjYW4gb25seSBpdGVyYXRlIG92ZXIgQXJyYXlzLCBTdHJpbmdzIG9yIE9iamVjdHMsIG5vdCAldABSRVRVUk4gc3RhdGVtZW50LCBidXQgbm90IGluIGEgZnVuY3Rpb24uCgBDT05USU5VRSBzdGF0ZW1lbnQgb3V0c2lkZSBvZiBGT1Igb3IgV0hJTEUgbG9vcABCUkVBSyBzdGF0ZW1lbnQgb3V0c2lkZSBvZiBTV0lUQ0gsIEZPUiBvciBXSElMRSBsb29wAP8AZXhwb3J0cwBtb2R1bGUAdW5kZWZpbmVkAEludmFsaWQgcGluIQAAU2VyaWFsAFVTQVJUAFJYAFRYAENLAFNQSQBNSVNPAE1PU0kAU0NLAEkyQwBTQ0wAU0RBAERBQwBDSDEAQ0gyAFRJTQBDb3VsZG4ndCBjb252ZXJ0IHBpbiBmdW5jdGlvbiAlZAoAIAAtPiAlcwoAPC0gJXMKABtbSgAbW0MAG1tEABtbQgAbW0EAZGVidWcAcGFzc3dvcmQAdGltZXJzAHdhdGNoZXMAZmxhZ3MAaW5pdABwaW4ARQAjb25pbml0AG9uSW5pdABSdW5uaW5nIG9uSW5pdCgpLi4uCgAldgBwcm90b3R5cGUALnByb3RvdHlwZQAjb24AJXYuJXYgPSAAOwoAX2JhdWRyYXRlAF9vcHRpb25zACVzLnNldHVwKCVkACwgACk7CgAlcy5zZXR1cCgAZWNobygwKTsAc2V0QnVzeUluZGljYXRvciglcCk7CgBzZXRTbGVlcEluZGljYXRvciglcCk7CgBFLnNldEZsYWdzKCVqKTsKAFVTQgBkaWdpdGFsV3JpdGUoJXAsICVkKTsKAHBpbk1vZGUoJXAsICVxJXMpOwoAACwgdHJ1ZQAjb25raWxsAHB3ZAAbWz83bAogX19fXyAgICAgICAgICAgICAgICAgXyAKfCAgX198X19fIF9fXyBfX18gXyBffF98X19fIF9fXyAKfCAgX198XyAtfCAuIHwgIF98IHwgfCB8ICAgfCAuIHwKfF9fX198X19ffCAgX3xffCB8X19ffF98X3xffF9fX3wKICAgICAgICAgfF98IGVzcHJ1aW5vLmNvbQogMnYxMSAoYykgMjAyMSBHLldpbGxpYW1zCgAKAGRiZ2hpc3QAaGlzdG9yeQAIIABFeGVjdXRpb24gSW50ZXJydXB0ZWQgZHVyaW5nIGV2ZW50IHByb2Nlc3NpbmcuCgBwcm9jZXNzACNvbnVuY2F1Z2h0RXhjZXB0aW9uAFVuY2F1Z2h0ICV2CgBzdGFjawBFeGVjdXRpb24gSW50ZXJydXB0ZWQKACNvbmVycm9yRmxhZwBOZXcgaW50ZXJwcmV0ZXIgZXJyb3I6ICV2CgAldgoACgoACjoACiAgSW52YWxpZCBwYXNzd29yZApwYXNzd29yZD4ACiAgTG9nZ2VkIGluLgoAICAgIABmdW5jAGFyZ3MAdGhpcwBVbmtub3duIHR5cGUgb2YgY2FsbGJhY2sgaW4gRXZlbnQgUXVldWUAZWRnZQAjb25mcmFtaW5nACNvbnBhcml0eQBkZWJvdW5jZQBzdGF0ZQB0aW1lb3V0AHRpbWUAd2F0Y2gAY2FsbGJhY2sAbGFzdFRpbWUAcmVjdXIAZGF0YQBDdHJsLUMgd2hpbGUgcHJvY2Vzc2luZyB3YXRjaCAtIHJlbW92aW5nIGl0LgBpbnRlcnZhbABDdHJsLUMgd2hpbGUgcHJvY2Vzc2luZyBpbnRlcnZhbCAtIHJlbW92aW5nIGl0LgBsb2FkAF9fRklMRV9fAGcAAGZ1bmN0aW9uICV2AHZhciAldiA9IABfX3Byb3RvX18AT2JqZWN0LmNyZWF0ZSgldik7CgBzZXRJbnRlcnZhbCgAc2V0VGltZW91dCgALCAlZik7IC8vICV2CgBzZXRXYXRjaCgALCAlaiwgeyByZXBlYXQ6JXMsIGVkZ2U6JyVzJwB0cnVlAGZhbHNlAGZhbGxpbmcAcmlzaW5nAGJvdGgALCBkZWJvdW5jZSA6ICVmACB9KTsKAC8vIENvZGUgc2F2ZWQgd2l0aCBFLnNldEJvb3RDb2RlCgByZXR1cm4AcGFyYW0gACA6IAAgW05vIHZhcmlhYmxlc10KAGhlbHAAaABDb21tYW5kczoKaGVscCAvIGggICAgICAgICAgIC0gdGhpcyBpbmZvcm1hdGlvbgpxdWl0IC8gcSAvIEN0cmwtQyAgLSBRdWl0IGRlYnVnIG1vZGUsIGJyZWFrIGV4ZWN1dGlvbgpyZXNldCAgICAgICAgICAgICAgLSBTb2Z0LXJlc2V0IEVzcHJ1aW5vCmNvbnRpbnVlIC8gYyAgICAgICAtIENvbnRpbnVlIGV4ZWN1dGlvbgpuZXh0IC8gbiAgICAgICAgICAgLSBleGVjdXRlIHRvIG5leHQgbGluZQpzdGVwIC8gcyAgICAgICAgICAgLSBleGVjdXRlIHRvIG5leHQgbGluZSwgb3Igc3RlcCBpbnRvIGZ1bmN0aW9uIGNhbGwKZmluaXNoIC8gZiAgICAgICAgIC0gZmluaXNoIGV4ZWN1dGlvbiBvZiB0aGUgZnVuY3Rpb24gY2FsbApwcmludCAuLi4gLyBwIC4uLiAgLSBldmFsdWF0ZSBhbmQgcHJpbnQgdGhlIG5leHQgYXJndW1lbnQKaW5mbyBsb2NhbHMgLyBpIGwpICAgIC0gb3V0cHV0IGxvY2FsIHZhcmlhYmxlcwppbmZvIHNjb3BlY2hhaW4gLyBpIHMgLSBvdXRwdXQgYWxsIHZhcmlhYmxlcyBpbiBhbGwgc2NvcGVzCgBxdWl0AHEAcmVzZXQAY29udGludWUAYwBuZXh0AG4Ac3RlcABzAGZpbmlzaABmAHByaW50AHAAaW5mbwBpAGxvY2FscwBsAE5vIGxvY2FscyBmb3VuZAoATG9jYWxzOgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoAc2NvcGVjaGFpbgBObyBzY29wZXMgZm91bmQKAFNjb3BlICVkOgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoAVW5rbm93biBjb21tYW5kCgBJbiBkZWJ1ZyBtb2RlOiBFeHBlY3RlZCBhIHNpbXBsZSBJRCwgdHlwZSAnaGVscCcgZm9yIG1vcmUgaW5mby4KACV2Lm9uKCVxLCAAbnVsbABMb29wYmFja0EATG9vcGJhY2tCAExpbWJvAFVTQgBUZXJtaW5hbABTZXJpYWwxAFNQSTEASTJDMQAAb29wYmFja0EAb29wYmFja0IAZXJtaW5hbABUaW1lb3V0IG9uIFV0aWxpdHkgVGltZXIAc2NsAHNkYQBiaXRyYXRlAEludmFsaWQgSTJDIGJpdHJhdGUAVGltZW91dCAoc3RhcnQpAEFyYml0cmF0aW9uIChzdGFydCkASTJDIEVycm9yOiAlcwBUaW1lb3V0ICh3cikAVGltZW91dCAocmQpAFRpbWVvdXQgKHN0b3ApAEFyYml0cmF0aW9uIChzdG9wKQByeAB0eABjawBjdHMAYnl0ZXNpemUAc3RvcGJpdHMAcGFyaXR5AGZsb3cAZXJyb3JzAEludmFsaWQgYmF1ZCByYXRlIHNwZWNpZmllZABvAG9kZABlAGV2ZW4ASW52YWxpZCBwYXJpdHkgJWQAbm9uZQB4b24ASW52YWxpZCBmbG93IGNvbnRyb2w6ICVxAF9iYXVkcmF0ZQBfb3B0aW9ucwBzd3NlcmlhbABVbmFibGUgdG8gYWxsb2NhdGUgZGF0YSBmb3IgU2VyaWFsIFJYAGlycURhdGEAZXh0aQBVbmFibGUgdG8gd2F0Y2ggcGluICVwLCBubyBTb2Z0d2FyZSBTZXJpYWwgUlgKAHNjawBtaXNvAG1vc2kAYmF1ZABtb2RlAG9yZGVyAGJpdHMAbXNiAGxzYgBTUEkgb3JkZXIgc2hvdWxkIGJlICdtc2InIG9yICdsc2InAEludmFsaWQgU1BJIGJhdWQgcmF0ZQBfb3B0aW9ucw==");
writeSegment(83778, "EQApAAAABgAhADgAAAASAAEAOQAAACIABXA8AAAAJgAFcD0AAAArAAEAJQAAADIAAQAoAAAAPAALAD4AAABEAAkJFQAAAE0AEQAWAAAAUgABACYAAABUAAkAFwAAAFoACQk/AAAAZwAJCUAAAAB0ABEAOwAAAH0AAQAUAAAAhgAEcEEAAACLAAEAIgAAAI8AAXBCAAAAlAAGcEMAAACdAAkJRAAAAKgACQlFAAAAswAJCUYAAAC9AAkAGgAAAMsAAQAsAAAA0AABcEcAAADUAAFwRwAAANkAAXBIAAAA3gAEcEkAAADiAAFwSgAAAOwAAXBLAAAA9gABADUAAAD7AAEALQAAAAMBAQAnAAAABwEGcEwAAAALAREALgAAABIBCQAvAAAAGQEpABwAAAAhAQkAOgAAACUBCQAdAAAALQEJABsAAAA8AUkAHgAAAEMBAQAhAAAARwEBcE0AAABMAQEAHwAAAFMBAXBOAAAAWwEBACAAAABnAREAMwAAAG4BCQAYAAAAegEBACQAAACNAQFwTwAAAJYBCQAZAAAAoAEBcFAAAACkAQkJUQAAALABCQlSAAAAvAEJCVMAAADIAQkJVAAAANMBCQlVAAAA5QEFcFYAAADtAWEAIwAAAPYBLgBXAAAAAQKoA1gAAAANAgFwWQAAABcCCQBaAAAAHAIJAFsAAAAhAogBXAAAADACEABdAAAAPgIQAF4AAABLAhAAXwAAAFYCAQArAAAAXgIJAGAAAABxAugCYQAAAH4CDABiAAAAigIIAWMAAACXAgAAZAAAAJwCGABlAAAAoQIIAGYAAACmAgkAZwAAALkCCQAJAAAAvgIBADAAAADBAikAaAAAAMwCAQBpAAAA1gIGAGoAAADeAgFwawAAAOUCCwBsAAAA7gILAG0AAAD0AggAbgAAAPkCDgBvAAAABANJAHAAAAANAyEBcQAAABQDIQFyAAAAGwMhAXMAAAAhA2gGdAAAACkDYAB1AAAAMANgAHYAAAA3A2AAdwAAAD0DEAB4AAAAQwMBADEAAABLAwkAeQAAAFMDGAB6AAAAWQMIAHsAAABqA4kFfAAAAHYDCAB9AAAAiAMwAH4AAACQA4kFfwAAAJsDSQOAAAAApANIAoEAAACtAwgAggAAAEFycmF5AEFycmF5QnVmZmVyAEFycmF5QnVmZmVyVmlldwBCVE4AQlROMQBCYW5nbGUAQmx1ZXRvb3RoAEJvb2xlYW4ARGF0YVZpZXcARGF0ZQBFAEVycm9yAEZsb2F0MzJBcnJheQBGbG9hdDY0QXJyYXkARnVuY3Rpb24AR3JhcGhpY3MASElHSABJMkMASTJDMQBJbmZpbml0eQBJbnQxNkFycmF5AEludDMyQXJyYXkASW50OEFycmF5AEludGVybmFsRXJyb3IASlNPTgBMRUQATEVEMQBMRUQyAExPVwBMb29wYmFja0EATG9vcGJhY2tCAE1hdGgATW9kdWxlcwBOUkYATmFOAE51bWJlcgBPYmplY3QAT25lV2lyZQBQaW4AUHJvbWlzZQBSZWZlcmVuY2VFcnJvcgBSZWdFeHAAU1BJAFNQSTEAU2VyaWFsAFNlcmlhbDEAU3RvcmFnZUZpbGUAU3RyaW5nAFN5bnRheEVycm9yAFRGTWljcm9JbnRlcnByZXRlcgBUZXJtaW5hbABUeXBlRXJyb3IAVVNCAFVpbnQxNkFycmF5AFVpbnQyNEFycmF5AFVpbnQzMkFycmF5AFVpbnQ4QXJyYXkAVWludDhDbGFtcGVkQXJyYXkAVklCUkFURQBXYXZlZm9ybQBhbmFsb2dSZWFkAGFuYWxvZ1dyaXRlAGFyZ3VtZW50cwBhdG9iAGJ0b2EAY2hhbmdlSW50ZXJ2YWwAY2xlYXJJbnRlcnZhbABjbGVhclRpbWVvdXQAY2xlYXJXYXRjaABjb25zb2xlAGRlY29kZVVSSUNvbXBvbmVudABkaWdpdGFsUHVsc2UAZGlnaXRhbFJlYWQAZGlnaXRhbFdyaXRlAGR1bXAAZWNobwBlZGl0AGVuY29kZVVSSUNvbXBvbmVudABldmFsAGZzAGdldFBpbk1vZGUAZ2V0U2VyaWFsAGdldFRpbWUAZ2xvYmFsAGlzRmluaXRlAGlzTmFOAGxvYWQAcGFyc2VGbG9hdABwYXJzZUludABwZWVrMTYAcGVlazMyAHBlZWs4AHBpbk1vZGUAcG9rZTE2AHBva2UzMgBwb2tlOABwcmludABwcm9jZXNzAHJlcXVpcmUAcmVzZXQAc2V0QnVzeUluZGljYXRvcgBzZXRJbnRlcnZhbABzZXRTbGVlcEluZGljYXRvcgBzZXRUaW1lAHNldFRpbWVvdXQAc2V0V2F0Y2gAc2hpZnRPdXQAdHJhY2U=");
writeSegment(85602, "A3CDAAAACgAhAYQAAAASACABhQAAABoAAXCGAAAAIgAhAYcAAAAuACABiAAAADoAIQGJAAAAPwChAYoAAABEACEBiwAAAE4AIAGMAAAAWAABAI0AAABcAAAAjgAAAGgAAACPAAAAdQABAJAAAAB+AAEAkQAAAIkAAQCSAAAAkwAJAJMAAACjAAEAlAAAAK4AAQCVAAAAtgABAJYAAADBAAEAlwAAAM0ABACYAAAA2gAhAZkAAADgACABmgAAAOYAAwCbAAAA9AADAJwAAAD/AAMAnQAAAAsBAwCeAAAAEwEDAJ8AAAAbAQMAoAAAACMBAwChAAAALAFgAKIAAAAyAQAAowAAAD4BAACkAAAAQgEJAKUAAABKAQAApgAAAFcBWwCnAAAAaQFbAKgAAAB5AVsAqQAAAIUBWwCqAAAAkQEwAKsAAACiAQgArAAAAK0BIACtAAAAugEYAK4AAADGATAArwAAANQBGACwAAAA3gEIALEAAADpATAAsgAAAPkBIACzAAAABgJIALQAAAAMAgAAtQAAABkCAAC2AAAARl9CRUVQU0VUAGFjY2VsUmQAYWNjZWxXcgBhcHBSZWN0AGJhcm9tZXRlclJkAGJhcm9tZXRlcldyAGJlZXAAYnV6egBjb21wYXNzUmQAY29tcGFzc1dyAGRiZwBkcmF3V2lkZ2V0cwBmYWN0b3J5UmVzZXQAZ2V0QWNjZWwAZ2V0Q29tcGFzcwBnZXRHUFNGaXgAZ2V0SGVhbHRoU3RhdHVzAGdldExDRE1vZGUAZ2V0TG9nbwBnZXRPcHRpb25zAGdldFByZXNzdXJlAGdldFN0ZXBDb3VudABocm1SZABocm1XcgBpc0Jhcm9tZXRlck9uAGlzQ2hhcmdpbmcAaXNDb21wYXNzT24AaXNHUFNPbgBpc0hSTU9uAGlzTENET24AaXNMb2NrZWQAbGNkV3IAbG9hZFdpZGdldHMAb2ZmAHByb2plY3QAcmVzZXRDb21wYXNzAHNldEJhcm9tZXRlclBvd2VyAHNldENvbXBhc3NQb3dlcgBzZXRHUFNQb3dlcgBzZXRIUk1Qb3dlcgBzZXRMQ0RCcmlnaHRuZXNzAHNldExDRE1vZGUAc2V0TENET2Zmc2V0AHNldExDRFBvd2VyAHNldExDRFRpbWVvdXQAc2V0TG9ja2VkAHNldE9wdGlvbnMAc2V0UG9sbEludGVydmFsAHNldFN0ZXBDb3VudABzZXRVSQBzaG93TGF1bmNoZXIAc29mdE9mZg==");
writeSegment(86578, "CQC3AAAABgBIBrgAAAAKALE9uQAAABMAiAC6AAAAFwC2DbsAAAAcAAgAvAAAACYATgi9AAAALwBJAr4AAAA6AAAAvwAAAEEAAADAAAAAUwABAMEAAABbAAAAwgAAAGkAcADDAAAAeADMAMQAAACFAAYAxQAAAJMABADGAAAAngABAMcAAACpAAEAyAAAALcAAQDJAAAAwAAJAcoAAADKAAYAywAAANkABADMAAAA4AAAAM0AAADtAAAAzgAAAPkASQbPAAAABgFIQtAAAAARASEB0QAAABwBSQDSAAAAJgFhAtMAAAAxAUgC1AAAADYBAADVAAAAPQEkANYAAABJAcgA1wAAAFUBDADYAAAAXgFIANkAAABpAQgA2gAAAHIBCADbAAAAfgEwANwAAACKAUkA3QAAAJQBCQDeAAAAnQFIAN8AAACpAUkA4AAAALQBCQDhAAAAwQEgAOIAAADHAQ4A4wAAAMsBCQDkAAAA2QEJAOUAAADeAREA5gAAAOcBEQDnAAAA9AGOAegAAABDUkMzMgBGRlQASFNCdG9SR0IAYXNtAGNsaXAAY29tcGlsZWRDAGNvbnZvbHZlAGRlY29kZVVURjgAZGVmcmFnAGR1bXBGcmFnbWVudGF0aW9uAGR1bXBTdHIAZHVtcFZhcmlhYmxlcwBlbmFibGVXYXRjaGRvZwBnZXRBZGRyZXNzT2YAZ2V0QW5hbG9nVlJlZgBnZXRCYXR0ZXJ5AGdldENvbnNvbGUAZ2V0RXJyb3JGbGFncwBnZXRGbGFncwBnZXRTaXplT2YAZ2V0VGVtcGVyYXR1cmUAaHdSYW5kAGtpY2tXYXRjaGRvZwBsb2NrQ29uc29sZQBsb29rdXBOb0Nhc2UAbWFwSW5QbGFjZQBtZW1vcnlBcmVhAG1lbW9yeU1hcABuYXRpdmVDYWxsAHBpcGUAcmVib290AHJldmVyc2VCeXRlAHNldEJvb3RDb2RlAHNldENsb2NrAHNldENvbnNvbGUAc2V0RmxhZ3MAc2V0UGFzc3dvcmQAc2V0VGltZVpvbmUAc2hvd0FsZXJ0AHNob3dNZW51AHNob3dNZXNzYWdlAHNob3dQcm9tcHQAc2hvd1Njcm9sbGVyAHNyYW5kAHN1bQB0b0FycmF5QnVmZmVyAHRvSlMAdG9TdHJpbmcAdG9VaW50OEFycmF5AHZhcmlhbmNlAAAAAAAAAYDpAAAABgAJgOoAAAAOAAGA6wAAABQACYDsAAAAGQAZgO0AAAAfAAnJ7gAAACkAIYnvAAAANAAhyfAAAABAAAmZ8QAAAEoASYDyAAAAVQAhyfMAAABeAMmA9AAAAGcACcn1AAAAcAAJufYAAAB7AACA9wAAAIAAIYn4AAAAiwAhyfkAAACXAAmA+gAAAKAACcn7AAAAqQAEgPwAAACwAASA/QAAALsABID+AAAAxAABgP8AAADMAASAAAEAANoAAYABAQAA4wAEgAIBAADtABmAAwEAAPkAJIEEAQAAAgEEgAUBAAALAQmABgEAABgBIYEHAQAAHwEhgQgBAAAmAUmACQEAADYBAYAKAQAAPAEhgQsBAABDAUmCDAEAAE4BIckNAQAAWgFJgg4BAABjAQmBDwEAAGsBIYAQAQAAeAEhgBEBAACEASGJEgEAAJEBAYATAQAAnwEJwxQBAACtASGAFQEAALsBIYMWAQAAxAHhgBcBAADQAQmAGAEAANkBCYAZAQAA5wEMgBoBAADzAQHwGwEAAPkBTIIcAQAAAQJJgB0BAAATAgmBHgEAAGFzQk1QAGFzSW1hZ2UAYXNVUkwAYmxpdABjbGVhcgBjbGVhclJlY3QAZHJhd0NpcmNsZQBkcmF3RWxsaXBzZQBkcmF3SW1hZ2UAZHJhd0ltYWdlcwBkcmF3TGluZQBkcmF3UG9seQBkcmF3UmVjdABkcmF3U3RyaW5nAGR1bXAAZmlsbENpcmNsZQBmaWxsRWxsaXBzZQBmaWxsUG9seQBmaWxsUmVjdABnZXRCUFAAZ2V0QmdDb2xvcgBnZXRDb2xvcgBnZXRGb250AGdldEZvbnRIZWlnaHQAZ2V0Rm9udHMAZ2V0SGVpZ2h0AGdldE1vZGlmaWVkAGdldFBpeGVsAGdldFdpZHRoAGltYWdlTWV0cmljcwBsaW5lVG8AbW92ZVRvAHF1YWRyYXRpY0JlemllcgByZXNldABzY3JvbGwAc2V0QmdDb2xvcgBzZXRDbGlwUmVjdABzZXRDb2xvcgBzZXRGb250AHNldEZvbnQxMngyMABzZXRGb250NngxNQBzZXRGb250QWxpZ24Ac2V0Rm9udEJpdG1hcABzZXRGb250Q3VzdG9tAHNldEZvbnRWZWN0b3IAc2V0UGl4ZWwAc2V0Um90YXRpb24Ac2V0VGhlbWUAc3RyaW5nTWV0cmljcwBzdHJpbmdXaWR0aAB0aGVtZQB0b0NvbG9yAHRyYW5zZm9ybVZlcnRpY2VzAHdyYXBTdHJpbmcAAAAAAAEAHwEAAAsAAQAgAQAAHQBIACEBAAAsAEgAIgEAAGdldEFkZHJlc3MAZ2V0U2VjdXJpdHlTdGF0dXMAc2V0QWR2ZXJ0aXNpbmcAc2V0U2VydmljZXM=");
writeSegment(88560, "IwEAAHNldENvbnNvbGUAAAAAEYAkAQAABwBJgCUBAAANAAmDJgEAABIASYAnAQAAGQAJgCgBAAAeAAmAKQEAACgASIAqAQAAMAALgSsBAAA5AAmBLAEAAEEACYAtAQAARgAB8C4BAABNAEmALwEAAFEAAYAwAQAAVQAUgDEBAABaAEmAMgEAAGEAAYAzAQAAaQABgDQBAABvAGGANQEAAHUASYA2AQAAegAJgDcBAAB/AGGEOAEAAIYACYABAAAAjwAUgDkB");
writeSegment(88768, "Y29uY2F0AGV2ZXJ5AGZpbGwAZmlsdGVyAGZpbmQAZmluZEluZGV4AGZvckVhY2gAaW5jbHVkZXMAaW5kZXhPZgBqb2luAGxlbmd0aABtYXAAcG9wAHB1c2gAcmVkdWNlAHJldmVyc2UAc2hpZnQAc2xpY2UAc29tZQBzb3J0AHNwbGljZQB0b1N0cmluZwB1bnNoaWZ0AAAAAAsAOgEAAGlzQXJyYXkAAAAAAAAABPA7AQAAYnl0ZUxlbmd0aAAAAAAB8DwBAAAHAATwPQEAABIABPA+AQAAHQAJgyYBAAAiAEmAJwEAACkACYAoAQAALgAJgCkBAAA4AEiAKgEAAEAAC4ErAQAASQAJgSwBAABRAAmALQEAAFYASYA/AQAAWgBJgDIBAABhAAGAMwEAAGkACIFAAQAAbQBhgDUBAABzAAmAQQEAAHgAYYBCAQAAYnVmZmVyAGJ5dGVMZW5ndGgAYnl0ZU9mZnNldABmaWxsAGZpbHRlcgBmaW5kAGZpbmRJbmRleABmb3JFYWNoAGluY2x1ZGVzAGluZGV4T2YAam9pbgBtYXAAcmVkdWNlAHJldmVyc2UAc2V0AHNsaWNlAHNvcnQAc3ViYXJyYXk=");
writeSegment(89250, "4YBDAQAACwDhgEQBAAAWAOGARQEAAB8A4YBGAQAAKADhgEcBAAAwAOGASAEAADoA4YBJAQAARADhgEoBAABNAGCGSwEAAFgAYIZMAQAAYwBghk0BAABsAGCGTgEAAHUAYIZPAQAAfQBghlABAACHAGCGUQEAAJEAYIZSAQAAZ2V0RmxvYXQzMgBnZXRGbG9hdDY0AGdldEludDE2AGdldEludDMyAGdldEludDgAZ2V0VWludDE2AGdldFVpbnQzMgBnZXRVaW50OABzZXRGbG9hdDMyAHNldEZsb2F0NjQAc2V0SW50MTYAc2V0SW50MzIAc2V0SW50OABzZXRVaW50MTYAc2V0VWludDMyAHNldFVpbnQ4");
writeSegment(89538, "BgBTAQAABAAOAFQBAABub3cAcGFyc2U=");
writeSegment(89570, "BIBVAQAACAAEgFYBAAAPAASAVwEAABsABIBYAQAAJAAEgFkBAAA0AASAWgEAAD8ABIBbAQAASAAEgFwBAABTAAaAXQEAAFsABIBeAQAAbQAmgF8BAAB1AGaCYAEAAIEAZpJhAQAAigAmgGIBAACaAGaCYwEAAKUAZoBkAQAArgBmgGUBAAC5ADaAZgEAAMEAAYBnAQAAzQABgGcBAADUAAGAaAEAAN0AAYBpAQAA6QAGgF0B");
writeSegment(89760, "Z2V0RGF0ZQBnZXREYXkAZ2V0RnVsbFllYXIAZ2V0SG91cnMAZ2V0TWlsbGlzZWNvbmRzAGdldE1pbnV0ZXMAZ2V0TW9udGgAZ2V0U2Vjb25kcwBnZXRUaW1lAGdldFRpbWV6b25lT2Zmc2V0AHNldERhdGUAc2V0RnVsbFllYXIAc2V0SG91cnMAc2V0TWlsbGlzZWNvbmRzAHNldE1pbnV0ZXMAc2V0TW9udGgAc2V0U2Vjb25kcwBzZXRUaW1lAHRvSVNPU3RyaW5nAHRvSlNPTgB0b1N0cmluZwB0b1VUQ1N0cmluZwB2YWx1ZU9mAAAAAAAAAYBqAQAAdG9TdHJpbmcAAAAAAAABgGoBAAB0b1N0cmluZwAAAAAAAAGAagEAAHRvU3RyaW5nAAAAAAAAAYBqAQAAdG9TdHJpbmcAAAAAAAABgGoBAAB0b1N0cmluZw==");
writeSegment(90114, "CABrAQAACgABAGwBAAASACEAbQEAABoAIQFuAQAAHwAIAW8B");
writeSegment(90160, "ZXJhc2VQYWdlAGdldEZyZWUAZ2V0UGFnZQByZWFkAHdyaXRlAAAAAAAAEAB4AAAAbG9n");
writeSegment(90226, "CQBwAQAABgBJAnEBAABwYXJzZQBzdHJpbmdpZnk=");
writeSegment(90274, "SAByAQAACgABAHMBAAAUAAAAdAEAACQACAB1AQAAYWRkQ2FjaGVkAGdldENhY2hlZAByZW1vdmVBbGxDYWNoZWQAcmVtb3ZlQ2FjaGVk");
writeSegment(90370, "AYB2AQAACAABgHcBAAAQAAiAeAEAABUAA4B5AQAAGgAAgHoBAAAgAACAewEAACQAA4B8AQAAKwAYgH0BAAAxAJiBfgE=");
writeSegment(90448, "Z2V0SW5mbwBnZXRNb2RlAG1vZGUAcmVhZAByZXNldABzZXQAdG9nZ2xlAHdyaXRlAHdyaXRlQXRUaW1lAAAAAAAABnB/AQAACgAGcIABAAAUAAZwgQEAACYABnCCAQAAKgAGcIMB");
writeSegment(90560, "TUFYX1ZBTFVFAE1JTl9WQUxVRQBORUdBVElWRV9JTkZJTklUWQBOYU4AUE9TSVRJVkVfSU5GSU5JVFkAAAAAAAAAIYCEAQAAdG9GaXhlZA==");
writeSegment(90658, "AYCFAQAABgCIgIYBAAALAAuAhwEAABoAAfAuAQAAIQBIgIgBAAAkAAiAiQEAADcASICKAQAARgAJgAEAAABPAAGAiwE=");
writeSegment(90736, "Y2xvbmUAZW1pdABoYXNPd25Qcm9wZXJ0eQBsZW5ndGgAb24AcmVtb3ZlQWxsTGlzdGVuZXJzAHJlbW92ZUxpc3RlbmVyAHRvU3RyaW5nAHZhbHVlT2Y=");
writeSegment(90834, "EQCMAQAABwBJAI0BAAAOAEkAjgEAAB8ASQKPAQAALgBJAJABAABHAAkAkQEAAFsACQCSAQAAagAJAJMBAABvAEkAlAE=");
writeSegment(90912, "YXNzaWduAGNyZWF0ZQBkZWZpbmVQcm9wZXJ0aWVzAGRlZmluZVByb3BlcnR5AGdldE93blByb3BlcnR5RGVzY3JpcHRvcgBnZXRPd25Qcm9wZXJ0eU5hbWVzAGdldFByb3RvdHlwZU9mAGtleXMAc2V0UHJvdG90eXBlT2YAAAAAAEmAlQEAAAYAiYCWAQAACwCJgJUBAAAQAAiAlwEAAGFwcGx5AGJpbmQAY2FsbAByZXBsYWNlV2l0aAAAAAAAAAAJgJgBAAAFAAOAmQEAAAsAIYCaAQAAEgAIgJsBAAAZAACAnAEAAB4AyICdAQAAcmVhZAByZXNldABzZWFyY2gAc2VsZWN0AHNraXAAd3JpdGUAAAAAAAAASALUAAAAcGlwZQ==");
writeSegment(91218, "AXCeAQAABAABAJ8BAAALAAFwoAE=");
writeSegment(91248, "ZW52AG1lbW9yeQB2ZXJzaW9u");
writeSegment(91282, "CQChAQAABAAJAKIBAAALAAkAowE=");
writeSegment(91312, "YWxsAHJlamVjdAByZXNvbHZl");
writeSegment(91346, "CYCkAQAABgBJgKUBAABjYXRjaAB0aGVu");
writeSegment(91378, "CYCmAQAABQALgKcBAABleGVjAHRlc3QAAAAAACkAqAEAAGZpbmQ=");
writeSegment(91426, "BICpAQAACgAQgKoBAAARAEiA1AAAABYACICrAQAAHAAIgKwBAAAkACGArQEAACkAGICuAQAANABIgK8BAAA6AACAsAEAAEIAEICxAQAAYXZhaWxhYmxlAGluamVjdABwaXBlAHByaW50AHByaW50bG4AcmVhZABzZXRDb25zb2xlAHNldHVwAHVuc2V0dXAAd3JpdGU=");
writeSegment(91588, "sgEAAAgACACzAQAADgAAALQBAAAXAAQAtQEAAB8ADAC2AQAAJABJALcBAAApAEkAuAEAAC4ACQm5AQAAMwAJALoBAABDAMkAuwEAAEwAS0i8AQAAUgBLAL0BAABjb21wYWN0AGVyYXNlAGVyYXNlQWxsAGdldEZyZWUAaGFzaABsaXN0AG9wZW4AcmVhZAByZWFkQXJyYXlCdWZmZXIAcmVhZEpTT04Ad3JpdGUAd3JpdGVKU09O");
writeSegment(91779, "gL4BAAAGAASAvwEAABAAIYDAAQAAFQABgMEBAAAeAAiAwgE=");
writeSegment(91824, "ZXJhc2UAZ2V0TGVuZ3RoAHJlYWQAcmVhZExpbmUAd3JpdGUAAAAAAAAAKQDDAQAAZmluZA==");
writeSegment(91890, "SYHEAQAABQAI2cUBAAAOAAjZxgEAABcACIDHAQAAHQAQgMgB");
writeSegment(91936, "c2VuZABzZW5kNGJpdABzZW5kOGJpdABzZXR1cAB3cml0ZQAAAAApAMkBAABmaW5k");
writeSegment(92002, "CYHKAQAACQAIgMsBAAAPAIiAzAE=");
writeSegment(92032, "cmVhZEZyb20Ac2V0dXAAd3JpdGVUbw==");
writeSegment(92066, "IYDNAQAABwAkgM4BAAASAEuAzwEAABsAS4DQAQAAJABMgNEBAAAsAEyA0gEAADgAAfAuAQAAPwAJgNMBAABFAGGA1AEAAEwAYYDVAQAAVQAhgNYBAABcAEmA1wEAAGQAYYDYAQAAagAJgNkBAABwAAuB2gEAAHsAYYDbAQAAggBhgNwBAACMAAGA3QEAAJgAAYDeAQAApAABgN8BAABjaGFyQXQAY2hhckNvZGVBdABlbmRzV2l0aABpbmNsdWRlcwBpbmRleE9mAGxhc3RJbmRleE9mAGxlbmd0aABtYXRjaABwYWRFbmQAcGFkU3RhcnQAcmVwZWF0AHJlcGxhY2UAc2xpY2UAc3BsaXQAc3RhcnRzV2l0aABzdWJzdHIAc3Vic3RyaW5nAHRvTG93ZXJDYXNlAHRvVXBwZXJDYXNlAHRyaW0AAAAAAAARAOABAABmcm9tQ2hhckNvZGU=");
writeSegment(92434, "qIPhAQAACwCog+IBAAAXAACA4wE=");
writeSegment(92464, "c3RhcnRJbnB1dABzdGFydE91dHB1dABzdG9wAAAAAAAAAAkA5AEAAAkACQDlAQAAY29tcHJlc3MAZGVjb21wcmVzcw==");
writeSegment(92546, "BnDmAQAAAgAGcOcBAAAHAAZw6AEAAAsABnDpAQAAEgAGcOoBAAAYAAZw6wEAABsABnDsAQAAIwAGcO0BAAApADYA7gEAAC0ANgDvAQAAMgA2APABAAA3ADYA8QEAADwAtgHyAQAAQgA2APMBAABHALYN9AEAAEwANgD1AQAAUAA2APYBAABUADYA9wEAAFoANgD4AQAAXgAWAPkBAABiABYA+gEAAGYAtgH7AQAAagAGAPwBAABxADEA/QEAAHcANgD+AQAAewA2AP8BAACAADYAAAIAAIQAtgEBAgAARQBMTjEwAExOMgBMT0cxMEUATE9HMkUAUEkAU1FSVDFfMgBTUVJUMgBhYnMAYWNvcwBhc2luAGF0YW4AYXRhbjIAY2VpbABjbGlwAGNvcwBleHAAZmxvb3IAbG9nAG1heABtaW4AcG93AHJhbmRvbQByb3VuZABzaW4Ac3FydAB0YW4Ad3JhcA==");
writeSegment(92914, "IRkCAgAAEgAhGQMCAAAhAAkABAIAAC0AAQAFAgAAY3JlYXRlQXJyYXlCdWZmZXIAY3JlYXRlQ2FsbGJhY2sAY3JlYXRlSW1hZ2UAZ2V0SW5zdGFuY2U=");
writeSegment(93010, "CQAGAgAABQAJAAcCAAAMAAkACAIAABMACQAJAgAAGgAJAAoC");
writeSegment(93056, "U0hBMQBTSEEyMjQAU0hBMjU2AFNIQTM4NABTSEE1MTIAAAAAAABhAAsCAABjcmVhdGU=");
writeSegment(93122, "AYAMAgAACQABgA0CAAATAACADgI=");
writeSegment(93152, "Z2V0SW5wdXQAZ2V0T3V0cHV0AGludm9rZQAAAAAAAABARwEAoEoBAGxgTgEAAFABADQwUgEAwFMBADLAVQEAcFcBADaQWQEAsFkBAATsWQEA9FkBAAEAWgEAwFoBABdYWwEAYFsBAAFsWwEAdFsBAAGAWwEAEFwBABKgXAEAIF0BABDAXQEA0F0BAALgXQEAoF4BABeUXwEAnF8BAAGoXwEAsF8BAAG8XwEAxF8BAAHQXwEA2F8BAAHkXwEA7F8BAAEAYAEAMGABAAVYYAEAYGABAAFwYAEAgGABAAKgYAEAwGABAAQAYQEAUGEBAAmQYQEAwGEBAAUAYgEACGIBAAEgYgEAcGIBAAnQYgEAIGMBAAmgYwEAwGMBAATgYwEAEGQBAAY4ZAEAQGQBAAFQZAEAcGQBAAOQZAEAsGQBAAPQZAEA4GQBAALwZAEAAGUBAAIMZQEAFGUBAAEgZQEAcGUBAArAZQEAIGYBAAyAZgEAsGYBAAXYZgEA4GYBAAHwZgEAIGcBAAVEZwEATGcBAAFgZwEAgGcBAAOgZwEAQGgBABTsaAEA9GgBAAEQaQEAMGkBAANQaQEAYGkBAAKAaQEAYGoBABzwagEAEGsBAARQawEAgGsBAAWkawEArGsBAAHAawEA4GsBAANfX3Byb3RvX18AY29uc3RydWN0b3IAQmFuZ2xlAEUAR3JhcGhpY3MATlJGAEJsdWV0b290aABBcnJheQBBcnJheUJ1ZmZlcgBBcnJheUJ1ZmZlclZpZXcAVWludDhBcnJheQBVaW50OENsYW1wZWRBcnJheQBJbnQ4QXJyYXkAVWludDE2QXJyYXkASW50MTZBcnJheQBVaW50MjRBcnJheQBVaW50MzJBcnJheQBJbnQzMkFycmF5AEZsb2F0MzJBcnJheQBGbG9hdDY0QXJyYXkARGF0YVZpZXcARGF0ZQBFcnJvcgBTeW50YXhFcnJvcgBUeXBlRXJyb3IASW50ZXJuYWxFcnJvcgBSZWZlcmVuY2VFcnJvcgBGdW5jdGlvbgBjb25zb2xlAEpTT04ATW9kdWxlcwBQaW4ATnVtYmVyAE9iamVjdABCb29sZWFuAE9uZVdpcmUAZnMAcHJvY2VzcwBQcm9taXNlAFJlZ0V4cABTZXJpYWwAU3RvcmFnZUZpbGUAU1BJAEkyQwBTdHJpbmcAV2F2ZWZvcm0ATWF0aABURk1pY3JvSW50ZXJwcmV0ZXIARmxhc2gAU3RvcmFnZQBoZWF0c2hyaW5rAGNyeXB0bwB0ZW5zb3JmbG93AGxvY2FsZQBleHBvcnRzPXtuYW1lOiJlbl9HQiIsY3VycmVuY3lTeW06Ilx1MDBhMyIsdHJhbnNsYXRlOmE9PmEsZGF0ZTooYSxiKT0+Yj8oIjAiK2EuZ2V0RGF0ZSgpKS5zdWJzdHIoLTIpKyIvIisoIjAiKyhhLmdldE1vbnRoKCkrMSkpLnN1YnN0cigtMikrIi8iK2EuZ2V0RnVsbFllYXIoKTphLnRvU3RyaW5nKCkuc3Vic3RyKDQsMTEpLHRpbWU6KGEsYik9Pnt2YXIgYz1hLmdldEhvdXJzKCksZD1hLmdldE1pbnV0ZXMoKTsocmVxdWlyZSgiU3RvcmFnZSIpLnJlYWRKU09OKCJzZXR0aW5nLmpzb24iLDEpfHx7fSlbIjEyaG91ciJdJiYoYz0wPT1jJTEyPzEyOmMlMTIpO2lmKGIpcmV0dXJuKCIgIitjKS5zdWJzdHIoLTIpKyI6IisoIjAiK2QpLnN1YnN0cigtMik7Yj0iYW0iOzA9PWM/Yz0xMjoxMjw9YyYmKDEyPGMmJihjLT0xMiksYj0icG0iKTtyZXR1cm4oIiAiK2MpLnN1YnN0cigtMikrIjoiKygiMCIrZCkuc3Vic3RyKC0yKSsiLiIrKCIwIithLmdldFNlY29uZHMoKSkuc3Vic3RyKC0yKSsKIiAiK2J9LGRvdzooYSxiKT0+Yj9hLnRvU3RyaW5nKCkuc3Vic3RyKDAsMyk6IlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5Ii5zcGxpdCgiICIpW2EuZ2V0RGF5KCldLG1vbnRoOihhLGIpPT5iP2EudG9TdHJpbmcoKS5zdWJzdHIoNCwzKToiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlciIuc3BsaXQoIiAiKVthLmdldE1vbnRoKCldLG51bWJlcjphPT5hLnRvU3RyaW5nKCksY3VycmVuY3k6YT0+Ilx1MDBhMyIrYS50b0ZpeGVkKDIpLGRpc3RhbmNlOmE9PjFFMz5hP01hdGgucm91bmQoYSkrIm0iOk1hdGgucm91bmQoYS8xNjAuOTM0KS8xMCsibWkiLHNwZWVkOmE9Pk1hdGgucm91bmQoYS8xLjYwOTM0KSsibXBoIix0ZW1wOmE9Pk1hdGgucm91bmQoYSkrIidDIixtZXJpZGlhbjphPT4xMj49YS5nZXRIb3VycygpPyJhbSI6CiJwbSJ9AEZsYXNoLFN0b3JhZ2UsaGVhdHNocmluayxjcnlwdG8sdGVuc29yZmxvdyxsb2NhbGUAVW5rbm93biBhcmdzcGVjICVkAEkyQzEAKGZ1bmN0aW9uKCl7cmV0dXJue192OiExLHJlYWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdn0sc2V0OmZ1bmN0aW9uKCl7dGhpcy53cml0ZSgxKX0scmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLndyaXRlKDApfSx3cml0ZTpmdW5jdGlvbihhKXtnLnNldENvbG9yKCh0aGlzLl92PSEhYSk/IiNmMDAiOmcudGhlbWUuYmcpLmZpbGxDaXJjbGUoKGcuZ2V0V2lkdGgoKS0yMCkvMiw1LDUpO0JhbmdsZS5zZXRMQ0RQb3dlcigxKX0sdG9nZ2xlOmZ1bmN0aW9uKCl7dGhpcy53cml0ZSghdGhpcy5fdil9fX0pAChmdW5jdGlvbigpe3JldHVybntfdjohMSxyZWFkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Z9LHNldDpmdW5jdGlvbigpe3RoaXMud3JpdGUoMSl9LHJlc2V0OmZ1bmN0aW9uKCl7dGhpcy53cml0ZSgwKX0sd3JpdGU6ZnVuY3Rpb24oYSl7Zy5zZXRDb2xvcigodGhpcy5fdj0hIWEpPyIjMGYwIjpnLnRoZW1lLmJnKS5maWxsQ2lyY2xlKChnLmdldFdpZHRoKCkrMjApLzIsNSw1KTtCYW5nbGUuc2V0TENEUG93ZXIoMSl9LHRvZ2dsZTpmdW5jdGlvbigpe3RoaXMud3JpdGUoIXRoaXMuX3YpfX19KQBMb29wYmFja0EATG9vcGJhY2tCAFNQSTEAU2VyaWFsMQBUZXJtaW5hbABVU0IAKGZ1bmN0aW9uKCl7dmFyIGQ9Zy5nZXRXaWR0aCgpLGU9Zy5nZXRIZWlnaHQoKSxjPXt0bDp7eDowLHk6MCxyOjAsYzowfSx0cjp7eDpkLTEseTowLHI6MSxjOjB9LGJsOnt4OjAseTplLTI0LHI6MCxjOjB9LGJyOnt4OmQtMSx5OmUtMjQscjoxLGM6MH19O2lmKGdsb2JhbC5XSURHRVRTKXtmb3IodmFyIGEgb2YgV0lER0VUUyl7dmFyIGI9Y1thLmFyZWFdO2ImJihhLng9Yi54LWIuciphLndpZHRoLGEueT1iLnksYi54Kz1hLndpZHRoKigxLTIqYi5yKSxiLmMrKyl9Zy5yZXNldCgpOyhjLnRsLmN8fGMudHIuYykmJmcuY2xlYXJSZWN0KDAsMCxkLTEsMjMpOyhjLmJsLmN8fGMuYnIuYykmJmcuY2xlYXJSZWN0KDAsZS0yNCxkLTEsZS0xKTt0cnl7Zm9yKGEgb2YgV0lER0VUUylhLmRyYXcoYSl9Y2F0Y2goZil7cHJpbnQoZil9fX0pAChmdW5jdGlvbigpe2dsb2JhbC5XSURHRVRTPXt9O3JlcXVpcmUoIlN0b3JhZ2UiKS5saXN0KC9cLndpZFwuanMkLykuZm9yRWFjaChhPT57dHJ5e2V2YWwocmVxdWlyZSgiU3RvcmFnZSIpLnJlYWQoYSkpfWNhdGNoKGMpe3ByaW50KGEsYyl9fSk7dmFyIGI9V0lER0VUUztXSURHRVRTPXt9O09iamVjdC5rZXlzKGIpLnNvcnQoKGEsYyk9PigwfGJbY10uc29ydG9yZGVyKS0oMHxiW2FdLnNvcnRvcmRlcikpLmZvckVhY2goYT0+V0lER0VUU1thXT1iW2FdKX0pAChmdW5jdGlvbihtb2RlLCBjYikgewogIGlmIChCYW5nbGUuYnRuV2F0Y2hlcykgewogICAgQmFuZ2xlLmJ0bldhdGNoZXMuZm9yRWFjaChjbGVhcldhdGNoKTsKICAgIGRlbGV0ZSBCYW5nbGUuYnRuV2F0Y2hlczsKICB9CiAgaWYgKEJhbmdsZS5kcmFnSGFuZGxlcikgewogICAgQmFuZ2xlLnJlbW92ZUxpc3RlbmVyKCJkcmFnIiwgQmFuZ2xlLmRyYWdIYW5kbGVyKTsKICAgIGRlbGV0ZSBCYW5nbGUuZHJhZ0hhbmRsZXI7CiAgfQogIGlmIChCYW5nbGUudG91Y2hIYW5kbGVyKSB7CiAgICBCYW5nbGUucmVtb3ZlTGlzdGVuZXIoInRvdWNoIiwgQmFuZ2xlLnRvdWNoSGFuZGxlcik7CiAgICBkZWxldGUgQmFuZ2xlLnRvdWNoSGFuZGxlcjsKICB9CiAgZnVuY3Rpb24gYigpIHsKICAgIHRyeXtCYW5nbGUuYnV6eigzMCk7fWNhdGNoKGUpe30KICB9CiAgaWYgKCFtb2RlKSByZXR1cm47CiAgZWxzZSBpZiAobW9kZT09InVwZG93biIpIHsKICAgIHZhciBkeSA9IDA7ICAgIAogICAgQmFuZ2xlLmRyYWdIYW5kbGVyID0gZT0+ewogICAgICBkeSArPSBlLmR5OwogICAgICBpZiAoIWUuYikgZHk9MDsKICAgICAgd2hpbGUgKE1hdGguYWJzKGR5KT4zMikgewogICAgICAgIGlmIChkeT4wKSB7IGR5LT0zMjsgY2IoMSkgfQogICAgICAgIGVsc2UgeyBkeSs9MzI7IGNiKC0xKSB9CiAgICAgICAgQmFuZ2xlLmJ1enooMjApOwogICAgICB9CiAgICB9OwogICAgQmFuZ2xlLm9uKCdkcmFnJyxCYW5nbGUuZHJhZ0hhbmRsZXIpOwogICAgQmFuZ2xlLnRvdWNoSGFuZGxlciA9IGQgPT4ge2IoKTtjYigpO307CiAgICBCYW5nbGUub24oInRvdWNoIiwgQmFuZ2xlLnRvdWNoSGFuZGxlcik7CiAgICBCYW5nbGUuYnRuV2F0Y2hlcyA9IFsKICAgICAgc2V0V2F0Y2goZnVuY3Rpb24oKSB7IGIoKTtjYigpOyB9LCBCVE4xLCB7cmVwZWF0OjF9KSwKICAgIF07CiAgfSBlbHNlIGlmIChtb2RlPT0ibGVmdHJpZ2h0IikgewogICAgdmFyIGR4ID0gMDsgICAgCiAgICBCYW5nbGUuZHJhZ0hhbmRsZXIgPSBlPT57CiAgICAgIGR4ICs9IGUuZHg7CiAgICAgIGlmICghZS5iKSBkeD0wOwogICAgICB3aGlsZSAoTWF0aC5hYnMoZHgpPjMyKSB7CiAgICAgICAgaWYgKGR4PjApIHsgZHgtPTMyOyBjYigxKSB9CiAgICAgICAgZWxzZSB7IGR4Kz0zMjsgY2IoLTEpIH0KICAgICAgICBCYW5nbGUuYnV6eigyMCk7CiAgICAgIH0KICAgIH07CiAgICBCYW5nbGUub24oJ2RyYWcnLEJhbmdsZS5kcmFnSGFuZGxlcik7CiAgICBCYW5nbGUudG91Y2hIYW5kbGVyID0gZCA9PiB7YigpO2NiKCk7fTsKICAgIEJhbmdsZS5vbigidG91Y2giLCBCYW5nbGUudG91Y2hIYW5kbGVyKTsKICAgIEJhbmdsZS5idG5XYXRjaGVzID0gWwogICAgICBzZXRXYXRjaChmdW5jdGlvbigpIHsgYigpO2NiKCk7IH0sIEJUTjEsIHtyZXBlYXQ6MX0pLAogICAgXTsKICB9IGVsc2UgaWYgKG1vZGU9PSJjbG9jayIpIHsKICAgIEJhbmdsZS5DTE9DSz0xOwogICAgQmFuZ2xlLmJ0bldhdGNoZXMgPSBbCiAgICAgIHNldFdhdGNoKEJhbmdsZS5zaG93TGF1bmNoZXIsIEJUTjEsIHtyZXBlYXQ6MSxlZGdlOiJmYWxsaW5nIn0pCiAgICBdOwogIH0gZWxzZSBpZiAobW9kZT09ImNsb2NrdXBkb3duIikgewogICAgQmFuZ2xlLkNMT0NLPTE7CiAgICBCYW5nbGUudG91Y2hIYW5kbGVyID0gKGQsZSkgPT4gewogICAgICBpZiAoZS54IDwgMTIwKSByZXR1cm47CiAgICAgIGIoKTtjYigoZS55ID4gODgpID8gMSA6IC0xKTsKICAgIH07CiAgICBCYW5nbGUub24oInRvdWNoIiwgQmFuZ2xlLnRvdWNoSGFuZGxlcik7CiAgICBCYW5nbGUuYnRuV2F0Y2hlcyA9IFsKICAgICAgc2V0V2F0Y2goQmFuZ2xlLnNob3dMYXVuY2hlciwgQlROMSwge3JlcGVhdDoxLGVkZ2U6ImZhbGxpbmcifSkKICAgIF07CiAgfSBlbHNlIGlmIChtb2RlPT0idG91Y2giKSB7CiAgICBCYW5nbGUudG91Y2hIYW5kbGVyID0gKF8sZSkgPT4ge2IoKTtjYihlKTt9OwogICAgQmFuZ2xlLm9uKCJ0b3VjaCIsIEJhbmdsZS50b3VjaEhhbmRsZXIpOwogIH0gZWxzZQogICAgdGhyb3cgbmV3IEVycm9yKCJVbmtub3duIFVJIG1vZGUiKTsKfSkAKGZ1bmN0aW9uKCl7dmFyIGI9cmVxdWlyZSgiU3RvcmFnZSIpLmxpc3QoL1wuaW5mbyQvKS5tYXAoYT0+e2lmKChhPXJlcXVpcmUoIlN0b3JhZ2UiKS5yZWFkSlNPTihhLDEpKSYmImxhdW5jaCI9PWEudHlwZSlyZXR1cm4gYX0pLmZpbmQoYT0+YSk7Yj9sb2FkKGIuc3JjKTpFLnNob3dNZXNzYWdlKCJMYXVuY2hlclxubm90IGZvdW5kIil9KQAoZnVuY3Rpb24oYSxiKXtyZXR1cm4gRS5zaG93UHJvbXB0KGEse3RpdGxlOmIsYnV0dG9uczp7T2s6MX0saW1nOnJlcXVpcmUoImhlYXRzaHJpbmsiKS5kZWNvbXByZXNzKGF0b2IoImxFbzRVQm92Ky8vL0JJTWdnRlZBQVFIQkFvWUlFQlExUUJJY0ZCSWRBQkljQkJBVlVIWXNWRGd3ZUVEZ2dlRUxRNEpLR0FjUCtBeURHQWNPMkF5REJKSTZEQklrQkJMcEtEQklnQUVCT0tCRUFCU3lHTVl3SlRHSWtCV2FiUkpkNmRWSXcwQkJJSXlER0FZSkJHUVl3RUR3d2NDRHd3Y0NBQVE1RkJRd0ZEQT0iKSl9KX0pAChmdW5jdGlvbihtKXtnLnJlc2V0KCkuY2xlYXJSZWN0KEJhbmdsZS5hcHBSZWN0KTtCYW5nbGUuc2V0TENEUG93ZXIoMSk7aWYobSl7dmFyIGg9T2JqZWN0LmtleXMobSksYz1tWyIiXTtjJiZoLnNwbGljZShoLmluZGV4T2YoIiIpLDEpO2MgaW5zdGFuY2VvZiBPYmplY3R8fChjPXt9KTtjLmZvbnRIZWlnaHQ9Yy5mb250SGVpZ2h0fHwyMTt2b2lkIDA9PT1jLnNlbGVjdGVkJiYoYy5zZWxlY3RlZD0wKTt2YXIgcT1CYW5nbGUuYXBwUmVjdCxyPXEueCxuPXEueDIsbD1xLnksdT1xLnkyLTEyO2MudGl0bGUmJihsKz0yMik7dmFyIHQ9cmVxdWlyZSgibG9jYWxlIiksZD17bGFzdElkeDowLGRyYXc6ZnVuY3Rpb24oYixhKXt2YXIgcD0wfE1hdGgubWluKCh1LWwpL2MuZm9udEhlaWdodCxoLmxlbmd0aCksZj1FLmNsaXAoYy5zZWxlY3RlZC0ocD4+MSksMCxoLmxlbmd0aC1wKTtmIT1kLmxhc3RJZHgmJihiPXZvaWQgMCk7ZC5sYXN0SWR4PWY7CnZhciBlPWw7Zy5yZXNldCgpLnNldEZvbnRBbGlnbigwLC0xLDApLnNldEZvbnQoIjEyeDIwIik7Yy5wcmVkcmF3JiZjLnByZWRyYXcoZyk7dm9pZCAwPT09YiYmYy50aXRsZSYmZy5kcmF3U3RyaW5nKGMudGl0bGUsKHIrbikvMixsLTIxKS5kcmF3TGluZShyLGwtMixuLGwtMikuc2V0Q29sb3IoZy50aGVtZS5mZykuc2V0QmdDb2xvcihnLnRoZW1lLmJnKTtlKz0xMjtnLnNldENvbG9yKDA8Zj9nLnRoZW1lLmZnOmcudGhlbWUuYmcpLmZpbGxQb2x5KFs3MixlLDEwNCxlLDg4LGUtMTJdKTt2b2lkIDAhPT1iJiYoZjxiJiYoZSs9Yy5mb250SGVpZ2h0KihiLWYpLGY9YiksZitwPmEmJihwPTErYS1iKSk7Zm9yKDtwLS07KXthPWhbZl07Yj1tW2FdO3ZhciBrPWY9PWMuc2VsZWN0ZWQmJiFkLnNlbGVjdEVkaXQ7Zy5zZXRDb2xvcihrP2cudGhlbWUuYmdIOmcudGhlbWUuYmcpO2cuZmlsbFJlY3QocixlLG4sZStjLmZvbnRIZWlnaHQtMSk7Zy5zZXRDb2xvcihrP2cudGhlbWUuZmdIOmcudGhlbWUuZmcpOwpnLnNldEZvbnRBbGlnbigtMSwtMSk7Zy5kcmF3U3RyaW5nKHQudHJhbnNsYXRlKGEpLHIrMSxlKzEpOyJvYmplY3QiPT10eXBlb2YgYiYmKGE9bixrPWIudmFsdWUsYi5mb3JtYXQmJihrPWIuZm9ybWF0KGspKSxrPXQudHJhbnNsYXRlKCIiK2spLGQuc2VsZWN0RWRpdCYmZj09Yy5zZWxlY3RlZCYmKGEtPTI1LGcuc2V0Q29sb3IoZy50aGVtZS5iZ0gpLmZpbGxSZWN0KGEtKGcuc3RyaW5nV2lkdGgoaykrNCksZSxuLGUrYy5mb250SGVpZ2h0LTEpLGcuc2V0Q29sb3IoZy50aGVtZS5mZ0gpLmRyYXdJbWFnZSgiXGZcdTAwMDVcdTAwODFceDAwIFx1MDAwN1x4MDBcdTAwZjlcdTAwZjBcdTAwMGVceDAwQCIsYSxlKyhjLmZvbnRIZWlnaHQtMTApLzIse3NjYWxlOjJ9KSksZy5zZXRGb250QWxpZ24oMSwtMSksZy5kcmF3U3RyaW5nKGssYS0yLGUrMSkpO2cuc2V0Q29sb3IoZy50aGVtZS5mZyk7ZSs9Yy5mb250SGVpZ2h0O2YrK31nLnNldEZvbnRBbGlnbigtMSwtMSk7Zy5zZXRDb2xvcihmPApoLmxlbmd0aD9nLnRoZW1lLmZnOmcudGhlbWUuYmcpLmZpbGxQb2x5KFs3MiwxNjYsMTA0LDE2Niw4OCwxNzRdKTtnLmZsaXAoKX0sc2VsZWN0OmZ1bmN0aW9uKCl7dmFyIGI9bVtoW2Muc2VsZWN0ZWRdXTtpZigiZnVuY3Rpb24iPT10eXBlb2YgYiliKGQpO2Vsc2UgaWYoIm9iamVjdCI9PXR5cGVvZiBiKXtpZigibnVtYmVyIj09dHlwZW9mIGIudmFsdWUpZC5zZWxlY3RFZGl0PWQuc2VsZWN0RWRpdD92b2lkIDA6YjtlbHNlIGlmKCJib29sZWFuIj09dHlwZW9mIGIudmFsdWUmJihiLnZhbHVlPSFiLnZhbHVlKSxiLm9uY2hhbmdlKWIub25jaGFuZ2UoYi52YWx1ZSk7ZC5kcmF3KCl9fSxtb3ZlOmZ1bmN0aW9uKGIpe3ZhciBhPWQuc2VsZWN0RWRpdDtpZihhKXthLnZhbHVlLT0oYnx8MSkqKGEuc3RlcHx8MSk7dm9pZCAwIT09YS5taW4mJmEudmFsdWU8YS5taW4mJihhLnZhbHVlPWEud3JhcD9hLm1heDphLm1pbik7dm9pZCAwIT09YS5tYXgmJmEudmFsdWU+YS5tYXgmJihhLnZhbHVlPQphLndyYXA/YS5taW46YS5tYXgpO2lmKGEub25jaGFuZ2UpYS5vbmNoYW5nZShhLnZhbHVlKTtkLmRyYXcoYy5zZWxlY3RlZCxjLnNlbGVjdGVkKX1lbHNlIGE9Yy5zZWxlY3RlZCxjLnNlbGVjdGVkPShiK2Muc2VsZWN0ZWQraC5sZW5ndGgpJWgubGVuZ3RoLGQuZHJhdyhNYXRoLm1pbihhLGMuc2VsZWN0ZWQpLE1hdGgubWF4KGEsYy5zZWxlY3RlZCkpfX07ZC5kcmF3KCk7QmFuZ2xlLnNldFVJKCJ1cGRvd24iLGI9PntiP2QubW92ZShiKTpkLnNlbGVjdCgpfSk7cmV0dXJuIGR9QmFuZ2xlLnNldFVJKCl9KQAoZnVuY3Rpb24oZSxhKXsic3RyaW5nIj09dHlwZW9mIGEmJihhPXt0aXRsZTphfSk7YT1hfHx7fTtnLmNsZWFyUmVjdChCYW5nbGUuYXBwUmVjdCk7Zy5yZXNldCgpLnNldEZvbnQoIjZ4OCIsMTI4PGcuZ2V0V2lkdGgoKT8yOjEpLnNldEZvbnRBbGlnbigwLC0xKTt2YXIgYz1CYW5nbGUuYXBwUmVjdC55LGI9Zy5nZXRXaWR0aCgpLGQ9Zy5nZXRIZWlnaHQoKS1jLGs9Zy5nZXRGb250SGVpZ2h0KCksZj1nLndyYXBTdHJpbmcoYS50aXRsZSxiLTIpO2U9Zy53cmFwU3RyaW5nKGV8fCIiLGItMik7ZD1jKyhkKyhmLmxlbmd0aC1lLmxlbmd0aCkqaykvMjtpZihhLmltZyl7dmFyIGg9Zy5pbWFnZU1ldHJpY3MoYS5pbWcpO2cuZHJhd0ltYWdlKGEuaW1nLChiLWgud2lkdGgpLzIsZC1oLmhlaWdodC8yKTtkKz00K2guaGVpZ2h0LzJ9Zy5kcmF3U3RyaW5nKGUuam9pbigiXG4iKSxiLzIsZCk7YS50aXRsZSYmZy5zZXRDb2xvcihnLnRoZW1lLmZnSCkuc2V0QmdDb2xvcihnLnRoZW1lLmJnSCkuY2xlYXJSZWN0KDAsCmMsYi0xLGMrNCtmLmxlbmd0aCprKS5kcmF3U3RyaW5nKGYuam9pbigiXG4iKSxiLzIsYysyKTtnLmZsaXAoKTtCYW5nbGUuc2V0TENEUG93ZXIoMSl9KQAoZnVuY3Rpb24odSxlKXtlfHwoZT17fSk7ZS5idXR0b25zfHwoZS5idXR0b25zPXtZZXM6ITAsTm86ITF9KTt2YXIgcj1yZXF1aXJlKCJsb2NhbGUiKSxuPU9iamVjdC5rZXlzKGUuYnV0dG9ucyksdj1bXTtnLmNsZWFyUmVjdChCYW5nbGUuYXBwUmVjdCk7aWYoIXUpcmV0dXJuIEJhbmdsZS5zZXRVSSgpLFByb21pc2UucmVzb2x2ZSgpOyhmdW5jdGlvbigpe2cucmVzZXQoKS5zZXRGb250KCI2eDgiLDIpLnNldEZvbnRBbGlnbigwLC0xKTt2YXIgaz1CYW5nbGUuYXBwUmVjdC55LGQ9Zy5nZXRXaWR0aCgpLGY9Zy5nZXRIZWlnaHQoKS1rLGw9Zy5nZXRGb250SGVpZ2h0KCkscD1nLndyYXBTdHJpbmcoZS50aXRsZSxkLTIpLHQ9Zy53cmFwU3RyaW5nKHV8fCIiLGQtMiksYT1rKyhmKyhwLmxlbmd0aC10Lmxlbmd0aCkqbCkvMi0yNDtlLmltZyYmKGY9Zy5pbWFnZU1ldHJpY3MoZS5pbWcpLGcuZHJhd0ltYWdlKGUuaW1nLChkLWYud2lkdGgpLwoyLGEtZi5oZWlnaHQvMiksYSs9NCtmLmhlaWdodC8yKTtwJiZnLnNldENvbG9yKGcudGhlbWUuZmdIKS5zZXRCZ0NvbG9yKGcudGhlbWUuYmdIKS5jbGVhclJlY3QoMCxrLGQtMSxrKzQrcC5sZW5ndGgqbCkuZHJhd1N0cmluZyhwLmpvaW4oIlxuIiksZC8yLGsrMik7Zy5zZXRDb2xvcihnLnRoZW1lLmZnKS5zZXRCZ0NvbG9yKGcudGhlbWUuYmcpLmRyYXdTdHJpbmcodC5qb2luKCJcbiIpLGQvMixhKTthKz10Lmxlbmd0aCpsKzMyO3ZhciBtPTA7Zy5zZXRGb250QWxpZ24oMCwwKTtuLmZvckVhY2goaD0+bSs9MjQrZy5zdHJpbmdXaWR0aChyLnRyYW5zbGF0ZShoKSkpO20+ZCYmKGcuc2V0Rm9udCgiNng4IiksbT0wLG4uZm9yRWFjaChoPT5tKz0yNCtnLnN0cmluZ1dpZHRoKHIudHJhbnNsYXRlKGgpKSkpO3ZhciBiPShkLW0pLzI7bi5mb3JFYWNoKChoLHEpPT57aD1yLnRyYW5zbGF0ZShoKTtxPWcuc3RyaW5nV2lkdGgoaCk7Yis9KDI0K3EpLzI7dmFyIGM9NitxLzI7di5wdXNoKHt4MTpiLQpjLHgyOmIrYyx5MTphLTI0LHkyOmErMjR9KTtjPVtiLWMsYS0xNixiK2MsYS0xNixiK2MrNCxhLTEyLGIrYys0LGErMTIsYitjLGErMTYsYi1jLGErMTYsYi1jLTQsYSsxMixiLWMtNCxhLTEyLGItYyxhLTE2XTtnLnNldENvbG9yKGcudGhlbWUuYmcyKS5maWxsUG9seShjKS5zZXRDb2xvcihnLnRoZW1lLmZnMikuZHJhd1BvbHkoYykuZHJhd1N0cmluZyhoLGIsYSsxKTtiKz0oMjQrcSkvMn0pO0JhbmdsZS5zZXRMQ0RQb3dlcigxKX0pKCk7cmV0dXJuIG5ldyBQcm9taXNlKGs9PntCYW5nbGUuc2V0VUkoInRvdWNoIixkPT57di5mb3JFYWNoKChmLGwpPT57ZC54Pj1mLngxJiZkLng8PWYueDImJmQueT49Zi55MSYmZC55PD1mLnkyJiYoRS5zaG93UHJvbXB0KCksayhlLmJ1dHRvbnNbbltsXV0pKX0pfSl9KX0pAChmdW5jdGlvbihjKXtmdW5jdGlvbiBsKGEpe3JldHVybiBNYXRoLmZsb29yKChhK2gtZCkvYy5oKX1CYW5nbGUuc2V0VUkoKTtpZihjKXt2YXIgaz0wLGg9MCxmPWcuZ2V0V2lkdGgoKSxlPWcuZ2V0SGVpZ2h0KCksZD1CYW5nbGUuYXBwUmVjdC55LG09Yy5oKmMuYy0oZS1kKTsoZnVuY3Rpb24oKXtnLnJlc2V0KCkuY2xlYXJSZWN0KDAsZCxmLTEsZS0xKTtnLnNldENsaXBSZWN0KDAsZCxmLTEsZS0xKTtmb3IodmFyIGE9bChkKSxiPU1hdGgubWluKGwoZS0xKSxjLmMtMSk7YTw9YjthKyspYy5kcmF3KGEse3g6MCx5OmEqYy5oK2QtaCx3OmYsaDpjLmh9KTtnLnNldENsaXBSZWN0KDAsMCxmLTEsZS0xKX0pKCk7Zy5mbGlwKCk7QmFuZ2xlLmRyYWdIYW5kbGVyPWE9Pnt2YXIgYj1hLmR5O2stYj5tJiYoYj1rLW0pOzA+ay1iJiYoYj1rKTtrLT1iO2I9aDtoPWsmLTI7aWYoYi09aCl7Zy5yZXNldCgpLnNldENsaXBSZWN0KDAsZCxnLmdldFdpZHRoKCktCjEsZy5nZXRIZWlnaHQoKS0xKTtnLnNjcm9sbCgwLGIpO2E9YS5keTtpZigwPmEpZm9yKGcuc2V0Q2xpcFJlY3QoMCxlLSgxLWEpLGYtMSxlLTEpLGE9bChlLSgxLWEpKSxiPWEqYy5oK2QtaDtiPGU7KWMuZHJhdyhhLHt4OjAseTpiLHc6ZixoOmMuaH0pLGErKyxiKz1jLmg7ZWxzZSBmb3IoZy5zZXRDbGlwUmVjdCgwLGQsZi0xLGQrYSksYT1sKGQrYSksYj1hKmMuaCtkLWg7Yj5kLWMuaDspYy5kcmF3KGEse3g6MCx5OmIsdzpmLGg6Yy5ofSksYi09Yy5oLGEtLTtnLnNldENsaXBSZWN0KDAsMCxmLTEsZS0xKX19O0JhbmdsZS5vbigiZHJhZyIsQmFuZ2xlLmRyYWdIYW5kbGVyKTtCYW5nbGUudG91Y2hIYW5kbGVyPShhLGIpPT57Yi55PGQtNHx8KGE9bChiLnkpLDA8PWEmJmE8Yy5jJiZjLnNlbGVjdChhKSl9O0JhbmdsZS5vbigidG91Y2giLEJhbmdsZS50b3VjaEhhbmRsZXIpfX0pADEyOjM0OjU2Ojc4OjkwOmFiADJ2MTE=");
writeSegment(104272, "alXqH0ItwEdCXwAEliQWcwNTBgOHBAAAABAAEAIgx0ESRCAAkj11UpVUFXP6HQAA3yVkWnY0qRqWJAAAAAAAAJIuABGSLiAAlixpW3pN4FtaLQAA/lclWbV7JVs+VwAAT1mKeYp5anlXfwAAlWVvW29br28VVwAAe1tUW1J7UX/WVQAA7U9tSLooFRnVHwAAFwgpZAEQAXDHcQAARBDeJGV/ZSneJgAAoEQzUK1tq1TpVQYIBgCyZXpbelt/ZQBAAATrXrVVZVSjMwEAAABte70qf0d6cwAMk3eSfNZwknCTcQBwAwAEAAYABgAEAAMAQAGSCUQppxVEfSoIBChHGgSogiQA/LokBCg3GwAAAgBEIAAAhBAAAAQJRQAACUIAAIn/AQAJQgiAEEUIQCAAEAAEAAAACEccAIjJIgCQSgMfkEocgKBMIIAg9z8AQAAAAAAAAE588x3RQBQiRnkvHEGGSCLxx4giTjiHHA==");
writeSegment(104644, "DgABIJEQAhCREPQJDwAIBIEQ9AmOEAIQACABIMABAAAuEu84cZIYJaIqDyOkuggjYMYYJQRG7zjgAQAAAAAAAP+76A4QwkgCnMNPAhDeSCIQxkgiH7roHA==");
writeSegment(104740, "EcboPBLuHCMU1hojHMYZPRLGGCHxx+gg");
writeSegment(104772, "zrsfIzFCEiPROxIjMQYSFTJGEhUtOuIIAQAAAAAA4CAxxo8QUUWBEJUogghVEYQILhKIBCqSjwQAAOACjgAEIIIAAiBCAeA8QgEQIiIC8CICABAjAgDwPA58AAAggAMgIAAEIO45/zwwRhQjMH4UIzBC9CLvPRQiAADgAERABgAAQAIAzEWiPURIUiNEcFIjREhSI05EUyOAAwAAAAAAEAAAABDOP+s8McYMETFG6BDRPxgQDgboDwAG");
writeSegment(104968, "McYYPzFGFQVRVRIJUVX1EI+oGD4AAOAAg2AADIQQABKEEAA4mIwEEJiMCjiEEAkShBAADINgAAAADAAAABAACAAQAAgAOAA+ABAACICRDQiAkFQJAGEJCARkAgCEaAceXxEoKAQgRywEwIAoH+xIKARsJx4EAAAAgABAGOADgAhPAMAQlAAAABYBAAAUAgAA7wMAAAAAAABpAwAAMgEAGlsSACwAOAAAAHz3AQA4AAAAEAAAAAAAAIAAAAgfAAAAy0EFPguiCgTAEQsIICAKEMDDBT4AAAAAAAACABEAYgAREIciCgDKHQQQihQEkIccBBByIwAQAgCROOUYkUAQBYowUB0fSJAlBCSQHZ8YUAGEBBABgHjgAAAA9xkAgAgkBYAOJAqADRjUgw4ASoANAEWACAAAAAcAgDEBAEQIkh6EEJA6HwmQGsQx0AoEAKAKHwCACgAAAAsAEAYkADAJJAAQSSkMEKkIDDhWEgABoBaAAEAvAAMAIhICZhxSAQAAVBJCCIQBpRSLEuccKaEYI3LFGCMzOgAAVhEAGISA4z6EEBYhSikLOc45DiExRhohMcbrPgAAQABGAWYc/3/nHBBCQgicc0IIEEJCCBBCQgj/f+ccAAAAAApYZhSOReccROUYI6TXGCMkzRgjRMUYI45F5xwAAAAAVoHADM4BFyMxghkjMaoaIzGSGiMxqhwjzgHnHAAACABKEQAYMUbIADFGLx0xqkgDMZI4HzESHyPOEWgfAAAAAMRZpQAAAEAAzjnnPCGEEArvvfc+McYYKe+99xYAAAAAgBmlGAAAAADOOecYMMYYCdB77wkQQggJ7733HAQAAABGKWUZAAAGAIwx4R2EEBcjhJAYI4SQGCPOORcdAAAAAEZZBQAAAAACzjlHHDHGCCYxxvgrMcYIMs45RxwAAAAgzChFIAAAACAxxhgtMcYYMzHGGDMxxvgs770XIAAA4CAKAAAAAAAAABEAAAARAAAAEQAAAA8AAAABAAAADgAAAAQEBAQEBAQEBB4EFRUeDAwEBAQEBAYEBAoKBAQLDg0KBgwHGBAEBAYEBAYLBCsMGxgUDAoGDAwQDAYOCh8QBAQOCAQHEAQECQoIBAgGBAQEFgQUBBUJBAwLBAQJBAwLBAQJHAkQBw8EBAkEChsEGxIWBAQEBBQEEQQeBAQEBAQeFAYGBhIOEAQEBAQEBAQLBgYECwsMEhMEBAQHCAQEFRQLBAQHBAQEBAwHBAQUBAQEBAQSGwQEBwgEBBUmCwQEBAQHCAQEBAQEBAAAAAAAAACpq8XDJymRjycpXVsqLGBeKy3HxS8xy8mCjaecT1p0aR0e1NMqKzpVU0VEUF1rbHuWo7zHxrecnqytoZSGhXZbTjUuMMXDKCo4Ul5dQVBFXUQpRTZBKUJdXE40lZelv8vKrr2yyrGWsqOulq/KybuhLDdQa8vNbVJGVGB2j5y3xsi9sX99lq6snpGFb1Y7HR9Eap7G7+3EnGhCGhxFbaHH7OrFn2tDKiyUkjVOiXA7VoNoaHCKgkRGrqyqrMbf3cRobYeCISPS0CosO1ZURkRQTjWcnqyuoqS9yMa3TlCenFRWpKIqLK6xy8OprERbQVRWY3yfuKuxy8OpkG1hVFZjfJekopWHhWttYSwuyshThIqknIInL0lDaoJeYG+KpKKIeniEgmknL0nHxUdBTlBda21hVFZjiG6XpKKVh4WRnpyPaoRbTlBqeHpuVFakooiJlJKDaFtdd3VcXnh2SWN5l7F1TlZwaIKKpJxBW3mPqX1UVmN8h5SSeGxtYayuyMZFSVhmgajAv6KWiJSisbytknlufZimpZmMcWJga4SeucjN2uXh0sSpdVxQKy3Ny1OknoWJU8XDJyw7VmN8bn2Ypb7Jxauvo5aIhGptYVRGQ8XDKy49S1ZHRlFqhJ+ur6Szv8rHuKqPW0I2Jyw7SWSYsb3IxautoolvVEVDxcMnL0lDam6IhKuxy8MnL0lDam6IhMXDe3+zsZeVJylqby4wzMqJhMXDJytFRKytx8OpqkJBLjClvsnGt5yRrJ6trqOvlicpdy4weczKhZHFwycpq7HLwycplZQwMs7MZK+uXcXDJymWLjDMyl3FwysuPUtmmrO/ysiur6SLcVZHRlFqhJ+uyMe4qo9bQjYnLDtWcImUkXd6blRGQ8XDsbzm24aIzMpOUF1rbXyXpKKVh4V2WycxS0fJx0VBJymenCcpoS8xyccnKcjGLC7MyjEzzMosLsjGJynNyy8xxcMnKW0vMYjJx4YnL0mrscvDqUdBGh85NtLV7+oaHNnXGh/v6tDTNzQrdXdSe33Q2PLqJylSUGBiysheX26Jo7zHraGHeXiEnqytx8a3nIJpJynFw15fbomHeXiEnqytoaO8x8a3nIJpLC7KyF5fbomjnoSHeXiEnqyuvMfGt5yCaSssRkVRxsRPNltgenVgYsrj7u3e0MTT1MheX26JysiHeXiEaVtdxcMnKUNBXV/H4Ovq0NHFKStFQycpkWBik8rIn6vFw2Nkc47PzYx+fYluW13s6mBi8e9eX258h3l4hGleX258iHl4hHeFhpWjvMfGt6mdrK2hrqCfkIJpKCqfra7Ix7idW12erK2hYGLKyLu8x8a3nFtdoGFjyMZbXcjGYGLMymVnzMqVyMZbXcvJYWPFw2JkyOHs69HSxltdrsdbYnyssMrDqXl1HyA6OUVfeISSrcfV1vDv4MWrkJ6PdWp2XUMqGhzs6hobKkVfemx7laCUrcfg6+rQ0cWrkoZ4XUM1NFFcdYKEd2t5lKOYf3JwfYl7YCwvPldIR1JrhaCvsKXAy8i5q5BcQzdocH11goqXj0FDXVt1d9/dUVJhfHpsa3eRn6CUlq+6uaqPdVxERcfGKyw7SVRGRVGSq7HLw6mQTzZoboiCQk5cdZCcqp6tlJKEal5gboiUraKwpJZ9YlZIVEVQdn6Lg5CYpZ2PkezqGhx3dSstR0UrLz5MZ5u0wMu+s5pmSzw4Q1yQq7q+y8e4qo9bQjZGSFdycGJgbIaUloqMpbCun4RqUV5shKCsgmFvh6OvhWhwsa+IgisvPDhDXJCrur7Lx7iqj1tCNi88S2aas77LwLSbZ0w+REhkfoqysIiWlHp8YmCurCcvSUE3OaGfqbHLw1tjfXUpK1BOnLjs6oKEnpzExdPg7Ord3tLf0V9rh5+tiVxohJyqhi8xxsQpKl5fbGlcXTZCNYqLzMuKi7CzwLyviYuZpr7Azcq9pZiWKCo4RVFEUl9raVxeUVBDRDc1eHqUoJ+ruMbIvL7X4uDRtqmQhURGYF4DBSAfBQcfHgQGIiASHhwEDxwRIBUIEwIEHhwGCCIgBAYULjo5HSwhOSAFIRIdBR45OCoQLDNNSXBzjYqxtc/Jop+GiEcuxcPIydfk8O7h4tbj1QIEHx4EBh4dAwUhHxEdGwEDHRsFByEfAAIdHAIEHBsoLEZFra7IxKqrQ0ICBCAeEBwaAAIcGgQGIB4oLTxKZZmyvsnGrK6jinBVRkTGxAQGISBCTrCkSFaqnDAyxcMnKZGcJylDRlVwiqOuq5GUiG5gXcXDKis6VWJue5exvcjGrK6ilXlsYFNFRFDFw041KStGRSosREMqLEhGOERCKjVCN0Y7LjkoKkRCLC5IRh0fLUdTUjZFOlI5HjorNh43UlFDKV5fbmNkc46oo4mMfn2Jo7GzwczLvMfFqZyEh6Gfq56sraGHeXdpxsfV4u7s3+DU4dNcXsbEJylEQygqQkFdX8fFKStHRTdDQSk1RF+JfFQ4LDpdT5KUrqxgYsXDKy1FRCcp7OotL0lHAAAAAAABAgMEBQYHCAkKCwwNAg4PEBESExQVFgAXGBkaGxwdGB4YGR8gGSEhGRgaIiMYGSQZGCUAFSYnKCkqKywYLS4vMDEyMzQwNTY3ODk6Ozw9Pjw/PUAYGUFCN0NERUZHSElKS0xNTk9QUFFSUFNUVVZXUFhRWVpbXF1RWFleWFlQUF9QYGFZYmNWZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7R3x9Wn5/gIGCg4SFhocLiImKi4xkjY6PkJGSk5GUkpGTlZaXmC6ZLpoumy6cnS6eLp8woDKhMqIyozKkpTamNqeoqaiqq6wWO5utPJk8mjybPJydPK6vsDyYsTeisTeasTecnbE3R5mys7RPULVPULZPULdPULi5T1BPULq7UrxUtFS1VLZUuLm9vlm/wMHAWn5QwsO3WFlQtFC1ULZQt1C4uROXxFDFZLRktWS2ZLi5aWrGx1BpalzIAAAAAAACAgQCAwEBAQEDAgEBAQEEAQIDAQMEAQMDAgIBAgEDAQEBAQEBAQIBAQEBAQEBAQECAgMBAgEBAgEBAQEBAQEBAgIBAgECAgICAgEBAwIBAgICAQIBAQECAgEBAQEBAAM=");
writeSegment(108320, "AgICAQMCAAICAAIBAAMBAQMAAAECAAEBAAACAwMDAgICAgIDAgECAgICAwICAgMCAgICAgIDAgIDAwMEAgEBAwMDAwQDAQICAgIDAgICAwMDAgICAgMDAgICAgMDAgT/Z2Z4AFVua25vd24gZ3JhcGhpY3MgdHlwZQoAYnVmZmVyAGlTZXRQaXhlbABpRmlsbFJlY3QABCEUpRznDGMAAJgvikKRRDdxz/vAtaXbtelbwlY58RHxWaSCP5LVXhyrmKoH2AFbgxK+hTEkw30MVXRdvnL+sd6Apwbcm3Txm8HBaZvkhke+78adwQ/MoQwkbyzpLaqEdErcqbBc2oj5dlJRPphtxjGoyCcDsMd/Wb/zC+DGR5Gn1VFjygZnKSkUhQq3JzghGy78bSxNEw04U1RzCmW7Cmp2LsnCgYUscpKh6L+iS2YaqHCLS8KjUWzHGeiS0SQGmdaFNQ70cKBqEBbBpBkIbDceTHdIJ7W8sDSzDBw5SqrYTk/KnFvzby5o7oKPdG9jpXgUeMiECALHjPr/vpDrbFCk96P5vvJ4ccaA");
writeSegment(108800, "Iq4o15gvikLNZe8jkUQ3cS87TezP+8C1vNuJgaXbtek4tUjzW8JWORnQBbbxEfFZm08Zr6SCP5IYgW3a1V4cq0ICA6OYqgfYvm9wRQFbgxKMsuROvoUxJOK0/9XDfQxVb4l78nRdvnKxlhY7/rHegDUSxyWnBtyblCZpz3Txm8HSSvGewWmb5OMlTziGR77vtdWMi8adwQ9lnKx3zKEMJHUCK1lvLOktg+SmbqqEdErU+0G93KmwXLVTEYPaiPl2q99m7lJRPpgQMrQtbcYxqD8h+5jIJwOw5A7vvsd/Wb/Cj6g98wvgxiWnCpNHkafVb4ID4FFjygZwbg4KZykpFPwv0kaFCrcnJskmXDghGy7tKsRa/G0sTd+zlZ0TDThT3mOvi1RzCmWosnc8uwpqduau7UcuycKBOzWCFIUscpJkA/FMoei/ogEwQrxLZhqokZf40HCLS8IwvlQGo1FsxxhS79YZ6JLREKllVSQGmdYqIHFXhTUO9LjRuzJwoGoQyNDSuBbBpBlTq0FRCGw3Hpnrjt9Md0gnqEib4bW8sDRjWsnFswwcOcuKQeNKqthOc+Njd0/KnFujuLLW828uaPyy713ugo90YC8XQ29jpXhyq/ChFHjIhOw5ZBoIAseMKB5jI/r/vpDpvYLe62xQpBV5xrL3o/m+K1Ny4/J4ccacYSbqzj4nygfCwCHHuIbRHuvgzdZ92up40W7uf0999bpvF3KqZ/AGppjIosV9YwquDfm+BJg/ERtHHBM1C3EbhH0EI/V32yiTJMdAe6vKMry+yRUKvp48TA0QnMRnHUO2Qj7LvtTFTCp+ZfycKX9Z7PrWOqtvy18XWEdKjBlEbIA=");
writeSegment(109568, "Tk9UWVBFAEZMT0FUMzIASU5UMTYASU5UMzIAVUlOVDgASU5UOABJTlQ2NABCT09MAENPTVBMRVg2NABDT01QTEVYMTI4AFNUUklORwBGTE9BVDE2AEZMT0FUNjQAVW5rbm93biB0eXBlAHsganNIYW5kbGVJTygpOyB9AHsgaHdTZXRQaW5WYWx1ZSgkMCwkMSkgfQB7IHJldHVybiBod0dldFBpblZhbHVlKCQwKSB9AHsgcmV0dXJuIERhdGUubm93KCk7IH0AeyBod0ZsYXNoV3JpdGUoJDAsMHhGRik7IH0AeyByZXR1cm4gaHdGbGFzaFJlYWQoJDApIH0AeyBod0ZsYXNoV3JpdGUoJDAsJDEpOyB9AE5vdCBpbXBsZW1lbnRlZA==");
writeSegment(109872, "BAAABAEABAIgBAMhBAQiBAUjBAYABAcABAgABAkABAoABAsABAwABA0ABA4ABA8ABBAAFBEABBIABBMABBQABBUABBYABBcABBgABBkABBoABBsABBwkBB0lBB4mBB8nBCAABCEABCIABCMABCQABCUABCYABCcABCgABCkABCoABCsABCwABC0ABC4ABC8AZ2Z4AEJhbmdsZQAjb25sY2RQb3dlcgBzZXRMQ0RNb2RlIGlzIHVuc3VwcG9ydGVkIG9uIHRoaXMgZGV2aWNlAEludmFsaWQgaW50ZXJ2YWwAZ2VzdHVyZVN0YXJ0VGhyZXNoAGdlc3R1cmVFbmRUaHJlc2gAZ2VzdHVyZUluYWN0aXZlQ291bnQAZ2VzdHVyZU1pbkxlbmd0aABzdGVwQ291bnRlclRocmVzaG9sZExvdwBzdGVwQ291bnRlclRocmVzaG9sZEhpZ2gAdHdpc3RUaHJlc2hvbGQAdHdpc3RUaW1lb3V0AHR3aXN0TWF4WQB3YWtlT25CVE4xAHdha2VPbkJUTjIAd2FrZU9uQlROMwB3YWtlT25GYWNlVXAAd2FrZU9uVG91Y2gAd2FrZU9uVHdpc3QAcG93ZXJTYXZlAGxvY2tUaW1lb3V0AGxjZFBvd2VyVGltZW91dABiYWNrbGlnaHRUaW1lb3V0ACNvbmxvY2sATm90IGVub3VnaCBzdGFjayBtZW1vcnkgdG8gZGVjb2RlIGRhdGEAeAB5AHoAbWFnAGRpZmYAMTBtaW4AbGFzdABkYXkAVW5rbm93biByYW5nZSBuYW1lICVxAHNldHRpbmcuanNvbgBiZWVwAHZpYnJhdGUAdGhlbWUAZmcAYmcAZmcyAGJnMgBmZ0gAYmdIAGRhcmsAR3JhcGhpY3MAZwBmbGlwAExvYWRpbmcuLi4ALnNwbGFzaABFbXVsYXRlZAAydjExAENvcHlyaWdodCAyMDIxIEcuV2lsbGlhbXMAI29uYWNjZWwAAGZyb250AGJhY2sAYm90dG9tAHRvcAByaWdodABsZWZ0AGRpcgBkb3VibGUAI29udGFwACNvbm1hZwAjb25oZWFsdGgAI29uZ2VzdHVyZQAjb25haUdlc3R1cmUALnRmbW9kZWwAVEYgZXJyb3IgLSBubyBtb2RlbAoAKGZ1bmN0aW9uKGEpIHt2YXIgbT0wLGc7Zm9yICh2YXIgaSBpbiBhKSBpZiAoYVtpXT5tKSB7IG09YVtpXTtnPWk7IH1pZiAoZyE9PXVuZGVmaW5lZCkge3ZhciBuPXJlcXVpcmUoJ1N0b3JhZ2UnKS5yZWFkKCcudGZuYW1lcycpO2lmIChuKSBnPW4uc3BsaXQoJywnKVtnXTt9cmV0dXJuIGc7fSkAI29uY2hhcmdpbmcAI29uc3RlcAAjb250d2lzdAAjb25mYWNlVXAAI29uc3dpcGUAdHlwZQAjb250b3VjaABiAGR4AGR5ACNvbmRyYWcAYWNjSGlzdG9yeUlkeABhY2NHZXN0dXJlQ291bnQAYWNjSWRsZUNvdW50AGxhdABsb24ALm9mZiBub3QgaW1wbGVtZW50ZWQgb24gZW11bGF0b3I=");
writeSegment(111088, "u84gINKgP/+AcLg//8AOLh4ONj//4AOLn//wAOLv//M5n//wNLM4P8M5v4M5qFMM4J2MM4IOMM4KFLgP4j4OIRwUPwEH8F/CArmDnkAgfgwFABwkCAYRlBgPhEoYACgggCE4MB4QOGhCTCAQNB4g0DAAUQAQMcDgOBxA0DAAUgAQMwIAMDyAlCAAZQCSIMIgcgEoR2FgICBmEHoBnFIIUDEQUOUoMf5F/gF+oUD/EOCYUNCINAqHBgcCwkIjBYBg0AjxqBgFhgMMgcIkEYLAJVBUwNEgFCgUQAIOAiFgNgU4gGIgGEgkggkhBYKiBKoNwgMQgMIhGAhFD//BM4MIgPggUgFAMRUQOEM4OAgMogfAglAFQIpBkJFBYAMCwEGEwIBBoFCJoKbBMoME8EdIIOAmGAw0BwkQhkMHQNgnSrBwGhgMGgsIiEwQoMUoFn/0A/x2Bg/yiEf4EYgEngJrBAAkEAYSBBoDECAAjzDBwOAYgLrFToIOCZ4IRBdYrzDvACB+AOFwIFDBwMHJI38Agd8gE/JIwAEn8D/AOM//gBxd//46GAAv//4NLgP/V4IAKgf/L4gOJLBkH/6TFAA0PM5sfM5qFBwCFNBpaFBM5gOBM4JXSURHRVRTAGFyZWEAdwBoAHgyAHkyAG1vdmVtZW50AHN0ZXBz");
writeSegment(111607, "D+YAACQAcAAAASADgAAAABABPAPAPPAPAPIAIAAAA4gIiBEQf/BEQIiAjgAABgYSECTAMmAZIEJDAwAAADwOhCIIRhBzIAGAHoAACQAcAAAAB8AwYIAiACAACACIAgwYB8AAACQAMAH4AMACQAAAAgAEAAgA/gAgAEAAgAAAAEgA4AAAEAAgAEAAgAEAAAAAYADAAAABAAwAYAMAGADAAAAA/gICCGIRhBAQH8AAAEABAAQAD/4AABA4QZCEIRBBwIAABAQQBCEIQhB7wAAADABoARAMID/4AIAAAfCCIIRBCIIQ+AAAP+CIIRBCIII+AAAQACB4QwCYAcAAAAPeCEIQhCEIPeAAAPCCEIQhCEIP+AAAGGAwwAAAwoGGAAAAgAKACIAggICAAACIARACIARACIARAAABAQEEARABQAEAAABAAQACCYQgCIAOAAAAP+CAIRxCRISJB/AAAAf4MQCCAMQAf4AAD/4QhCEIQhB7wAAB/wQBCAIQBBAQAAD/4QBCAIICA/gAAD/4QhCEIQhCAIAAD/4RACIARACAAAAB/wQBCAIQhBHwAAD/4AgAEAAgD/4AACAIf/CAIAACAwQBCAIQBD/wAAD/4AgAKAGMDAYAAD/4ABAAIABAAIAAD/4MAAYAMAD/4AAD/4MAAYAAwD/4AAB/wQBCAIQBB/wAAD/4QgCEAQgB4AAAB/wQBCAoQCB/oAAD/4QgCEAQ4B44AABwQRBCEIQRBBwAACAAQAD/4QACAAAAD/wABAAIABD/wAAD4AA8AAYA8D4AAAD/gADABgAwABgADD/gAADA4GYAMAGYDA4AADgADAAH4DADgAAACAYQNCOIWBDAIAAD/8QAiAEAADAAGAAMAAYAAwABAAAQAiAEf/gAACABgAQABgACAAAAABAAIABAAIABAAIAAAAAQABAAAAAJwCRASICSAP4AAD/4BCAQICBAPwAAAPwCBAQICBAIQAAAPwCBAQIBCD/4AAAPwCRASICRAOQAAAQAP/CQASACQAAAAOsCKQRSCKQeSCBgAAf/AIACAAQAB/AAAABAQIT/AAIABAAAAAgACAAQQCT/gAAf/ABAAYAMgCDAAAABCAIf/AAIABAAAD/AQAD/AQAB/AAAD/AIACAAQAB/AAAB+AQICBAQIB+AAAD/wIQCBAQIB+AAAB+AQICBAIQD/wAAD/AIACAAQABAAAABiASICRARIBGAAACAD/wCBAQICBAAAD+AAIABAAQD/AAADgADgADADgDgAAAD8AAYAcAAYD8AAADDAEgAYAEgDDAAADwYBsACABgDwAAACDAQoCZAUIDBAAAOTiNiQAQAAf/AAAQASNiOTgAAAgAIABAAEAAQACAAgAAAD/BiAQQBiGD/IABAAABAf/gEEBAgAEAAgAALoAiAIIBBAIIAiALoAAAf/gAEIAiAEAAgAAOCCIIQhCCIIOAAANjCSERIiEkMbAAAOCCIIQhCCIIOAAAOCCIJQhqCKIOAAAQACAAf/CAAQAAAACDAQoKZCUIDBAAACDCQoKZCUIDBAAACDAQoKZAUIDBAAAMACQASABgAAAAJwCRQSNCSIP4AAACIQhD/4CBAgIAABAAQAAAAAAhAEP/hAEQAgAABiBSISRBRIBGAAAQABAAQAAAABiCSIKRCRIBGAAABiASJCRoRKBGAAABAB/4BAgIEVAjAAAAAQYCFBTIShAYIAAAQYSFBTIShAYIAAAQYCFBTIChAYIAAD/4QgCEAQ4B44AAAf4MQCCAMQAf4AAAf4MQCCAMQAf4AAAf4MQCCAMQAf4AAAf4MQCCAMQAf4AAD/4ABAAIABAAIAAB/wQBCAIQBBAQAAB/wQBKANQBRAQAAB/wQBCAIQBBAQAAD/4QhCEIQhCAIAAD/4QhSENQhKAIAAD/4QhCEIQhCAIAAD/4QhCEIQhCAIAACAIf/CAIAACAIf/CAIAAD/4QBCAIICA/gAAD/4QhCEIICA/gAAD/4MAAYAAwD/4AAD/4MAAYAAwD/4AAB/wQBCAIQBB/wAAB/wQBCAIQBB/wAAB/wQBCAIQBB/wAAB/wQBCAIQBB/wAAD/4QgCEAQ4B44AAB/4AAiAEAAh/4AAD/wABAAIABD/wAAD/wABAAIABD/wAAD/wABAAIABD/wAADgADAAH4DADgAAACAAQAL/+QACAAAAB/4QACIIRBB0IAeAAAD/AIAKACQABAAAABOASIKRCSQB/AAABOBSISRBSQB/AAABOCSIKRCSQB/AAABOBSICRBSQB/AAAABCAIf/AAIABAAAB+AQIKBCQIBCAAAB+AQICBwQJBCAAAB+CQIKBCQIBCAAAB+ASIKRCSIByAAAB+ASICRwSJByAAAB+BSICRBSIByAAAB+CSIKRCSIByAAAABAQIL/CAIABAAAABBQIT/BAIABAAAB/AQECAgIIP/iAAAAAPwCBAQIJCD/4IAAAAD/AIAKACQAB/AAAD/CIAKACQAB/AAAB+AQIKBCQIB+AAAB+BQISBBQIB+AAAB+BQISBBQIR+AAAB+BQICBBQIB+AAAD/CIAKACQABAAAAB/BAEUAhAIB/gAAD+AAIIBCAQD/AAAD+BAIQBBAQT/AAAD+BAIABBAQD/AAADwYBsICCBgDwAAACAD/wCBIQOCBA");
writeSegment(113616, "AwIGCAgICAMFBQYIAwYDBwcFBgYHBgYGBgYDAwYHBgcHBgYGBgYGBgYEBgYGBgYGBgYGBgYGBggGBgYEBwQGBwQGBgYGBgYHBgYGBgYGBgYGBgYGBgYGBgYGBgQCBAg=");
writeSegment(113745, "BwAHCAYGBgAGBgYGAAYGBQYABgMGBgQABgYHBgAGBgYGBgYGBgYGBgYGBgYEBAYGBgYGBgYGAAYGBgYGBgYHBgYGBgYGBgYGBgYGBgYGBwcGBgYGBgYABgYGBgYGBg==");
writeSegment(113855, "f+cH/nAAAA+AAPgAAAAAAAAPgAD4AAAAAAQQAEEAf/8H//AEEABBAH//B//wBBAAQQAAAADggB8MAxhgIIIP//j//4IIIDDGAYfACDgAAAAYAAPAMCQPA8PAGPAAPGAPDwPAkDAPAABgAAAAA8AcfgPsMGOBBBgQY8MD5mAcPAAP8ADDAAAA+AAPgAAAAAB/AB/8A4DgYAMEABAAAAQAEGADA4DgH/wAfwAAAAAIAAiIAMmABrAAPgABwAA+AAawAMmACIgACAAAAAAIAACAAAgAAIAA/4AP+AAIAACAAAgAAIAAAAAAAIAA+AAPAAAAAIAACAAAgAAIAACAAAgAAIAACAAAgAAIAAAAAABwAAcAAAAAAwAA8AA8AA8AA8AA8AA8AAMAAAAAAf/AP/4GAzBAYQQMEEGBBDAQZgMD/+Af/AAAAAgBAYAQMAEH//B//wAAEAABAAAQAAABwDA8BwYA0EAZBAMQQGEEDBBhgQPwEB4BAAAAEAQDAGBgAwQIEECBBAgQQIEGHDA/fgHjwAAAAAeAAPgAGIADCABggAwIAYCAMAgH//B//wAAAH8EB/BgQQMEEBBBAQQQEEEBBBgwQP4EB8AAAAH/wD/+BhAwQQEEEBBBAQQQEEGDBA/gAHwAAABwAAcAAEAABAAAQB8EB/BB4AR4AH4AB4AAAAAB48A/fgYcMECBBAgQQIEECBBhwwP34B48AAAAHwAD+BBgwQQEEEBBBAQQQEEGBDA//gH/wAAAAHDgBw4AAAAAAIBw+AcPAAAAAIAAHAADYABjAAwYAYDAMAYGADBAAQAAAAIQACEAAhAAIQACEAAhAAIQACEAAhAAIQAAAAQAEGADAwBgGAwAwYAGMAA2AAHAAAgAAAABwAA8AAYAAEAABAZwQOcEGABjAAPgABwAAAAAH/wD/+BgAwQAEEPhBH8QTBkEgJBoCQP/kB/5AAAAH/8D//BgQAQEAEBABAQAQEAGBAA//wH/8AAAB//wf/8EEBBBAQQQEEEBBBAQY4MD7+AcfAAAAB/8A//gYAMEABBAAQQAEEABBgAwOA4BgMAAAAf/8H//BAAQQAEEABBAAQQAEGADA//gH/wAAAB//wf/8ECBBAgQQIEECBBAgQQIEEABBAAQAAAH//B//wQIAECABAgAQIAECABAgAQAAEAAAAAAH/wD/+BgAwQAEEABBAgQQIEGCDA4/gGPwAAAB//wf/8ACAAAgAAIAACAAAgAAIAH//B//wAAAEABBAAQf/8H//BAAQQAEAAAAAHAAB4AADAAAQAAEEABBAAwf/4H/8BAAAQAAAAAB//wf/8AHAADYABjAAwYAYDAMAYGADBAAQAAAH//B//wAAEAABAAAQAAEAABAAAQAAEAABAAAAf/8D//AYAADAAAYAADAABgAAwAAYAAP/8H//AAAAf/8H//AGAAAwAAGAAAwAAGAAAwB//wf/8AAAAf/AP/4GADBAAQQAEEABBAAQYAMD/+Af/AAAAH//B//wQIAECABAgAQIAECABhgAPwAB4AAAAAH/wD/+BgAwQAEEAFBABwQAMGADg//sH/xAAAB//wf/8EDABA4AQLAECYBAjAYYYD8DAeAQAAAB4EA/BgYYMECBBAgQQIEECBBgwwMH4BA8AAAAQAAEAABAAAQAAH//B//wQAAEAABAAAQAAAAAB//Af/4AADAAAQAAEAABAAAQAAMH/+B//AAAAHgAB/gAB/AAB8AADwAA8AB8AH8Af4AHgAAAAAf/8H/+AADAABgAAwAAYAADAAAYAADAf/4H//AAAAYAMHgPAePAB3AAHAABwAB3AB48B4DwYAMAAABgAAeAAB4AAHgAAf8AH/AHgAHgAHgABgAAAAAEAPBAHwQDEEBhBAwQQYEEMBBGAQfAEHgBAAAAf/8H//BAAQQAEEABAAAAMAADwAAPAAA8AADwAAPAAA8AADAAAAQAEEABBAAQf/8H//AAAACAABgAAwAAYAAMAADAAAYAADAAAYAACAAAAAAAAEAABAAAQAAEAABAAAQAAEAABAAAQAAEAAAIAADAAAYAACAAAAAAABwAQ+AEYwBEEARBAEQQBEEAZBAD/wAf8AAAB//wf/8AQBAEAQBAEAQBAEAQBgMAP+AB/AAAAAH8AD/gBgMAQBAEAQBAEAQBAGAwAwYAEEAAAAAfwAP+AGAwBAEAQBAEAQBAEAQBB//wf/8AAAAB/AA/4AYjAEIQBCEAQhAEIQBiEAPjAB4gAAAAQAAEAABAAD//B//wRAAEQABEAAQAAAAAAB/AA/4QYDEEARBAEQQBEEARBAMwf/4H/8AAAH//B//wBAAAQAAEAABAAAQAAGAAA/8AH/AAAABAEAQBB3/wd/8AABAAAQAAAAAAwAAOAAAwAAEEABBAA3f/53/8AAAH//B//wACAABwAA2AAYwAMGAGAwBAEAAABAAQQAEH//B//wAAEAABAAAAB/8Af/AEAABAAAf/AH/wBAAAYAAD/wAf8AAAAH/wB/8AQAAEAABAAAQAAEAABgAAP/AB/wAAAAH8AD/gBgMAQBAEAQBAEAQBAGAwA/4AH8AAAAB//wf/8EAQBAEAQBAEAQBAEAYDAD/gAfwAAAAB/AA/4AYDAEAQBAEAQBAEAQBAEAf/8H//AAAAf/AH/wAYAAMAAGAABAAAQAAEAABAAAQAAAAAA8IAfjAEIQBCEAQhAEIQBCEAQhAGPwAh4AAAAEAABAAAQAB//gf/8AQBAEAQBAEAABAAAAB/wAf+AAAwAAEAABAAAQAAEAABAH/wB/8AAAAHAAB8AADwAAPAAA8AAPAAPAAPAAfAAHAAAAAAf+AH/wAAEAABAAfwAH8AABAAAQB/8Af+AAAABgMAcHABjAANgABwAAcAANgAGMAHBwBgMAAAAH/AB/4QADEAARAAEQABEAARAAMwf/4H/8AAAAQDAEBwBA0AQZAEMQBGEATBAFgQBwEAYBAAAAAIAACAAf/AP34GADBAAQQAEAAAB//wf/8AAABAAQQAEGADA/fgH/wACAAAgAAAAHAADwAAgAAIAADgAAcAABAAAQAA8AAOAAAAAAc/8HP/AAAAAfwAP+AGAwBAEB//wf/8BAEAYDADBgAQQAAAAAgQH/8D//BggQQIEECBBggQMAEBAHAABwAAABACAb9gD/wAQIAECABAgAQIAECAD/wBv2AQAgAAAGAAB4JAHiQAckAB/wAf8AckAeJAeCQGAAAAAAfj8H4/AAAAd8IP/jCIMQiBEIwRDH/wQ+4AAADgAA4AAAAAAAAA4AAOAAAAAAB/gAgEAT8gF/oBQKAUCgFAoBc6ATMgCAQAf4AAAADyAJ+gCQoAkKAJCgCQoAkKAP+gB/oAAAAAAgAAcAANgAGMADJgBnMATZABjAAwYAYDAEAQAAAAIAACAAAgAAIAACAAAgAAIAACAAA/AAPwAAAAAIAACAAAgAAIAACAAAgAAIAACAAAAAB/gAgEAX+gF/oBRCAUYgFHIBfaATigCAQAf4");
writeSegment(116517, "B4AA/AAIQACEAAhAAPwAB4AAAAAACBAAgQAIEACBAP+QD/kACBAAgQAIEACBAAAAYgAOYACOAAmgAPIABiAAAAAEQADGAAkgAJIAD+AAbAAAAAAgAAYAAMAACAAAAAAAf/8H//AAEAABAAAQAAEAADAABgB/8Af/AAAAPwAH+ABAgAQIAH//B//wQAAEAAB//wf/8AAAABwAAcAAAAAAABAADwAA4AAAIAAGIAD+AA/gAAIAAAAAPiAH8gDBoAgKAICgCAoAwaAH8gA+IAAAAAQBAGAwAwYAGMAE2QBnMAMmABjAANgABwAAIAAAAAAGAgDAYBgP4wD+ZgAM4AGaADMgBn+Ax/gAAAAAwCAYBgMA/mAP7YgBuYAyOAYmgMPIGBiAAABEBgxgwJIYCSMA/mYGzOABmgAzIAZ/gMf4AAAAAcAAPgAGMADBBzgQcwEAABAAAwAB4AAcAAAAA//gf/6MCAyAgGgIAoCACAgAwIAH/+A//gAAAD/+B//gwIAICAKAgGgIDICAjAgAf/4D/+AAAAP/4H/+LAgGgIDICAyAgGgIAsCAB//gP/4AAAA//mf/7sCAiAgMgIBoCAKAgOwIDH/+A//gAAAD/+B//uwIDoCACAgAgIDoCA7AgAf/4D/+AAAAP/4H/+bAgPgICYCAmAgPgIBsCAB//gP/4AAAH/8D//BggAQIAECABAgAf/8H//BAgQQIEECBBAgQAAAB/8A//gYAMEABFAAfQAHkABBgAwOA4BgMAAAAD//g//6IECyBAmgQIoECCBAggQIIACCAAgAAAP/+D//ggQIIECKBAmgQLIECiBAggAIIACAAAA//4P/+KBAmgQLIECyBAmgQIoECCAAggAIAAAD//g//7oEC6BAggQIIEC6BAugQIIACCAAgAACIACyAAm//4v/+CAAggAIAAACAAggAIv/+b//sgAKIACAAACgAJoACz//s//5oACKAAgAADoAC6AAg//4P/+6AAugAIAAAAIAH//B//wQIEECBBAgQQIEEABBgAwP/4B/8AAAAD//m//7gwAgGAMAwBgGAIAwOAGDP/+D//gAAAD/4B//IwAbIACaAAigAIIACDABgf/wD/4AAAAP/gH/8DABggAIoACaAAsgAKMAGB//AP/gAAAA/+Af/wsAGaAAsgALIACaAAiwAYH/8A/+AAAAD/4Z//OwAaIACyAAmgAIoAC7ABsf/wD/4AAAAP/gH/87ABugAIIACCAAugALsAGB//AP/gAAACAgAwYAGMAA2AAHAABwAA2AAYwAMGACAgAAAAABAH/wD/+BgMwQGEEDBBBgQQwEGYDA//gH/wBAAAAAAD/+A//yAAGwAAmAAIgACAAAgAAYP/8D/+AAAAP/4D//AAAYAACIAAmAALAACgABg//wP/4AAAA//gP/8IABmAALAACwAAmAAIgAGD//A//gAAAD/+A//zgAG4AAgAAIAAC4AAuAAYP/8D/+AAAAMAADwAAPAAA8AID/mA/7A8Ag8AA8AAMAAAAAH//B//wCBAAgQAIEACBAAgQAMMAB+AAPAAAAAP/8H//BBBAQQMEEBBBAQYwED+DAc/gAHwAAAAAHABD4ERjBkQQNEEBRBAEQQBkEAP/AB/wAAAAAcAEPgBGMARBAUQQNEEGRBBGQQA/8AH/AAAAABwAQ+AUYwNEEGRBBkQQNEEBZBAD/wAf8AAAAAHAND4HRjBEQQZEEDRBAUQQdkEGP/AB/wAAAAAcAEPgdGMHRBAEQQBEEHRBB2QQA/8AH/AAAAABwAQ+A0YwfEEExBBMQQfEEDZBAD/wAf8AAAAAPgBH8ARBAEQQBkEAP/AH/gBCMAQhAEIQB+MAPiAAAAAfwAP+AGAwBAEQQB8EAeBAEAYDADBgAQQAAAAB/AA/4EYjBkIQNCEBQhAEIQBiEAPjAB4gAAAAH8AD/gBiMAQhAUIQNCEGQhBGIQA+MAHiAAAAAfwAP+AWIwNCEGQhBkIQNCEBYhAD4wAeIAAAAB/AA/4HYjB0IQBCEAQhB0IQdiEAPjAB4gAAAEQBBkAQN/8Bf/AAAQAAEAAAAEAQBAEBf/A3/wYAEEABAAAAFAEDQBBn/wZ/8DABAQAQAAAHQBB0AQB/8Af/BwAQcAEAAAAB/AU/4HYDAkAQdAEFwBAMAQBgMAP+AB/AAAAAf/A3/wdAAEQABkAANAABQAB2AAY/8AH/AAAAAfwAP+BGAwZAEDQBAUAQBAEAYDAD/gAfwAAAAB/AA/4AYDAEAQFAEDQBBkAQRgMAP+AB/AAAAAH8AD/gFgMDQBBkAQZAEDQBAWAwA/4AH8AAAAAfwDP+B2AwRAEGQBA0AQFAEHYDBj/gAfwAAAAB/AA/4HYDB0AQBAEAQBB0AQdgMAP+AB/AAAAACAAAgAAIAACAAcnAHJwACAAAgAAIAACAAAAAAf0AP+AGDwBBkAQxAEYQBMEAeDAD/gBfwAAAAH/AB/4EADBgAQMAEBABAAAQAAEAf/AH/wAAAAf8AH/gAAMAABAQAQMAEGABBAAQB/8Af/AAAAB/wAf+AQAwMAEGABBgAQMAEBABAH/wB/8AAAAH/AB/4HADBwAQAAEAABBwAQcAEAf/AH/wAAAAf8AH/hAAMQABEQARMAEWABFAAzB//gf/wAAAf//3//8EAQBAEAQBAEAQBAEAYDAD/gAfwAAAAH/AB/4XADFwARAAEQABFwARcAMwf/4H/8");
writeSegment(118576, "BgMHCwsLCwMGBgwLBAsDCQsJCwsLCwsLCwsDBAoLCgsMCwsLCwsLCwsHDAsLDAsLCwsLCwsLCwwLCwsGCQYLCwULCwsLCwoLCwcJCgcLCwsLCwsLCgsLCwsLCwgDCAs=");
writeSegment(118705, "AwsLDAsDCAcMCgwLCQwJCAsHBwULCwMEBgoMCwsLCwsLCwsLCw0LCwsLCwcHBwcMCwsLCwsLCw0LCwsLCwsLCwsLCwsLDQsLCwsLBwcHBwsLCwsLCwsLCwsLCwsLCwtJbnZhbGlkIGFycmF5IGxlbmd0aAAsAG1hcABmb3JFYWNoAGZpbHRlcgBmaW5kAGZpbmRJbmRleABzb21lAGV2ZXJ5AHJlZHVjZQBBcnJheS4lcyBjYW4gb25seSBiZSBjYWxsZWQgb24gc29tZXRoaW5nIGl0ZXJhYmxlAEFycmF5LiVzJ3MgZmlyc3QgYXJndW1lbnQgc2hvdWxkIGJlIGEgZnVuY3Rpb24AQXJyYXkuJXMgd2l0aG91dCBpbml0aWFsIHZhbHVlIHJlcXVpcmVkIG5vbi1lbXB0eSBhcnJheQBFeHBlY3RpbmcgY29tcGFyZSBmdW5jdGlvbiwgZ290ICV0AEFycmF5LiVzJ3Mgc2Vjb25kIGFyZ3VtZW50IHNob3VsZCBiZSB1bmRlZmluZWQsIG9yIGFuIG9iamVjdABJbnZhbGlkIGxlbmd0aCBmb3IgQXJyYXlCdWZmZXIKAEFycmF5QnVmZmVyIHRvbyBsb25nCgBVbnN1cHBvcnRlZCBmaXJzdCBhcmd1bWVudCBvZiB0eXBlICV0CgBFeHBlY3RpbmcgZmlyc3QgYXJndW1lbnQgdG8gYmUgYW4gYXJyYXksIG5vdCAldABBcnJheUJ1ZmZlclZpZXcubWFwIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBhbiBBcnJheUJ1ZmZlclZpZXcAQXJyYXlCdWZmZXJWaWV3Lm1hcCdzIGZpcnN0IGFyZ3VtZW50IHNob3VsZCBiZSBhIGZ1bmN0aW9uAEFycmF5QnVmZmVyVmlldy5tYXAncyBzZWNvbmQgYXJndW1lbnQgc2hvdWxkIGJlIHVuZGVmaW5lZCwgb3IgYW4gb2JqZWN0AEFycmF5QnVmZmVyVmlldy5zdWJhcnJheSBjYW4gb25seSBiZSBjYWxsZWQgb24gYW4gQXJyYXlCdWZmZXJWaWV3AEV4cGVjdGluZyBBcnJheUJ1ZmZlciwgZ290ICV0AERhdGFWaWV3AGJ1ZmZlcgBieXRlT2Zmc2V0AGJ5dGVMZW5ndGg=");
writeSegment(119602, "HwA7AFoAeACXALUA1ADzABEBMAFOAW0B");
writeSegment(119634, "HwA8AFsAeQCYALYA1QD0ABIBMQFPAW4BAABtAdoCSARKYW4ARmViAE1hcgBBcHIATWF5AEp1bgBKdWwAQXVnAFNlcABPY3QATm92AERlYwBTdW4ATW9uAFR1ZQBXZWQAVGh1AEZyaQBTYXQAdHoARGF0ZQBWYXJpYWJsZXMgb2YgdHlwZSAldCBhcmUgbm90IHN1cHBvcnRlZCBpbiBkYXRlIGNvbnN0cnVjdG9yAG1zACVzICVzICVkICVkICUwMmQ6JTAyZDolMDJkIEdNVCVjJTA0ZAAlcywgJWQgJXMgJWQgJTAyZDolMDJkOiUwMmQgR01UACVkLSUwMmQtJTAyZFQlMDJkOiUwMmQ6JTAyZC4lMDNkWgBHTVQAbWVzc2FnZQB0eXBlAEVycm9yAFN5bnRheEVycm9yAFR5cGVFcnJvcgBJbnRlcm5hbEVycm9yAFJlZmVyZW5jZUVycm9yACV2OiAldgBpbnQAZG91YmxlAGJvb2wAUGluAEpzVmFyAEVycm9yIFBhcnNpbmcgc2lnbmF0dXJlIGF0IGFyZ3VtZW50IG51bWJlciAlZABJbnZhbGlkIFNpZ25hdHVyZQD/Y29kAEV4cGVjdGluZyBmaXJzdCBhcmd1bWVudCB0byBiZSBhbiBhcnJheSwgbm90ICV0AEV4cGVjdGluZyBmaXJzdCBhcmd1bWVudCB0byBiZSBpdGVyYWJsZSwgbm90ICV0AEV4cGVjdGluZyBmaXJzdCAyIGFyZ3VtZW50cyB0byBiZSBpdGVyYWJsZSwgbm90ICV0IGFuZCAldABFeHBlY3RpbmcgZmlyc3QgMiBhcmd1bWVudHMgdG8gYmUgaXRlcmFibGUgb3IgdW5kZWZpbmVkLCBub3QgJXQgYW5kICV0AEluc3VmZmljaWVudCBzdGFjayBmb3IgY29tcHV0aW5nIEZGVABGSUZPX0ZVTEwAQlVGRkVSX0ZVTEwAQ0FMTEJBQ0sATE9XX01FTU9SWQBNRU1PUlkATUVNT1JZX0JVU1kAVUFSVF9PVkVSRkxPVwBmb3JjZQBVbmtub3duIGRldmljZSB0eXBlICVxAHNldENvbnNvbGUgY2FuJ3QgYmUgdXNlZCBvbiAnc29mdCcgb3Igbm9uLVNlcmlhbCBkZXZpY2VzACAACgBMACMAPQByZWYsc2l6ZSxuYW1lLGxpbmtzLi4uCgAlZCwlZCwAJXEsACwAJWQsAG5hbWUAc2l6ZQBtb3JlAEZpcnN0IDIgYXJndW1lbnRzIHNob3VsZCBiZSBhcnJheSBidWZmZXJzAFRoaXJkIGFyZ3VtZW50IHNob3VsZCBiZSBhIGZ1bmN0aW9uIG9yIGFycmF5AFNlYXJjaCBzdHJpbmcgaXMgdG9vIGxvbmcgKD49JWQgY2hhcnMpAHB3ZAB0egAoZnVuY3Rpb24oYmFzZSxqKSB7dmFyIG89e30sYWRkcjtmb3IgKHZhciByZWcgaW4gaikge2FkZHI9YmFzZStqW3JlZ107T2JqZWN0LmRlZmluZVByb3BlcnR5KG8scmVnLHtnZXQ6cGVlazMyLmJpbmQodW5kZWZpbmVkLGFkZHIpLHNldDpwb2tlMzIuYmluZCh1bmRlZmluZWQsYWRkcil9KTt9cmV0dXJuIG87fSkAJ0UuYXNtJyBjYWxscyBzaG91bGQgaGF2ZSBiZWVuIHJlcGxhY2VkIGJ5IHRoZSBFc3BydWlubyB0b29scyBiZWZvcmUgdXBsb2FkACdFLklubGluZUMnIGNhbGxzIHNob3VsZCBoYXZlIGJlZW4gcmVwbGFjZWQgYnkgdGhlIEVzcHJ1aW5vIHRvb2xzIGJlZm9yZSB1cGxvYWQARXhwZWN0aW5nIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGEgc3RyaW5nLCBub3QgJXQAYWRkcgBsZW5ndGgAQWRkcmVzcyBzaG91bGQgYmUgYW4gaW50ZWdlciwgZ290ICV0AERhdGEgaXMgbm90IGRlZmluZWQATm90IGVub3VnaCBzdGFjayBtZW1vcnkgdG8gZGVjb2RlIGRhdGEAQ2FuIG9ubHkgdXNlICdhcmd1bWVudHMnIHZhcmlhYmxlIGluc2lkZSBhIGZ1bmN0aW9uAGFyZ3VtZW50cwD/AP9jb2QAU3RyaW5nIHRvbyBiaWcgdG8gY29udmVydCB0byBpbnRlZ2VyCgBJbmZpbml0eQAtSW5maW5pdHkAU3RyaW5nIHRvbyBiaWcgdG8gY29udmVydCB0byBmbG9hdAoARXhwZWN0aW5nIGEgc3RyaW5nIG9yIGFycmF5LCBnb3QgJXQARXhwZWN0aW5nIGEgc3RyaW5nLCBnb3QgJXQAQVNDSUkgb25seQoASW52YWxpZCBVUkkKAGxvYWQAIAAKAP9zY28AZnVuY3Rpb24gAC5yZXBsYWNlV2l0aCgAKTsARWRpdCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIG5hbWUgb2YgYSBmdW5jdGlvbgBFZGl0IHNob3VsZCBiZSBjYWxsZWQgd2l0aCBlZGl0KGZ1bmNOYW1lKSBvciBlZGl0KCdmdW5jTmFtZScpAC0ARnVuY3Rpb24gb3IgU3RyaW5nIG5vdCBzdXBwbGllZCEASW50ZXJ2YWwgaXMgdG9vIGxvbmcgKD4xMDAgeWVhcnMpAHRpbWUAaW50ZXJ2YWwAY2FsbGJhY2sAYXJncwB3YXRjaABUaW1lb3V0AEludGVydmFsAGNsZWFyJXModW5kZWZpbmVkKSBub3QgYWxsb3dlZC4gVXNlIGNsZWFyJXMoKSBpbnN0ZWFkLgBVbmtub3duIEludGVydmFsAGZyZXEAZm9yY2VTb2Z0AHNvZnQAUHVsc2UgVGltZSBnaXZlbiBmb3IgZGlnaXRhbFB1bHNlIGlzIGxlc3MgdGhhbiAwLCBvciBub3QgYSBudW1iZXIARXhwZWN0aW5nIGEgbnVtYmVyIG9yIGFycmF5LCBnb3QgJXQAd3JpdGUASW52YWxpZCBwaW4hAHJlYWQASW52YWxpZCBwaW4AYW5hbG9nAGlucHV0AGlucHV0X3B1bGx1cABpbnB1dF9wdWxsZG93bgBvdXRwdXQAb3BlbmRyYWluAG9wZW5kcmFpbl9wdWxsdXAAYWZfb3V0cHV0AGFmX29wZW5kcmFpbgBhdXRvAFVua25vd24gcGluIG1vZGUAY2xrAGNsa1BvbAByZXBlYXQAVG9vIG1hbnkgcGlucyEgJWQgTWF4aW11bS4AVW5hYmxlIHRvIHNldCB3YXRjaC4gWW91IG1heSBhbHJlYWR5IGhhdmUgYSB3YXRjaCBvbiBhIHBpbiB3aXRoIHRoZSBzYW1lIG51bWJlciAoZWcuIEEwIGFuZCBCMCksCm9yIHRoaXMgcGluIGNhbm5vdCBiZSB1c2VkIHdpdGggd2F0Y2gAZGVib3VuY2UAZWRnZQByaXNpbmcAZmFsbGluZwBib3RoACdlZGdlJyBpbiBzZXRXYXRjaCBzaG91bGQgYmUgMSwgLTEsIDAsICdyaXNpbmcnLCAnZmFsbGluZycgb3IgJ2JvdGgnAGlycQBkYXRhAEZ1bmN0aW9uIG9yIFN0cmluZyBub3Qgc3VwcGxpZWQhAHBpbgByZWN1cgBjYWxsYmFjawBzdGF0ZQBDYW4ndCBoYXZlIGEgZGF0YSBwaW4gYW5kIGlycTp0cnVlAGlycT10cnVlIHNldCwgYnV0IGZ1bmN0aW9uIGlzIG5vdCBhIG5hdGl2ZSBmdW5jdGlvbgBpcnE9dHJ1ZSBzZXQsIGJ1dCB3YXRjaCBpcyBhbHJlYWR5IHVzZWQAY2xlYXJXYXRjaCh1bmRlZmluZWQpIG5vdCBhbGxvd2VkLiBVc2UgY2xlYXJXYXRjaCgpIGluc3RlYWQuAFVua25vd24gV2F0Y2ggJXYAIC4uLiAARXhwZWN0aW5nIGEgdmFsaWQgdmFsdWUsIGdvdCAlcwAoACwAJXYA/2NvZAApIAB7IFtuYXRpdmUgY29kZV0gfQB7JXN9AHsKICAAewByZXR1cm4gAAp9AH0Ae30ACgAgIAB1bmRlZmluZWQAWyAAWwAsIABudWxsACBdAF0AbmV3ICVzKCVkKQBBcnJheUJ1ZmZlcgBVaW50OEFycmF5AG5ldyAlcyhbAF0pAC5idWZmZXIAJXMAX19wcm90b19fAGNvbnN0cnVjdG9yACV2OiAAdG9TdHJpbmcAdG9KU09OAHsgACB9AGZ1bmN0aW9uIAAlcSVzJXEAJVEAJXEAJVElcwAlcSVzACV2JXMAOiAAOgBFeHBlY3RpbmcgYSBtb2R1bGUgbmFtZSBhcyBhIHN0cmluZywgYnV0IGdvdCAldABNb2R1bGUgbmFtZSB0b28gbG9uZyAobWF4IDEyOCBjaGFycykATW9kdWxlICVzIG5vdCBmb3VuZABUaGUgYXJndW1lbnQgdG8gcmVtb3ZlQ2FjaGVkIG11c3QgYmUgYSBzdHJpbmcATW9kdWxlICVxIG5vdCBmb3VuZABhcmdzIG11c3QgYmUgYWRkQ2FjaGVkKHN0cmluZywgc3RyaW5nfGZ1bmN0aW9uKQBVbmFibGUgdG8gbG9hZCBtb2R1bGUgJXEAbW9kdWxlcwBwb3J0AG51bQBBRENzAGNoYW5uZWwAdHlwZQBhZgBmdW5jdGlvbnMASW52YWxpZCB0eXBlICV0IGZvciB2YWx1ZU9mAGNvbnN0cnVjdG9yAF9fcHJvdG9fXwBsZW5ndGgAT2JqZWN0IHByb3RvdHlwZSBtYXkgb25seSBiZSBhbiBPYmplY3Qgb3IgbnVsbDogJXQAcHJvcGVydGllc09iamVjdCBpcyBub3Qgc3VwcG9ydGVkIHlldAB3cml0YWJsZQBlbnVtZXJhYmxlAGNvbmZpZ3VyYWJsZQBnZXQAc2V0AHZhbHVlAEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0LCBnb3QgJXQAUHJvcGVydHkgZGVzY3JpcHRpb24gbXVzdCBiZSBhbiBvYmplY3QsIGdvdCAldABGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdCwgZ290ICV0CgBTZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QsIGdvdCAldAoAQ2FuJ3QgZXh0ZW5kICV0CgBFeHBlY3RpbmcgT2JqZWN0LCBnb3QgJXQKAFBhcmVudCBtdXN0IGJlIGFuIG9iamVjdCAtIG5vdCBhIFN0cmluZywgSW50ZWdlciwgZXRjLgBGaXJzdCBhcmd1bWVudCB0byBFdmVudEVtaXR0ZXIub24oLi4pIG11c3QgYmUgYSBzdHJpbmcAU2Vjb25kIGFyZ3VtZW50IHRvIEV2ZW50RW1pdHRlci5vbiguLikgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGEgU3RyaW5nIChjb250YWluaW5nIGNvZGUpACNvbiV2AGRhdGEA/2J1ZgAjb25kYXRhAEZpcnN0IGFyZ3VtZW50IHRvIEV2ZW50RW1pdHRlci5lbWl0KC4uKSBtdXN0IGJlIGEgc3RyaW5nAFRvbyBtYW55IGFyZ3VtZW50cyAoPiVkKQBGaXJzdCBhcmd1bWVudCB0byBFdmVudEVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoLi4pIG11c3QgYmUgYSBzdHJpbmcAI29uAEZpcnN0IGFyZ3VtZW50IHRvIEV2ZW50RW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoLi4pIG11c3QgYmUgYSBzdHJpbmcsIG9yIHVuZGVmaW5lZABBcmd1bWVudCBzaG91bGQgYmUgYSBmdW5jdGlvbgD/c2NvAHByb3RvdHlwZQBBcnJheSBwYXNzZWQgdG8gRnVuY3Rpb24uYXBwbHkgaXMgdG9vIGJpZyEgTWF4aW11bSAyNTYgYXJndW1lbnRzLCBnb3QgJWQAU2Vjb25kIGFyZ3VtZW50IHRvIEZ1bmN0aW9uLmFwcGx5IG11c3QgYmUgaXRlcmFibGUsIGdvdCAldABGdW5jdGlvbi5iaW5kIGV4cGVjdHMgdG8gYmUgY2FsbGVkIG9uIGZ1bmN0aW9uLCBnb3QgJXQA/3RocwBPbmVXaXJlAHBpbgBJbnZhbGlkIE9uZVdpcmUgZGV2aWNlIGFkZHJlc3MgJXEAUGlwZQByZWFkAHdyaXRlAGNvbXBsZXRlACNvbmNvbXBsZXRlAGVuZABjaHVua1NpemUAY2h1bmtTaXplIG11c3QgYmUgYW4gaW50ZWdlciA+IDAAJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LCBvciB1bmRlZmluZWQAY2xvc2UAZHJhaW4AcG9zaXRpb24Ac291cmNlAGRlc3RpbmF0aW9uAERlc3RpbmF0aW9uIG9iamVjdCBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIHJlcXVpcmVkIHdyaXRlKGJ1ZmZlciwgbGVuZ3RoLCBwb3NpdGlvbikgbWV0aG9kLgBTb3VyY2Ugb2JqZWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgcmVxdWlyZWQgcmVhZChidWZmZXIsIGxlbmd0aCwgcG9zaXRpb24pIG1ldGhvZC4AcGlwZXMAZHJhaW5XYWl0AFNvdXJjZSBTdHJlYW0gZG9lcyBub3QgaW1wbGVtZW50IHRoZSByZXF1aXJlZCByZWFkKGxlbmd0aCkgbWV0aG9kLgBEZXN0aW5hdGlvbiBTdHJlYW0gZG9lcyBub3QgaW1wbGVtZW50IHRoZSByZXF1aXJlZCB3cml0ZShidWZmZXIpIG1ldGhvZC4A/2J1ZgAAAAAAADcCAAA4AgAAOQIAADoCAAA7AgAAPAIAAD0CAAA+AgAAPwIAAEACAABBAgAAQgIAAEMCAABEAgAARQIAAEYCAABHAgAAAAAAAFZFUlNJT04AMnYxMQBHSVRfQ09NTUlUADUzMTA4MDg1OABCT0FSRABFTVNDUklQVEVOMgBGTEFTSABTUElGTEFTSABIV1ZFUlNJT04AU1RPUkFHRQBSQU0AU0VSSUFMAENPTlNPTEUATU9EVUxFUwBFWFBUUgBoaXN0b3J5AGZyZWUAdXNhZ2UAdG90YWwAZ2MAZ2N0aW1lAGJsb2Nrc2l6ZQD/dGhuAP9jYXQAY2hhaW4A/3RocwByZXNvbHZlZABVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb246ICV2AP9sZWZ0AP9yZXMAUHJvbWlzZQBFeHBlY3Rpbmcgc29tZXRoaW5nIGl0ZXJhYmxlLCBnb3QgJXQAdGhlbgBDYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24sIGdvdCAldABVbmZpbmlzaGVkIGNoYXJhY3RlciBzZXQgaW4gUmVnRXgAQmFja3JlZmVyZW5jZXMgbm90IHN1cHBvcnRlZABFeHBlY3RpbmcgU3RyaW5nIGFzIGZpcnN0IGFyZ3VtZW50LCBnb3QgJXQAUmVnRXhwAHNvdXJjZQBmbGFncwBsYXN0SW5kZXgAaW5kZXgAaW5wdXQAU2VyaWFsAHNldENvbnNvbGUgY2FuJ3QgYmUgdXNlZCBvbiAnc29mdCcgZGV2aWNlcwBfb3B0aW9ucwBfYmF1ZHJhdGUAU29mdHdhcmUgU2VyaWFsIENLIG5vdCBpbXBsZW1lbnRlZCB5ZXQKAHNmAHIAdwBhAEludmFsaWQgbW9kZSAlagBTdG9yYWdlRmlsZQBuYW1lAGNodW5rAG9mZnNldABhZGRyAGxlbgBtb2RlAENhbid0IHJlYWQgaW4gdGhpcyBtb2RlAENhbid0IHdyaXRlIGluIHRoaXMgbW9kZQBGaWxlIGRlbGV0ZWQgd2hpbGUgd3JpdGluZyEARmlsZSB0b28gYmlnIQBTUEkAX29wdGlvbnMAU1BJLnNlbmQ0Yml0IG9ubHkgd29ya3Mgb24gaGFyZHdhcmUgU1BJAFZhcmlhYmxlIHR5cGUgJXQgbm90IHN1aXRlZCB0byB0cmFuc21pdCBvcGVyYXRpb24AU1BJLnNlbmQ4Yml0IG9ubHkgd29ya3Mgb24gaGFyZHdhcmUgU1BJAEkyQwBOb3QgZW5vdWdoIHN0YWNrIG1lbW9yeSB0byBkZWNvZGUgZGF0YQBzdGFydGVkAE5vdCBlbm91Z2ggZnJlZSBzdGFjayB0byByZWNlaXZlIHRoaXMgYW1vdW50IG9mIGRhdGEAc3RvcABhZGRyZXNzAP9idWYAI29uZGF0YQBFcnJvciBwcm9jZXNzaW5nIFNlcmlhbCBkYXRhIGhhbmRsZXIgLSByZW1vdmluZyBpdC4AUmVnRXhwAGxhc3RJbmRleABpbmRleABpbnB1dABJbnZhbGlkIGNvdW50IHZhbHVlACAAd2F2ZQBydW5uaW5nAGJ1ZmZlcgAjb25maW5pc2gAY3VycmVudEJ1ZmZlcgBidWZmZXIyACNvbmJ1ZmZlcgBXYXZlZm9ybSBjb3VsZG4ndCBiZSBzdG9wcGVkAFNhbXBsZXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMABkb3VibGVCdWZmZXIAYml0cwBJbnZhbGlkIG51bWJlciBvZiBiaXRzAEV4cGVjdGluZyBvcHRpb25zIHRvIGJlIHVuZGVmaW5lZCBvciBhbiBPYmplY3QsIG5vdCAldABXYXZlZm9ybQBXYXZlZm9ybSBpcyBub3QgcnVubmluZwBXYXZlZm9ybSBpcyBhbHJlYWR5IHJ1bm5pbmcASW52YWxpZCBwaW4ARnJlcXVlbmN5IG11c3QgYmUgYWJvdmUgMC4wMDFIegB0aW1lAHJlcGVhdABVbmFibGUgdG8gc2NoZWR1bGUgYSB0aW1lcgBmcmVxAEV4cGVjdGluZyBzb21ldGhpbmcgaXRlcmFibGUsIGdvdCAldABOb3QgZW5vdWdoIG1lbW9yeSBmb3IgcmVzdWx0");
writeSegment(126498, "HwDgB/8HAPgf+OD///8=");
writeSegment(126530, "KEJRjNe9JpuAYSADQAXfBBkAEzAT+ADYIPvg////AAAGAAwAEwAZAB8AgAGGAYwBkwGZAZ8BIAMmAywDMwM5Az8DwATGBMwE0wTZBN8EYAZmBmwGcwZ5Bn8G4AfmB+wH8wf5B/8HADAGMAwwEzAZMB8wgDGGMYwxkzGZMZ8xIDMmMywzMzM5Mz8zwDTGNMw00zTZNN80YDZmNmw2czZ5Nn824DfmN+w38zf5N/83AGAGYAxgE2AZYB9ggGGGYYxhk2GZYZ9hIGMmYyxjM2M5Yz9jwGTGZMxk02TZZN9kYGZmZmxmc2Z5Zn9m4GfmZ+xn82f5Z/9nAJgGmAyYE5gZmB+YgJmGmYyZk5mZmZ+ZIJsmmyybM5s5mz+bwJzGnMyc05zZnN+cYJ5mnmyec555nn+e4J/mn+yf85/5n/+fAMgGyAzIE8gZyB/IgMmGyYzJk8mZyZ/JIMsmyyzLM8s5yz/LwMzGzMzM08zZzN/MYM5mzmzOc855zn/O4M/mz+zP88/5z//PAPgG+Az4E/gZ+B/4gPmG+Yz5k/mZ+Z/5IPsm+yz7M/s5+z/7wPzG/Mz80/zZ/N/8YP5m/mz+c/55/n/+4P/m/+z/8//5////");
writeSegment(127070, "//8AACsAgQCsAHkATgAMABIAFwAEACcAtwCQAMAA0gDXAGdmeABJbnZhbGlkIFNpemUASW52YWxpZCBCUFAAR3JhcGhpY3MAemlnemFnAG1zYgBpbnRlcmxlYXZleAB2ZXJ0aWNhbF9ieXRlAHZlcnRpY2FsX2J5dGUgb25seSB3b3JrcyBmb3IgMWJwcCBBcnJheUJ1ZmZlcnMKAGhlaWdodCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgOCB3aGVuIHVzaW5nIHZlcnRpY2FsX2J5dGUKAGNvbG9yX29yZGVyAHJnYgBicmcAYmdyAGdicgBncmIAcmJnAGNvbG9yX29yZGVyIG11c3QgYmUgMyBjaGFyYWN0ZXJzAHNldFBpeGVsAGZpbGxSZWN0AEV4cGVjdGluZyBDYWxsYmFjayBGdW5jdGlvbiBvciBhbiBPYmplY3QgYnV0IGdvdCAldABFeHBlY3RpbmcgYSBTdHJpbmcAd2lkdGgAaGVpZ2h0AGJ1ZmZlcgB4AHkAeDEAeTEAeDIAeTIAdwBoAElmIENvbG9yIGlzIGEgU3RyaW5nLCBpdCBtdXN0IGJlIG9mIHRoZSBmb3JtICcjcnJnZ2JiJyBvciAnI3JnYicA/2ZuQgD/Zm5XAP9mbkgA/2ZuMQBGb250IGJpdG1hcCBtdXN0IGJlIGEgU3RyaW5nAEZpcnN0IGNoYXJhY3RlciBvdXQgb2YgcmFuZ2UARm9udCB3aWR0aCBtdXN0IGJlIGEgU3RyaW5nIG9yIGFuIGludGVnZXIASW52YWxpZCBCUFAgLSAxLDIsNCBzdXBwb3J0ZWQAVmVjdG9yADR4NgA2eDgAc2V0Rm9udCV2AFVua25vd24gZm9udCAlagBDdXN0b20AJXM6JWR4JWQAJXM6JWQAc2V0Rm9udABzZXRGb250Qml0bWFwAHNldEZvbnRBbGlnbgBzZXRGb250Q3VzdG9tACAATWF4aW11bSBudW1iZXIgb2YgcG9pbnRzICglZCkgZXhjZWVkZWQgZm9yIGZpbGxQb2x5AGJwcAB0cmFuc3BhcmVudABmcmFtZXMAZnJhbWUAc2NhbGUAcm90YXRlAEV4cGVjdGluZyBhcnJheSBmb3IgZmlyc3QgYXJndW1lbnQgd2l0aCA8JWQgZW50cmllcwBpbWFnZQBjZW50ZXIAcmVwZWF0AG5vYm91bmRzAG9iamVjdABzdHJpbmcAVW5rbm93biBpbWFnZSB0eXBlICVqAHNldE1vZGlmaWVkAEludmFsaWQgb3B0aW9ucwBkYXRhOmltYWdlL2JtcDtiYXNlNjQsJXYACgBjb3VudABFeHBlY3RlZCBlaXRoZXIgYW4gb2JqZWN0IG9yIGFuIGFycmF5IHdpdGggNiBlbnRyaWVzIGZvciBzZWNvbmQgYXJndW1lbnQAZmcAYmcAZmcyAGJnMgBmZ0gAYmdIAGRhcmsAcGFsZXR0ZQBQYWxldHRlIHNwZWNpZmllZCwgYnV0IG11c3QgYmUgYSBmbGF0IFVpbnQxNkFycmF5IG9mIDIsNCw4LDE2LDI1NiBlbGVtZW50cwBVbmFibGUgdG8gZ2V0IHBvaW50ZXIgdG8gcGFsZXR0ZS4gSW1hZ2UgaW4gZmxhc2g/AEV4cGVjdGluZyBmaXJzdCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3Qgb3IgYSBTdHJpbmcARXhwZWN0aW5nIGZpcnN0IGFyZ3VtZW50IHRvIGEgdmFsaWQgSW1hZ2UAZmxpcABOb3QgZW5vdWdoIHN0YWNrIG1lbW9yeSB0byBkZWNvZGUgZGF0YQBOb3QgZW5vdWdoIG1lbW9yeSBmb3IgcmVzdWx0AG1pAFRGTWljcm9JbnRlcnByZXRlciBzdHJ1Y3R1cmUgY29ycnVwdGVkAEludmFsaWQgQXJlbmEgU2l6ZQBNb2RlbCBpcyBub3QgYSBGbGF0IFN0cmluZy9BcnJheUJ1ZmZlcgBURk1pY3JvSW50ZXJwcmV0ZXIAVW5hYmxlIHRvIGFsbG9jYXRlIGVub3VnaCBSQU0gZm9yIFRlbnNvckZsb3cAbW9kZWwATWljcm9JbnRlcnByZXRlciBjcmVhdGlvbiBmYWlsZWQAVW5hYmxlIHRvIGdldCB0ZW5zb3IAVW5zdXBwb3J0ZWQgVGVuc29yIGZvcm1hdCBUZkxpdGVUeXBlOiVkAFRGTWljcm9JbnRlcnByZXRlciBpbnZva2UgZmFpbGVk");
writeSegment(128792, "VgIAAFcCAABYAgAAWQIAAFoCAABbAgAASW50ZXJuYWwgZXJyb3I6IEVuc3VyZUhlYWRTaXplKCkgbmVlZHMgdG8gYmUgY2FsbGVkIGFmdGVyUmVzZXRUZW1wQWxsb2NhdGlvbnMoKS4ARmFpbGVkIHRvIGFkanVzdCBoZWFkIHNpemUuIFJlcXVlc3RlZDogJXUsIGF2YWlsYWJsZSAldSwgbWlzc2luZzogJXUARmFpbGVkIHRvIGFsbG9jYXRlIHRhaWwgbWVtb3J5LiBSZXF1ZXN0ZWQ6ICV1LCBhdmFpbGFibGUgJXUsIG1pc3Npbmc6ICV1AEZhaWxlZCB0byBhbGxvY2F0ZSB0ZW1wIG1lbW9yeS4gUmVxdWVzdGVkOiAldSwgYXZhaWxhYmxlICV1LCBtaXNzaW5nOiAldQBPbmx5IDEgc3ViZ3JhcGggaXMgY3VycmVudGx5IHN1cHBvcnRlZC4KAEZhaWxlZCBzdGFydGluZyBtb2RlbCBhbGxvY2F0aW9uLgoATm9kZSAlcyAobnVtYmVyICVkZikgZmFpbGVkIHRvIHByZXBhcmUgd2l0aCBzdGF0dXMgJWQASW52b2tlKCkgY2FsbGVkIGFmdGVyIGluaXRpYWxpemF0aW9uIGZhaWxlZAoATm9kZSAlcyAobnVtYmVyICVkKSBmYWlsZWQgdG8gaW52b2tlIHdpdGggc3RhdHVzICVkAElucHV0IGluZGV4ICVkIG91dCBvZiByYW5nZSAobGVuZ3RoIGlzICVkKQBJbnB1dCB0ZW5zb3JzIG5vdCBhdCBpbmRleCAwIGFyZSBhbGxvY2F0ZWQgZnJvbSB0aGUgcGVyc2lzdGVudCBtZW1vcnkgYXJlbmEuIFJlcGVhdCBjYWxscyB3aWxsIGNhdXNlIGV4Y2VzcyBhbGxvY2F0aW9uIQBPdXRwdXQgaW5kZXggJWQgb3V0IG9mIHJhbmdlIChsZW5ndGggaXMgJWQpAE91dHB1dCB0ZW5zb3JzIG5vdCBhdCBpbmRleCAwIGFyZSBhbGxvY2F0ZWQgZnJvbSB0aGUgcGVyc2lzdGVudCBtZW1vcnkgYXJlbmEuIFJlcGVhdCBjYWxscyB3aWxsIGNhdXNlIGV4Y2VzcyBhbGxvY2F0aW9uIQ==");
writeSegment(129680, "kPwBAJT8AQCk/AEAsvwBALr8AQDM/AEA2/wBAOb8AQD3/AEA/fwBAA39AQAe/QEAL/0BADr9AQBX/QEAYP0BAG/9AQB0/QEAgP0BAIT9AQCJ/QEAlv0BAJz9AQCk/QEAtP0BALj9AQDA/QEAz/0BANT9AQDZ/QEA6/0BAPX9AQD6/QEAAf4BABn+AQAd/gEAOf4BAED+AQBS/gEAZP4BAG7+AQBz/gEAd/4BAHv+AQCD/gEAoP4BAK7+AQDJ/gEAzf4BANX+AQDb/gEA5/4BAPD+AQAM/wEAEf8BABf/AQAf/wEAJ/8BAC//AQA0/wEAOP8BAD7/AQBG/wEAVP8BAF//AQBm/wEAbP8BAHD/AQB//wEAj/8BAJT/AQCg/wEApv8BALD/AQC0/wEAuP8BAL3/AQDD/wEAyf8BAM3/AQDV/wEA4P8BAOz/AQD3/wEA/P8BAAcAAgAPAAIAGwACACcAAgAuAAIAOQACAEMAAgBOAAIAVQACAGAAAgBlAAIAbwACAHUAAgCNAAIAmAACAKsAAgC2AAIAugACAMIAAgDJAAIAzgACANkAAgDfAAIA6QACAO0AAgDzAAIA+AACAPwAAgANAQIAGQECACIBAgAyAQIAOAECAEMBAgBGAQIATAECAGMBAgB6AQIAhQECAI8BAgCXAQIAowECAAAAAABBREQAQVZFUkFHRV9QT09MXzJEAENPTkNBVEVOQVRJT04AQ09OVl8yRABERVBUSFdJU0VfQ09OVl8yRABERVBUSF9UT19TUEFDRQBERVFVQU5USVpFAEVNQkVERElOR19MT09LVVAARkxPT1IARlVMTFlfQ09OTkVDVEVEAEhBU0hUQUJMRV9MT09LVVAATDJfTk9STUFMSVpBVElPTgBMMl9QT09MXzJEAExPQ0FMX1JFU1BPTlNFX05PUk1BTElaQVRJT04ATE9HSVNUSUMATFNIX1BST0pFQ1RJT04ATFNUTQBNQVhfUE9PTF8yRABNVUwAUkVMVQBSRUxVX04xX1RPXzEAUkVMVTYAUkVTSEFQRQBSRVNJWkVfQklMSU5FQVIAUk5OAFNPRlRNQVgAU1BBQ0VfVE9fREVQVEgAU1ZERgBUQU5IAENPTkNBVF9FTUJFRERJTkdTAFNLSVBfR1JBTQBDQUxMAENVU1RPTQBFTUJFRERJTkdfTE9PS1VQX1NQQVJTRQBQQUQAVU5JRElSRUNUSU9OQUxfU0VRVUVOQ0VfUk5OAEdBVEhFUgBCQVRDSF9UT19TUEFDRV9ORABTUEFDRV9UT19CQVRDSF9ORABUUkFOU1BPU0UATUVBTgBTVUIARElWAFNRVUVFWkUAVU5JRElSRUNUSU9OQUxfU0VRVUVOQ0VfTFNUTQBTVFJJREVEX1NMSUNFAEJJRElSRUNUSU9OQUxfU0VRVUVOQ0VfUk5OAEVYUABUT1BLX1YyAFNQTElUAExPR19TT0ZUTUFYAERFTEVHQVRFAEJJRElSRUNUSU9OQUxfU0VRVUVOQ0VfTFNUTQBDQVNUAFBSRUxVAE1BWElNVU0AQVJHX01BWABNSU5JTVVNAExFU1MATkVHAFBBRFYyAEdSRUFURVIAR1JFQVRFUl9FUVVBTABMRVNTX0VRVUFMAFNFTEVDVABTTElDRQBTSU4AVFJBTlNQT1NFX0NPTlYAU1BBUlNFX1RPX0RFTlNFAFRJTEUARVhQQU5EX0RJTVMARVFVQUwATk9UX0VRVUFMAExPRwBTVU0AU1FSVABSU1FSVABTSEFQRQBQT1cAQVJHX01JTgBGQUtFX1FVQU5UAFJFRFVDRV9QUk9EAFJFRFVDRV9NQVgAUEFDSwBMT0dJQ0FMX09SAE9ORV9IT1QATE9HSUNBTF9BTkQATE9HSUNBTF9OT1QAVU5QQUNLAFJFRFVDRV9NSU4ARkxPT1JfRElWAFJFRFVDRV9BTlkAU1FVQVJFAFpFUk9TX0xJS0UARklMTABGTE9PUl9NT0QAUkFOR0UAUkVTSVpFX05FQVJFU1RfTkVJR0hCT1IATEVBS1lfUkVMVQBTUVVBUkVEX0RJRkZFUkVOQ0UATUlSUk9SX1BBRABBQlMAU1BMSVRfVgBVTklRVUUAQ0VJTABSRVZFUlNFX1YyAEFERF9OAEdBVEhFUl9ORABDT1MAV0hFUkUAUkFOSwBFTFUAUkVWRVJTRV9TRVFVRU5DRQBNQVRSSVhfRElBRwBRVUFOVElaRQBNQVRSSVhfU0VUX0RJQUcAUk9VTkQASEFSRF9TV0lTSABJRgBXSElMRQBOT05fTUFYX1NVUFBSRVNTSU9OX1Y0AE5PTl9NQVhfU1VQUFJFU1NJT05fVjUAU0NBVFRFUl9ORABTRUxFQ1RfVjIAREVOU0lGWQBTRUdNRU5UX1NVTQBCQVRDSF9NQVRNVUwAAAAAAFVuYWJsZSB0byBhbGxvY2F0ZSBUZkxpdGVBZmZpbmVRdWFudGl6YXRpb24uCgBVbmFibGUgdG8gYWxsb2NhdGUgcXVhbnRpemF0aW9uLT56ZXJvX3BvaW50Lgo=");
writeSegment(131608, "ZQIAAGYCAABnAgAAYwIAAGgCAABpAgAAagIAAGsCAABsAgAAbQIAAG4CAABvAgAAJWQgYnl0ZXMgbG9zdCBkdWUgdG8gYWxpZ25tZW50LiBUbyBhdm9pZCB0aGlzIGxvc3MsIHBsZWFzZSBtYWtlIHN1cmUgdGhlIHRlbnNvcl9hcmVuYSBpcyAxNiBieXRlcyBhbGlnbmVkLgBNaWNyb0FsbG9jYXRvcjogTW9kZWwgYWxsb2NhdGlvbiBzdGFydGVkIGJlZm9yZSBmaW5pc2hpbmcgcHJldmlvdXNseSBhbGxvY2F0ZWQgbW9kZWwATWljcm9BbGxvY2F0b3I6IE1vZGVsIGFsbG9jYXRpb24gZmluaXNoZWQgYmVmb3JlIHN0YXJ0aW5nIGFsbG9jYXRpbmcgbW9kZWwASW50ZXJuYWwgZXJyb3I6IEFsbG9jYXRlRnJvbVRhaWwgY2FuIG5vdCBiZSBjYWxsZWQgYmV0d2VlbiB0d28gUmVxdWVzdFNjcmF0Y2hCdWZmZXJJbkFyZW5hIGNhbGxzLgBGYWlsZWQgdG8gcmVnaXN0ZXIgc2NyYXRjaCBidWZmZXIgaGFuZGxlIGZvciBub2RlICVzAEJ1ZmZlciAlZCBub3QgZm91bmQuICVkIGJ1ZmZlcnMgYXZhaWxhYmxlLgBGYWlsZWQgdG8gYWxsb2NhdGUgbWVtb3J5IGZvciBub2RlX2FuZF9yZWdpc3RyYXRpb25zLgBNaXNzaW5nIHJlZ2lzdHJhdGlvbiBmb3Igb3Bjb2RlX2luZGV4ICVkCgBGYWlsZWQgdG8gZ2V0IHJlZ2lzdHJhdGlvbiBmcm9tIG9wIGNvZGUgJXMKIABTa2lwcGluZyBvcCBmb3Igb3Bjb2RlX2luZGV4ICVkCgBVbnN1cHBvcnRlZCBiZWhhdmlvcjogZm91bmQgYnVpbHRpbiBvcGVyYXRvciAlcyB3aXRoIGN1c3RvbSBvcHRpb25zLgoARGlkIG5vdCBmaW5kIGEgcGFyc2VyIGZvciAlcwBGYWlsZWQgdG8gcG9wdWxhdGUgYSBwZXJzaXN0ZW50IFRmTGl0ZVRlbnNvciBzdHJ1Y3QgZnJvbSBmbGF0YnVmZmVyIGRhdGEhAEZhaWxlZCB0byBwb3B1bGF0ZSBhIHRlbXAgVGZMaXRlVGVuc29yIHN0cnVjdCBmcm9tIGZsYXRidWZmZXIgZGF0YSEARmFpbGVkIHRvIGFsbG9jYXRlIG1lbW9yeSBmb3IgY29udGV4dC0+ZXZhbF90ZW5zb3JzLCAlZCBieXRlcyByZXF1aXJlZABGYWlsZWQgdG8gaW5pdGlhbGl6ZSB0ZW5zb3IgJWQARmFpbGVkIHRvIGFsbG9jYXRlIHZhcmlhYmxlIHRlbnNvciBvZiBzaXplICVkAE9ubHkgMSBzdWJncmFwaCBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLgoAJXM6JWQgJXMgd2FzIG5vdCB0cnVlLgAvaG9tZS9ndy93b3Jrc3BhY2UvRXNwcnVpbm8vbGlicy90ZW5zb3JmbG93L3RlbnNvcmZsb3cvbGl0ZS9taWNyby9taWNyb19hbGxvY2F0b3IuY2MAcGxhbm5lcl9hcmVuYSAhPSBudWxscHRyAEFyZW5hIHNpemUgaXMgdG9vIHNtYWxsIGZvciBhY3RpdmF0aW9uIGJ1ZmZlcnMuIE5lZWRlZCAlZCBidXQgb25seSAlZCB3YXMgYXZhaWxhYmxlLg==");
writeSegment(132948, "cAIAAHECAAByAgAAcwI=");
writeSegment(132972, "dAIAAHQCAAB1AgAAdgIAAEZhaWxlZCB0byBhbGxvY2F0ZSBtZW1vcnkgZm9yIGFsbG9jYXRpb25faW5mbywgJWQgYnl0ZXMgcmVxdWlyZWQAAAAAT2ZmbGluZU1lbW9yeUFsbG9jYXRpb24ATmJyIG9mIG9mZmxpbmUgYnVmZmVyIG9mZnNldHMgKCVkKSBpbiBtZXRhZGF0YSBub3QgZXF1YWwgbmJyIHRlbnNvcnMgKCVkKQoATG9naWMgZXJyb3IgaW4gbWVtb3J5IHBsYW5uZXIsIHRlbnNvciAlZCBoYXMgYW4gaW52YWxpZCBsaWZldGltZTogZmlyc3RfY3JlYXRlZDogJWQsIGxhc3RfdXNlZDogJWQAJXM6JWQgJXMgIT0gJXMgKCVkICE9ICVkKQAvaG9tZS9ndy93b3Jrc3BhY2UvRXNwcnVpbm8vbGlicy90ZW5zb3JmbG93L3RlbnNvcmZsb3cvbGl0ZS9taWNyby9rZXJuZWxzL2RlcHRod2lzZV9jb252LmNjAGZpbHRlci0+cXVhbnRpemF0aW9uLnR5cGUAa1RmTGl0ZUFmZmluZVF1YW50aXphdGlvbgAlczolZCAlcyB3YXMgbm90IHRydWUuAGFmZmluZV9xdWFudGl6YXRpb24AYWZmaW5lX3F1YW50aXphdGlvbi0+c2NhbGUAYWZmaW5lX3F1YW50aXphdGlvbi0+emVyb19wb2ludABhZmZpbmVfcXVhbnRpemF0aW9uLT5zY2FsZS0+c2l6ZSA9PSAxIHx8IGFmZmluZV9xdWFudGl6YXRpb24tPnNjYWxlLT5zaXplID09IGZpbHRlci0+ZGltcy0+ZGF0YVtrRGVwdGh3aXNlQ29udlF1YW50aXplZERpbWVuc2lvbl0AYWZmaW5lX3F1YW50aXphdGlvbi0+c2NhbGUtPnNpemUAYWZmaW5lX3F1YW50aXphdGlvbi0+emVyb19wb2ludC0+c2l6ZQBUeXBlICVzICglZCkgbm90IHN1cHBvcnRlZC4AaGFzX2JpYXMgfHwgbm9kZS0+aW5wdXRzLT5zaXplID09IDIAbm9kZS0+b3V0cHV0cy0+c2l6ZQAxACVzOiVkICVzIHdhcyBub3QgdHJ1ZS4AL2hvbWUvZ3cvd29ya3NwYWNlL0VzcHJ1aW5vL2xpYnMvdGVuc29yZmxvdy90ZW5zb3JmbG93L2xpdGUvbWljcm8va2VybmVscy9jb252LmNjAGhhc19iaWFzIHx8IG5vZGUtPmlucHV0cy0+c2l6ZSA9PSAyACVzOiVkICVzICE9ICVzICglZCAhPSAlZCkAbm9kZS0+b3V0cHV0cy0+c2l6ZQAxAGZpbHRlci0+cXVhbnRpemF0aW9uLnR5cGUAa1RmTGl0ZUFmZmluZVF1YW50aXphdGlvbgBhZmZpbmVfcXVhbnRpemF0aW9uAGFmZmluZV9xdWFudGl6YXRpb24tPnNjYWxlAGFmZmluZV9xdWFudGl6YXRpb24tPnplcm9fcG9pbnQAYWZmaW5lX3F1YW50aXphdGlvbi0+c2NhbGUtPnNpemUgPT0gMSB8fCBhZmZpbmVfcXVhbnRpemF0aW9uLT5zY2FsZS0+c2l6ZSA9PSBmaWx0ZXItPmRpbXMtPmRhdGFba0NvbnZRdWFudGl6ZWREaW1lbnNpb25dAGFmZmluZV9xdWFudGl6YXRpb24tPnNjYWxlLT5zaXplAGFmZmluZV9xdWFudGl6YXRpb24tPnplcm9fcG9pbnQtPnNpemUAVHlwZSAlcyAoJWQpIG5vdCBzdXBwb3J0ZWQuAElucHV0IHR5cGUgJXMgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQAVHlwZSAlcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZC4AJXM6JWQgJXMgIT0gJXMgKCVkICE9ICVkKQAvaG9tZS9ndy93b3Jrc3BhY2UvRXNwcnVpbm8vbGlicy90ZW5zb3JmbG93L3RlbnNvcmZsb3cvbGl0ZS9taWNyby9rZXJuZWxzL3NvZnRtYXguY2MATnVtSW5wdXRzKG5vZGUpADEATnVtT3V0cHV0cyhub2RlKQAlczolZCAlcyB3YXMgbm90IHRydWUuAE51bURpbWVuc2lvbnMoaW5wdXQpID49IDEAVHlwZSAlcyAoJWQpIG5vdCBzdXBwb3J0ZWQuACVzOiVkICVzICE9ICVzICglcyAhPSAlcykAb3V0cHV0LT50eXBlAGtUZkxpdGVVSW50OABvdXRwdXQtPnBhcmFtcy56ZXJvX3BvaW50ADAAaW5wdXQtPnR5cGUAa1RmTGl0ZUludDgALTMyNzY4AC0xMjgAb3V0cHV0LT5wYXJhbXMuc2NhbGUgPT0gMS5mIC8gMjU2AGtUZkxpdGVGbG9hdDMyACVzOiVkICVzICE9ICVzICglcyAhPSAlcykAL2hvbWUvZ3cvd29ya3NwYWNlL0VzcHJ1aW5vL2xpYnMvdGVuc29yZmxvdy90ZW5zb3JmbG93L2xpdGUvbWljcm8va2VybmVscy9mdWxseV9jb25uZWN0ZWQuY2MAaW5wdXQtPnR5cGUAb3V0cHV0LT50eXBlAC9ob21lL2d3L3dvcmtzcGFjZS9Fc3BydWluby9saWJzL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9saXRlL21pY3JvL2tlcm5lbHMvZnVsbHlfY29ubmVjdGVkLmNjIEh5YnJpZCBtb2RlbHMgYXJlIG5vdCBzdXBwb3J0ZWQgb24gVEZMaXRlIE1pY3JvLgBUeXBlICVzICglZCkgbm90IHN1cHBvcnRlZC4AJXM6JWQgJXMgIT0gJXMgKCVkICE9ICVkKQAvaG9tZS9ndy93b3Jrc3BhY2UvRXNwcnVpbm8vbGlicy90ZW5zb3JmbG93L3RlbnNvcmZsb3cvbGl0ZS9taWNyby9rZXJuZWxzL3F1YW50aXplLmNjAE51bUlucHV0cyhub2RlKQAxAE51bU91dHB1dHMobm9kZSkAb3V0cHV0LT5xdWFudGl6YXRpb24udHlwZQBrVGZMaXRlQWZmaW5lUXVhbnRpemF0aW9uACVzOiVkICVzIHdhcyBub3QgdHJ1ZS4AYWZmaW5lX3F1YW50aXphdGlvbgBhZmZpbmVfcXVhbnRpemF0aW9uLT5zY2FsZQBhZmZpbmVfcXVhbnRpemF0aW9uLT5zY2FsZS0+c2l6ZSA9PSAxAGlucHV0LT50eXBlID09IGtUZkxpdGVGbG9hdDMyIHx8IGlucHV0LT50eXBlID09IGtUZkxpdGVJbnQxNiB8fCBpbnB1dC0+dHlwZSA9PSBrVGZMaXRlSW50OABvdXRwdXQtPnR5cGUgPT0ga1RmTGl0ZVVJbnQ4IHx8IG91dHB1dC0+dHlwZSA9PSBrVGZMaXRlSW50OCB8fCBvdXRwdXQtPnR5cGUgPT0ga1RmTGl0ZUludDE2AElucHV0ICVzLCBvdXRwdXQgJXMgbm90IHN1cHBvcnRlZC4AAACA////fwAAAAAAAAD/AAAAAID///9/AABSZXF1YW50aXplAACA////fwAAAACA////fwAAgP///38AAAAlczolZCAlcyAhPSAlcyAoJWQgIT0gJWQpAC9ob21lL2d3L3dvcmtzcGFjZS9Fc3BydWluby9saWJzL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9saXRlL21pY3JvL2tlcm5lbHMvZGVxdWFudGl6ZS5jYwBOdW1JbnB1dHMobm9kZSkAMQBOdW1PdXRwdXRzKG5vZGUpACVzOiVkICVzIHdhcyBub3QgdHJ1ZS4AaW5wdXQtPnR5cGUgPT0ga1RmTGl0ZVVJbnQ4IHx8IGlucHV0LT50eXBlID09IGtUZkxpdGVJbnQ4IHx8IGlucHV0LT50eXBlID09IGtUZkxpdGVJbnQxNgBvdXRwdXQtPnR5cGUgPT0ga1RmTGl0ZUZsb2F0MzIgfHwgb3V0cHV0LT50eXBlID09IGtUZkxpdGVJbnQzMgBJbnB1dCAlcywgb3V0cHV0ICVzIG5vdCBzdXBwb3J0ZWQuAFJlcXVhbnRpemUAAAAAAACA////fwAAAID///9/JXM6JWQgJXMgIT0gJXMgKCVkICE9ICVkKQAvaG9tZS9ndy93b3Jrc3BhY2UvRXNwcnVpbm8vbGlicy90ZW5zb3JmbG93L3RlbnNvcmZsb3cvbGl0ZS9taWNyby9rZXJuZWxzL3Jlc2hhcGUuY2MAc3RyZXRjaF9kaW0ALTEAJXM6JWQgJXMgIT0gJXMgKCVzICE9ICVzKQBpbnB1dC0+dHlwZQBvdXRwdXQtPnR5cGUAbnVtX2lucHV0X2VsZW1lbnRzAG51bV9vdXRwdXRfZWxlbWVudHMAJXM6JWQgJXMgd2FzIG5vdCB0cnVlLgBOdW1JbnB1dHMobm9kZSkgPT0gMSB8fCBOdW1JbnB1dHMobm9kZSkgPT0gMgBOdW1PdXRwdXRzKG5vZGUpADEAUmVzaGFwZU91dHB1dChjb250ZXh0LCBub2RlKQBrVGZMaXRlT2s=");
writeSegment(136456, "jwIAAJACAAB0AgAAdAIAAHQCAAB0Ag==");
writeSegment(136488, "kQIAAJICAACTAgAAlAIAAJUCAACWAgAAVG9vIG1hbnkgYnVmZmVycyAobWF4IGlzICVkKQBidWZmZXIgaW5kZXggJWQgaXMgb3V0c2lkZSByYW5nZSAwIHRvICVkAFVuc3VwcG9ydGVkIGRhdGEgdHlwZSAlZCBpbiB0ZW5zb3IKACVzOiVkICVzIHdhcyBub3QgdHJ1ZS4AL2hvbWUvZ3cvd29ya3NwYWNlL0VzcHJ1aW5vL2xpYnMvdGVuc29yZmxvdy90ZW5zb3JmbG93L2xpdGUvY29yZS9hcGkvZmxhdGJ1ZmZlcl9jb252ZXJzaW9ucy5jYwBwYXJhbXMgIT0gbnVsbHB0cgBVbmhhbmRsZWQgZnVsbHktY29ubmVjdGVkIHdlaWdodHMgZm9ybWF0LgByZXNoYXBlAElucHV0IGFycmF5IG5vdCBwcm92aWRlZCBmb3Igb3BlcmF0aW9uICclcycuCgBGb3VuZCB0b28gbWFueSBkaW1lbnNpb25zIGluIHRoZSBpbnB1dCBhcnJheSBvZiBvcGVyYXRpb24gJyVzJy4KAE9wIGJ1aWx0aW5fY29kZSBvdXQgb2YgcmFuZ2U6ICVkLiBBcmUgeW91IHVzaW5nIG9sZCBURkxpdGUgYmluYXJ5IHdpdGggbmV3ZXIgbW9kZWw/AERpZG4ndCBmaW5kIG9wIGZvciBidWlsdGluIG9wY29kZSAnJXMnIHZlcnNpb24gJyVkJwoAT3BlcmF0b3Igd2l0aCBDVVNUT00gYnVpbHRpbl9jb2RlIGhhcyBubyBjdXN0b21fY29kZS4KACVzOiVkICVzICE9ICVzICglZCAhPSAlZCkAL2hvbWUvZ3cvd29ya3NwYWNlL0VzcHJ1aW5vL2xpYnMvdGVuc29yZmxvdy90ZW5zb3JmbG93L2xpdGUva2VybmVscy9rZXJuZWxfdXRpbC5jYwBpbnB1dC0+cXVhbnRpemF0aW9uLnR5cGUAa1RmTGl0ZUFmZmluZVF1YW50aXphdGlvbgBmaWx0ZXItPnF1YW50aXphdGlvbi50eXBlACVzOiVkICVzIHdhcyBub3QgdHJ1ZS4AYWZmaW5lX3F1YW50aXphdGlvbgBhZmZpbmVfcXVhbnRpemF0aW9uLT5zY2FsZQBpbnB1dC0+dHlwZSA9PSBrVGZMaXRlSW50OCB8fCBpbnB1dC0+dHlwZSA9PSBrVGZMaXRlSW50MTYAZmlsdGVyLT50eXBlAGtUZkxpdGVJbnQ4AGFmZmluZV9xdWFudGl6YXRpb24tPnNjYWxlLT5zaXplAG51bV9jaGFubmVscwBmaWx0ZXItPmRpbXMtPmRhdGFbYWZmaW5lX3F1YW50aXphdGlvbi0+cXVhbnRpemVkX2RpbWVuc2lvbl0Ac2NhbGVfZGlmZiAvIG91dHB1dF9zY2FsZSA8PSAwLjAyAGlucHV0X3Byb2R1Y3Rfc2NhbGUgPj0gMABmYWxzZQBNb2RlbCBwcm92aWRlZCBpcyBzY2hlbWEgdmVyc2lvbiAlZCBub3QgZXF1YWwgdG8gc3VwcG9ydGVkIHZlcnNpb24gJWQuAEludm9rZSBmYWlsZWQ=");
writeSegment(137712, "nwIAAKACAAChAg==");
writeSegment(137732, "ogIAAKMCAAB0AgAAJXM=");
writeSegment(137756, "pAIAAKUCAACmAgAApwIAAKgCAACpAgAAqgIAAKsC");
writeSegment(137796, "pAIAAKUCAACmAgAArAIAAK0CAAB0AgAAdAIAAHQC");
writeSegment(137836, "dAIAAHQCAACmAgAArgIAAK8CAABJbnZhbGlkIHBhcmFtZXRlciBCdWlsdGluT3BlcmF0b3JfQ1VTVE9NIHRvIHRoZSBBZGRCdWlsdGluIGZ1bmN0aW9uLgBDYWxsaW5nIEFkZEJ1aWx0aW4gd2l0aCB0aGUgc2FtZSBvcCBtb3JlIHRoYW4gb25jZSBpcyBub3Qgc3VwcG9ydGVkIChPcDogIyVkKS4AQ291bGRuJ3QgcmVnaXN0ZXIgYnVpbHRpbiBvcCAjJWQsIHJlc29sdmVyIHNpemUgaXMgdG9vIHNtYWxsICglZCkuAC0rICAgMFgweAAobnVsbCk=");
writeSegment(138096, "EQAKABEREQAAAAAFAAAAAAAACQAAAAAL");
writeSegment(138128, "EQAPChEREQMKBwABEwkLCwAACQYLAAALAAYRAAAAERER");
writeSegment(138177, "Cw==");
writeSegment(138186, "EQAKChEREQAKAAACAAkLAAAACQALAAAL");
writeSegment(138235, "DA==");
writeSegment(138247, "DAAAAAAMAAAAAAkMAAAAAAAMAAAM");
writeSegment(138293, "Dg==");
writeSegment(138305, "DQAAAAQNAAAAAAkOAAAAAAAOAAAO");
writeSegment(138351, "EA==");
writeSegment(138363, "DwAAAAAPAAAAAAkQAAAAAAAQAAAQAAASAAAAEhIS");
writeSegment(138418, "EgAAABISEgAAAAAAAAk=");
writeSegment(138467, "Cw==");
writeSegment(138479, "CgAAAAAKAAAAAAkLAAAAAAALAAAL");
writeSegment(138525, "DA==");
writeSegment(138537, "DAAAAAAMAAAAAAkMAAAAAAAMAAAMAAAwMTIzNDU2Nzg5QUJDREVGLTBYKzBYIDBYLTB4KzB4IDB4AGluZgBJTkYAbmFuAE5BTgAuAAAAAKApAgBQdXJlIHZpcnR1YWwgZnVuY3Rpb24gY2FsbGVkIQAAAAAAAAADAAAABAAAAAQAAAAGAAAAg/miAERObgD8KRUA0VcnAN009QBi28AAPJmVAEGQQwBjUf4Au96rALdhxQA6biQA0k1CAEkG4AAJ6i4AHJLRAOsd/gApsRwA6D6nAPU1ggBEuy4AnOmEALQmcABBfl8A1pE5AFODOQCc9DkAi1+EACj5vQD4HzsA3v+XAA+YBQARL+8AClqLAG0fbQDPfjYACcsnAEZPtwCeZj8ALepfALondQDl68cAPXvxAPc5BwCSUooA+2vqAB+xXwAIXY0AMANWAHv8RgDwq2sAILzPADb0mgDjqR0AXmGRAAgb5gCFmWUAoBRfAI1AaACA2P8AJ3NNAAYGMQDKVhUAyahzAHviYABrjMAAGcRHAM1nwwAJ6NwAWYMqAIt2xACmHJYARK/dABlX0QClPgUABQf/ADN+PwDCMugAmE/eALt9MgAmPcMAHmvvAJ/4XgA1HzoAf/LKAPGHHQB8kCEAaiR8ANVu+gAwLXcAFTtDALUUxgDDGZ0ArcTCACxNQQAMAF0Ahn1GAONxLQCbxpoAM2IAALTSfAC0p5cAN1XVANc+9gCjEBgATXb8AGSdKgBw16sAY3z4AHqwVwAXFecAwElWADvW2QCnhDgAJCPLANaKdwBaVCMAAB+5APEKGwAZzt8AnzH/AGYeagCZV2EArPtHAH5/2AAiZbcAMuiJAOa/YADvxM0AbDYJAF0/1AAW3tcAWDveAN6bkgDSIigAKIboAOJYTQDGyjIACOMWAOB9ywAXwFAA8x2nABjgWwAuEzQAgxJiAINIAQD1jlsArbB/AB7p8gBISkMAEGfTAKrd2ACuX0IAamHOAAoopADTmbQABqbyAFx3fwCjwoMAYTyIAIpzeACvjFoAb9e9AC2mYwD0v8sAjYHvACbBZwBVykUAytk2ACio0gDCYY0AEsl3AAQmFAASRpsAxFnEAMjFRABNspEAABfzANRDrQApSeUA/dUQAAC+/AAelMwAcM7uABM+9QDs8YAAs+fDAMf4KACTBZQAwXE+AC4JswALRfMAiBKcAKsgewAutZ8AR5LCAHsyLwAMVW0AcqeQAGvnHwAxy5YAeRZKAEF54gD034kA6JSXAOLmhACZMZcAiO1rAF9fNgC7/Q4ASJq0AGekbABxckIAjV0yAJ8VuAC85QkAjTElAPd0OQAwBRwADQwBAEsIaAAs7lgAR6qQAHTnAgC91iQA932mAG5IcgCfFu8AjpSmALSR9gDRU1EAzwryACCYMwD1S34AsmNoAN0+XwBAXQMAhYl/AFVSKQA3ZMAAbdgQADJIMgBbTHUATnHUAEVUbgALCcEAKvVpABRm1QAnB50AXQRQALQ72wDqdsUAh/kXAElrfQAdJ7oAlmkpAMbMrACtFFQAkOJqAIjZiQAsclAABKS+AHcHlADzMHAAAPwnAOpxqABmwkkAZOA9AJfdgwCjP5cAQ5T9AA2GjAAxQd4AkjmdAN1wjAAXt+cACN87ABU3KwBcgKAAWoCTABARkgAP6NgAbICvANv/SwA4kA8AWRh2AGKlFQBhy7sAx4m5ABBAvQDS8gQASXUnAOu29gDbIrsAChSqAIkmLwBkg3YACTszAA6UGgBROqoAHaPCAK/trgBcJhIAbcJNAC16nADAVpcAAz+DAAnw9gArQIwAbTGZADm0BwAMIBUA2MNbAPWSxADGrUsATsqlAKc3zQDmqTYAq5KUAN1CaAAZY94AdozvAGiLUgD82zcArqGrAN8VMQAArqEADPvaAGRNZgDtBbcAKWUwAFdWvwBH/zoAavm5AHW+8wAok98Aq4AwAGaM9gAEyxUA+iIGANnkHQA9s6QAVxuPADbNCQBOQukAE76kADMjtQDwqhoAT2WoANLBpQALPw8AW3jNACP5dgB7iwQAiRdyAMamUwBvbuIA7+sAAJtKWADE2rcAqma6AHbPzwDRAh0AsfEtAIyZwQDDrXcAhkjaAPddoADGgPQArPAvAN3smgA/XLwA0N5tAJDHHwAq27YAoyU6AACvmgCtU5MAtlcEACkttABLgH4A2genAHaqDgB7WaEAFhIqANy3LQD65f0Aidv+AIm+/QDkdmwABqn8AD6AcACFbhUA/Yf/ACg+BwBhZzMAKhiGAE296gCz568Aj21uAJVnOQAxv1sAhNdIADDfFgDHLUMAJWE1AMlwzgAwy7gAv2z9AKQAogAFbOQAWt2gACFvRwBiEtIAuVyEAHBhSQBrVuAAmVIBAFBVNwAe1bcAM/HEABNuXwBdMOQAhS6pAB2ywwChMjYACLekAOqx1AAW9yEAj2nkACf/dwAMA4AAjUAtAE/NoAAgpZkAs6LTAC9dCgC0+UIAEdrLAH2+0ACb28EAqxe9AMqigQAIalwALlUXACcAVQB/FPAA4QeGABQLZACWQY0Ah77eANr9KgBrJbYAe4k0AAXz/gC5v54AaGpPAEoqqABPxFoALfi8ANdamAD0x5UADU2NACA6pgCkV18AFD+xAIA4lQDMIAEAcd2GAMnetgC/YPUATWURAAEHawCMsKwAssDQAFFVSAAe+w4AlXLDAKMGOwDAQDUABtx7AOBFzABOKfoA1srIAOjzQQB8ZN4Am2TYANm+MQCkl8MAd1jUAGnjxQDw2hMAujo8AEYYRgBVdV8A0r31AG6SxgCsLl0ADkTtABw+QgBhxIcAKf3pAOfW8wAifMoAb5E1AAjgxQD/140AbmriALD9xgCTCMEAfF10AGutsgDNbp0APnJ7AMYRagD3z6kAKXPfALXJugC3AFEA4rINAHS6JADlfWAAdNiKAA0VLACBGAwAfmaUAAEpFgCfenYA/f2+AFZF7wDZfjYA7NkTAIu6uQDEl/wAMagnAPFuwwCUxTYA2KhWALSotQDPzA4AEoktAG9XNAAsVokAmc7jANYguQBrXqoAPiqcABFfzAD9C0oA4fT7AI47bQDihiwA6dSEAPy0qQDv7tEALjXJAC85YQA4IUQAG9nIAIH8CgD7SmoALxzYAFO0hABOmYwAVCLMACpV3ADAxtYACxmWABpwuABplWQAJlpgAD9S7gB/EQ8A9LURAPzL9QA0vC0ANLzuAOhdzADdXmAAZ46bAJIz7wDJF7gAYVibAOFXvABRg8YA2D4QAN1xSAAtHN0ArxihACEsRgBZ89cA2XqYAJ5UwABPhvoAVgb8AOV5rgCJIjYAOK0iAGeT3ABV6KoAgiY4AMrnmwBRDaQAmTOxAKnXDgBpBUgAZbLwAH+IpwCITJcA+dE2ACGSswB7gkoAmM8hAECf3ADcR1UA4XQ6AGfrQgD+nd8AXtRfAHtnpAC6rHoAVfaiACuIIwBBulUAWW4IACEqhgA5R4MAiePmAOWe1ABJ+0AA/1bpABwPygDFWYoAlPorANPBxQAPxc8A21quAEfFhgCFQ2IAIYY7ACx5lAAQYYcAKkx7AIAsGgBDvxIAiCaQAHg8iQCoxOQA5dt7AMQ6wgAm9OoA92eKAA2SvwBloysAPZOxAL18CwCkUdwAJ91jAGnh3QCalBkAqCmVAGjOKAAJ7bQARJ8gAE6YygBwgmMAfnwjAA+5MgCn9Y4AFFbnACHxCAC1nSoAb35NAKUZUQC1+asAgt/WAJbdYQAWNgIAxDqfAIOioQBy7W0AOY16AIK4qQBrMlwARidbAAA07QDSAHcA/PRVAAFZTQDgcYA=");
writeSegment(141443, "QPsh+T8AAAAALUR0PgAAAICYRvg8AAAAYFHMeDsAAACAgxvwOQAAAEAgJXo4AAAAgCKC4zYAAAAAHfNpNU+7YQVnrN0/GC1EVPsh6T+b9oHSC3PvPxgtRFT7Ifk/4mUvIn8rejwHXBQzJqaBPL3L8HqIB3A8B1wUMyamkTwYLURU+yHpPxgtRFT7Iem/0iEzf3zZAkDSITN/fNkCwA==");
writeSegment(141615, "gBgtRFT7IQlAGC1EVPshCcAAAAAAAADgPwAAAAAAAOC/AAAAPwAAAL8=");
writeSegment(141656, "rDABAOAuAADvvq3evrr+yhX//wD//////////wEAIAPQBwAABAAAAAoAAAAgAwAA4Pz//+gDAABy0wEAotMBAAffAQAVAAAABQ==");
writeSegment(141740, "sgI=");
writeSegment(141764, "swIAALQCAABIJAU=");
writeSegment(141788, "Ag==");
writeSegment(141803, "//////8=");
writeSegment(142060, "dCQF");
return asmFunc({
    'Int8Array': Int8Array,
    'Int16Array': Int16Array,
    'Int32Array': Int32Array,
    'Uint8Array': Uint8Array,
    'Uint16Array': Uint16Array,
    'Uint32Array': Uint32Array,
    'Float32Array': Float32Array,
    'Float64Array': Float64Array,
    'NaN': NaN,
    'Infinity': Infinity,
    'Math': Math
  },
  asmLibraryArg,
  wasmMemory.buffer
)

}// EMSCRIPTEN_END_ASM




)(asmLibraryArg, wasmMemory, wasmTable);
    return {
      'exports': exports
    };
  },

  instantiate: function(binary, info) {
    return {
      then: function(ok, err) {
        ok({
          'instance': new WebAssembly.Instance(new WebAssembly.Module(binary, info))
        });
      }
    };
  },

  RuntimeError: Error
};

// We don't need to actually download a wasm binary, mark it as present but empty.
wasmBinary = [];




if (typeof WebAssembly !== 'object') {
  abort('No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead.');
}


// In MINIMAL_RUNTIME, setValue() and getValue() are only available when building with safe heap enabled, for heap safety checking.
// In traditional runtime, setValue() and getValue() are always available (although their use is highly discouraged due to perf penalties)

/** @type {function(number, number, string, boolean=)} */
function setValue(ptr, value, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': HEAP8[((ptr)>>0)]=value; break;
      case 'i8': HEAP8[((ptr)>>0)]=value; break;
      case 'i16': HEAP16[((ptr)>>1)]=value; break;
      case 'i32': HEAP32[((ptr)>>2)]=value; break;
      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;
      case 'float': HEAPF32[((ptr)>>2)]=value; break;
      case 'double': HEAPF64[((ptr)>>3)]=value; break;
      default: abort('invalid type for setValue: ' + type);
    }
}

/** @type {function(number, string, boolean=)} */
function getValue(ptr, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': return HEAP8[((ptr)>>0)];
      case 'i8': return HEAP8[((ptr)>>0)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP32[((ptr)>>2)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return HEAPF64[((ptr)>>3)];
      default: abort('invalid type for getValue: ' + type);
    }
  return null;
}





// Wasm globals

var wasmMemory;

// In fastcomp asm.js, we don't need a wasm Table at all.
// In the wasm backend, we polyfill the WebAssembly object,
// so this creates a (non-native-wasm) table for us.
var wasmTable = new WebAssembly.Table({
  'initial': 693,
  'maximum': 693 + 0,
  'element': 'anyfunc'
});


//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS = 0;

/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed: ' + text);
  }
}

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  var func = Module['_' + ident]; // closure exported function
  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');
  return func;
}

// C calling interface.
function ccall(ident, returnType, argTypes, args, opts) {
  // For fast lookup of conversion functions
  var toC = {
    'string': function(str) {
      var ret = 0;
      if (str !== null && str !== undefined && str !== 0) { // null string
        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
        var len = (str.length << 2) + 1;
        ret = stackAlloc(len);
        stringToUTF8(str, ret, len);
      }
      return ret;
    },
    'array': function(arr) {
      var ret = stackAlloc(arr.length);
      writeArrayToMemory(arr, ret);
      return ret;
    }
  };

  function convertReturnValue(ret) {
    if (returnType === 'string') return UTF8ToString(ret);
    if (returnType === 'boolean') return Boolean(ret);
    return ret;
  }

  var func = getCFunc(ident);
  var cArgs = [];
  var stack = 0;
  assert(returnType !== 'array', 'Return type should not be "array".');
  if (args) {
    for (var i = 0; i < args.length; i++) {
      var converter = toC[argTypes[i]];
      if (converter) {
        if (stack === 0) stack = stackSave();
        cArgs[i] = converter(args[i]);
      } else {
        cArgs[i] = args[i];
      }
    }
  }
  var ret = func.apply(null, cArgs);

  ret = convertReturnValue(ret);
  if (stack !== 0) stackRestore(stack);
  return ret;
}

function cwrap(ident, returnType, argTypes, opts) {
  return function() {
    return ccall(ident, returnType, argTypes, arguments, opts);
  }
}

var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call
var ALLOC_DYNAMIC = 2; // Cannot be freed except through sbrk
var ALLOC_NONE = 3; // Do not allocate

// allocate(): This is for internal use. You can use it yourself as well, but the interface
//             is a little tricky (see docs right below). The reason is that it is optimized
//             for multiple syntaxes to save space in generated code. So you should
//             normally not use allocate(), and instead allocate memory using _malloc(),
//             initialize it with setValue(), and so forth.
// @slab: An array of data, or a number. If a number, then the size of the block to allocate,
//        in *bytes* (note that this is sometimes confusing: the next parameter does not
//        affect this!)
// @types: Either an array of types, one for each byte (or 0 if no type at that position),
//         or a single type which is used for the entire block. This only matters if there
//         is initial data - if @slab is a number, then this does not matter at all and is
//         ignored.
// @allocator: How to allocate memory, see ALLOC_*
/** @type {function((TypedArray|Array<number>|number), string, number, number=)} */
function allocate(slab, types, allocator, ptr) {
  var zeroinit, size;
  if (typeof slab === 'number') {
    zeroinit = true;
    size = slab;
  } else {
    zeroinit = false;
    size = slab.length;
  }

  var singleType = typeof types === 'string' ? types : null;

  var ret;
  if (allocator == ALLOC_NONE) {
    ret = ptr;
  } else {
    ret = [_malloc,
    stackAlloc,
    dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length));
  }

  if (zeroinit) {
    var stop;
    ptr = ret;
    assert((ret & 3) == 0);
    stop = ret + (size & ~3);
    for (; ptr < stop; ptr += 4) {
      HEAP32[((ptr)>>2)]=0;
    }
    stop = ret + size;
    while (ptr < stop) {
      HEAP8[((ptr++)>>0)]=0;
    }
    return ret;
  }

  if (singleType === 'i8') {
    if (slab.subarray || slab.slice) {
      HEAPU8.set(/** @type {!Uint8Array} */ (slab), ret);
    } else {
      HEAPU8.set(new Uint8Array(slab), ret);
    }
    return ret;
  }

  var i = 0, type, typeSize, previousType;
  while (i < size) {
    var curr = slab[i];

    type = singleType || types[i];
    if (type === 0) {
      i++;
      continue;
    }
    assert(type, 'Must know what type to store in allocate!');

    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later

    setValue(ret+i, curr, type);

    // no need to look up size unless type changes, so cache it
    if (previousType !== type) {
      typeSize = getNativeTypeSize(type);
      previousType = type;
    }
    i += typeSize;
  }

  return ret;
}

// Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready
function getMemory(size) {
  if (!runtimeInitialized) return dynamicAlloc(size);
  return _malloc(size);
}




/** @type {function(number, number=)} */
function Pointer_stringify(ptr, length) {
  abort("this function has been removed - you should use UTF8ToString(ptr, maxBytesToRead) instead!");
}

// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function AsciiToString(ptr) {
  var str = '';
  while (1) {
    var ch = HEAPU8[((ptr++)>>0)];
    if (!ch) return str;
    str += String.fromCharCode(ch);
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.

function stringToAscii(str, outPtr) {
  return writeAsciiToMemory(str, outPtr, false);
}


// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns
// a copy of that string as a Javascript String object.

var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;

/**
 * @param {number} idx
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ArrayToString(u8Array, idx, maxBytesToRead) {
  var endIdx = idx + maxBytesToRead;
  var endPtr = idx;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)
  while (u8Array[endPtr] && !(endPtr >= endIdx)) ++endPtr;

  if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {
    return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));
  } else {
    var str = '';
    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that
    while (idx < endPtr) {
      // For UTF8 byte structure, see:
      // http://en.wikipedia.org/wiki/UTF-8#Description
      // https://www.ietf.org/rfc/rfc2279.txt
      // https://tools.ietf.org/html/rfc3629
      var u0 = u8Array[idx++];
      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
      var u1 = u8Array[idx++] & 63;
      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
      var u2 = u8Array[idx++] & 63;
      if ((u0 & 0xF0) == 0xE0) {
        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
      } else {
        if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte 0x' + u0.toString(16) + ' encountered when deserializing a UTF-8 string on the asm.js/wasm heap to a JS string!');
        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (u8Array[idx++] & 63);
      }

      if (u0 < 0x10000) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 0x10000;
        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
      }
    }
  }
  return str;
}

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a
// copy of that string as a Javascript String object.
// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit
//                 this parameter to scan the string until the first \0 byte. If maxBytesToRead is
//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the
//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will
//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)
//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may
//                 throw JS JIT optimizations off, so it is worth to consider consistently using one
//                 style or the other.
/**
 * @param {number} ptr
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ToString(ptr, maxBytesToRead) {
  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
}

// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.
//   outIdx: The starting offset in the array to begin the copying.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array.
//                    This count should include the null terminator,
//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) {
      var u1 = str.charCodeAt(++i);
      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
    }
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      outU8Array[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      outU8Array[outIdx++] = 0xC0 | (u >> 6);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      outU8Array[outIdx++] = 0xE0 | (u >> 12);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 3 >= endIdx) break;
      if (u >= 0x200000) warnOnce('Invalid Unicode code point 0x' + u.toString(16) + ' encountered when serializing a JS string to an UTF-8 string on the asm.js/wasm heap! (Valid unicode code points should be in range 0-0x1FFFFF).');
      outU8Array[outIdx++] = 0xF0 | (u >> 18);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  outU8Array[outIdx] = 0;
  return outIdx - startIdx;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8(str, outPtr, maxBytesToWrite) {
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.
function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) ++len;
    else if (u <= 0x7FF) len += 2;
    else if (u <= 0xFFFF) len += 3;
    else len += 4;
  }
  return len;
}


// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;
function UTF16ToString(ptr) {
  assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');
  var endPtr = ptr;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  var idx = endPtr >> 1;
  while (HEAP16[idx]) ++idx;
  endPtr = idx << 1;

  if (endPtr - ptr > 32 && UTF16Decoder) {
    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
  } else {
    var i = 0;

    var str = '';
    while (1) {
      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];
      if (codeUnit == 0) return str;
      ++i;
      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
      str += String.fromCharCode(codeUnit);
    }
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.
// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF16(str, outPtr, maxBytesToWrite) {
  assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 2) return 0;
  maxBytesToWrite -= 2; // Null terminator.
  var startPtr = outPtr;
  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;
  for (var i = 0; i < numCharsToWrite; ++i) {
    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    HEAP16[((outPtr)>>1)]=codeUnit;
    outPtr += 2;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP16[((outPtr)>>1)]=0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF16(str) {
  return str.length*2;
}

function UTF32ToString(ptr) {
  assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');
  var i = 0;

  var str = '';
  while (1) {
    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];
    if (utf32 == 0)
      return str;
    ++i;
    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    if (utf32 >= 0x10000) {
      var ch = utf32 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    } else {
      str += String.fromCharCode(utf32);
    }
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.
// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF32(str, outPtr, maxBytesToWrite) {
  assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 4) return 0;
  var startPtr = outPtr;
  var endPtr = startPtr + maxBytesToWrite - 4;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
      var trailSurrogate = str.charCodeAt(++i);
      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
    }
    HEAP32[((outPtr)>>2)]=codeUnit;
    outPtr += 4;
    if (outPtr + 4 > endPtr) break;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP32[((outPtr)>>2)]=0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF32(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i);
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
    len += 4;
  }

  return len;
}

// Allocate heap space for a JS string, and write it there.
// It is the responsibility of the caller to free() that memory.
function allocateUTF8(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = _malloc(size);
  if (ret) stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Allocate stack space for a JS string, and write it there.
function allocateUTF8OnStack(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = stackAlloc(size);
  stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Deprecated: This function should not be called because it is unsafe and does not provide
// a maximum length limit of how many bytes it is allowed to write. Prefer calling the
// function stringToUTF8Array() instead, which takes in a maximum length that can be used
// to be secure from out of bounds writes.
/** @deprecated */
function writeStringToMemory(string, buffer, dontAddNull) {
  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');

  var /** @type {number} */ lastChar, /** @type {number} */ end;
  if (dontAddNull) {
    // stringToUTF8Array always appends null. If we don't want to do that, remember the
    // character that existed at the location where the null will be placed, and restore
    // that after the write (below).
    end = buffer + lengthBytesUTF8(string);
    lastChar = HEAP8[end];
  }
  stringToUTF8(string, buffer, Infinity);
  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.
}

function writeArrayToMemory(array, buffer) {
  assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)')
  HEAP8.set(array, buffer);
}

function writeAsciiToMemory(str, buffer, dontAddNull) {
  for (var i = 0; i < str.length; ++i) {
    assert(str.charCodeAt(i) === str.charCodeAt(i)&0xff);
    HEAP8[((buffer++)>>0)]=str.charCodeAt(i);
  }
  // Null-terminate the pointer to the HEAP.
  if (!dontAddNull) HEAP8[((buffer)>>0)]=0;
}




// Memory management

var PAGE_SIZE = 16384;
var WASM_PAGE_SIZE = 65536;
var ASMJS_PAGE_SIZE = 16777216;

function alignUp(x, multiple) {
  if (x % multiple > 0) {
    x += multiple - (x % multiple);
  }
  return x;
}

var HEAP,
/** @type {ArrayBuffer} */
  buffer,
/** @type {Int8Array} */
  HEAP8,
/** @type {Uint8Array} */
  HEAPU8,
/** @type {Int16Array} */
  HEAP16,
/** @type {Uint16Array} */
  HEAPU16,
/** @type {Int32Array} */
  HEAP32,
/** @type {Uint32Array} */
  HEAPU32,
/** @type {Float32Array} */
  HEAPF32,
/** @type {Float64Array} */
  HEAPF64;

function updateGlobalBufferAndViews(buf) {
  buffer = buf;
  Module['HEAP8'] = HEAP8 = new Int8Array(buf);
  Module['HEAP16'] = HEAP16 = new Int16Array(buf);
  Module['HEAP32'] = HEAP32 = new Int32Array(buf);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);
}

var STATIC_BASE = 1024,
    STACK_BASE = 5580592,
    STACKTOP = STACK_BASE,
    STACK_MAX = 337712,
    DYNAMIC_BASE = 5580592,
    DYNAMICTOP_PTR = 337552;

assert(STACK_BASE % 16 === 0, 'stack must start aligned');
assert(DYNAMIC_BASE % 16 === 0, 'heap must start aligned');



var TOTAL_STACK = 5242880;
if (Module['TOTAL_STACK']) assert(TOTAL_STACK === Module['TOTAL_STACK'], 'the stack size can no longer be determined at runtime')

var INITIAL_TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;if (!Object.getOwnPropertyDescriptor(Module, 'TOTAL_MEMORY')) Object.defineProperty(Module, 'TOTAL_MEMORY', { configurable: true, get: function() { abort('Module.TOTAL_MEMORY has been replaced with plain INITIAL_TOTAL_MEMORY') } });

assert(INITIAL_TOTAL_MEMORY >= TOTAL_STACK, 'TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + INITIAL_TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')');

// check for full engine support (use string 'subarray' to avoid closure compiler confusion)
assert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined,
       'JS engine does not provide full typed array support');






// In standalone mode, the wasm creates the memory, and the user can't provide it.
// In non-standalone/normal mode, we create the memory here.

// Create the main memory. (Note: this isn't used in STANDALONE_WASM mode since the wasm
// memory is created in the wasm, not in JS.)

  if (Module['wasmMemory']) {
    wasmMemory = Module['wasmMemory'];
  } else
  {
    wasmMemory = new WebAssembly.Memory({
      'initial': INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE
      ,
      'maximum': INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE
    });
  }


if (wasmMemory) {
  buffer = wasmMemory.buffer;
}

// If the user provides an incorrect length, just use that length instead rather than providing the user to
// specifically provide the memory length with Module['TOTAL_MEMORY'].
INITIAL_TOTAL_MEMORY = buffer.byteLength;
assert(INITIAL_TOTAL_MEMORY % WASM_PAGE_SIZE === 0);
updateGlobalBufferAndViews(buffer);

HEAP32[DYNAMICTOP_PTR>>2] = DYNAMIC_BASE;




// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.
function writeStackCookie() {
  assert((STACK_MAX & 3) == 0);
  // The stack grows downwards
  HEAPU32[(STACK_MAX >> 2)+1] = 0x02135467;
  HEAPU32[(STACK_MAX >> 2)+2] = 0x89BACDFE;
  // Also test the global address 0 for integrity.
  // We don't do this with ASan because ASan does its own checks for this.
  HEAP32[0] = 0x63736d65; /* 'emsc' */
}

function checkStackCookie() {
  var cookie1 = HEAPU32[(STACK_MAX >> 2)+1];
  var cookie2 = HEAPU32[(STACK_MAX >> 2)+2];
  if (cookie1 != 0x02135467 || cookie2 != 0x89BACDFE) {
    abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x02135467, but received 0x' + cookie2.toString(16) + ' ' + cookie1.toString(16));
  }
  // Also test the global address 0 for integrity.
  // We don't do this with ASan because ASan does its own checks for this.
  if (HEAP32[0] !== 0x63736d65 /* 'emsc' */) abort('Runtime error: The application has corrupted its heap memory area (address zero)!');
}

function abortStackOverflow(allocSize) {
  abort('Stack overflow! Attempted to allocate ' + allocSize + ' bytes on the stack, but stack has only ' + (STACK_MAX - stackSave() + allocSize) + ' bytes available!');
}




// Endianness check (note: assumes compiler arch was little-endian)
(function() {
  var h16 = new Int16Array(1);
  var h8 = new Int8Array(h16.buffer);
  h16[0] = 0x6373;
  if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian!';
})();

function abortFnPtrError(ptr, sig) {
	abort("Invalid function pointer " + ptr + " called with signature '" + sig + "'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this). Build with ASSERTIONS=2 for more info.");
}



function callRuntimeCallbacks(callbacks) {
  while(callbacks.length > 0) {
    var callback = callbacks.shift();
    if (typeof callback == 'function') {
      callback();
      continue;
    }
    var func = callback.func;
    if (typeof func === 'number') {
      if (callback.arg === undefined) {
        Module['dynCall_v'](func);
      } else {
        Module['dynCall_vi'](func, callback.arg);
      }
    } else {
      func(callback.arg === undefined ? null : callback.arg);
    }
  }
}

var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATMAIN__    = []; // functions called when main() is to be run
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the main() is called

var runtimeInitialized = false;
var runtimeExited = false;


function preRun() {

  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
  checkStackCookie();
  assert(!runtimeInitialized);
  runtimeInitialized = true;
  
  callRuntimeCallbacks(__ATINIT__);
}

function preMain() {
  checkStackCookie();
  
  callRuntimeCallbacks(__ATMAIN__);
}

function exitRuntime() {
  checkStackCookie();
  runtimeExited = true;
}

function postRun() {
  checkStackCookie();

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnPreMain(cb) {
  __ATMAIN__.unshift(cb);
}

function addOnExit(cb) {
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}

function unSign(value, bits, ignore) {
  if (value >= 0) {
    return value;
  }
  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts
                    : Math.pow(2, bits)         + value;
}
function reSign(value, bits, ignore) {
  if (value <= 0) {
    return value;
  }
  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32
                        : Math.pow(2, bits-1);
  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
                                                       // TODO: In i64 mode 1, resign the two parts separately and safely
    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
  }
  return value;
}


assert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');

var Math_abs = Math.abs;
var Math_cos = Math.cos;
var Math_sin = Math.sin;
var Math_tan = Math.tan;
var Math_acos = Math.acos;
var Math_asin = Math.asin;
var Math_atan = Math.atan;
var Math_atan2 = Math.atan2;
var Math_exp = Math.exp;
var Math_log = Math.log;
var Math_sqrt = Math.sqrt;
var Math_ceil = Math.ceil;
var Math_floor = Math.floor;
var Math_pow = Math.pow;
var Math_imul = Math.imul;
var Math_fround = Math.fround;
var Math_round = Math.round;
var Math_min = Math.min;
var Math_max = Math.max;
var Math_clz32 = Math.clz32;
var Math_trunc = Math.trunc;



// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled
var runDependencyTracking = {};

function getUniqueRunDependency(id) {
  var orig = id;
  while (1) {
    if (!runDependencyTracking[id]) return id;
    id = orig + Math.random();
  }
  return id;
}

function addRunDependency(id) {
  runDependencies++;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

  if (id) {
    assert(!runDependencyTracking[id]);
    runDependencyTracking[id] = 1;
    if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {
      // Check for missing dependencies every few seconds
      runDependencyWatcher = setInterval(function() {
        if (ABORT) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
          return;
        }
        var shown = false;
        for (var dep in runDependencyTracking) {
          if (!shown) {
            shown = true;
            err('still waiting on run dependencies:');
          }
          err('dependency: ' + dep);
        }
        if (shown) {
          err('(end of list)');
        }
      }, 10000);
    }
  } else {
    err('warning: run dependency added without ID');
  }
}

function removeRunDependency(id) {
  runDependencies--;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

  if (id) {
    assert(runDependencyTracking[id]);
    delete runDependencyTracking[id];
  } else {
    err('warning: run dependency removed without ID');
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data


function abort(what) {
  if (Module['onAbort']) {
    Module['onAbort'](what);
  }

  what += '';
  out(what);
  err(what);

  ABORT = true;
  EXITSTATUS = 1;

  var output = 'abort(' + what + ') at ' + stackTrace();
  what = output;

  // Throw a wasm runtime error, because a JS error might be seen as a foreign
  // exception, which means we'd run destructors on it. We need the error to
  // simply make the program stop.
  throw new WebAssembly.RuntimeError(what);
}


var memoryInitializer = null;




// show errors on likely calls to FS when it was not included
var FS = {
  error: function() {
    abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with  -s FORCE_FILESYSTEM=1');
  },
  init: function() { FS.error() },
  createDataFile: function() { FS.error() },
  createPreloadedFile: function() { FS.error() },
  createLazyFile: function() { FS.error() },
  open: function() { FS.error() },
  mkdev: function() { FS.error() },
  registerDevice: function() { FS.error() },
  analyzePath: function() { FS.error() },
  loadFilesFromDB: function() { FS.error() },

  ErrnoError: function ErrnoError() { FS.error() },
};
Module['FS_createDataFile'] = FS.createDataFile;
Module['FS_createPreloadedFile'] = FS.createPreloadedFile;



// Copyright 2017 The Emscripten Authors.  All rights reserved.
// Emscripten is available under two separate licenses, the MIT license and the
// University of Illinois/NCSA Open Source License.  Both these licenses can be
// found in the LICENSE file.

// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix = 'data:application/octet-stream;base64,';

// Indicates whether filename is a base64 data URI.
function isDataURI(filename) {
  return String.prototype.startsWith ?
      filename.startsWith(dataURIPrefix) :
      filename.indexOf(dataURIPrefix) === 0;
}




var wasmBinaryFile = 'emulator_banglejs2.wasm';
if (!isDataURI(wasmBinaryFile)) {
  wasmBinaryFile = locateFile(wasmBinaryFile);
}

function getBinary() {
  try {
    if (wasmBinary) {
      return new Uint8Array(wasmBinary);
    }

    var binary = tryParseAsDataURI(wasmBinaryFile);
    if (binary) {
      return binary;
    }
    if (readBinary) {
      return readBinary(wasmBinaryFile);
    } else {
      throw "both async and sync fetching of the wasm failed";
    }
  }
  catch (err) {
    abort(err);
  }
}

function getBinaryPromise() {
  // if we don't have the binary yet, and have the Fetch api, use that
  // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web
  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') {
    return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
      if (!response['ok']) {
        throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
      }
      return response['arrayBuffer']();
    }).catch(function () {
      return getBinary();
    });
  }
  // Otherwise, getBinary should be able to get it synchronously
  return new Promise(function(resolve, reject) {
    resolve(getBinary());
  });
}



// Create the wasm instance.
// Receives the wasm imports, returns the exports.
function createWasm() {
  // prepare imports
  var info = {
    'env': asmLibraryArg,
    'wasi_unstable': asmLibraryArg
  };
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  function receiveInstance(instance, module) {
    var exports = instance.exports;
    Module['asm'] = exports;
    removeRunDependency('wasm-instantiate');
  }
   // we can't run yet (except in a pthread, where we have a custom sync instantiator)
  addRunDependency('wasm-instantiate');


  // Async compilation can be confusing when an error on the page overwrites Module
  // (for example, if the order of elements is wrong, and the one defining Module is
  // later), so we save Module and check it later.
  var trueModule = Module;
  function receiveInstantiatedSource(output) {
    // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.
    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');
    trueModule = null;
      // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
      // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.
    receiveInstance(output['instance']);
  }


  function instantiateArrayBuffer(receiver) {
    return getBinaryPromise().then(function(binary) {
      return WebAssembly.instantiate(binary, info);
    }).then(receiver, function(reason) {
      err('failed to asynchronously prepare wasm: ' + reason);
      abort(reason);
    });
  }

  // Prefer streaming instantiation if available.
  function instantiateAsync() {
    if (!wasmBinary &&
        typeof WebAssembly.instantiateStreaming === 'function' &&
        !isDataURI(wasmBinaryFile) &&
        typeof fetch === 'function') {
      fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function (response) {
        var result = WebAssembly.instantiateStreaming(response, info);
        return result.then(receiveInstantiatedSource, function(reason) {
            // We expect the most common failure cause to be a bad MIME type for the binary,
            // in which case falling back to ArrayBuffer instantiation should work.
            err('wasm streaming compile failed: ' + reason);
            err('falling back to ArrayBuffer instantiation');
            instantiateArrayBuffer(receiveInstantiatedSource);
          });
      });
    } else {
      return instantiateArrayBuffer(receiveInstantiatedSource);
    }
  }
  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel
  // to any other async startup actions they are performing.
  if (Module['instantiateWasm']) {
    try {
      var exports = Module['instantiateWasm'](info, receiveInstance);
      return exports;
    } catch(e) {
      err('Module.instantiateWasm callback failed with error: ' + e);
      return false;
    }
  }

  instantiateAsync();
  return {}; // no exports yet; we'll fill them in later
}


// Globals used by JS i64 conversions
var tempDouble;
var tempI64;

// === Body ===

var ASM_CONSTS = {
  109674: function() {jsHandleIO();},  
 109692: function($0, $1) {hwSetPinValue($0,$1)},  
 109717: function($0) {return hwGetPinValue($0)},  
 109746: function() {return Date.now();},  
 109769: function($0) {hwFlashWrite($0,0xFF);},  
 109796: function($0) {return hwFlashRead($0)},  
 109823: function($0, $1) {hwFlashWrite($0,$1);}
};

// Avoid creating a new array
var _readAsmConstArgsArray = [];

function readAsmConstArgs(sigPtr, buf) {
  var args = _readAsmConstArgsArray;
  args.length = 0;
  while (1) {
    var ch = HEAPU8[sigPtr++];
    if (!ch) return args;
    if (ch === 'd'.charCodeAt(0) || ch === 'f'.charCodeAt(0)) {
      buf = alignMemory(buf, 8);
      args.push(HEAPF64[(buf >> 3)]);
      buf += 8;
    } else if (ch === 'i'.charCodeAt(0)) {
      buf = alignMemory(buf, 4);
      args.push(HEAP32[(buf >> 2)]);
      buf += 4;
    } else abort("unexpected char in asm const signature " + ch);
  }
}


function _emscripten_asm_const_dii(code, sigPtr, argbuf) {
  var args = readAsmConstArgs(sigPtr, argbuf);
  return ASM_CONSTS[code].apply(null, args);
}

function _emscripten_asm_const_iii(code, sigPtr, argbuf) {
  var args = readAsmConstArgs(sigPtr, argbuf);
  return ASM_CONSTS[code].apply(null, args);
}



// STATICTOP = STATIC_BASE + 336688;
/* global initializers */  __ATINIT__.push({ func: function() { ___wasm_call_ctors() } });



/* no memory initializer */
// {{PRE_LIBRARY}}


  function demangle(func) {
      warnOnce('warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling');
      return func;
    }

  function demangleAll(text) {
      var regex =
        /\b_Z[\w\d_]+/g;
      return text.replace(regex,
        function(x) {
          var y = demangle(x);
          return x === y ? x : (y + ' [' + x + ']');
        });
    }

  function jsStackTrace() {
      var err = new Error();
      if (!err.stack) {
        // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,
        // so try that as a special-case.
        try {
          throw new Error(0);
        } catch(e) {
          err = e;
        }
        if (!err.stack) {
          return '(no stack trace available)';
        }
      }
      return err.stack.toString();
    }

  function stackTrace() {
      var js = jsStackTrace();
      if (Module['extraStackTrace']) js += '\n' + Module['extraStackTrace']();
      return demangleAll(js);
    }

  function ___lock() {}

  function ___unlock() {}

  function _abort() {
      abort();
    }

  function _emscripten_get_heap_size() {
      return HEAP8.length;
    }

  function _emscripten_get_sbrk_ptr() {
      return 337552;
    }

  function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.set(HEAPU8.subarray(src, src+num), dest);
    }

  
  function abortOnCannotGrowMemory(requestedSize) {
      abort('Cannot enlarge memory arrays to size ' + requestedSize + ' bytes (OOM). Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + HEAP8.length + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');
    }function _emscripten_resize_heap(requestedSize) {
      abortOnCannotGrowMemory(requestedSize);
    }

  
  
  var PATH={splitPath:function(filename) {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },normalizeArray:function(parts, allowAboveRoot) {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift('..');
          }
        }
        return parts;
      },normalize:function(path) {
        var isAbsolute = path.charAt(0) === '/',
            trailingSlash = path.substr(-1) === '/';
        // Normalize the path
        path = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },dirname:function(path) {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          // No dirname whatsoever
          return '.';
        }
        if (dir) {
          // It has a dirname, strip trailing slash
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },basename:function(path) {
        // EMSCRIPTEN return '/'' for '/', not an empty string
        if (path === '/') return '/';
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash+1);
      },extname:function(path) {
        return PATH.splitPath(path)[3];
      },join:function() {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.join('/'));
      },join2:function(l, r) {
        return PATH.normalize(l + '/' + r);
      }};var SYSCALLS={buffers:[null,[],[]],printChar:function(stream, curr) {
        var buffer = SYSCALLS.buffers[stream];
        assert(buffer);
        if (curr === 0 || curr === 10) {
          (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));
          buffer.length = 0;
        } else {
          buffer.push(curr);
        }
      },varargs:0,get:function(varargs) {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];
        return ret;
      },getStr:function() {
        var ret = UTF8ToString(SYSCALLS.get());
        return ret;
      },get64:function() {
        var low = SYSCALLS.get(), high = SYSCALLS.get();
        if (low >= 0) assert(high === 0);
        else assert(high === -1);
        return low;
      },getZero:function() {
        assert(SYSCALLS.get() === 0);
      }};function _fd_close(fd) {try {
  
      abort('it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM');
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }

  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {try {
  
      abort('it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM');
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }

  
  function flush_NO_FILESYSTEM() {
      // flush anything remaining in the buffers during shutdown
      var fflush = Module["_fflush"];
      if (fflush) fflush(0);
      var buffers = SYSCALLS.buffers;
      if (buffers[1].length) SYSCALLS.printChar(1, 10);
      if (buffers[2].length) SYSCALLS.printChar(2, 10);
    }function _fd_write(fd, iov, iovcnt, pnum) {try {
  
      // hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0
      var num = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAP32[(((iov)+(i*8))>>2)];
        var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
        for (var j = 0; j < len; j++) {
          SYSCALLS.printChar(fd, HEAPU8[ptr+j]);
        }
        num += len;
      }
      HEAP32[((pnum)>>2)]=num
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }

  
  function _memcpy(dest, src, num) {
      dest = dest|0; src = src|0; num = num|0;
      var ret = 0;
      var aligned_dest_end = 0;
      var block_aligned_dest_end = 0;
      var dest_end = 0;
      // Test against a benchmarked cutoff limit for when HEAPU8.set() becomes faster to use.
      if ((num|0) >= 8192) {
        _emscripten_memcpy_big(dest|0, src|0, num|0)|0;
        return dest|0;
      }
  
      ret = dest|0;
      dest_end = (dest + num)|0;
      if ((dest&3) == (src&3)) {
        // The initial unaligned < 4-byte front.
        while (dest & 3) {
          if ((num|0) == 0) return ret|0;
          HEAP8[((dest)>>0)]=((HEAP8[((src)>>0)])|0);
          dest = (dest+1)|0;
          src = (src+1)|0;
          num = (num-1)|0;
        }
        aligned_dest_end = (dest_end & -4)|0;
        block_aligned_dest_end = (aligned_dest_end - 64)|0;
        while ((dest|0) <= (block_aligned_dest_end|0) ) {
          HEAP32[((dest)>>2)]=((HEAP32[((src)>>2)])|0);
          HEAP32[(((dest)+(4))>>2)]=((HEAP32[(((src)+(4))>>2)])|0);
          HEAP32[(((dest)+(8))>>2)]=((HEAP32[(((src)+(8))>>2)])|0);
          HEAP32[(((dest)+(12))>>2)]=((HEAP32[(((src)+(12))>>2)])|0);
          HEAP32[(((dest)+(16))>>2)]=((HEAP32[(((src)+(16))>>2)])|0);
          HEAP32[(((dest)+(20))>>2)]=((HEAP32[(((src)+(20))>>2)])|0);
          HEAP32[(((dest)+(24))>>2)]=((HEAP32[(((src)+(24))>>2)])|0);
          HEAP32[(((dest)+(28))>>2)]=((HEAP32[(((src)+(28))>>2)])|0);
          HEAP32[(((dest)+(32))>>2)]=((HEAP32[(((src)+(32))>>2)])|0);
          HEAP32[(((dest)+(36))>>2)]=((HEAP32[(((src)+(36))>>2)])|0);
          HEAP32[(((dest)+(40))>>2)]=((HEAP32[(((src)+(40))>>2)])|0);
          HEAP32[(((dest)+(44))>>2)]=((HEAP32[(((src)+(44))>>2)])|0);
          HEAP32[(((dest)+(48))>>2)]=((HEAP32[(((src)+(48))>>2)])|0);
          HEAP32[(((dest)+(52))>>2)]=((HEAP32[(((src)+(52))>>2)])|0);
          HEAP32[(((dest)+(56))>>2)]=((HEAP32[(((src)+(56))>>2)])|0);
          HEAP32[(((dest)+(60))>>2)]=((HEAP32[(((src)+(60))>>2)])|0);
          dest = (dest+64)|0;
          src = (src+64)|0;
        }
        while ((dest|0) < (aligned_dest_end|0) ) {
          HEAP32[((dest)>>2)]=((HEAP32[((src)>>2)])|0);
          dest = (dest+4)|0;
          src = (src+4)|0;
        }
      } else {
        // In the unaligned copy case, unroll a bit as well.
        aligned_dest_end = (dest_end - 4)|0;
        while ((dest|0) < (aligned_dest_end|0) ) {
          HEAP8[((dest)>>0)]=((HEAP8[((src)>>0)])|0);
          HEAP8[(((dest)+(1))>>0)]=((HEAP8[(((src)+(1))>>0)])|0);
          HEAP8[(((dest)+(2))>>0)]=((HEAP8[(((src)+(2))>>0)])|0);
          HEAP8[(((dest)+(3))>>0)]=((HEAP8[(((src)+(3))>>0)])|0);
          dest = (dest+4)|0;
          src = (src+4)|0;
        }
      }
      // The remaining unaligned < 4 byte tail.
      while ((dest|0) < (dest_end|0)) {
        HEAP8[((dest)>>0)]=((HEAP8[((src)>>0)])|0);
        dest = (dest+1)|0;
        src = (src+1)|0;
      }
      return ret|0;
    }

  function _memset(ptr, value, num) {
      ptr = ptr|0; value = value|0; num = num|0;
      var end = 0, aligned_end = 0, block_aligned_end = 0, value4 = 0;
      end = (ptr + num)|0;
  
      value = value & 0xff;
      if ((num|0) >= 67 /* 64 bytes for an unrolled loop + 3 bytes for unaligned head*/) {
        while ((ptr&3) != 0) {
          HEAP8[((ptr)>>0)]=value;
          ptr = (ptr+1)|0;
        }
  
        aligned_end = (end & -4)|0;
        value4 = value | (value << 8) | (value << 16) | (value << 24);
  
        block_aligned_end = (aligned_end - 64)|0;
  
        while((ptr|0) <= (block_aligned_end|0)) {
          HEAP32[((ptr)>>2)]=value4;
          HEAP32[(((ptr)+(4))>>2)]=value4;
          HEAP32[(((ptr)+(8))>>2)]=value4;
          HEAP32[(((ptr)+(12))>>2)]=value4;
          HEAP32[(((ptr)+(16))>>2)]=value4;
          HEAP32[(((ptr)+(20))>>2)]=value4;
          HEAP32[(((ptr)+(24))>>2)]=value4;
          HEAP32[(((ptr)+(28))>>2)]=value4;
          HEAP32[(((ptr)+(32))>>2)]=value4;
          HEAP32[(((ptr)+(36))>>2)]=value4;
          HEAP32[(((ptr)+(40))>>2)]=value4;
          HEAP32[(((ptr)+(44))>>2)]=value4;
          HEAP32[(((ptr)+(48))>>2)]=value4;
          HEAP32[(((ptr)+(52))>>2)]=value4;
          HEAP32[(((ptr)+(56))>>2)]=value4;
          HEAP32[(((ptr)+(60))>>2)]=value4;
          ptr = (ptr + 64)|0;
        }
  
        while ((ptr|0) < (aligned_end|0) ) {
          HEAP32[((ptr)>>2)]=value4;
          ptr = (ptr+4)|0;
        }
      }
      // The remaining bytes.
      while ((ptr|0) < (end|0)) {
        HEAP8[((ptr)>>0)]=value;
        ptr = (ptr+1)|0;
      }
      return (end-num)|0;
    }

  
  function _round(d) {
      d = +d;
      return d >= +0 ? +Math_floor(d + +0.5) : +Math_ceil(d - +0.5);
    }

  function _roundf(d) {
      d = +d;
      return d >= +0 ? +Math_floor(d + +0.5) : +Math_ceil(d - +0.5);
    }

  function _setTempRet0($i) {
      setTempRet0(($i) | 0);
    }
var ASSERTIONS = true;

// Copyright 2017 The Emscripten Authors.  All rights reserved.
// Emscripten is available under two separate licenses, the MIT license and the
// University of Illinois/NCSA Open Source License.  Both these licenses can be
// found in the LICENSE file.

/** @type {function(string, boolean=, number=)} */
function intArrayFromString(stringy, dontAddNull, length) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      if (ASSERTIONS) {
        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');
      }
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}


// Copied from https://github.com/strophe/strophejs/blob/e06d027/src/polyfills.js#L149

// This code was written by Tyler Akins and has been placed in the
// public domain.  It would be nice if you left this header intact.
// Base64 code from Tyler Akins -- http://rumkin.com

/**
 * Decodes a base64 string.
 * @param {String} input The string to decode.
 */
var decodeBase64 = typeof atob === 'function' ? atob : function (input) {
  var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  var output = '';
  var chr1, chr2, chr3;
  var enc1, enc2, enc3, enc4;
  var i = 0;
  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
  do {
    enc1 = keyStr.indexOf(input.charAt(i++));
    enc2 = keyStr.indexOf(input.charAt(i++));
    enc3 = keyStr.indexOf(input.charAt(i++));
    enc4 = keyStr.indexOf(input.charAt(i++));

    chr1 = (enc1 << 2) | (enc2 >> 4);
    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
    chr3 = ((enc3 & 3) << 6) | enc4;

    output = output + String.fromCharCode(chr1);

    if (enc3 !== 64) {
      output = output + String.fromCharCode(chr2);
    }
    if (enc4 !== 64) {
      output = output + String.fromCharCode(chr3);
    }
  } while (i < input.length);
  return output;
};

// Converts a string of base64 into a byte array.
// Throws error on invalid input.
function intArrayFromBase64(s) {
  if (typeof ENVIRONMENT_IS_NODE === 'boolean' && ENVIRONMENT_IS_NODE) {
    var buf;
    try {
      buf = Buffer.from(s, 'base64');
    } catch (_) {
      buf = new Buffer(s, 'base64');
    }
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }

  try {
    var decoded = decodeBase64(s);
    var bytes = new Uint8Array(decoded.length);
    for (var i = 0 ; i < decoded.length ; ++i) {
      bytes[i] = decoded.charCodeAt(i);
    }
    return bytes;
  } catch (_) {
    throw new Error('Converting base64 string to bytes failed.');
  }
}

// If filename is a base64 data URI, parses and returns data (Buffer on node,
// Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.
function tryParseAsDataURI(filename) {
  if (!isDataURI(filename)) {
    return;
  }

  return intArrayFromBase64(filename.slice(dataURIPrefix.length));
}


// ASM_LIBRARY EXTERN PRIMITIVES: Int8Array,Int32Array,Math_floor,Math_ceil

var asmGlobalArg = {};
var asmLibraryArg = { "__lock": ___lock, "__unlock": ___unlock, "abort": _abort, "emscripten_asm_const_dii": _emscripten_asm_const_dii, "emscripten_asm_const_iii": _emscripten_asm_const_iii, "emscripten_get_sbrk_ptr": _emscripten_get_sbrk_ptr, "emscripten_memcpy_big": _emscripten_memcpy_big, "emscripten_resize_heap": _emscripten_resize_heap, "fd_close": _fd_close, "fd_seek": _fd_seek, "fd_write": _fd_write, "getTempRet0": getTempRet0, "memory": wasmMemory, "round": _round, "roundf": _roundf, "setTempRet0": setTempRet0, "table": wasmTable };
var asm = createWasm();
var real____wasm_call_ctors = asm["__wasm_call_ctors"];
asm["__wasm_call_ctors"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real____wasm_call_ctors.apply(null, arguments);
};

var real__jshPushIOCharEvent = asm["jshPushIOCharEvent"];
asm["jshPushIOCharEvent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__jshPushIOCharEvent.apply(null, arguments);
};

var real__jshGetCharToTransmit = asm["jshGetCharToTransmit"];
asm["jshGetCharToTransmit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__jshGetCharToTransmit.apply(null, arguments);
};

var real__jshGetDeviceToTransmit = asm["jshGetDeviceToTransmit"];
asm["jshGetDeviceToTransmit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__jshGetDeviceToTransmit.apply(null, arguments);
};

var real__jsGfxChanged = asm["jsGfxChanged"];
asm["jsGfxChanged"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__jsGfxChanged.apply(null, arguments);
};

var real__jsGfxGetPtr = asm["jsGfxGetPtr"];
asm["jsGfxGetPtr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__jsGfxGetPtr.apply(null, arguments);
};

var real__malloc = asm["malloc"];
asm["malloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__malloc.apply(null, arguments);
};

var real__free = asm["free"];
asm["free"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__free.apply(null, arguments);
};

var real__jsInit = asm["jsInit"];
asm["jsInit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__jsInit.apply(null, arguments);
};

var real__jsIdle = asm["jsIdle"];
asm["jsIdle"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__jsIdle.apply(null, arguments);
};

var real__jsSendPinWatchEvent = asm["jsSendPinWatchEvent"];
asm["jsSendPinWatchEvent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__jsSendPinWatchEvent.apply(null, arguments);
};

var real__jsSendTouchEvent = asm["jsSendTouchEvent"];
asm["jsSendTouchEvent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__jsSendTouchEvent.apply(null, arguments);
};

var real__jsKill = asm["jsKill"];
asm["jsKill"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__jsKill.apply(null, arguments);
};

var real__htons = asm["htons"];
asm["htons"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__htons.apply(null, arguments);
};

var real__ntohs = asm["ntohs"];
asm["ntohs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__ntohs.apply(null, arguments);
};

var real__htonl = asm["htonl"];
asm["htonl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__htonl.apply(null, arguments);
};

var real__fflush = asm["fflush"];
asm["fflush"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__fflush.apply(null, arguments);
};

var real____errno_location = asm["__errno_location"];
asm["__errno_location"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real____errno_location.apply(null, arguments);
};

var real___ZSt18uncaught_exceptionv = asm["_ZSt18uncaught_exceptionv"];
asm["_ZSt18uncaught_exceptionv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real___ZSt18uncaught_exceptionv.apply(null, arguments);
};

var real__setThrew = asm["setThrew"];
asm["setThrew"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__setThrew.apply(null, arguments);
};

var real__emscripten_builtin_memalign = asm["emscripten_builtin_memalign"];
asm["emscripten_builtin_memalign"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__emscripten_builtin_memalign.apply(null, arguments);
};

var real_stackSave = asm["stackSave"];
asm["stackSave"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_stackSave.apply(null, arguments);
};

var real_stackAlloc = asm["stackAlloc"];
asm["stackAlloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_stackAlloc.apply(null, arguments);
};

var real_stackRestore = asm["stackRestore"];
asm["stackRestore"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_stackRestore.apply(null, arguments);
};

var real___growWasmMemory = asm["__growWasmMemory"];
asm["__growWasmMemory"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real___growWasmMemory.apply(null, arguments);
};

var real_dynCall_iii = asm["dynCall_iii"];
asm["dynCall_iii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_iii.apply(null, arguments);
};

var real_dynCall_vii = asm["dynCall_vii"];
asm["dynCall_vii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_vii.apply(null, arguments);
};

var real_dynCall_ii = asm["dynCall_ii"];
asm["dynCall_ii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_ii.apply(null, arguments);
};

var real_dynCall_viii = asm["dynCall_viii"];
asm["dynCall_viii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_viii.apply(null, arguments);
};

var real_dynCall_vi = asm["dynCall_vi"];
asm["dynCall_vi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_vi.apply(null, arguments);
};

var real_dynCall_viiii = asm["dynCall_viiii"];
asm["dynCall_viiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_viiii.apply(null, arguments);
};

var real_dynCall_i = asm["dynCall_i"];
asm["dynCall_i"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_i.apply(null, arguments);
};

var real_dynCall_iiii = asm["dynCall_iiii"];
asm["dynCall_iiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_iiii.apply(null, arguments);
};

var real_dynCall_d = asm["dynCall_d"];
asm["dynCall_d"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_d.apply(null, arguments);
};

var real_dynCall_di = asm["dynCall_di"];
asm["dynCall_di"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_di.apply(null, arguments);
};

var real_dynCall_vidi = asm["dynCall_vidi"];
asm["dynCall_vidi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_vidi.apply(null, arguments);
};

var real_dynCall_vid = asm["dynCall_vid"];
asm["dynCall_vid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_vid.apply(null, arguments);
};

var real_dynCall_v = asm["dynCall_v"];
asm["dynCall_v"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_v.apply(null, arguments);
};

var real_dynCall_iidi = asm["dynCall_iidi"];
asm["dynCall_iidi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_iidi.apply(null, arguments);
};

var real_dynCall_vd = asm["dynCall_vd"];
asm["dynCall_vd"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_vd.apply(null, arguments);
};

var real_dynCall_iid = asm["dynCall_iid"];
asm["dynCall_iid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_iid.apply(null, arguments);
};

var real_dynCall_idddi = asm["dynCall_idddi"];
asm["dynCall_idddi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_idddi.apply(null, arguments);
};

var real_dynCall_dddd = asm["dynCall_dddd"];
asm["dynCall_dddd"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_dddd.apply(null, arguments);
};

var real_dynCall_diii = asm["dynCall_diii"];
asm["dynCall_diii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_diii.apply(null, arguments);
};

var real_dynCall_vdi = asm["dynCall_vdi"];
asm["dynCall_vdi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_vdi.apply(null, arguments);
};

var real_dynCall_did = asm["dynCall_did"];
asm["dynCall_did"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_did.apply(null, arguments);
};

var real_dynCall_iiiiii = asm["dynCall_iiiiii"];
asm["dynCall_iiiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_iiiiii.apply(null, arguments);
};

var real_dynCall_iiiii = asm["dynCall_iiiii"];
asm["dynCall_iiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_iiiii.apply(null, arguments);
};

var real_dynCall_dii = asm["dynCall_dii"];
asm["dynCall_dii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_dii.apply(null, arguments);
};

var real_dynCall_diiii = asm["dynCall_diiii"];
asm["dynCall_diiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_diiii.apply(null, arguments);
};

var real_dynCall_diiiii = asm["dynCall_diiiii"];
asm["dynCall_diiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_diiiii.apply(null, arguments);
};

var real_dynCall_viid = asm["dynCall_viid"];
asm["dynCall_viid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_viid.apply(null, arguments);
};

var real_dynCall_viiiii = asm["dynCall_viiiii"];
asm["dynCall_viiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_viiiii.apply(null, arguments);
};

var real_dynCall_viidi = asm["dynCall_viidi"];
asm["dynCall_viidi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_viidi.apply(null, arguments);
};

var real_dynCall_dd = asm["dynCall_dd"];
asm["dynCall_dd"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_dd.apply(null, arguments);
};

var real_dynCall_ddd = asm["dynCall_ddd"];
asm["dynCall_ddd"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_ddd.apply(null, arguments);
};

var real_dynCall_id = asm["dynCall_id"];
asm["dynCall_id"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_id.apply(null, arguments);
};

var real_dynCall_viiiiiii = asm["dynCall_viiiiiii"];
asm["dynCall_viiiiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_viiiiiii.apply(null, arguments);
};

var real_dynCall_viiiiii = asm["dynCall_viiiiii"];
asm["dynCall_viiiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_viiiiii.apply(null, arguments);
};

var real_dynCall_iiiiiii = asm["dynCall_iiiiiii"];
asm["dynCall_iiiiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_iiiiiii.apply(null, arguments);
};

var real_dynCall_iidiiii = asm["dynCall_iidiiii"];
asm["dynCall_iidiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_iidiiii.apply(null, arguments);
};

var real_dynCall_jiji = asm["dynCall_jiji"];
asm["dynCall_jiji"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_dynCall_jiji.apply(null, arguments);
};

Module["asm"] = asm;
var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__wasm_call_ctors"].apply(null, arguments)
};

var _jshPushIOCharEvent = Module["_jshPushIOCharEvent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["jshPushIOCharEvent"].apply(null, arguments)
};

var _jshGetCharToTransmit = Module["_jshGetCharToTransmit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["jshGetCharToTransmit"].apply(null, arguments)
};

var _jshGetDeviceToTransmit = Module["_jshGetDeviceToTransmit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["jshGetDeviceToTransmit"].apply(null, arguments)
};

var _jsGfxChanged = Module["_jsGfxChanged"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["jsGfxChanged"].apply(null, arguments)
};

var _jsGfxGetPtr = Module["_jsGfxGetPtr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["jsGfxGetPtr"].apply(null, arguments)
};

var _malloc = Module["_malloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["malloc"].apply(null, arguments)
};

var _free = Module["_free"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["free"].apply(null, arguments)
};

var _jsInit = Module["_jsInit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["jsInit"].apply(null, arguments)
};

var _jsIdle = Module["_jsIdle"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["jsIdle"].apply(null, arguments)
};

var _jsSendPinWatchEvent = Module["_jsSendPinWatchEvent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["jsSendPinWatchEvent"].apply(null, arguments)
};

var _jsSendTouchEvent = Module["_jsSendTouchEvent"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["jsSendTouchEvent"].apply(null, arguments)
};

var _jsKill = Module["_jsKill"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["jsKill"].apply(null, arguments)
};

var _htons = Module["_htons"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["htons"].apply(null, arguments)
};

var _ntohs = Module["_ntohs"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ntohs"].apply(null, arguments)
};

var _htonl = Module["_htonl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["htonl"].apply(null, arguments)
};

var _fflush = Module["_fflush"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fflush"].apply(null, arguments)
};

var ___errno_location = Module["___errno_location"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__errno_location"].apply(null, arguments)
};

var __ZSt18uncaught_exceptionv = Module["__ZSt18uncaught_exceptionv"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZSt18uncaught_exceptionv"].apply(null, arguments)
};

var _setThrew = Module["_setThrew"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setThrew"].apply(null, arguments)
};

var _emscripten_builtin_memalign = Module["_emscripten_builtin_memalign"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_builtin_memalign"].apply(null, arguments)
};

var stackSave = Module["stackSave"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stackSave"].apply(null, arguments)
};

var stackAlloc = Module["stackAlloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stackAlloc"].apply(null, arguments)
};

var stackRestore = Module["stackRestore"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stackRestore"].apply(null, arguments)
};

var __growWasmMemory = Module["__growWasmMemory"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__growWasmMemory"].apply(null, arguments)
};

var dynCall_iii = Module["dynCall_iii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iii"].apply(null, arguments)
};

var dynCall_vii = Module["dynCall_vii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_vii"].apply(null, arguments)
};

var dynCall_ii = Module["dynCall_ii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_ii"].apply(null, arguments)
};

var dynCall_viii = Module["dynCall_viii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_viii"].apply(null, arguments)
};

var dynCall_vi = Module["dynCall_vi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_vi"].apply(null, arguments)
};

var dynCall_viiii = Module["dynCall_viiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_viiii"].apply(null, arguments)
};

var dynCall_i = Module["dynCall_i"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_i"].apply(null, arguments)
};

var dynCall_iiii = Module["dynCall_iiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iiii"].apply(null, arguments)
};

var dynCall_d = Module["dynCall_d"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_d"].apply(null, arguments)
};

var dynCall_di = Module["dynCall_di"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_di"].apply(null, arguments)
};

var dynCall_vidi = Module["dynCall_vidi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_vidi"].apply(null, arguments)
};

var dynCall_vid = Module["dynCall_vid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_vid"].apply(null, arguments)
};

var dynCall_v = Module["dynCall_v"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_v"].apply(null, arguments)
};

var dynCall_iidi = Module["dynCall_iidi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iidi"].apply(null, arguments)
};

var dynCall_vd = Module["dynCall_vd"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_vd"].apply(null, arguments)
};

var dynCall_iid = Module["dynCall_iid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iid"].apply(null, arguments)
};

var dynCall_idddi = Module["dynCall_idddi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_idddi"].apply(null, arguments)
};

var dynCall_dddd = Module["dynCall_dddd"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_dddd"].apply(null, arguments)
};

var dynCall_diii = Module["dynCall_diii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_diii"].apply(null, arguments)
};

var dynCall_vdi = Module["dynCall_vdi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_vdi"].apply(null, arguments)
};

var dynCall_did = Module["dynCall_did"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_did"].apply(null, arguments)
};

var dynCall_iiiiii = Module["dynCall_iiiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iiiiii"].apply(null, arguments)
};

var dynCall_iiiii = Module["dynCall_iiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iiiii"].apply(null, arguments)
};

var dynCall_dii = Module["dynCall_dii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_dii"].apply(null, arguments)
};

var dynCall_diiii = Module["dynCall_diiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_diiii"].apply(null, arguments)
};

var dynCall_diiiii = Module["dynCall_diiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_diiiii"].apply(null, arguments)
};

var dynCall_viid = Module["dynCall_viid"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_viid"].apply(null, arguments)
};

var dynCall_viiiii = Module["dynCall_viiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_viiiii"].apply(null, arguments)
};

var dynCall_viidi = Module["dynCall_viidi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_viidi"].apply(null, arguments)
};

var dynCall_dd = Module["dynCall_dd"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_dd"].apply(null, arguments)
};

var dynCall_ddd = Module["dynCall_ddd"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_ddd"].apply(null, arguments)
};

var dynCall_id = Module["dynCall_id"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_id"].apply(null, arguments)
};

var dynCall_viiiiiii = Module["dynCall_viiiiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_viiiiiii"].apply(null, arguments)
};

var dynCall_viiiiii = Module["dynCall_viiiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_viiiiii"].apply(null, arguments)
};

var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iiiiiii"].apply(null, arguments)
};

var dynCall_iidiiii = Module["dynCall_iidiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iidiiii"].apply(null, arguments)
};

var dynCall_jiji = Module["dynCall_jiji"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_jiji"].apply(null, arguments)
};




// === Auto-generated postamble setup entry stuff ===

Module['asm'] = asm;

if (!Object.getOwnPropertyDescriptor(Module, "intArrayFromString")) Module["intArrayFromString"] = function() { abort("'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "intArrayToString")) Module["intArrayToString"] = function() { abort("'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
Module["ccall"] = ccall;
if (!Object.getOwnPropertyDescriptor(Module, "cwrap")) Module["cwrap"] = function() { abort("'cwrap' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "setValue")) Module["setValue"] = function() { abort("'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getValue")) Module["getValue"] = function() { abort("'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "allocate")) Module["allocate"] = function() { abort("'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getMemory")) Module["getMemory"] = function() { abort("'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "AsciiToString")) Module["AsciiToString"] = function() { abort("'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stringToAscii")) Module["stringToAscii"] = function() { abort("'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "UTF8ArrayToString")) Module["UTF8ArrayToString"] = function() { abort("'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "UTF8ToString")) Module["UTF8ToString"] = function() { abort("'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stringToUTF8Array")) Module["stringToUTF8Array"] = function() { abort("'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stringToUTF8")) Module["stringToUTF8"] = function() { abort("'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "lengthBytesUTF8")) Module["lengthBytesUTF8"] = function() { abort("'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "UTF16ToString")) Module["UTF16ToString"] = function() { abort("'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stringToUTF16")) Module["stringToUTF16"] = function() { abort("'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "lengthBytesUTF16")) Module["lengthBytesUTF16"] = function() { abort("'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "UTF32ToString")) Module["UTF32ToString"] = function() { abort("'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stringToUTF32")) Module["stringToUTF32"] = function() { abort("'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "lengthBytesUTF32")) Module["lengthBytesUTF32"] = function() { abort("'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "allocateUTF8")) Module["allocateUTF8"] = function() { abort("'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stackTrace")) Module["stackTrace"] = function() { abort("'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "addOnPreRun")) Module["addOnPreRun"] = function() { abort("'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "addOnInit")) Module["addOnInit"] = function() { abort("'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "addOnPreMain")) Module["addOnPreMain"] = function() { abort("'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "addOnExit")) Module["addOnExit"] = function() { abort("'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "addOnPostRun")) Module["addOnPostRun"] = function() { abort("'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "writeStringToMemory")) Module["writeStringToMemory"] = function() { abort("'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "writeArrayToMemory")) Module["writeArrayToMemory"] = function() { abort("'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "writeAsciiToMemory")) Module["writeAsciiToMemory"] = function() { abort("'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "addRunDependency")) Module["addRunDependency"] = function() { abort("'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "removeRunDependency")) Module["removeRunDependency"] = function() { abort("'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "ENV")) Module["ENV"] = function() { abort("'ENV' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "FS")) Module["FS"] = function() { abort("'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "FS_createFolder")) Module["FS_createFolder"] = function() { abort("'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "FS_createPath")) Module["FS_createPath"] = function() { abort("'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "FS_createDataFile")) Module["FS_createDataFile"] = function() { abort("'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "FS_createPreloadedFile")) Module["FS_createPreloadedFile"] = function() { abort("'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "FS_createLazyFile")) Module["FS_createLazyFile"] = function() { abort("'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "FS_createLink")) Module["FS_createLink"] = function() { abort("'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "FS_createDevice")) Module["FS_createDevice"] = function() { abort("'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "FS_unlink")) Module["FS_unlink"] = function() { abort("'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "GL")) Module["GL"] = function() { abort("'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "dynamicAlloc")) Module["dynamicAlloc"] = function() { abort("'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "loadDynamicLibrary")) Module["loadDynamicLibrary"] = function() { abort("'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "loadWebAssemblyModule")) Module["loadWebAssemblyModule"] = function() { abort("'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getLEB")) Module["getLEB"] = function() { abort("'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getFunctionTables")) Module["getFunctionTables"] = function() { abort("'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "alignFunctionTables")) Module["alignFunctionTables"] = function() { abort("'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "registerFunctions")) Module["registerFunctions"] = function() { abort("'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "addFunction")) Module["addFunction"] = function() { abort("'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "removeFunction")) Module["removeFunction"] = function() { abort("'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getFuncWrapper")) Module["getFuncWrapper"] = function() { abort("'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "prettyPrint")) Module["prettyPrint"] = function() { abort("'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "makeBigInt")) Module["makeBigInt"] = function() { abort("'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "dynCall")) Module["dynCall"] = function() { abort("'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getCompilerSetting")) Module["getCompilerSetting"] = function() { abort("'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stackSave")) Module["stackSave"] = function() { abort("'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stackRestore")) Module["stackRestore"] = function() { abort("'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stackAlloc")) Module["stackAlloc"] = function() { abort("'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "establishStackSpace")) Module["establishStackSpace"] = function() { abort("'establishStackSpace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "print")) Module["print"] = function() { abort("'print' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "printErr")) Module["printErr"] = function() { abort("'printErr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getTempRet0")) Module["getTempRet0"] = function() { abort("'getTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "setTempRet0")) Module["setTempRet0"] = function() { abort("'setTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "callMain")) Module["callMain"] = function() { abort("'callMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "abort")) Module["abort"] = function() { abort("'abort' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "Pointer_stringify")) Module["Pointer_stringify"] = function() { abort("'Pointer_stringify' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "warnOnce")) Module["warnOnce"] = function() { abort("'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
Module["writeStackCookie"] = writeStackCookie;
Module["checkStackCookie"] = checkStackCookie;
Module["abortStackOverflow"] = abortStackOverflow;
if (!Object.getOwnPropertyDescriptor(Module, "intArrayFromBase64")) Module["intArrayFromBase64"] = function() { abort("'intArrayFromBase64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "tryParseAsDataURI")) Module["tryParseAsDataURI"] = function() { abort("'tryParseAsDataURI' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };if (!Object.getOwnPropertyDescriptor(Module, "ALLOC_NORMAL")) Object.defineProperty(Module, "ALLOC_NORMAL", { configurable: true, get: function() { abort("'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") } });
if (!Object.getOwnPropertyDescriptor(Module, "ALLOC_STACK")) Object.defineProperty(Module, "ALLOC_STACK", { configurable: true, get: function() { abort("'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") } });
if (!Object.getOwnPropertyDescriptor(Module, "ALLOC_DYNAMIC")) Object.defineProperty(Module, "ALLOC_DYNAMIC", { configurable: true, get: function() { abort("'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") } });
if (!Object.getOwnPropertyDescriptor(Module, "ALLOC_NONE")) Object.defineProperty(Module, "ALLOC_NONE", { configurable: true, get: function() { abort("'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") } });
if (!Object.getOwnPropertyDescriptor(Module, "calledRun")) Object.defineProperty(Module, "calledRun", { configurable: true, get: function() { abort("'calledRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") } });



var calledRun;


/**
 * @constructor
 * @this {ExitStatus}
 */
function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
}

var calledMain = false;


dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!calledRun) run();
  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
};





/** @type {function(Array=)} */
function run(args) {
  args = args || arguments_;

  if (runDependencies > 0) {
    return;
  }

  writeStackCookie();

  preRun();

  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later

  function doRun() {
    // run may have just been called through dependencies being fulfilled just in this very frame,
    // or while the async setStatus time below was happening
    if (calledRun) return;
    calledRun = true;

    if (ABORT) return;

    initRuntime();

    preMain();

    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

    assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]');

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else
  {
    doRun();
  }
  checkStackCookie();
}
Module['run'] = run;

function checkUnflushedContent() {
  // Compiler settings do not allow exiting the runtime, so flushing
  // the streams is not possible. but in ASSERTIONS mode we check
  // if there was something to flush, and if so tell the user they
  // should request that the runtime be exitable.
  // Normally we would not even include flush() at all, but in ASSERTIONS
  // builds we do so just for this check, and here we see if there is any
  // content to flush, that is, we check if there would have been
  // something a non-ASSERTIONS build would have not seen.
  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0
  // mode (which has its own special function for this; otherwise, all
  // the code is inside libc)
  var print = out;
  var printErr = err;
  var has = false;
  out = err = function(x) {
    has = true;
  }
  try { // it doesn't matter if it fails
    var flush = flush_NO_FILESYSTEM;
    if (flush) flush(0);
  } catch(e) {}
  out = print;
  err = printErr;
  if (has) {
    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.');
    warnOnce('(this may also be due to not including full filesystem support - try building with -s FORCE_FILESYSTEM=1)');
  }
}

function exit(status, implicit) {
  checkUnflushedContent();

  // if this is just main exit-ing implicitly, and the status is 0, then we
  // don't need to do anything here and can just leave. if the status is
  // non-zero, though, then we need to report it.
  // (we may have warned about this earlier, if a situation justifies doing so)
  if (implicit && noExitRuntime && status === 0) {
    return;
  }

  if (noExitRuntime) {
    // if exit() was called, we may warn the user if the runtime isn't actually being shut down
    if (!implicit) {
      err('program exited (with status: ' + status + '), but EXIT_RUNTIME is not set, so halting execution but not exiting the runtime or preventing further async execution (build with EXIT_RUNTIME=1, if you want a true shutdown)');
    }
  } else {

    ABORT = true;
    EXITSTATUS = status;

    exitRuntime();

    if (Module['onExit']) Module['onExit'](status);
  }

  quit_(status, new ExitStatus(status));
}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}


  noExitRuntime = true;

run();





// {{MODULE_ADDITIONS}}



